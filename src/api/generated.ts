/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * Comfy API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from './mutator/axios-instance';
export interface APIKey {
  created_at?: string;
  description?: string;
  id?: string;
  key_prefix?: string;
  name?: string;
}

export type APIKeyWithPlaintext = APIKey & {
  /** The full API key (only returned at creation) */
  plaintext_key?: string;
};

/**
 * Time series of VRAM usage.
 */
export type MachineStatsVramTimeSeries = { [key: string]: unknown };

export interface MachineStats {
  /** Total CPU on the machine. */
  cpu_capacity?: string;
  /** Total disk capacity on the machine. */
  disk_capacity?: string;
  /** The GPU type. eg. NVIDIA Tesla K80 */
  gpu_type?: string;
  /** Initial CPU available before the job starts. */
  initial_cpu?: string;
  /** Initial disk available before the job starts. */
  initial_disk?: string;
  /** Initial RAM available before the job starts. */
  initial_ram?: string;
  /** Name of the machine. */
  machine_name?: string;
  /** Total memory on the machine. */
  memory_capacity?: string;
  /** The operating system version. eg. Ubuntu Linux 20.04 */
  os_version?: string;
  /** The pip freeze output */
  pip_freeze?: string;
  /** Time series of VRAM usage. */
  vram_time_series?: MachineStatsVramTimeSeries;
}

export type WorkflowRunStatus = typeof WorkflowRunStatus[keyof typeof WorkflowRunStatus];


export const WorkflowRunStatus = {
  WorkflowRunStatusStarted: 'WorkflowRunStatusStarted',
  WorkflowRunStatusFailed: 'WorkflowRunStatusFailed',
  WorkflowRunStatusCompleted: 'WorkflowRunStatusCompleted',
} as const;

export interface StorageFile {
  /** Path to the file in storage */
  file_path?: string;
  /** Unique identifier for the storage file */
  id?: string;
  /** Public URL */
  public_url?: string;
}

export interface ActionJobResult {
  /** Identifier of the job this result belongs to */
  action_job_id?: string;
  /** Identifier of the run this result belongs to */
  action_run_id?: string;
  /** The author of the commit */
  author?: string;
  /** The average VRAM used by the job */
  avg_vram?: number;
  /** Name of the relevant git branch */
  branch_name?: string;
  /** The comfy run flags. E.g. `--low-vram` */
  comfy_run_flags?: string;
  /** The hash of the commit */
  commit_hash?: string;
  /** The ID of the commit */
  commit_id?: string;
  /** The message of the commit */
  commit_message?: string;
  /** The Unix timestamp when the commit was made */
  commit_time?: number;
  /** CUDA version used */
  cuda_version?: string;
  /** The end time of the job as a Unix timestamp. */
  end_time?: number;
  /** The repository name */
  git_repo?: string;
  /** Unique identifier for the job result */
  id?: string;
  /** The user who triggered the job. */
  job_trigger_user?: string;
  machine_stats?: MachineStats;
  /** Operating system used */
  operating_system?: string;
  /** The peak VRAM used by the job */
  peak_vram?: number;
  /** The pull request number */
  pr_number?: string;
  /** PyTorch version used */
  python_version?: string;
  /** PyTorch version used */
  pytorch_version?: string;
  /** The start time of the job as a Unix timestamp. */
  start_time?: number;
  status?: WorkflowRunStatus;
  storage_file?: StorageFile;
  /** Name of the workflow */
  workflow_name?: string;
}

/**
 * data related to the event
 */
export type AuditLogParams = { [key: string]: unknown };

export interface AuditLog {
  /** The date and time the event was created */
  createdAt?: string;
  /** the id of the event */
  event_id?: string;
  /** the type of the event */
  event_type?: string;
  /** data related to the event */
  params?: AuditLogParams;
}

export interface BFLAsyncResponse {
  id: string;
  polling_url: string;
}

export interface BFLAsyncWebhookResponse {
  id: string;
  status: string;
  webhook_url: string;
}

export type BFLOutputFormat = typeof BFLOutputFormat[keyof typeof BFLOutputFormat];


export const BFLOutputFormat = {
  jpeg: 'jpeg',
  png: 'png',
} as const;

export interface BFLCannyInputs {
  /** High threshold for Canny edge detection */
  canny_high_threshold?: number;
  /** Low threshold for Canny edge detection */
  canny_low_threshold?: number;
  /** Base64 encoded image to use as control input if no preprocessed image is provided */
  control_image?: string;
  /** Guidance strength for the image generation process */
  guidance?: number;
  /** Output format for the generated image. Can be 'jpeg' or 'png'. */
  output_format?: BFLOutputFormat;
  /** Optional pre-processed image that will bypass the control preprocessing step */
  preprocessed_image?: string;
  /** Text prompt for image generation */
  prompt: string;
  /** Whether to perform upsampling on the prompt */
  prompt_upsampling?: boolean;
  /**
   * Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
   * @minimum 0
   * @maximum 6
   */
  safety_tolerance?: number;
  /** Optional seed for reproducibility */
  seed?: number;
  /** Number of steps for the image generation process */
  steps?: number;
  /** Optional secret for webhook signature verification */
  webhook_secret?: string;
  /** URL to receive webhook notifications */
  webhook_url?: string;
}

export interface BFLDepthInputs {
  /** Base64 encoded image to use as control input */
  control_image?: string;
  /** Guidance strength for the image generation process */
  guidance?: number;
  /** Output format for the generated image. Can be 'jpeg' or 'png'. */
  output_format?: BFLOutputFormat;
  /** Optional pre-processed image that will bypass the control preprocessing step */
  preprocessed_image?: string;
  /** Text prompt for image generation */
  prompt: string;
  /** Whether to perform upsampling on the prompt */
  prompt_upsampling?: boolean;
  /**
   * Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
   * @minimum 0
   * @maximum 6
   */
  safety_tolerance?: number;
  /** Optional seed for reproducibility */
  seed?: number;
  /** Number of steps for the image generation process */
  steps?: number;
  /** Optional secret for webhook signature verification */
  webhook_secret?: string;
  /** URL to receive webhook notifications */
  webhook_url?: string;
}

/**
 * Output format for the generated image.
 */
export type BFLFlux2ProGenerateRequestOutputFormat = typeof BFLFlux2ProGenerateRequestOutputFormat[keyof typeof BFLFlux2ProGenerateRequestOutputFormat];


export const BFLFlux2ProGenerateRequestOutputFormat = {
  jpeg: 'jpeg',
  png: 'png',
} as const;

/**
 * Request body for the BFL Flux 2 Pro image generation API.
 */
export interface BFLFlux2ProGenerateRequest {
  /**
   * Height of the image.
   * @minimum 256
   * @maximum 2048
   */
  height?: number;
  /** Base64 encoded image for image-to-image generation. */
  input_image?: string;
  /** Base64 encoded image for image-to-image generation. */
  input_image_2?: string;
  /** Base64 encoded image for image-to-image generation. */
  input_image_3?: string;
  /** Base64 encoded image for image-to-image generation. */
  input_image_4?: string;
  /** Base64 encoded image for image-to-image generation. */
  input_image_5?: string;
  /** Base64 encoded image for image-to-image generation. */
  input_image_6?: string;
  /** Base64 encoded image for image-to-image generation. */
  input_image_7?: string;
  /** Base64 encoded image for image-to-image generation. */
  input_image_8?: string;
  /** Base64 encoded image for image-to-image generation. */
  input_image_9?: string;
  /** Output format for the generated image. */
  output_format?: BFLFlux2ProGenerateRequestOutputFormat;
  /** Text description of the image to generate. */
  prompt: string;
  /** Automatically modify prompt for generation. */
  prompt_upsampling?: boolean;
  /**
   * Moderation tolerance level (Flux 2 Max only).
   * @minimum 0
   * @maximum 5
   */
  safety_tolerance?: number;
  /** Seed for reproducibility. */
  seed?: number;
  /**
   * Width of the image.
   * @minimum 256
   * @maximum 2048
   */
  width?: number;
}

export interface BFLFluxKontextMaxGenerateRequest {
  /**
   * The guidance scale for generation
   * @minimum 1
   * @maximum 20
   */
  guidance?: number;
  /** Base64 encoded image to be edited */
  input_image: string;
  /** The text prompt describing what to edit on the image */
  prompt: string;
  /**
   * Number of inference steps
   * @minimum 1
   * @maximum 50
   */
  steps?: number;
}

export interface BFLFluxKontextMaxGenerateResponse {
  /** Job ID for tracking */
  id: string;
  /** URL to poll for results */
  polling_url: string;
}

export interface BFLFluxKontextProGenerateRequest {
  /**
   * The guidance scale for generation
   * @minimum 1
   * @maximum 20
   */
  guidance?: number;
  /** Base64 encoded image to be edited */
  input_image: string;
  /** The text prompt describing what to edit on the image */
  prompt: string;
  /**
   * Number of inference steps
   * @minimum 1
   * @maximum 50
   */
  steps?: number;
}

export interface BFLFluxKontextProGenerateResponse {
  /** Job ID for tracking */
  id: string;
  /** URL to poll for results */
  polling_url: string;
}

/**
 * Output image format
 */
export type BFLFluxPro11GenerateRequestOutputFormat = typeof BFLFluxPro11GenerateRequestOutputFormat[keyof typeof BFLFluxPro11GenerateRequestOutputFormat];


export const BFLFluxPro11GenerateRequestOutputFormat = {
  jpeg: 'jpeg',
  png: 'png',
} as const;

export interface BFLFluxPro11GenerateRequest {
  /** Height of the generated image */
  height: number;
  /** Optional image prompt */
  image_prompt?: string;
  /** Output image format */
  output_format?: BFLFluxPro11GenerateRequestOutputFormat;
  /** The main text prompt for image generation */
  prompt: string;
  /** Whether to use prompt upsampling */
  prompt_upsampling?: boolean;
  /** Safety tolerance level */
  safety_tolerance?: number;
  /** Random seed for reproducibility */
  seed?: number;
  /** Optional webhook secret for async processing */
  webhook_secret?: string;
  /** Optional webhook URL for async processing */
  webhook_url?: string;
  /** Width of the generated image */
  width: number;
}

export interface BFLFluxPro11GenerateResponse {
  /** Job ID for tracking */
  id: string;
  /** URL to poll for results */
  polling_url: string;
}

export interface BFLFluxProExpandInputs {
  /** Number of pixels to expand at the bottom of the image */
  bottom?: number;
  /** Guidance strength for the image generation process */
  guidance?: number;
  /** A Base64-encoded string representing the image you wish to expand. */
  image: string;
  /** Number of pixels to expand on the left side of the image */
  left?: number;
  /** Output format for the generated image. Can be 'jpeg' or 'png'. */
  output_format?: BFLOutputFormat;
  /** The description of the changes you want to make. This text guides the expansion process, allowing you to specify features, styles, or modifications for the expanded areas. */
  prompt?: string;
  /** Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation */
  prompt_upsampling?: boolean;
  /** Number of pixels to expand on the right side of the image */
  right?: number;
  /**
   * Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
   * @minimum 0
   * @maximum 6
   */
  safety_tolerance?: number;
  /** Optional seed for reproducibility */
  seed?: number;
  /** Number of steps for the image generation process */
  steps?: number;
  /** Number of pixels to expand at the top of the image */
  top?: number;
  /** Optional secret for webhook signature verification */
  webhook_secret?: string;
  /** URL to receive webhook notifications */
  webhook_url?: string;
}

export interface BFLFluxProFillInputs {
  /** Guidance strength for the image generation process */
  guidance?: number;
  /** A Base64-encoded string representing the image you wish to modify. Can contain alpha mask if desired. */
  image: string;
  /** A Base64-encoded string representing a mask for the areas you want to modify in the image. The mask should be the same dimensions as the image and in black and white. Black areas (0%) indicate no modification, while white areas (100%) specify areas for inpainting. Optional if you provide an alpha mask in the original image. Validation: The endpoint verifies that the dimensions of the mask match the original image. */
  mask?: string;
  /** Output format for the generated image. Can be 'jpeg' or 'png'. */
  output_format?: BFLOutputFormat;
  /** The description of the changes you want to make. This text guides the inpainting process, allowing you to specify features, styles, or modifications for the masked area. */
  prompt?: string;
  /** Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation */
  prompt_upsampling?: boolean;
  /**
   * Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
   * @minimum 0
   * @maximum 6
   */
  safety_tolerance?: number;
  /** Optional seed for reproducibility */
  seed?: number;
  /** Number of steps for the image generation process */
  steps?: number;
  /** Optional secret for webhook signature verification */
  webhook_secret?: string;
  /** URL to receive webhook notifications */
  webhook_url?: string;
}

/**
 * Request body for the BFL Flux Pro 1.1 Ultra image generation API.
 */
export interface BFLFluxProGenerateRequest {
  /**
   * The guidance scale for generation.
   * @minimum 1
   * @maximum 20
   */
  guidance_scale?: number;
  /**
   * The height of the image to generate.
   * @minimum 64
   * @maximum 2048
   */
  height: number;
  /** The negative prompt for image generation. */
  negative_prompt?: string;
  /**
   * The number of images to generate.
   * @minimum 1
   * @maximum 4
   */
  num_images?: number;
  /**
   * The number of inference steps.
   * @minimum 1
   * @maximum 100
   */
  num_inference_steps?: number;
  /** The text prompt for image generation. */
  prompt: string;
  /** The seed value for reproducibility. */
  seed?: number;
  /**
   * The width of the image to generate.
   * @minimum 64
   * @maximum 2048
   */
  width: number;
}

/**
 * Response from the BFL Flux Pro 1.1 Ultra image generation API.
 */
export interface BFLFluxProGenerateResponse {
  /** The cost of the generation task. */
  cost?: number;
  /** The unique identifier for the generation task. */
  id: string;
  /** Input megapixels. */
  input_mp?: number;
  /** Output megapixels. */
  output_mp?: number;
  /** URL to poll for the generation result. */
  polling_url: string;
}

export interface BFLValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
}

export interface BFLHTTPValidationError {
  detail?: BFLValidationError[];
}

/**
 * Asynchronous response from Bria API (202 Accepted)
 */
export interface BriaAsyncResponse {
  /** Unique identifier for the request. */
  request_id?: string;
  /** URL to poll for the result. */
  status_url?: string;
  /** Optional warning message. */
  warning?: string;
}

export type BriaErrorResponseError = {
  /** Error code. */
  code?: number;
  /** Additional error details. */
  details?: string;
  /** Error message. */
  message?: string;
};

/**
 * Error response from Bria API
 */
export interface BriaErrorResponse {
  error?: BriaErrorResponseError;
  /** Unique identifier for the request. */
  request_id?: string;
}

/**
 * The version of the model to use.
 */
export type BriaFiboEditRequestModelVersion = typeof BriaFiboEditRequestModelVersion[keyof typeof BriaFiboEditRequestModelVersion];


export const BriaFiboEditRequestModelVersion = {
  FIBO: 'FIBO',
} as const;

/**
 * Request body for Bria FIBO Edit API
 */
export interface BriaFiboEditRequest {
  /**
   * Determines how closely the generated image should adhere to the instruction.
   * @minimum 3
   * @maximum 5
   */
  guidance_scale?: number;
  /**
   * The source image to be edited. Publicly available URL or Base64-encoded. Accepted formats JPEG, JPG, PNG, WEBP. Must contain exactly one item.
   * @minItems 1
   * @maxItems 1
   */
  images: string[];
  /** Text-based edit instruction (e.g., "make the sky blue", "add a cat"). Either instruction or structured_instruction must be provided. */
  instruction?: string;
  /** If true, returns a warning for potential IP content in the instruction. */
  ip_signal?: boolean;
  /** Optional mask image URL or Base64-encoded. Black areas will be preserved, white areas will be edited. */
  mask?: string;
  /** The version of the model to use. */
  model_version?: BriaFiboEditRequestModelVersion;
  /** A text prompt specifying concepts, styles, or objects to exclude from the edited image. */
  negative_prompt?: string;
  /** If true, returns 422 on instruction moderation failure. */
  prompt_content_moderation?: boolean;
  /** Seed for deterministic generation. If omitted, a random seed is used. */
  seed?: number;
  /**
   * Number of diffusion steps.
   * @minimum 20
   * @maximum 50
   */
  steps_num?: number;
  /** A string containing the structured edit instruction in JSON format. Use this instead of instruction for precise, programmatic control. */
  structured_instruction?: string;
  /** If true, returns 422 on images or mask moderation failure. */
  visual_input_content_moderation?: boolean;
  /** If true, returns 422 on visual output moderation failure. */
  visual_output_content_moderation?: boolean;
}

/**
 * Request body for Bria Image Remove Background API
 */
export interface BriaImageRemoveBackgroundRequest {
  /** The image to remove background from. Supported input types are Base64-encoded string or URL pointing to a publicly accessible image file. Accepted formats JPEG, JPG, PNG, WEBP. */
  image: string;
  /** Controls whether partially transparent areas from the input image are retained in the output after background removal. */
  preserve_alpha?: boolean;
  /** When false (default), the request is processed asynchronously. When true, the API holds the connection open until complete. */
  sync?: boolean;
  /** When enabled, applies content moderation to input visual. Returns 422 if the image fails moderation. */
  visual_input_content_moderation?: boolean;
  /** When enabled, applies content moderation to result visual. Returns 422 if the output fails moderation. */
  visual_output_content_moderation?: boolean;
}

export type BriaStatusNotFoundResponseStatus = typeof BriaStatusNotFoundResponseStatus[keyof typeof BriaStatusNotFoundResponseStatus];


export const BriaStatusNotFoundResponseStatus = {
  NOT_FOUND: 'NOT_FOUND',
} as const;

/**
 * Response when request_id is not found or expired
 */
export interface BriaStatusNotFoundResponse {
  status: BriaStatusNotFoundResponseStatus;
}

/**
 * Error object (only present when status is ERROR)
 */
export type BriaStatusResponseError = {
  /** Error code. */
  code?: number;
  /** Additional error details. */
  details?: string;
  /** Error message. */
  message?: string;
};

/**
 * Result object (only present when status is COMPLETED)
 */
export type BriaStatusResponseResult = {
  /** URL of the generated/edited image. */
  image_url?: string;
  /** Original prompt. */
  prompt?: string;
  /** Refined version of the prompt. */
  refined_prompt?: string;
  /** Seed used for generation. */
  seed?: number;
  /** The detailed JSON structured prompt. */
  structured_prompt?: string;
  /** URL of the generated video. */
  video_url?: string;
};

/**
 * Current status of the request.
 */
export type BriaStatusResponseStatus = typeof BriaStatusResponseStatus[keyof typeof BriaStatusResponseStatus];


export const BriaStatusResponseStatus = {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  ERROR: 'ERROR',
  UNKNOWN: 'UNKNOWN',
} as const;

/**
 * Status response from Bria API
 */
export interface BriaStatusResponse {
  /** Error object (only present when status is ERROR) */
  error?: BriaStatusResponseError;
  /** Unique identifier for the request. */
  request_id?: string;
  /** Result object (only present when status is COMPLETED) */
  result?: BriaStatusResponseResult;
  /** Current status of the request. */
  status?: BriaStatusResponseStatus;
}

/**
 * Request body for Bria Structured Instruction Generate API
 */
export interface BriaStructuredInstructionRequest {
  /**
   * The source image to be edited. Publicly available URL or Base64-encoded. Must contain exactly one item.
   * @minItems 1
   * @maxItems 1
   */
  images: string[];
  /** Required. Text-based edit instruction (e.g., "make the sky blue", "add a cat"). */
  instruction: string;
  /** If true, returns a warning for potential IP content in the instruction. */
  ip_signal?: boolean;
  /** Optional mask image URL or Base64-encoded. Black areas will be preserved, white areas will be edited. */
  mask?: string;
  /** If true, returns 422 on instruction moderation failure. */
  prompt_content_moderation?: boolean;
  /** Seed for deterministic generation. If omitted, a random seed is used. */
  seed?: number;
  /** If true, returns 422 on images or mask moderation failure. */
  visual_input_content_moderation?: boolean;
}

/**
 * Background color for the output video. If Transparent, the output codec must support alpha.
 */
export type BriaVideoRemoveBackgroundRequestBackgroundColor = typeof BriaVideoRemoveBackgroundRequestBackgroundColor[keyof typeof BriaVideoRemoveBackgroundRequestBackgroundColor];


export const BriaVideoRemoveBackgroundRequestBackgroundColor = {
  Transparent: 'Transparent',
  Black: 'Black',
  White: 'White',
  Gray: 'Gray',
  Red: 'Red',
  Green: 'Green',
  Blue: 'Blue',
  Yellow: 'Yellow',
  Cyan: 'Cyan',
  Magenta: 'Magenta',
  Orange: 'Orange',
} as const;

/**
 * Output container and codec preset.
 */
export type BriaVideoRemoveBackgroundRequestOutputContainerAndCodec = typeof BriaVideoRemoveBackgroundRequestOutputContainerAndCodec[keyof typeof BriaVideoRemoveBackgroundRequestOutputContainerAndCodec];


export const BriaVideoRemoveBackgroundRequestOutputContainerAndCodec = {
  mp4_h264: 'mp4_h264',
  mp4_h265: 'mp4_h265',
  webm_vp9: 'webm_vp9',
  mov_h265: 'mov_h265',
  mov_proresks: 'mov_proresks',
  mkv_h264: 'mkv_h264',
  mkv_h265: 'mkv_h265',
  mkv_vp9: 'mkv_vp9',
  gif: 'gif',
} as const;

/**
 * Request body for Bria Video Remove Background API
 */
export interface BriaVideoRemoveBackgroundRequest {
  /** Background color for the output video. If Transparent, the output codec must support alpha. */
  background_color?: BriaVideoRemoveBackgroundRequestBackgroundColor;
  /** Output container and codec preset. */
  output_container_and_codec?: BriaVideoRemoveBackgroundRequestOutputContainerAndCodec;
  /** Whether to preserve audio from the input video. */
  preserve_audio?: boolean;
  /** Publicly accessible URL of the input video. Input resolution supported up to 16000x16000 (16K). Max duration 60 seconds. */
  video: string;
}

/**
 * Status of the retrieval operation
 */
export type BulkNodeVersionResultStatus = typeof BulkNodeVersionResultStatus[keyof typeof BulkNodeVersionResultStatus];


export const BulkNodeVersionResultStatus = {
  success: 'success',
  not_found: 'not_found',
  error: 'error',
} as const;

export interface NodeVersionIdentifier {
  /** The unique identifier of the node */
  node_id: string;
  /** The version of the node */
  version: string;
}

export type NodeVersionStatus = typeof NodeVersionStatus[keyof typeof NodeVersionStatus];


export const NodeVersionStatus = {
  NodeVersionStatusActive: 'NodeVersionStatusActive',
  NodeVersionStatusDeleted: 'NodeVersionStatusDeleted',
  NodeVersionStatusBanned: 'NodeVersionStatusBanned',
  NodeVersionStatusPending: 'NodeVersionStatusPending',
  NodeVersionStatusFlagged: 'NodeVersionStatusFlagged',
} as const;

export interface NodeVersion {
  /** Summary of changes made in this version */
  changelog?: string;
  /** The status of comfy node extraction process. */
  comfy_node_extract_status?: string;
  /** The date and time the version was created. */
  createdAt?: string;
  /** A list of pip dependencies required by the node. */
  dependencies?: string[];
  /** Indicates if this version is deprecated. */
  deprecated?: boolean;
  /** [Output Only] URL to download this version of the node */
  downloadUrl?: string;
  id?: string;
  /** The unique identifier of the node. */
  node_id?: string;
  status?: NodeVersionStatus;
  status_reason?: string;
  /** List of accelerators (e.g. CUDA, DirectML, ROCm) that this node supports */
  supported_accelerators?: string[];
  /** Supported versions of ComfyUI frontend */
  supported_comfyui_frontend_version?: string;
  /** Supported versions of ComfyUI */
  supported_comfyui_version?: string;
  /** List of operating systems that this node supports */
  supported_os?: string[];
  tags?: string[];
  /** Admin-only tags for security warnings and admin metadata */
  tags_admin?: string[];
  /** The version identifier, following semantic versioning. Must be unique for the node. */
  version?: string;
}

export interface BulkNodeVersionResult {
  /** Error message if retrieval failed (only present if status is error) */
  error_message?: string;
  identifier: NodeVersionIdentifier;
  node_version?: NodeVersion;
  /** Status of the retrieval operation */
  status: BulkNodeVersionResultStatus;
}

export interface BulkNodeVersionsRequest {
  /** List of node ID and version pairs to retrieve */
  node_versions: NodeVersionIdentifier[];
}

export interface BulkNodeVersionsResponse {
  /** List of retrieved node versions with their status */
  node_versions: BulkNodeVersionResult[];
}

export type BytePlusImageGenerationRequestModel = typeof BytePlusImageGenerationRequestModel[keyof typeof BytePlusImageGenerationRequestModel];


export const BytePlusImageGenerationRequestModel = {
  'seedream-3-0-t2i-250415': 'seedream-3-0-t2i-250415',
  'seededit-3-0-i2i-250628': 'seededit-3-0-i2i-250628',
  'seedream-4-0-250828': 'seedream-4-0-250828',
  'seedream-4-5-251128': 'seedream-4-5-251128',
} as const;

/**
 * Specifies the format of the generated image returned in the response
 */
export type BytePlusImageGenerationRequestResponseFormat = typeof BytePlusImageGenerationRequestResponseFormat[keyof typeof BytePlusImageGenerationRequestResponseFormat];


export const BytePlusImageGenerationRequestResponseFormat = {
  url: 'url',
  b64_json: 'b64_json',
} as const;

/**
 * Only seedream-4.0 supports this parameter.
Configuration for the batch image generation feature. This parameter is only effective when sequential_image_generation is set to auto.

 */
export type BytePlusImageGenerationRequestSequentialImageGenerationOptions = {
  /**
   * Specifies the maximum number of images to generate in this request. Number of input reference images + Number of generated images ‚â§ 15.
   * @minimum 1
   * @maximum 15
   */
  max_images?: number;
};

export interface BytePlusImageGenerationRequest {
  /**
   * Controls how closely the output image aligns with the input prompt. Range [1, 10]. Higher values result in stronger prompt adherence. Default 2.5 for seedream-3-0-t2i-250415 and 5.5 for seededit-3-0-i2i-250628
   * @minimum 1
   * @maximum 10
   */
  guidance_scale?: number;
  /** Only seedream-4.0 and seededit-3.0-i2i support this parameter.

Enter the Base64 encoding or an accessible URL of the image to edit. Among the models, bytedance-seedream-4.0 supports inputting a single image or multiple images (see the multi-image blending example), while bytedance-seededit-3.0-i2 only supports single-image input.

‚Ä¢ Image URL: Make sure that the image URL is accessible.
‚Ä¢ Base64 encoding: The format must be data:image/<image format>;base64,<Base64 encoding>. Note: <image format> must be in lowercase, e.g., data:image/png;base64,<base64_image>.

An input image must meet the following requirements:
‚Ä¢ Image format: jpeg, png
‚Ä¢ Aspect ratio (width/height): In the range [1/3, 3]
‚Ä¢ Width and height (px): > 14
‚Ä¢ Size: No more than 10 MB
 */
  image?: string | string[];
  model: BytePlusImageGenerationRequestModel;
  /** Text description for image generation or transformation */
  prompt: string;
  /** Specifies the format of the generated image returned in the response */
  response_format?: BytePlusImageGenerationRequestResponseFormat;
  /** Random seed to control the stochasticity of image generation. Range: [-1, 2147483647]. If not specified, a seed will be automatically generated. To reproduce the same output, use the same seed value. */
  seed?: number;
  /** Controls whether to disable the batch generation feature. This parameter is only supported on seedream-4.0. Valid values:
auto: In automatic mode, the model automatically determines whether to return multiple images and how many images it will contain based on the user's prompt.
disabled: Disables batch generation feature. The model will only generate one image.
 */
  sequential_image_generation?: string;
  /** Only seedream-4.0 supports this parameter.
Configuration for the batch image generation feature. This parameter is only effective when sequential_image_generation is set to auto.
 */
  sequential_image_generation_options?: BytePlusImageGenerationRequestSequentialImageGenerationOptions;
  /** "seedream-3-0-t2i-250415": Specifies the dimensions (width x height in pixels) of the generated image. Must be between [512x512, 2048x2048]
"seededit-3-0-i2i-250628": The width and height pixels of the generated image. Currently only supports adaptive.
"seedream-4-0-250828": Set the specification for the generated image. Two methods are available but cannot be used together.
  Method 1 | Example: Specify the resolution of the generated image, and describe its aspect ratio, shape, or purpose in the prompt using natural language, let the model ultimately determine the final image width and height.
    Optional values: 1K, 2K, 4K
  Method 2 | Example: Specify the width and height of the generated image in pixels:
    Default value: 2048x2048
    The value range of total pixels: [1024x1024, 4096x4096]
    The aspect ratio value range: [1/16, 16]
 */
  size?: string;
  /** Specifies whether to add a watermark to the generated image. false = No watermark, true = Adds watermark with 'AI generated' label */
  watermark?: boolean;
}

export type BytePlusImageGenerationResponseDataItem = {
  /** Base64-encoded image data (if response_format is "b64_json") */
  b64_json?: string;
  /** URL for image download (if response_format is "url") */
  url?: string;
};

/**
 * Error information (if any)
 */
export type BytePlusImageGenerationResponseError = {
  /** Error code */
  code?: string;
  /** Error message */
  message?: string;
};

export type BytePlusImageGenerationResponseUsage = {
  /** Number of images generated by the model */
  generated_images?: number;
  /** The number of tokens used for the picture generated by the model. */
  output_tokens?: number;
  /** The total number of tokens consumed by this request. */
  total_tokens?: number;
};

export interface BytePlusImageGenerationResponse {
  /** Unix timestamp (in seconds) indicating the time when the request was created */
  created?: number;
  /** Contains information about the generated image(s) */
  data?: BytePlusImageGenerationResponseDataItem[];
  /** Error information (if any) */
  error?: BytePlusImageGenerationResponseError;
  /** The model ID used for the request */
  model?: string;
  usage?: BytePlusImageGenerationResponseUsage;
}

export type BytePlusVideoGenerationContentImageUrl = {
  /** Image content for image-to-video generation (when type is "image")
Image URL: Make sure that the image URL is accessible.
Base64-encoded content: Format must be data:image/<format>;base64,<content>
 */
  url?: string;
};

/**
 * The type of the input content
 */
export type BytePlusVideoGenerationContentType = typeof BytePlusVideoGenerationContentType[keyof typeof BytePlusVideoGenerationContentType];


export const BytePlusVideoGenerationContentType = {
  text: 'text',
  image_url: 'image_url',
} as const;

export interface BytePlusVideoGenerationContent {
  image_url?: BytePlusVideoGenerationContentImageUrl;
  /**
   * The input text information for the model. Includes text prompt and optional parameters.

Text prompt (required): Description of the video to be generated using Chinese and English characters.

Parameters (optional): Add --[parameters] after the text prompt to control video specifications:
- --resolution (--rs): 480p, 720p, 1080p (default: 720p)
- --ratio (--rt): 21:9, 16:9, 4:3, 1:1, 3:4, 9:16, 9:21, adaptive (default: 16:9 or adaptive)
- --duration (--dur): 3-12 seconds (default: 5)
- --framepersecond (--fps): 24 (default: 24)
- --watermark (--wm): true/false (default: false)
- --seed (--seed): -1 to 2^32-1 (default: -1)
- --camerafixed (--cf): true/false (default: false)

Example: "A beautiful landscape --ratio 16:9 --resolution 720p --duration 5"

   * @maxLength 4096
   */
  text?: string;
  /** The type of the input content */
  type: BytePlusVideoGenerationContentType;
}

/**
 * The output after the video generation task is completed, which contains the download URL of the output video.
 */
export type BytePlusVideoGenerationQueryResponseContent = {
  /** The URL of the output video. For security purposes, the output video is cleared after 24 hours. */
  video_url?: string;
};

/**
 * The error information. If the task succeeds, null is returned. If the task fails, the error information is returned.
 * @nullable
 */
export type BytePlusVideoGenerationQueryResponseError = {
  /** The error code */
  code?: string;
  /** The error message */
  message?: string;
} | null;

/**
 * The state of the task
 */
export type BytePlusVideoGenerationQueryResponseStatus = typeof BytePlusVideoGenerationQueryResponseStatus[keyof typeof BytePlusVideoGenerationQueryResponseStatus];


export const BytePlusVideoGenerationQueryResponseStatus = {
  queued: 'queued',
  running: 'running',
  cancelled: 'cancelled',
  succeeded: 'succeeded',
  failed: 'failed',
} as const;

/**
 * The token usage for the request
 */
export type BytePlusVideoGenerationQueryResponseUsage = {
  /** The number of tokens generated by the model */
  completion_tokens?: number;
  /** For the video generation model, the number of input tokens is not calculated and defaults to 0. Therefore, total_tokens = completion_tokens. */
  total_tokens?: number;
};

export interface BytePlusVideoGenerationQueryResponse {
  /** The output after the video generation task is completed, which contains the download URL of the output video. */
  content?: BytePlusVideoGenerationQueryResponseContent;
  /** The time when the task was created. The value is a UNIX timestamp in seconds. */
  created_at?: number;
  /**
   * The error information. If the task succeeds, null is returned. If the task fails, the error information is returned.
   * @nullable
   */
  error?: BytePlusVideoGenerationQueryResponseError;
  /** The ID of the video generation task */
  id?: string;
  /** The name and version of the model used by the task */
  model?: string;
  /** The state of the task */
  status?: BytePlusVideoGenerationQueryResponseStatus;
  /** The time when the task was last updated. The value is a UNIX timestamp in seconds. */
  updated_at?: number;
  /** The token usage for the request */
  usage?: BytePlusVideoGenerationQueryResponseUsage;
}

/**
 * The ID of the model to call. Available models include seedance-1-5-pro-251215, seedance-1-0-pro-250528, seedance-1-0-pro-fast-251015, seedance-1-0-lite-t2v-250428, seedance-1-0-lite-i2v-250428
 */
export type BytePlusVideoGenerationRequestModel = typeof BytePlusVideoGenerationRequestModel[keyof typeof BytePlusVideoGenerationRequestModel];


export const BytePlusVideoGenerationRequestModel = {
  'seedance-1-5-pro-251215': 'seedance-1-5-pro-251215',
  'seedance-1-0-pro-250528': 'seedance-1-0-pro-250528',
  'seedance-1-0-lite-t2v-250428': 'seedance-1-0-lite-t2v-250428',
  'seedance-1-0-lite-i2v-250428': 'seedance-1-0-lite-i2v-250428',
  'seedance-1-0-pro-fast-251015': 'seedance-1-0-pro-fast-251015',
} as const;

export interface BytePlusVideoGenerationRequest {
  /** Callback notification address for the result of this generation task */
  callback_url?: string;
  /**
   * The input content for the model to generate a video
   * @minItems 1
   */
  content: BytePlusVideoGenerationContent[];
  /** Only supported by Seedance 1.5 pro. Whether the generated video includes audio synchronized with the visuals.
true: The model outputs a video with synchronized audio. Seedance 1.5 pro can automatically generate matching voice, sound effects, or background music based on the prompt and visual content. It is recommended to enclose dialogue in double quotes. Example: A man stops a woman and says, "Remember, never point your finger at the moon."
false: The model outputs a silent video.
 */
  generate_audio?: boolean;
  /** The ID of the model to call. Available models include seedance-1-5-pro-251215, seedance-1-0-pro-250528, seedance-1-0-pro-fast-251015, seedance-1-0-lite-t2v-250428, seedance-1-0-lite-i2v-250428 */
  model: BytePlusVideoGenerationRequestModel;
  /** Whether to return the last frame image of the generated video.
true: Returns the last frame image of the generated video. After setting this parameter to true, you can obtain the last frame image by calling the Querying the information about a video generation task. The last frame image is in PNG format, with its pixel width and height consistent with those of the generated video, and it contains no watermarks. Using this parameter allows the generation of multiple consecutive videos: the last frame of the previously generated video is used as the first frame of the next video task, enabling quick generation of multiple consecutive videos.
false: Does not return the last frame image of the generated video.
 */
  return_last_frame?: boolean;
}

export interface BytePlusVideoGenerationResponse {
  /** The ID of the video generation task */
  id: string;
}

export interface ClaimMyNodeRequest {
  /** GitHub token to verify if the user owns the repo of the node */
  GH_TOKEN: string;
}

export type ComfyNodePolicy = typeof ComfyNodePolicy[keyof typeof ComfyNodePolicy];


export const ComfyNodePolicy = {
  ComfyNodePolicyActive: 'ComfyNodePolicyActive',
  ComfyNodePolicyBanned: 'ComfyNodePolicyBanned',
  ComfyNodePolicyLocalOnly: 'ComfyNodePolicyLocalOnly',
} as const;

export interface ComfyNode {
  /** UI category where the node is listed, used for grouping nodes. */
  category?: string;
  /** Unique identifier for the node */
  comfy_node_name?: string;
  /** Indicates if the node is deprecated. Deprecated nodes are hidden in the UI. */
  deprecated?: boolean;
  /** Brief description of the node's functionality or purpose. */
  description?: string;
  /** Indicates if the node is experimental, subject to changes or removal. */
  experimental?: boolean;
  /** Name of the entry-point function to execute the node. */
  function?: string;
  /** Defines input parameters */
  input_types?: string;
  /** Boolean values indicating if each output is a list. */
  output_is_list?: boolean[];
  policy?: ComfyNodePolicy;
  /** Names of the outputs for clarity in workflows. */
  return_names?: string;
  /** Specifies the types of outputs produced by the node. */
  return_types?: string;
}

export interface ComfyNodeCloudBuildInfo {
  build_id?: string;
  location?: string;
  project_id?: string;
  project_number?: string;
}

export interface ComfyNodeUpdateRequest {
  /** UI category where the node is listed, used for grouping nodes. */
  category?: string;
  /** Indicates if the node is deprecated. Deprecated nodes are hidden in the UI. */
  deprecated?: boolean;
  /** Brief description of the node's functionality or purpose. */
  description?: string;
  /** Indicates if the node is experimental, subject to changes or removal. */
  experimental?: boolean;
  /** Name of the entry-point function to execute the node. */
  function?: string;
  /** Defines input parameters */
  input_types?: string;
  /** Boolean values indicating if each output is a list. */
  output_is_list?: boolean[];
  policy?: ComfyNodePolicy;
  /** Names of the outputs for clarity in workflows. */
  return_names?: string;
  /** Specifies the types of outputs produced by the node. */
  return_types?: string;
}

export type ComputerToolCallAction = { [key: string]: unknown };

/**
 * The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.

 */
export type ComputerToolCallStatus = typeof ComputerToolCallStatus[keyof typeof ComputerToolCallStatus];


export const ComputerToolCallStatus = {
  in_progress: 'in_progress',
  completed: 'completed',
  incomplete: 'incomplete',
} as const;

/**
 * The type of the computer call. Always `computer_call`.
 */
export type ComputerToolCallType = typeof ComputerToolCallType[keyof typeof ComputerToolCallType];


export const ComputerToolCallType = {
  computer_call: 'computer_call',
} as const;

/**
 * A tool call to a computer use tool. See the
[computer use guide](/docs/guides/tools-computer-use) for more information.

 */
export interface ComputerToolCall {
  action: ComputerToolCallAction;
  /** An identifier used when responding to the tool call with output.
 */
  call_id: string;
  /** The unique ID of the computer call. */
  id: string;
  /** The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.
 */
  status: ComputerToolCallStatus;
  /** The type of the computer call. Always `computer_call`. */
  type: ComputerToolCallType;
}

/**
 * The type of computer environment to control.
 */
export type ComputerUsePreviewToolEnvironment = typeof ComputerUsePreviewToolEnvironment[keyof typeof ComputerUsePreviewToolEnvironment];


export const ComputerUsePreviewToolEnvironment = {
  windows: 'windows',
  mac: 'mac',
  linux: 'linux',
  ubuntu: 'ubuntu',
  browser: 'browser',
} as const;

/**
 * The type of the computer use tool. Always `computer_use_preview`.
 */
export type ComputerUsePreviewToolType = typeof ComputerUsePreviewToolType[keyof typeof ComputerUsePreviewToolType];


export const ComputerUsePreviewToolType = {
  computer_use_preview: 'computer_use_preview',
} as const;

/**
 * A tool that controls a virtual computer. Learn more about the [computer tool](https://platform.openai.com/docs/guides/tools-computer-use).
 */
export interface ComputerUsePreviewTool {
  /** The height of the computer display. */
  display_height: number;
  /** The width of the computer display. */
  display_width: number;
  /** The type of computer environment to control. */
  environment: ComputerUsePreviewToolEnvironment;
  /** The type of the computer use tool. Always `computer_use_preview`. */
  type: ComputerUsePreviewToolType;
}

/**
 * How long the coupon lasts
 */
export type CouponResponseDuration = typeof CouponResponseDuration[keyof typeof CouponResponseDuration];


export const CouponResponseDuration = {
  once: 'once',
  repeating: 'repeating',
  forever: 'forever',
} as const;

/**
 * Set of key-value pairs for storing additional information
 */
export type CouponResponseMetadata = {[key: string]: string};

export interface CouponResponse {
  /** Amount off in cents */
  amount_off?: number;
  /** Currency for amount_off */
  currency?: string;
  /** How long the coupon lasts */
  duration: CouponResponseDuration;
  /** Number of months for repeating coupons */
  duration_in_months?: number;
  /** The Stripe coupon ID */
  id: string;
  /** Maximum number of times this coupon can be redeemed */
  max_redemptions?: number;
  /** Set of key-value pairs for storing additional information */
  metadata?: CouponResponseMetadata;
  /** Name of the coupon displayed to customers */
  name?: string;
  /** Percent off discount (0-100) */
  percent_off?: number;
  /** Unix timestamp specifying the last time at which the coupon can be redeemed */
  redeem_by?: number;
  /** Number of times this coupon has been redeemed */
  times_redeemed?: number;
  /** Whether the coupon can still be redeemed */
  valid: boolean;
}

export interface CreateAPIKeyRequest {
  description?: string;
  name: string;
}

/**
 * Currency for amount_off (required if amount_off is set)
 */
export type CreateCouponRequestCurrency = typeof CreateCouponRequestCurrency[keyof typeof CreateCouponRequestCurrency];


export const CreateCouponRequestCurrency = {
  usd: 'usd',
} as const;

/**
 * How long the coupon lasts
 */
export type CreateCouponRequestDuration = typeof CreateCouponRequestDuration[keyof typeof CreateCouponRequestDuration];


export const CreateCouponRequestDuration = {
  once: 'once',
  repeating: 'repeating',
  forever: 'forever',
} as const;

/**
 * Set of key-value pairs for storing additional information
 */
export type CreateCouponRequestMetadata = {[key: string]: string};

export interface CreateCouponRequest {
  /**
   * Amount off in cents
   * @minimum 0
   */
  amount_off?: number;
  /** Currency for amount_off (required if amount_off is set) */
  currency?: CreateCouponRequestCurrency;
  /** How long the coupon lasts */
  duration?: CreateCouponRequestDuration;
  /**
   * Required if duration is repeating
   * @minimum 1
   */
  duration_in_months?: number;
  /**
   * Maximum number of times this coupon can be redeemed
   * @minimum 1
   */
  max_redemptions?: number;
  /** Set of key-value pairs for storing additional information */
  metadata?: CreateCouponRequestMetadata;
  /** Name of the coupon displayed to customers */
  name?: string;
  /**
   * Percent off discount (0-100)
   * @minimum 0
   * @maximum 100
   */
  percent_off?: number;
  /** Unix timestamp specifying the last time at which the coupon can be redeemed */
  redeem_by?: number;
}

/**
 * How to handle truncation of the response
 */
export type ModelResponsePropertiesTruncation = typeof ModelResponsePropertiesTruncation[keyof typeof ModelResponsePropertiesTruncation];


export const ModelResponsePropertiesTruncation = {
  disabled: 'disabled',
  auto: 'auto',
} as const;

/**
 * Common properties for model responses
 */
export interface ModelResponseProperties {
  /** Instructions for the model on how to generate the response */
  instructions?: string;
  /** Maximum number of tokens to generate */
  max_output_tokens?: number;
  /** The model used to generate the response */
  model?: string;
  /**
   * Controls randomness in the response
   * @minimum 0
   * @maximum 2
   */
  temperature?: number;
  /**
   * Controls diversity of the response via nucleus sampling
   * @minimum 0
   * @maximum 1
   */
  top_p?: number;
  /** How to handle truncation of the response */
  truncation?: ModelResponsePropertiesTruncation;
}

export type CreateModelResponseProperties = ModelResponseProperties;

export interface CreatePromoCodeRequest {
  /** The Stripe coupon ID to create the promotional code for */
  coupon_id: string;
  /**
   * Number of days until the promotion code expires
   * @minimum 1
   */
  expire_days?: number;
  /**
   * Maximum number of times this code can be redeemed
   * @minimum 1
   */
  max_redemptions?: number;
}

export interface Customer {
  /** The date and time the user was created */
  createdAt?: string;
  /** The email address for this user */
  email?: string;
  /** Whether the user has funds */
  has_fund?: boolean;
  /** The firebase UID of the user */
  id: string;
  /** Whether the user is an admin */
  is_admin?: boolean;
  /** The Metronome customer ID */
  metronome_id?: string;
  /** The name for this user */
  name?: string;
  /** The Stripe customer ID */
  stripe_id?: string;
  /** The date and time the user was last updated */
  updatedAt?: string;
}

export interface CustomerAdmin {
  /**
   * The date when the subscription is set to end (ISO 8601 format)
   * @nullable
   */
  cloud_subscription_end_date?: string | null;
  /** Whether the customer has an active cloud subscription */
  cloud_subscription_is_active?: boolean;
  /**
   * The next renewal date for the subscription (ISO 8601 format)
   * @nullable
   */
  cloud_subscription_renewal_date?: string | null;
  /**
   * The active subscription ID if one exists
   * @nullable
   */
  cloud_subscription_subscription_id?: string | null;
  /** The date and time the user was created */
  createdAt?: string;
  /** The email address for this user */
  email?: string;
  /** Whether the user has funds */
  has_fund?: boolean;
  /** The firebase UID of the user */
  id: string;
  /** Whether the user is an admin */
  is_admin?: boolean;
  /** The Metronome customer ID */
  metronome_id?: string;
  /** The name for this user */
  name?: string;
  /** The Stripe customer ID */
  stripe_id?: string;
  /** The date and time the user was last updated */
  updatedAt?: string;
}

export interface CustomerStorageResourceResponse {
  /** The signed URL to use for downloading the file from the specified path */
  download_url?: string;
  /** Whether an existing file with the same hash was found */
  existing_file?: boolean;
  /** When the signed URL will expire */
  expires_at?: string;
  /** The signed URL to use for uploading the file to the specified path */
  upload_url?: string;
}

/**
 * The role of the message input. One of `user`, `assistant`, `system`, or
`developer`.

 */
export type EasyInputMessageRole = typeof EasyInputMessageRole[keyof typeof EasyInputMessageRole];


export const EasyInputMessageRole = {
  user: 'user',
  assistant: 'assistant',
  system: 'system',
  developer: 'developer',
} as const;

/**
 * The type of the message input. Always `message`.

 */
export type EasyInputMessageType = typeof EasyInputMessageType[keyof typeof EasyInputMessageType];


export const EasyInputMessageType = {
  message: 'message',
} as const;

/**
 * The type of the input item. Always `input_text`.
 */
export type InputTextContentType = typeof InputTextContentType[keyof typeof InputTextContentType];


export const InputTextContentType = {
  input_text: 'input_text',
} as const;

/**
 * A text input to the model.
 */
export interface InputTextContent {
  /** The text input to the model. */
  text: string;
  /** The type of the input item. Always `input_text`. */
  type: InputTextContentType;
}

/**
 * The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`.
 */
export type InputImageContentDetail = typeof InputImageContentDetail[keyof typeof InputImageContentDetail];


export const InputImageContentDetail = {
  low: 'low',
  high: 'high',
  auto: 'auto',
} as const;

/**
 * The type of the input item. Always `input_image`.
 */
export type InputImageContentType = typeof InputImageContentType[keyof typeof InputImageContentType];


export const InputImageContentType = {
  input_image: 'input_image',
} as const;

/**
 * An image input to the model. Learn about [image inputs](/docs/guides/vision).
 */
export interface InputImageContent {
  /** The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`. */
  detail: InputImageContentDetail;
  /** The ID of the file to be sent to the model. */
  file_id?: string;
  /** The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL. */
  image_url?: string;
  /** The type of the input item. Always `input_image`. */
  type: InputImageContentType;
}

/**
 * The type of the input item. Always `input_file`.
 */
export type InputFileContentType = typeof InputFileContentType[keyof typeof InputFileContentType];


export const InputFileContentType = {
  input_file: 'input_file',
} as const;

/**
 * A file input to the model.
 */
export interface InputFileContent {
  /** The content of the file to be sent to the model.
 */
  file_data?: string;
  /** The ID of the file to be sent to the model. */
  file_id?: string;
  /** The name of the file to be sent to the model. */
  filename?: string;
  /** The type of the input item. Always `input_file`. */
  type: InputFileContentType;
}

export type InputContent = InputTextContent | InputImageContent | InputFileContent;

/**
 * A list of one or many input items to the model, containing different content
types.

 */
export type InputMessageContentList = InputContent[];

/**
 * A message input to the model with a role indicating instruction following
hierarchy. Instructions given with the `developer` or `system` role take
precedence over instructions given with the `user` role. Messages with the
`assistant` role are presumed to have been generated by the model in previous
interactions.

 */
export interface EasyInputMessage {
  /** Text, image, or audio input to the model, used to generate a response.
Can also contain previous assistant responses.
 */
  content: string | InputMessageContentList;
  /** The role of the message input. One of `user`, `assistant`, `system`, or
`developer`.
 */
  role: EasyInputMessageRole;
  /** The type of the message input. Always `message`.
 */
  type?: EasyInputMessageType;
}

export interface Error {
  /** Optional detailed information about the error or hints for resolving it. */
  details?: string[];
  /** A clear and concise description of the error. */
  message?: string;
}

export interface ErrorResponse {
  error: string;
  message: string;
}

export interface FeaturesResponse {
  /** The conversion rate for partner nodes */
  partner_node_conversion_rate: number;
}

/**
 * The type of tool
 */
export type FileSearchToolType = typeof FileSearchToolType[keyof typeof FileSearchToolType];


export const FileSearchToolType = {
  file_search: 'file_search',
} as const;

export interface FileSearchTool {
  /** The type of tool */
  type: FileSearchToolType;
  /** IDs of vector stores to search in */
  vector_store_ids: string[];
}

export type FileSearchToolCallResultsItem = {
  /** The unique ID of the file.
 */
  file_id?: string;
  /** The name of the file.
 */
  filename?: string;
  /** The relevance score of the file - a value between 0 and 1.
 */
  score?: number;
  /** The text that was retrieved from the file.
 */
  text?: string;
};

/**
 * The status of the file search tool call. One of `in_progress`,
`searching`, `incomplete` or `failed`,

 */
export type FileSearchToolCallStatus = typeof FileSearchToolCallStatus[keyof typeof FileSearchToolCallStatus];


export const FileSearchToolCallStatus = {
  in_progress: 'in_progress',
  searching: 'searching',
  completed: 'completed',
  incomplete: 'incomplete',
  failed: 'failed',
} as const;

/**
 * The type of the file search tool call. Always `file_search_call`.

 */
export type FileSearchToolCallType = typeof FileSearchToolCallType[keyof typeof FileSearchToolCallType];


export const FileSearchToolCallType = {
  file_search_call: 'file_search_call',
} as const;

/**
 * The results of a file search tool call. See the
[file search guide](/docs/guides/tools-file-search) for more information.

 */
export interface FileSearchToolCall {
  /** The unique ID of the file search tool call.
 */
  id: string;
  /** The queries used to search for files.
 */
  queries: string[];
  /** The results of the file search tool call.
 */
  results?: FileSearchToolCallResultsItem[];
  /** The status of the file search tool call. One of `in_progress`,
`searching`, `incomplete` or `failed`,
 */
  status: FileSearchToolCallStatus;
  /** The type of the file search tool call. Always `file_search_call`.
 */
  type: FileSearchToolCallType;
}

export interface FreepikErrorResponse {
  error?: string;
  message?: string;
}

/**
 * Engine preset for relighting:
- balanced: Well-rounded, general-purpose option
- cool: Brighter with cooler tones
- real: Aims to enhance photographic quality (Experimental)
- illusio: Optimized for illustrations and drawings
- fairy: Suited for fantasy-themed images
- colorful_anime: Ideal for anime, cartoons, and vibrant colors
- hard_transform: Significantly alters the original image
- softy: Slightly softer effect, suitable for graphic designs

 */
export type FreepikMagnificRelightRequestAdvancedSettingsEngine = typeof FreepikMagnificRelightRequestAdvancedSettingsEngine[keyof typeof FreepikMagnificRelightRequestAdvancedSettingsEngine];


export const FreepikMagnificRelightRequestAdvancedSettingsEngine = {
  automatic: 'automatic',
  balanced: 'balanced',
  cool: 'cool',
  real: 'real',
  illusio: 'illusio',
  fairy: 'fairy',
  colorful_anime: 'colorful_anime',
  hard_transform: 'hard_transform',
  softy: 'softy',
} as const;

/**
 * Adjusts the intensity of light transfer.
 */
export type FreepikMagnificRelightRequestAdvancedSettingsTransferLightA = typeof FreepikMagnificRelightRequestAdvancedSettingsTransferLightA[keyof typeof FreepikMagnificRelightRequestAdvancedSettingsTransferLightA];


export const FreepikMagnificRelightRequestAdvancedSettingsTransferLightA = {
  automatic: 'automatic',
  low: 'low',
  medium: 'medium',
  normal: 'normal',
  high: 'high',
  high_on_faces: 'high_on_faces',
} as const;

/**
 * Also modifies light transfer intensity. Can be combined with transfer_light_a for varied effects.
 */
export type FreepikMagnificRelightRequestAdvancedSettingsTransferLightB = typeof FreepikMagnificRelightRequestAdvancedSettingsTransferLightB[keyof typeof FreepikMagnificRelightRequestAdvancedSettingsTransferLightB];


export const FreepikMagnificRelightRequestAdvancedSettingsTransferLightB = {
  automatic: 'automatic',
  composition: 'composition',
  straight: 'straight',
  smooth_in: 'smooth_in',
  smooth_out: 'smooth_out',
  smooth_both: 'smooth_both',
  reverse_both: 'reverse_both',
  soft_in: 'soft_in',
  soft_out: 'soft_out',
  soft_mid: 'soft_mid',
  strong_mid: 'strong_mid',
  style_shift: 'style_shift',
  strong_shift: 'strong_shift',
} as const;

export type FreepikMagnificRelightRequestAdvancedSettings = {
  /**
   * Adjust the level of black color in the image.
   * @minimum 0
   * @maximum 100
   */
  blacks?: number;
  /**
   * Adjust the level of brightness in the image.
   * @minimum 0
   * @maximum 100
   */
  brightness?: number;
  /**
   * Adjust the level of contrast in the image.
   * @minimum 0
   * @maximum 100
   */
  contrast?: number;
  /** Engine preset for relighting:
- balanced: Well-rounded, general-purpose option
- cool: Brighter with cooler tones
- real: Aims to enhance photographic quality (Experimental)
- illusio: Optimized for illustrations and drawings
- fairy: Suited for fantasy-themed images
- colorful_anime: Ideal for anime, cartoons, and vibrant colors
- hard_transform: Significantly alters the original image
- softy: Slightly softer effect, suitable for graphic designs
 */
  engine?: FreepikMagnificRelightRequestAdvancedSettingsEngine;
  /** When enabled, using the same settings will consistently produce the same image. */
  fixed_generation?: boolean;
  /**
   * Adjust the level of saturation in the image.
   * @minimum 0
   * @maximum 100
   */
  saturation?: number;
  /** Adjusts the intensity of light transfer. */
  transfer_light_a?: FreepikMagnificRelightRequestAdvancedSettingsTransferLightA;
  /** Also modifies light transfer intensity. Can be combined with transfer_light_a for varied effects. */
  transfer_light_b?: FreepikMagnificRelightRequestAdvancedSettingsTransferLightB;
  /**
   * Adjust the level of white color in the image.
   * @minimum 0
   * @maximum 100
   */
  whites?: number;
};

/**
 * Style preset for the relight operation.
 */
export type FreepikMagnificRelightRequestStyle = typeof FreepikMagnificRelightRequestStyle[keyof typeof FreepikMagnificRelightRequestStyle];


export const FreepikMagnificRelightRequestStyle = {
  standard: 'standard',
  darker_but_realistic: 'darker_but_realistic',
  clean: 'clean',
  smooth: 'smooth',
  brighter: 'brighter',
  contrasted_n_hdr: 'contrasted_n_hdr',
  just_composition: 'just_composition',
} as const;

export interface FreepikMagnificRelightRequest {
  advanced_settings?: FreepikMagnificRelightRequestAdvancedSettings;
  /** When enabled, changes the background based on prompt and/or reference image. Useful for product placement and portraits. */
  change_background?: boolean;
  /** Base64 or URL of the image to do the relight */
  image: string;
  /** When enabled, makes the final image interpolate from the original using the light transfer strength slider. */
  interpolate_from_original?: boolean;
  /**
   * Level of light transfer intensity. 0% keeps closest to original, 100% is maximum transfer.
   * @minimum 0
   * @maximum 100
   */
  light_transfer_strength?: number;
  /** Maintains texture and small details of the original image. Good for product photography, texts, etc. */
  preserve_details?: boolean;
  /** You can guide the generation process and influence the light transfer with a descriptive prompt.
IMPORTANT: You can emphasize specific aspects of the light in your prompt by using a number in parentheses, ranging from 1 to 1.4, like "(dark scene:1.3)".
 */
  prompt?: string;
  /** Style preset for the relight operation. */
  style?: FreepikMagnificRelightRequestStyle;
  /** Base64 or URL of the lightmap for light transfer. Incompatible with 'transfer_light_from_reference_image' */
  transfer_light_from_lightmap?: string;
  /** Base64 or URL of the reference image for light transfer. Incompatible with 'transfer_light_from_lightmap' */
  transfer_light_from_reference_image?: string;
  /** Optional callback URL that will receive asynchronous notifications whenever the task changes status. */
  webhook_url?: string;
}

/**
 * Engine preset for style transfer
 */
export type FreepikMagnificStyleTransferRequestEngine = typeof FreepikMagnificStyleTransferRequestEngine[keyof typeof FreepikMagnificStyleTransferRequestEngine];


export const FreepikMagnificStyleTransferRequestEngine = {
  balanced: 'balanced',
  definio: 'definio',
  illusio: 'illusio',
  '3d_cartoon': '3d_cartoon',
  colorful_anime: 'colorful_anime',
  caricature: 'caricature',
  real: 'real',
  super_real: 'super_real',
  softy: 'softy',
} as const;

/**
 * Flavor of the transferring style
 */
export type FreepikMagnificStyleTransferRequestFlavor = typeof FreepikMagnificStyleTransferRequestFlavor[keyof typeof FreepikMagnificStyleTransferRequestFlavor];


export const FreepikMagnificStyleTransferRequestFlavor = {
  faithful: 'faithful',
  gen_z: 'gen_z',
  psychedelia: 'psychedelia',
  detaily: 'detaily',
  clear: 'clear',
  donotstyle: 'donotstyle',
  donotstyle_sharp: 'donotstyle_sharp',
} as const;

/**
 * Facial beautification on portrait images. Only used if is_portrait is true.
 */
export type FreepikMagnificStyleTransferRequestPortraitBeautifier = typeof FreepikMagnificStyleTransferRequestPortraitBeautifier[keyof typeof FreepikMagnificStyleTransferRequestPortraitBeautifier];


export const FreepikMagnificStyleTransferRequestPortraitBeautifier = {
  beautify_face: 'beautify_face',
  beautify_face_max: 'beautify_face_max',
} as const;

/**
 * Visual style applied to portrait images. Only used if is_portrait is true.
 */
export type FreepikMagnificStyleTransferRequestPortraitStyle = typeof FreepikMagnificStyleTransferRequestPortraitStyle[keyof typeof FreepikMagnificStyleTransferRequestPortraitStyle];


export const FreepikMagnificStyleTransferRequestPortraitStyle = {
  standard: 'standard',
  pop: 'pop',
  super_pop: 'super_pop',
} as const;

export interface FreepikMagnificStyleTransferRequest {
  /** Engine preset for style transfer */
  engine?: FreepikMagnificStyleTransferRequestEngine;
  /** When enabled, using the same settings will consistently produce the same image. */
  fixed_generation?: boolean;
  /** Flavor of the transferring style */
  flavor?: FreepikMagnificStyleTransferRequestFlavor;
  /** Base64 or URL of the image to do the style transfer */
  image: string;
  /** Indicates whether the image should be processed as a portrait. */
  is_portrait?: boolean;
  /** Facial beautification on portrait images. Only used if is_portrait is true. */
  portrait_beautifier?: FreepikMagnificStyleTransferRequestPortraitBeautifier;
  /** Visual style applied to portrait images. Only used if is_portrait is true. */
  portrait_style?: FreepikMagnificStyleTransferRequestPortraitStyle;
  /** Prompt for the AI model */
  prompt?: string;
  /** Base64 or URL of the reference image for style transfer */
  reference_image: string;
  /**
   * Allows to maintain the structure of the original image
   * @minimum 0
   * @maximum 100
   */
  structure_strength?: number;
  /**
   * Percentage of style strength
   * @minimum 0
   * @maximum 100
   */
  style_strength?: number;
  /** Optional callback URL for async notifications. */
  webhook_url?: string;
}

/**
 * Magnific model engines.
 */
export type FreepikMagnificUpscalerCreativeRequestEngine = typeof FreepikMagnificUpscalerCreativeRequestEngine[keyof typeof FreepikMagnificUpscalerCreativeRequestEngine];


export const FreepikMagnificUpscalerCreativeRequestEngine = {
  automatic: 'automatic',
  magnific_illusio: 'magnific_illusio',
  magnific_sharpy: 'magnific_sharpy',
  magnific_sparkle: 'magnific_sparkle',
} as const;

/**
 * Styles to optimize the upscale process.
 */
export type FreepikMagnificUpscalerCreativeRequestOptimizedFor = typeof FreepikMagnificUpscalerCreativeRequestOptimizedFor[keyof typeof FreepikMagnificUpscalerCreativeRequestOptimizedFor];


export const FreepikMagnificUpscalerCreativeRequestOptimizedFor = {
  standard: 'standard',
  soft_portraits: 'soft_portraits',
  hard_portraits: 'hard_portraits',
  art_n_illustration: 'art_n_illustration',
  videogame_assets: 'videogame_assets',
  nature_n_landscapes: 'nature_n_landscapes',
  films_n_photography: 'films_n_photography',
  '3d_renders': '3d_renders',
  science_fiction_n_horror: 'science_fiction_n_horror',
} as const;

/**
 * Configure scale factor of the image. For higher scales, the image will take longer to process.
 */
export type FreepikMagnificUpscalerCreativeRequestScaleFactor = typeof FreepikMagnificUpscalerCreativeRequestScaleFactor[keyof typeof FreepikMagnificUpscalerCreativeRequestScaleFactor];


export const FreepikMagnificUpscalerCreativeRequestScaleFactor = {
  '2x': '2x',
  '4x': '4x',
  '8x': '8x',
  '16x': '16x',
} as const;

export interface FreepikMagnificUpscalerCreativeRequest {
  /**
   * Increase or decrease AI's creativity. Valid values range [-10, 10].
   * @minimum -10
   * @maximum 10
   */
  creativity?: number;
  /** Magnific model engines. */
  engine?: FreepikMagnificUpscalerCreativeRequestEngine;
  /**
   * Control the strength of the prompt and intricacy per square pixel. Valid values range [-10, 10].
   * @minimum -10
   * @maximum 10
   */
  fractality?: number;
  /**
   * Increase or decrease the level of definition and detail. Valid values range [-10, 10].
   * @minimum -10
   * @maximum 10
   */
  hdr?: number;
  /** Base64 image or URL to upscale. The resulted image can't exceed maximum allowed size of 25.3 million pixels. */
  image: string;
  /** Styles to optimize the upscale process. */
  optimized_for?: FreepikMagnificUpscalerCreativeRequestOptimizedFor;
  /** Prompt to guide the upscale process. Reusing the same prompt for AI-generated images will improve the results. */
  prompt?: string;
  /**
   * Adjust the level of resemblance to the original image. Valid values range [-10, 10].
   * @minimum -10
   * @maximum 10
   */
  resemblance?: number;
  /** Configure scale factor of the image. For higher scales, the image will take longer to process. */
  scale_factor?: FreepikMagnificUpscalerCreativeRequestScaleFactor;
  /** Optional callback URL that will receive asynchronous notifications whenever the task changes status. */
  webhook_url?: string;
}

/**
 * Image processing flavor:
- sublime: Optimized for artistic and illustrated images
- photo: Optimized for photographic images
- photo_denoiser: Specialized for photos with noise reduction

 */
export type FreepikMagnificUpscalerPrecisionV2RequestFlavor = typeof FreepikMagnificUpscalerPrecisionV2RequestFlavor[keyof typeof FreepikMagnificUpscalerPrecisionV2RequestFlavor];


export const FreepikMagnificUpscalerPrecisionV2RequestFlavor = {
  sublime: 'sublime',
  photo: 'photo',
  photo_denoiser: 'photo_denoiser',
} as const;

export interface FreepikMagnificUpscalerPrecisionV2Request {
  /** Image processing flavor:
- sublime: Optimized for artistic and illustrated images
- photo: Optimized for photographic images
- photo_denoiser: Specialized for photos with noise reduction
 */
  flavor?: FreepikMagnificUpscalerPrecisionV2RequestFlavor;
  /** Source image to upscale. Accepts either:
- A publicly accessible HTTPS URL pointing to the image
- A base64-encoded image string
 */
  image: string;
  /**
   * Image scaling factor. Determines how much larger the output will be compared to input.
   * @minimum 2
   * @maximum 16
   */
  scale_factor?: number;
  /**
   * Image sharpness intensity control. Higher values increase edge definition and clarity.
   * @minimum 0
   * @maximum 100
   */
  sharpen?: number;
  /**
   * Intelligent grain/texture enhancement. Higher values add more fine-grained texture.
   * @minimum 0
   * @maximum 100
   */
  smart_grain?: number;
  /**
   * Ultra detail enhancement level. Higher values create more intricate details.
   * @minimum 0
   * @maximum 100
   */
  ultra_detail?: number;
  /** Optional callback URL that will receive asynchronous notifications when the upscaling task completes. */
  webhook_url?: string;
}

export interface FreepikSkinEnhancerCreativeRequest {
  /** Input image. Supports Base64 encoding or HTTPS URL (must be publicly accessible). */
  image: string;
  /**
   * Sharpening intensity
   * @minimum 0
   * @maximum 100
   */
  sharpen?: number;
  /**
   * Smart grain intensity
   * @minimum 0
   * @maximum 100
   */
  smart_grain?: number;
  /** Optional callback URL for async notifications. */
  webhook_url?: string;
}

export interface FreepikSkinEnhancerFaithfulRequest {
  /** Input image. Supports Base64 encoding or HTTPS URL (must be publicly accessible). */
  image: string;
  /**
   * Sharpening intensity
   * @minimum 0
   * @maximum 100
   */
  sharpen?: number;
  /**
   * Skin detail enhancement level
   * @minimum 0
   * @maximum 100
   */
  skin_detail?: number;
  /**
   * Smart grain intensity
   * @minimum 0
   * @maximum 100
   */
  smart_grain?: number;
  /** Optional callback URL for async notifications. */
  webhook_url?: string;
}

/**
 * Optimization target for flexible skin enhancer
 */
export type FreepikSkinEnhancerFlexibleRequestOptimizedFor = typeof FreepikSkinEnhancerFlexibleRequestOptimizedFor[keyof typeof FreepikSkinEnhancerFlexibleRequestOptimizedFor];


export const FreepikSkinEnhancerFlexibleRequestOptimizedFor = {
  enhance_skin: 'enhance_skin',
  improve_lighting: 'improve_lighting',
  enhance_everything: 'enhance_everything',
  transform_to_real: 'transform_to_real',
  no_make_up: 'no_make_up',
} as const;

export interface FreepikSkinEnhancerFlexibleRequest {
  /** Input image. Supports Base64 encoding or HTTPS URL (must be publicly accessible). */
  image: string;
  /** Optimization target for flexible skin enhancer */
  optimized_for?: FreepikSkinEnhancerFlexibleRequestOptimizedFor;
  /**
   * Sharpening intensity
   * @minimum 0
   * @maximum 100
   */
  sharpen?: number;
  /**
   * Smart grain intensity
   * @minimum 0
   * @maximum 100
   */
  smart_grain?: number;
  /** Optional callback URL for async notifications. */
  webhook_url?: string;
}

export type FreepikTaskDataStatus = typeof FreepikTaskDataStatus[keyof typeof FreepikTaskDataStatus];


export const FreepikTaskDataStatus = {
  CREATED: 'CREATED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
} as const;

export interface FreepikTaskData {
  /** URLs to the generated images. */
  generated?: string[];
  status?: FreepikTaskDataStatus;
  task_id?: string;
}

export interface FreepikTaskResponse {
  data: FreepikTaskData;
}

/**
 * JSON Schema object describing the function parameters
 */
export type FunctionToolParameters = { [key: string]: unknown };

/**
 * The type of tool
 */
export type FunctionToolType = typeof FunctionToolType[keyof typeof FunctionToolType];


export const FunctionToolType = {
  function: 'function',
} as const;

export interface FunctionTool {
  /** Description of what the function does */
  description?: string;
  /** Name of the function */
  name: string;
  /** JSON Schema object describing the function parameters */
  parameters: FunctionToolParameters;
  /** The type of tool */
  type: FunctionToolType;
}

/**
 * The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.

 */
export type FunctionToolCallStatus = typeof FunctionToolCallStatus[keyof typeof FunctionToolCallStatus];


export const FunctionToolCallStatus = {
  in_progress: 'in_progress',
  completed: 'completed',
  incomplete: 'incomplete',
} as const;

/**
 * The type of the function tool call. Always `function_call`.

 */
export type FunctionToolCallType = typeof FunctionToolCallType[keyof typeof FunctionToolCallType];


export const FunctionToolCallType = {
  function_call: 'function_call',
} as const;

/**
 * A tool call to run a function. See the
[function calling guide](/docs/guides/function-calling) for more information.

 */
export interface FunctionToolCall {
  /** A JSON string of the arguments to pass to the function.
 */
  arguments: string;
  /** The unique ID of the function tool call generated by the model.
 */
  call_id: string;
  /** The unique ID of the function tool call.
 */
  id?: string;
  /** The name of the function to run.
 */
  name: string;
  /** The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.
 */
  status?: FunctionToolCallStatus;
  /** The type of the function tool call. Always `function_call`.
 */
  type: FunctionToolCallType;
}

export interface GeminiCitation {
  authors?: string[];
  endIndex?: number;
  license?: string;
  publicationDate?: string;
  startIndex?: number;
  title?: string;
  uri?: string;
}

export interface GeminiCitationMetadata {
  citations?: GeminiCitation[];
}

/**
 * The media type of the file specified in the data or fileUri fields. Acceptable values include the following. For gemini-2.0-flash-lite and gemini-2.0-flash, the maximum length of an audio file is 8.4 hours and the maximum length of a video file (without audio) is one hour. For more information, see Gemini audio and video requirements. Text files must be UTF-8 encoded. The contents of the text file count toward the token limit. There is no limit on image resolution.
 */
export type GeminiMimeType = typeof GeminiMimeType[keyof typeof GeminiMimeType];


export const GeminiMimeType = {
  'application/pdf': 'application/pdf',
  'audio/mpeg': 'audio/mpeg',
  'audio/mp3': 'audio/mp3',
  'audio/wav': 'audio/wav',
  'image/png': 'image/png',
  'image/jpeg': 'image/jpeg',
  'image/webp': 'image/webp',
  'text/plain': 'text/plain',
  'video/mov': 'video/mov',
  'video/mpeg': 'video/mpeg',
  'video/mp4': 'video/mp4',
  'video/mpg': 'video/mpg',
  'video/avi': 'video/avi',
  'video/wmv': 'video/wmv',
  'video/mpegps': 'video/mpegps',
  'video/flv': 'video/flv',
} as const;

/**
 * URI based data.
 */
export interface GeminiFileData {
  /** URI */
  fileUri?: string;
  mimeType?: GeminiMimeType;
}

/**
 * Inline data in raw bytes. For gemini-2.0-flash-lite and gemini-2.0-flash, you can specify up to 3000 images by using inlineData.

 */
export interface GeminiInlineData {
  /** The base64 encoding of the image, PDF, or video to include inline in the prompt. When including media inline, you must also specify the media type (mimeType) of the data. Size limit: 20MB
 */
  data?: string;
  mimeType?: GeminiMimeType;
}

export interface GeminiPart {
  fileData?: GeminiFileData;
  inlineData?: GeminiInlineData;
  /** A text prompt or code snippet. */
  text?: string;
}

export type GeminiContentRole = typeof GeminiContentRole[keyof typeof GeminiContentRole];


export const GeminiContentRole = {
  user: 'user',
  model: 'model',
} as const;

/**
 * The content of the current conversation with the model. For single-turn queries, this is a single instance. For multi-turn queries, this is a repeated field that contains conversation history and the latest request.

 */
export interface GeminiContent {
  parts: GeminiPart[];
  role: GeminiContentRole;
}

export type GeminiSafetyCategory = typeof GeminiSafetyCategory[keyof typeof GeminiSafetyCategory];


export const GeminiSafetyCategory = {
  HARM_CATEGORY_SEXUALLY_EXPLICIT: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
  HARM_CATEGORY_HATE_SPEECH: 'HARM_CATEGORY_HATE_SPEECH',
  HARM_CATEGORY_HARASSMENT: 'HARM_CATEGORY_HARASSMENT',
  HARM_CATEGORY_DANGEROUS_CONTENT: 'HARM_CATEGORY_DANGEROUS_CONTENT',
} as const;

/**
 * The probability that the content violates the specified safety category
 */
export type GeminiSafetyRatingProbability = typeof GeminiSafetyRatingProbability[keyof typeof GeminiSafetyRatingProbability];


export const GeminiSafetyRatingProbability = {
  NEGLIGIBLE: 'NEGLIGIBLE',
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  UNKNOWN: 'UNKNOWN',
} as const;

export interface GeminiSafetyRating {
  category?: GeminiSafetyCategory;
  /** The probability that the content violates the specified safety category */
  probability?: GeminiSafetyRatingProbability;
}

export interface GeminiCandidate {
  citationMetadata?: GeminiCitationMetadata;
  content?: GeminiContent;
  finishReason?: string;
  safetyRatings?: GeminiSafetyRating[];
}

/**
 * JSON schema for the function parameters
 */
export type GeminiFunctionDeclarationParameters = { [key: string]: unknown };

export interface GeminiFunctionDeclaration {
  description?: string;
  name: string;
  /** JSON schema for the function parameters */
  parameters: GeminiFunctionDeclarationParameters;
}

export type GeminiGenerationConfigResponseModalitiesItem = typeof GeminiGenerationConfigResponseModalitiesItem[keyof typeof GeminiGenerationConfigResponseModalitiesItem];


export const GeminiGenerationConfigResponseModalitiesItem = {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
} as const;

/**
 * Configuration for image generation
 */
export type GeminiGenerationConfigImageConfig = {
  /** Aspect ratio for generated images */
  aspectRatio?: string;
  /** Optional. Specifies the size of generated images. Supported values are 1K, 2K, 4K. If not specified, the model will use default value 1K. */
  imageSize?: string;
};

export interface GeminiGenerationConfig {
  /** Configuration for image generation */
  imageConfig?: GeminiGenerationConfigImageConfig;
  /**
   * Maximum number of tokens that can be generated in the response. A token is approximately 4 characters. 100 tokens correspond to roughly 60-80 words.

   * @minimum 16
   * @maximum 8192
   */
  maxOutputTokens?: number;
  responseModalities?: GeminiGenerationConfigResponseModalitiesItem[];
  /** When seed is fixed to a specific value, the model makes a best effort to provide the same response for repeated requests. Deterministic output isn't guaranteed. Also, changing the model or parameter settings, such as the temperature, can cause variations in the response even when you use the same seed value. By default, a random seed value is used. Available for the following models:, gemini-2.5-flash, gemini-2.5-pro, gemini-2.5-flash-preview-04-1, gemini-2.5-pro-preview-05-0, gemini-2.0-flash-lite-00, gemini-2.0-flash-001
 */
  seed?: number;
  stopSequences?: string[];
  /**
   * The temperature is used for sampling during response generation, which occurs when topP and topK are applied. Temperature controls the degree of randomness in token selection. Lower temperatures are good for prompts that require a less open-ended or creative response, while higher temperatures can lead to more diverse or creative results. A temperature of 0 means that the highest probability tokens are always selected. In this case, responses for a given prompt are mostly deterministic, but a small amount of variation is still possible. If the model returns a response that's too generic, too short, or the model gives a fallback response, try increasing the temperature

   * @minimum 0
   * @maximum 2
   */
  temperature?: number;
  /**
   * Top-K changes how the model selects tokens for output. A top-K of 1 means the next selected token is the most probable among all tokens in the model's vocabulary. A top-K of 3 means that the next token is selected from among the 3 most probable tokens by using temperature.

   * @minimum 1
   */
  topK?: number;
  /**
   * If specified, nucleus sampling is used.
Top-P changes how the model selects tokens for output. Tokens are selected from the most (see top-K) to least probable until the sum of their probabilities equals the top-P value. For example, if tokens A, B, and C have a probability of 0.3, 0.2, and 0.1 and the top-P value is 0.5, then the model will select either A or B as the next token by using temperature and excludes C as a candidate.
Specify a lower value for less random responses and a higher value for more random responses.

   * @minimum 0
   * @maximum 1
   */
  topP?: number;
}

export type GeminiSafetyThreshold = typeof GeminiSafetyThreshold[keyof typeof GeminiSafetyThreshold];


export const GeminiSafetyThreshold = {
  OFF: 'OFF',
  BLOCK_NONE: 'BLOCK_NONE',
  BLOCK_LOW_AND_ABOVE: 'BLOCK_LOW_AND_ABOVE',
  BLOCK_MEDIUM_AND_ABOVE: 'BLOCK_MEDIUM_AND_ABOVE',
  BLOCK_ONLY_HIGH: 'BLOCK_ONLY_HIGH',
} as const;

/**
 * Per request settings for blocking unsafe content. Enforced on GenerateContentResponse.candidates.

 */
export interface GeminiSafetySetting {
  category: GeminiSafetyCategory;
  threshold: GeminiSafetyThreshold;
}

export interface GeminiTextPart {
  /** A text prompt or code snippet. */
  text?: string;
}

/**
 * The identity of the entity that creates the message. The following values are supported: user: This indicates that the message is sent by a real person, typically a user-generated message. model: This indicates that the message is generated by the model. The model value is used to insert messages from the model into the conversation during multi-turn conversations. For non-multi-turn conversations, this field can be left blank or unset.

 */
export type GeminiSystemInstructionContentRole = typeof GeminiSystemInstructionContentRole[keyof typeof GeminiSystemInstructionContentRole];


export const GeminiSystemInstructionContentRole = {
  user: 'user',
  model: 'model',
} as const;

/**
 * Available for gemini-2.0-flash and gemini-2.0-flash-lite. Instructions for the model to steer it toward better performance. For example, "Answer as concisely as possible" or "Don't use technical terms in your response". The text strings count toward the token limit. The role field of systemInstruction is ignored and doesn't affect the performance of the model. Note: Only text should be used in parts and content in each part should be in a separate paragraph.

 */
export interface GeminiSystemInstructionContent {
  /** A list of ordered parts that make up a single message. Different parts may have different IANA MIME types. For limits on the inputs, such as the maximum number of tokens or the number of images, see the model specifications on the Google models page.
 */
  parts: GeminiTextPart[];
  /** The identity of the entity that creates the message. The following values are supported: user: This indicates that the message is sent by a real person, typically a user-generated message. model: This indicates that the message is generated by the model. The model value is used to insert messages from the model into the conversation during multi-turn conversations. For non-multi-turn conversations, this field can be left blank or unset.
 */
  role: GeminiSystemInstructionContentRole;
}

/**
 * A piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the model. See Function calling.

 */
export interface GeminiTool {
  functionDeclarations?: GeminiFunctionDeclaration[];
}

/**
 * Represents a duration offset for video timeline positions.

 */
export interface GeminiOffset {
  /**
   * Signed fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values.

   * @minimum 0
   * @maximum 999999999
   */
  nanos?: number;
  /**
   * Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive.

   * @minimum -315576000000
   * @maximum 315576000000
   */
  seconds?: number;
}

/**
 * For video input, the start and end offset of the video in Duration format. For example, to specify a 10 second clip starting at 1:00, set "startOffset": { "seconds": 60 } and "endOffset": { "seconds": 70 }. The metadata should only be specified while the video data is presented in inlineData or fileData.

 */
export interface GeminiVideoMetadata {
  endOffset?: GeminiOffset;
  startOffset?: GeminiOffset;
}

export interface GeminiGenerateContentRequest {
  contents: GeminiContent[];
  generationConfig?: GeminiGenerationConfig;
  safetySettings?: GeminiSafetySetting[];
  systemInstruction?: GeminiSystemInstructionContent;
  tools?: GeminiTool[];
  /** If true, generated images will be uploaded to cloud storage and returned as signed URLs instead of inline base64 data. The URLs expire after 24 hours. */
  uploadImagesToStorage?: boolean;
  videoMetadata?: GeminiVideoMetadata;
}

export interface GeminiPromptFeedback {
  blockReason?: string;
  blockReasonMessage?: string;
  safetyRatings?: GeminiSafetyRating[];
}

/**
 * Type of input or output content modality.
 */
export type Modality = typeof Modality[keyof typeof Modality];


export const Modality = {
  MODALITY_UNSPECIFIED: 'MODALITY_UNSPECIFIED',
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  DOCUMENT: 'DOCUMENT',
} as const;

export interface ModalityTokenCount {
  modality?: Modality;
  /** Number of tokens for the given modality. */
  tokenCount?: number;
}

export interface GeminiUsageMetadata {
  /** Output only. Number of tokens in the cached part in the input (the cached content). */
  cachedContentTokenCount?: number;
  /** Number of tokens in the response(s). */
  candidatesTokenCount?: number;
  /** Breakdown of candidate tokens by modality. */
  candidatesTokensDetails?: ModalityTokenCount[];
  /** Number of tokens in the request. When cachedContent is set, this is still the total effective prompt size meaning this includes the number of tokens in the cached content. */
  promptTokenCount?: number;
  /** Breakdown of prompt tokens by modality. */
  promptTokensDetails?: ModalityTokenCount[];
  /** Number of tokens present in thoughts output. */
  thoughtsTokenCount?: number;
  /** Number of tokens present in tool-use prompt(s). */
  toolUsePromptTokenCount?: number;
  /** Total number of tokens (prompt + candidates). */
  totalTokenCount?: number;
  /** Traffic type used for the request (e.g., PROVISIONED_THROUGHPUT). */
  trafficType?: string;
}

export interface GeminiGenerateContentResponse {
  candidates?: GeminiCandidate[];
  /** Timestamp when the response was created. */
  createTime?: string;
  /** The model version used to generate the response. */
  modelVersion?: string;
  promptFeedback?: GeminiPromptFeedback;
  /** Unique identifier for the response. */
  responseId?: string;
  usageMetadata?: GeminiUsageMetadata;
}

/**
 * A map of operating system to status pairs
 */
export type GitCommitSummaryStatusSummary = {[key: string]: string};

export interface GitCommitSummary {
  /** The author of the commit */
  author?: string;
  /** The branch where the commit was made */
  branch_name?: string;
  /** The hash of the commit */
  commit_hash?: string;
  /** The name of the commit */
  commit_name?: string;
  /** A map of operating system to status pairs */
  status_summary?: GitCommitSummaryStatusSummary;
  /** The timestamp when the commit was made */
  timestamp?: string;
}

/**
 * A GitHub enterprise
 */
export interface GithubEnterprise {
  /** URL to the enterprise avatar */
  avatar_url: string;
  /** When the enterprise was created */
  created_at: string;
  /**
   * The enterprise description
   * @nullable
   */
  description?: string | null;
  /** The HTML URL of the enterprise */
  html_url: string;
  /** The enterprise ID */
  id: number;
  /** The enterprise name */
  name: string;
  /** The enterprise node ID */
  node_id: string;
  /** The enterprise slug */
  slug: string;
  /** When the enterprise was last updated */
  updated_at: string;
  /**
   * The enterprise website URL
   * @nullable
   */
  website_url?: string | null;
}

/**
 * The installation permissions
 */
export type GithubInstallationPermissions = { [key: string]: unknown };

/**
 * Repository selection for the installation
 */
export type GithubInstallationRepositorySelection = typeof GithubInstallationRepositorySelection[keyof typeof GithubInstallationRepositorySelection];


export const GithubInstallationRepositorySelection = {
  selected: 'selected',
  all: 'all',
} as const;

/**
 * The type of user
 */
export type GithubUserType = typeof GithubUserType[keyof typeof GithubUserType];


export const GithubUserType = {
  Bot: 'Bot',
  User: 'User',
  Organization: 'Organization',
} as const;

/**
 * A GitHub user
 */
export interface GithubUser {
  /** URL to the user's avatar */
  avatar_url: string;
  /**
   * The user's gravatar ID
   * @nullable
   */
  gravatar_id?: string | null;
  /** The HTML URL of the user */
  html_url: string;
  /** The user's ID */
  id: number;
  /** The user's login name */
  login: string;
  /** The user's node ID */
  node_id: string;
  /** Whether the user is a site admin */
  site_admin: boolean;
  /** The type of user */
  type: GithubUserType;
  /** The API URL of the user */
  url: string;
}

/**
 * A GitHub App installation
 */
export interface GithubInstallation {
  /** The API URL for access tokens */
  access_tokens_url: string;
  account: GithubUser;
  /** The GitHub App ID */
  app_id: number;
  /** When the installation was created */
  created_at: string;
  /** The events the installation subscribes to */
  events: string[];
  /** The HTML URL of the installation */
  html_url: string;
  /** The installation ID */
  id: number;
  /** The installation permissions */
  permissions: GithubInstallationPermissions;
  /** The API URL for repositories */
  repositories_url: string;
  /** Repository selection for the installation */
  repository_selection: GithubInstallationRepositorySelection;
  /**
   * The single file name if applicable
   * @nullable
   */
  single_file_name?: string | null;
  /** The target ID */
  target_id: number;
  /** The target type */
  target_type: string;
  /** When the installation was last updated */
  updated_at: string;
}

/**
 * A GitHub organization
 */
export interface GithubOrganization {
  /** URL to the organization's avatar */
  avatar_url: string;
  /**
   * The organization description
   * @nullable
   */
  description?: string | null;
  /** The API URL of the organization's events */
  events_url: string;
  /** The API URL of the organization's hooks */
  hooks_url: string;
  /** The organization ID */
  id: number;
  /** The API URL of the organization's issues */
  issues_url: string;
  /** The organization's login name */
  login: string;
  /** The API URL of the organization's members */
  members_url: string;
  /** The organization node ID */
  node_id: string;
  /** The API URL of the organization's public members */
  public_members_url: string;
  /** The API URL of the organization's repositories */
  repos_url: string;
  /** The API URL of the organization */
  url: string;
}

/**
 * The state of the asset
 */
export type GithubReleaseAssetState = typeof GithubReleaseAssetState[keyof typeof GithubReleaseAssetState];


export const GithubReleaseAssetState = {
  uploaded: 'uploaded',
  open: 'open',
} as const;

/**
 * A GitHub release asset
 */
export interface GithubReleaseAsset {
  /** The browser download URL */
  browser_download_url: string;
  /** The content type of the asset */
  content_type: string;
  /** When the asset was created */
  created_at: string;
  /** The number of downloads */
  download_count: number;
  /** The asset ID */
  id: number;
  /**
   * The label of the asset
   * @nullable
   */
  label?: string | null;
  /** The name of the asset */
  name: string;
  /** The asset node ID */
  node_id: string;
  /** The size of the asset in bytes */
  size: number;
  /** The state of the asset */
  state: GithubReleaseAssetState;
  /** When the asset was last updated */
  updated_at: string;
  uploader: GithubUser;
}

/**
 * The action performed on the release
 */
export type GithubReleaseWebhookAction = typeof GithubReleaseWebhookAction[keyof typeof GithubReleaseWebhookAction];


export const GithubReleaseWebhookAction = {
  published: 'published',
  unpublished: 'unpublished',
  created: 'created',
  edited: 'edited',
  deleted: 'deleted',
  prereleased: 'prereleased',
  released: 'released',
} as const;

/**
 * The release object
 */
export type GithubReleaseWebhookRelease = {
  /** Array of release assets */
  assets: GithubReleaseAsset[];
  /** The URL to the release assets */
  assets_url?: string;
  author: GithubUser;
  /**
   * The release notes/body
   * @nullable
   */
  body?: string | null;
  /** When the release was created */
  created_at: string;
  /** Whether the release is a draft */
  draft: boolean;
  /** The HTML URL of the release */
  html_url: string;
  /** The ID of the release */
  id: number;
  /**
   * The name of the release
   * @nullable
   */
  name?: string | null;
  /** The node ID of the release */
  node_id: string;
  /** Whether the release is a prerelease */
  prerelease: boolean;
  /**
   * When the release was published
   * @nullable
   */
  published_at?: string | null;
  /** The tag name of the release */
  tag_name: string;
  /** URL to the tarball */
  tarball_url: string;
  /** The branch or commit the release was created from */
  target_commitish: string;
  /** The URL to upload release assets */
  upload_url?: string;
  /** The API URL of the release */
  url: string;
  /** URL to the zipball */
  zipball_url: string;
};

/**
 * A GitHub repository
 */
export interface GithubRepository {
  /** The clone URL of the repository */
  clone_url: string;
  /** When the repository was created */
  created_at: string;
  /** The default branch of the repository */
  default_branch: string;
  /**
   * The repository description
   * @nullable
   */
  description?: string | null;
  /** Whether the repository is a fork */
  fork: boolean;
  /** The full name of the repository (owner/repo) */
  full_name: string;
  /** The git URL of the repository */
  git_url: string;
  /** The HTML URL of the repository */
  html_url: string;
  /** The repository ID */
  id: number;
  /** The name of the repository */
  name: string;
  /** The repository node ID */
  node_id: string;
  owner: GithubUser;
  /** Whether the repository is private */
  private: boolean;
  /** When the repository was last pushed to */
  pushed_at: string;
  /** The SSH URL of the repository */
  ssh_url: string;
  /** When the repository was last updated */
  updated_at: string;
  /** The API URL of the repository */
  url: string;
}

/**
 * GitHub release webhook payload based on official webhook documentation
 */
export interface GithubReleaseWebhook {
  /** The action performed on the release */
  action: GithubReleaseWebhookAction;
  enterprise?: GithubEnterprise;
  installation?: GithubInstallation;
  organization?: GithubOrganization;
  /** The release object */
  release: GithubReleaseWebhookRelease;
  repository: GithubRepository;
  sender: GithubUser;
}

/**
 * Error response from HitPaw API
 */
export interface HitPawErrorResponse {
  /** Error code */
  error_code?: number;
  /** Error message */
  message?: string;
}

export type HitPawJobResponseData = {
  /** Number of coins consumed for this task */
  consume_coins?: number;
  /** Unique identifier for the enhancement job */
  job_id?: string;
};

/**
 * Response from HitPaw Enhancement APIs (photo and video)
 */
export interface HitPawJobResponse {
  /** Status code, 200 indicates success */
  code?: number;
  data?: HitPawJobResponseData;
  /** Response message */
  message?: string;
}

/**
 * The model name to use for enhancement.

**Available Models:**
- face_2x, face_4x: Face Clear Model (2x/4x upscaling)
- face_v2_2x, face_v2_4x: Face Natural Model (2x/4x upscaling)
- general_2x, general_4x: General Enhance Model (2x/4x upscaling)
- high_fidelity_2x, high_fidelity_4x: High Fidelity Model (2x/4x upscaling)
- sharpen_denoise: Sharp Denoise Model
- detail_denoise: Detail Denoise Model
- generative_portrait: Generative Portrait Model
- generative: Generative Enhance Model

 */
export type HitPawPhotoEnhancerRequestModelName = typeof HitPawPhotoEnhancerRequestModelName[keyof typeof HitPawPhotoEnhancerRequestModelName];


export const HitPawPhotoEnhancerRequestModelName = {
  face_2x: 'face_2x',
  face_4x: 'face_4x',
  face_v2_2x: 'face_v2_2x',
  face_v2_4x: 'face_v2_4x',
  general_2x: 'general_2x',
  general_4x: 'general_4x',
  high_fidelity_2x: 'high_fidelity_2x',
  high_fidelity_4x: 'high_fidelity_4x',
  sharpen_denoise: 'sharpen_denoise',
  detail_denoise: 'detail_denoise',
  generative_portrait: 'generative_portrait',
  generative: 'generative',
} as const;

/**
 * Request body for HitPaw Photo Enhancement API
 */
export interface HitPawPhotoEnhancerRequest {
  /** Target DPI for the output image */
  DPI?: number;
  /** Whether to preserve EXIF data (default false) */
  exif?: boolean;
  /** File extension of the image (e.g., ".jpg", ".png") */
  extension: string;
  /** URL of the image to be enhanced. Must be publicly accessible. */
  img_url: string;
  /** The model name to use for enhancement.

**Available Models:**
- face_2x, face_4x: Face Clear Model (2x/4x upscaling)
- face_v2_2x, face_v2_4x: Face Natural Model (2x/4x upscaling)
- general_2x, general_4x: General Enhance Model (2x/4x upscaling)
- high_fidelity_2x, high_fidelity_4x: High Fidelity Model (2x/4x upscaling)
- sharpen_denoise: Sharp Denoise Model
- detail_denoise: Detail Denoise Model
- generative_portrait: Generative Portrait Model
- generative: Generative Enhance Model
 */
  model_name: HitPawPhotoEnhancerRequestModelName;
}

/**
 * Request body for HitPaw Task Status Query API
 */
export interface HitPawTaskStatusRequest {
  /** Task ID obtained from Enhancement API response */
  job_id: string;
}

/**
 * Task status:
- WAITING: The job is queued and waiting to be processed
- CONVERTING: Processing task in progress
- COMPLETED: Task completed successfully
- ERROR: Task failed

 */
export type HitPawTaskStatusResponseDataStatus = typeof HitPawTaskStatusResponseDataStatus[keyof typeof HitPawTaskStatusResponseDataStatus];


export const HitPawTaskStatusResponseDataStatus = {
  WAITING: 'WAITING',
  CONVERTING: 'CONVERTING',
  COMPLETED: 'COMPLETED',
  ERROR: 'ERROR',
} as const;

export type HitPawTaskStatusResponseData = {
  /** Task ID */
  job_id?: string;
  /** Original Image URL (photo enhancement only) */
  original_url?: string;
  /** Result URL, only valid when status is COMPLETED */
  res_url?: string;
  /** Task status:
- WAITING: The job is queued and waiting to be processed
- CONVERTING: Processing task in progress
- COMPLETED: Task completed successfully
- ERROR: Task failed
 */
  status?: HitPawTaskStatusResponseDataStatus;
};

/**
 * Response from HitPaw Task Status Query API
 */
export interface HitPawTaskStatusResponse {
  /** Status code, 200 indicates success */
  code?: number;
  data?: HitPawTaskStatusResponseData;
  /** Response message */
  message?: string;
}

/**
 * Model name to use for enhancement.

**Available Models:**
- face_soft: Face Soft Model
- portrait_restore_1x: Portrait Restore Model 1x
- portrait_restore_2x: Portrait Restore Model 2x
- general_restore_1x: General Restore Model 1x
- general_restore_2x: General Restore Model 2x
- general_restore_4x: General Restore Model 4x
- ultrahd_restore: Ultra HD Model
- generative: Generative Model (SD)

 */
export type HitPawVideoEnhancerRequestModelName = typeof HitPawVideoEnhancerRequestModelName[keyof typeof HitPawVideoEnhancerRequestModelName];


export const HitPawVideoEnhancerRequestModelName = {
  face_soft: 'face_soft',
  portrait_restore_1x: 'portrait_restore_1x',
  portrait_restore_2x: 'portrait_restore_2x',
  general_restore_1x: 'general_restore_1x',
  general_restore_2x: 'general_restore_2x',
  general_restore_4x: 'general_restore_4x',
  ultrahd_restore: 'ultrahd_restore',
  generative: 'generative',
} as const;

/**
 * Request body for HitPaw Video Enhancement API
 */
export interface HitPawVideoEnhancerRequest {
  /** File extension for the output video (default ".mp4") */
  extension?: string;
  /** Model name to use for enhancement.

**Available Models:**
- face_soft: Face Soft Model
- portrait_restore_1x: Portrait Restore Model 1x
- portrait_restore_2x: Portrait Restore Model 2x
- general_restore_1x: General Restore Model 1x
- general_restore_2x: General Restore Model 2x
- general_restore_4x: General Restore Model 4x
- ultrahd_restore: Ultra HD Model
- generative: Generative Model (SD)
 */
  model_name: HitPawVideoEnhancerRequestModelName;
  /**
   * Original video resolution [width, height]
   * @minItems 2
   * @maxItems 2
   */
  original_resolution?: number[];
  /**
   * Target resolution [width, height]
   * @minItems 2
   * @maxItems 2
   */
  resolution: number[];
  /** URL of the video to be enhanced */
  video_url: string;
}

/**
 * A color palette specification that can either use a preset name or explicit color definitions with weights
 */
export type IdeogramColorPalette = {
  /** Name of the preset color palette */
  name: string;
} | {
  /** Array of color definitions with optional weights */
  members: {
  /**
   * Hexadecimal color code
   * @pattern ^#[0-9A-Fa-f]{6}$
   */
  color?: string;
  /**
   * Optional weight for the color (0-1)
   * @minimum 0
   * @maximum 1
   */
  weight?: number;
}[];
};

/**
 * Optional. Color palette object. Only for V_2, V_2_TURBO.
 */
export type IdeogramGenerateRequestImageRequestColorPalette = { [key: string]: unknown };

/**
 * The image generation request parameters.
 */
export type IdeogramGenerateRequestImageRequest = {
  /** Optional. The aspect ratio (e.g., 'ASPECT_16_9', 'ASPECT_1_1'). Cannot be used with resolution. Defaults to 'ASPECT_1_1' if unspecified. */
  aspect_ratio?: string;
  /** Optional. Color palette object. Only for V_2, V_2_TURBO. */
  color_palette?: IdeogramGenerateRequestImageRequestColorPalette;
  /** Optional. MagicPrompt usage ('AUTO', 'ON', 'OFF'). */
  magic_prompt_option?: string;
  /** The model used (e.g., 'V_2', 'V_2A_TURBO') */
  model: string;
  /** Optional. Description of what to exclude. Only for V_1, V_1_TURBO, V_2, V_2_TURBO. */
  negative_prompt?: string;
  /**
   * Optional. Number of images to generate (1-8). Defaults to 1.
   * @minimum 1
   * @maximum 8
   */
  num_images?: number;
  /** Required. The prompt to use to generate the image. */
  prompt: string;
  /** Optional. Resolution (e.g., 'RESOLUTION_1024_1024'). Only for model V_2. Cannot be used with aspect_ratio. */
  resolution?: string;
  /**
   * Optional. A number between 0 and 2147483647.
   * @minimum 0
   * @maximum 2147483647
   */
  seed?: number;
  /** Optional. Style type ('AUTO', 'GENERAL', 'REALISTIC', 'DESIGN', 'RENDER_3D', 'ANIME'). Only for models V_2 and above. */
  style_type?: string;
};

/**
 * Parameters for the Ideogram generation proxy request. Based on Ideogram's API.
 */
export interface IdeogramGenerateRequest {
  /** The image generation request parameters. */
  image_request: IdeogramGenerateRequestImageRequest;
}

export type IdeogramGenerateResponseDataItem = {
  /** Indicates whether the image is considered safe. */
  is_image_safe?: boolean;
  /** The prompt used to generate this image. */
  prompt?: string;
  /** The resolution of the generated image (e.g., '1024x1024'). */
  resolution?: string;
  /** The seed value used for this generation. */
  seed?: number;
  /** The style type used for generation (e.g., 'REALISTIC', 'ANIME'). */
  style_type?: string;
  /** URL to the generated image. */
  url?: string;
};

/**
 * Response from the Ideogram image generation API.
 */
export interface IdeogramGenerateResponse {
  /** Timestamp when the generation was created. */
  created?: string;
  /** Array of generated image information. */
  data?: IdeogramGenerateResponseDataItem[];
}

export type IdeogramStyleType = typeof IdeogramStyleType[keyof typeof IdeogramStyleType];


export const IdeogramStyleType = {
  AUTO: 'AUTO',
  GENERAL: 'GENERAL',
  REALISTIC: 'REALISTIC',
  DESIGN: 'DESIGN',
  FICTION: 'FICTION',
} as const;

/**
 * The rendering speed setting that controls the trade-off between generation speed and quality
 */
export type RenderingSpeed = typeof RenderingSpeed[keyof typeof RenderingSpeed];


export const RenderingSpeed = {
  DEFAULT: 'DEFAULT',
  TURBO: 'TURBO',
  QUALITY: 'QUALITY',
} as const;

export interface IdeogramV3EditRequest {
  /** Generations with character reference are subject to the character reference pricing. A set of images to use as character references (maximum total size 10MB across all character references), currently only supports 1 character reference image. The images should be in JPEG, PNG or WebP format. */
  character_reference_images?: string[];
  /** Optional masks for character reference images. When provided, must match the number of character_reference_images. Each mask should be a grayscale image of the same dimensions as the corresponding character reference image. The images should be in JPEG, PNG or WebP format. */
  character_reference_images_mask?: string[];
  color_palette?: IdeogramColorPalette;
  /** The image being edited (max size 10MB); only JPEG, WebP and PNG formats are supported at this time. */
  image?: string;
  /** Determine if MagicPrompt should be used in generating the request or not. */
  magic_prompt?: string;
  /** A black and white image of the same size as the image being edited (max size 10MB). Black regions in the mask should match up with the regions of the image that you would like to edit; only JPEG, WebP and PNG formats are supported at this time. */
  mask?: string;
  /** The number of images to generate. */
  num_images?: number;
  /** The prompt used to describe the edited result. */
  prompt: string;
  rendering_speed: RenderingSpeed;
  /** Random seed. Set for reproducible generation. */
  seed?: number;
  /** A list of 8 character hexadecimal codes representing the style of the image. Cannot be used in conjunction with style_reference_images or style_type. */
  style_codes?: string[];
  /** A set of images to use as style references (maximum total size 10MB across all style references). The images should be in JPEG, PNG or WebP format. */
  style_reference_images?: string[];
  style_type?: IdeogramStyleType;
}

export type IdeogramV3IdeogramResponseDataItem = {
  is_image_safe?: boolean;
  prompt?: string;
  resolution?: string;
  seed?: number;
  style_type?: string;
  url?: string;
};

export interface IdeogramV3IdeogramResponse {
  created?: string;
  data?: IdeogramV3IdeogramResponseDataItem[];
}

export type IdeogramV3ReframeRequestColorPalette = { [key: string]: unknown };

export interface IdeogramV3ReframeRequest {
  color_palette?: IdeogramV3ReframeRequestColorPalette;
  image?: string;
  /**
   * @minimum 1
   * @maximum 8
   */
  num_images?: number;
  rendering_speed?: RenderingSpeed;
  resolution: string;
  /**
   * @minimum 0
   * @maximum 2147483647
   */
  seed?: number;
  style_codes?: string[];
  style_reference_images?: string[];
}

export type IdeogramV3RemixRequestColorPalette = { [key: string]: unknown };

export type IdeogramV3RemixRequestMagicPrompt = typeof IdeogramV3RemixRequestMagicPrompt[keyof typeof IdeogramV3RemixRequestMagicPrompt];


export const IdeogramV3RemixRequestMagicPrompt = {
  AUTO: 'AUTO',
  ON: 'ON',
  OFF: 'OFF',
} as const;

export interface IdeogramV3RemixRequest {
  aspect_ratio?: string;
  /** Generations with character reference are subject to the character reference pricing. A set of images to use as character references (maximum total size 10MB across all character references), currently only supports 1 character reference image. The images should be in JPEG, PNG or WebP format. */
  character_reference_images?: string[];
  /** Optional masks for character reference images. When provided, must match the number of character_reference_images. Each mask should be a grayscale image of the same dimensions as the corresponding character reference image. The images should be in JPEG, PNG or WebP format. */
  character_reference_images_mask?: string[];
  color_palette?: IdeogramV3RemixRequestColorPalette;
  image?: string;
  /**
   * @minimum 1
   * @maximum 100
   */
  image_weight?: number;
  magic_prompt?: IdeogramV3RemixRequestMagicPrompt;
  negative_prompt?: string;
  /**
   * @minimum 1
   * @maximum 8
   */
  num_images?: number;
  prompt: string;
  rendering_speed?: RenderingSpeed;
  resolution?: string;
  /**
   * @minimum 0
   * @maximum 2147483647
   */
  seed?: number;
  style_codes?: string[];
  style_reference_images?: string[];
  style_type?: IdeogramStyleType;
}

export type IdeogramV3ReplaceBackgroundRequestColorPalette = { [key: string]: unknown };

export type IdeogramV3ReplaceBackgroundRequestMagicPrompt = typeof IdeogramV3ReplaceBackgroundRequestMagicPrompt[keyof typeof IdeogramV3ReplaceBackgroundRequestMagicPrompt];


export const IdeogramV3ReplaceBackgroundRequestMagicPrompt = {
  AUTO: 'AUTO',
  ON: 'ON',
  OFF: 'OFF',
} as const;

export interface IdeogramV3ReplaceBackgroundRequest {
  color_palette?: IdeogramV3ReplaceBackgroundRequestColorPalette;
  image?: string;
  magic_prompt?: IdeogramV3ReplaceBackgroundRequestMagicPrompt;
  /**
   * @minimum 1
   * @maximum 8
   */
  num_images?: number;
  prompt: string;
  rendering_speed?: RenderingSpeed;
  /**
   * @minimum 0
   * @maximum 2147483647
   */
  seed?: number;
  style_codes?: string[];
  style_reference_images?: string[];
}

export type IdeogramV3RequestColorPalette = {
  /** Name of the color palette */
  name: string;
};

/**
 * Whether to enable magic prompt enhancement
 */
export type IdeogramV3RequestMagicPrompt = typeof IdeogramV3RequestMagicPrompt[keyof typeof IdeogramV3RequestMagicPrompt];


export const IdeogramV3RequestMagicPrompt = {
  ON: 'ON',
  OFF: 'OFF',
} as const;

export interface IdeogramV3Request {
  /** Aspect ratio in format WxH */
  aspect_ratio?: string;
  /** Generations with character reference are subject to the character reference pricing. A set of images to use as character references (maximum total size 10MB across all character references), currently only supports 1 character reference image. The images should be in JPEG, PNG or WebP format. */
  character_reference_images?: string[];
  /** Optional masks for character reference images. When provided, must match the number of character_reference_images. Each mask should be a grayscale image of the same dimensions as the corresponding character reference image. The images should be in JPEG, PNG or WebP format. */
  character_reference_images_mask?: string[];
  color_palette?: IdeogramV3RequestColorPalette;
  /** Whether to enable magic prompt enhancement */
  magic_prompt?: IdeogramV3RequestMagicPrompt;
  /** Text prompt specifying what to avoid in the generation */
  negative_prompt?: string;
  /**
   * Number of images to generate
   * @minimum 1
   */
  num_images?: number;
  /** The text prompt for image generation */
  prompt: string;
  rendering_speed: RenderingSpeed;
  /** Image resolution in format WxH */
  resolution?: string;
  /** Seed value for reproducible generation */
  seed?: number;
  /** Array of style codes in hexadecimal format */
  style_codes?: string[];
  /** Array of reference image URLs or identifiers */
  style_reference_images?: string[];
  style_type?: IdeogramStyleType;
}

export interface ImagenImageGenerationInstance {
  /** Text prompt for image generation */
  prompt: string;
}

export type ImagenImageGenerationParametersAspectRatio = typeof ImagenImageGenerationParametersAspectRatio[keyof typeof ImagenImageGenerationParametersAspectRatio];


export const ImagenImageGenerationParametersAspectRatio = {
  '1:1': '1:1',
  '9:16': '9:16',
  '16:9': '16:9',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type ImagenOutputOptionsMimeType = typeof ImagenOutputOptionsMimeType[keyof typeof ImagenOutputOptionsMimeType];


export const ImagenOutputOptionsMimeType = {
  'image/png': 'image/png',
  'image/jpeg': 'image/jpeg',
} as const;

export interface ImagenOutputOptions {
  /**
   * @minimum 0
   * @maximum 100
   */
  compressionQuality?: number;
  mimeType?: ImagenOutputOptionsMimeType;
}

export type ImagenImageGenerationParametersPersonGeneration = typeof ImagenImageGenerationParametersPersonGeneration[keyof typeof ImagenImageGenerationParametersPersonGeneration];


export const ImagenImageGenerationParametersPersonGeneration = {
  dont_allow: 'dont_allow',
  allow_adult: 'allow_adult',
  allow_all: 'allow_all',
} as const;

export type ImagenImageGenerationParametersSafetySetting = typeof ImagenImageGenerationParametersSafetySetting[keyof typeof ImagenImageGenerationParametersSafetySetting];


export const ImagenImageGenerationParametersSafetySetting = {
  block_most: 'block_most',
  block_some: 'block_some',
  block_few: 'block_few',
  block_fewest: 'block_fewest',
} as const;

export interface ImagenImageGenerationParameters {
  addWatermark?: boolean;
  aspectRatio?: ImagenImageGenerationParametersAspectRatio;
  enhancePrompt?: boolean;
  includeRaiReason?: boolean;
  includeSafetyAttributes?: boolean;
  outputOptions?: ImagenOutputOptions;
  personGeneration?: ImagenImageGenerationParametersPersonGeneration;
  safetySetting?: ImagenImageGenerationParametersSafetySetting;
  /**
   * @minimum 1
   * @maximum 4
   */
  sampleCount?: number;
  seed?: number;
  storageUri?: string;
}

export interface ImagenGenerateImageRequest {
  instances: ImagenImageGenerationInstance[];
  parameters: ImagenImageGenerationParameters;
}

export interface ImagenImagePrediction {
  /** Base64-encoded image content */
  bytesBase64Encoded?: string;
  /** MIME type of the generated image */
  mimeType?: string;
  /** Enhanced or rewritten prompt used to generate this image */
  prompt?: string;
}

export interface ImagenGenerateImageResponse {
  predictions?: ImagenImagePrediction[];
}

/**
 * Specify additional output data to include in the model response. Currently
supported values are:
- `file_search_call.results`: Include the search results of
  the file search tool call.
- `message.input_image.image_url`: Include image urls from the input message.
- `computer_call_output.output.image_url`: Include image urls from the computer call output.

 */
export type Includable = typeof Includable[keyof typeof Includable];


export const Includable = {
  file_search_callresults: 'file_search_call.results',
  messageinput_imageimage_url: 'message.input_image.image_url',
  computer_call_outputoutputimage_url: 'computer_call_output.output.image_url',
} as const;

export type InputMessageRole = typeof InputMessageRole[keyof typeof InputMessageRole];


export const InputMessageRole = {
  user: 'user',
  system: 'system',
  developer: 'developer',
} as const;

export type InputMessageStatus = typeof InputMessageStatus[keyof typeof InputMessageStatus];


export const InputMessageStatus = {
  in_progress: 'in_progress',
  completed: 'completed',
  incomplete: 'incomplete',
} as const;

export type InputMessageType = typeof InputMessageType[keyof typeof InputMessageType];


export const InputMessageType = {
  message: 'message',
} as const;

export interface InputMessage {
  content?: InputMessageContentList;
  role?: InputMessageRole;
  status?: InputMessageStatus;
  type?: InputMessageType;
}

/**
 * The type of output content
 */
export type OutputTextContentType = typeof OutputTextContentType[keyof typeof OutputTextContentType];


export const OutputTextContentType = {
  output_text: 'output_text',
} as const;

export interface OutputTextContent {
  /** The text content */
  text: string;
  /** The type of output content */
  type: OutputTextContentType;
}

/**
 * The type of output content
 */
export type OutputAudioContentType = typeof OutputAudioContentType[keyof typeof OutputAudioContentType];


export const OutputAudioContentType = {
  output_audio: 'output_audio',
} as const;

export interface OutputAudioContent {
  /** Base64-encoded audio data */
  data: string;
  /** Transcript of the audio */
  transcript: string;
  /** The type of output content */
  type: OutputAudioContentType;
}

export type OutputContent = OutputTextContent | OutputAudioContent;

/**
 * The role of the message
 */
export type OutputMessageRole = typeof OutputMessageRole[keyof typeof OutputMessageRole];


export const OutputMessageRole = {
  assistant: 'assistant',
} as const;

/**
 * The type of output item
 */
export type OutputMessageType = typeof OutputMessageType[keyof typeof OutputMessageType];


export const OutputMessageType = {
  message: 'message',
} as const;

export interface OutputMessage {
  /** The content of the message */
  content: OutputContent[];
  /** The role of the message */
  role: OutputMessageRole;
  /** The type of output item */
  type: OutputMessageType;
}

/**
 * The status of the web search tool call.

 */
export type WebSearchToolCallStatus = typeof WebSearchToolCallStatus[keyof typeof WebSearchToolCallStatus];


export const WebSearchToolCallStatus = {
  in_progress: 'in_progress',
  searching: 'searching',
  completed: 'completed',
  failed: 'failed',
} as const;

/**
 * The type of the web search tool call. Always `web_search_call`.

 */
export type WebSearchToolCallType = typeof WebSearchToolCallType[keyof typeof WebSearchToolCallType];


export const WebSearchToolCallType = {
  web_search_call: 'web_search_call',
} as const;

/**
 * The results of a web search tool call. See the
[web search guide](/docs/guides/tools-web-search) for more information.

 */
export interface WebSearchToolCall {
  /** The unique ID of the web search tool call.
 */
  id: string;
  /** The status of the web search tool call.
 */
  status: WebSearchToolCallStatus;
  /** The type of the web search tool call. Always `web_search_call`.
 */
  type: WebSearchToolCallType;
}

/**
 * The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.

 */
export type ReasoningItemStatus = typeof ReasoningItemStatus[keyof typeof ReasoningItemStatus];


export const ReasoningItemStatus = {
  in_progress: 'in_progress',
  completed: 'completed',
  incomplete: 'incomplete',
} as const;

/**
 * The type of the object. Always `summary_text`.

 */
export type ReasoningItemSummaryItemType = typeof ReasoningItemSummaryItemType[keyof typeof ReasoningItemSummaryItemType];


export const ReasoningItemSummaryItemType = {
  summary_text: 'summary_text',
} as const;

/**
 * The type of the object. Always `reasoning`.

 */
export type ReasoningItemType = typeof ReasoningItemType[keyof typeof ReasoningItemType];


export const ReasoningItemType = {
  reasoning: 'reasoning',
} as const;

export type ReasoningItemSummaryItem = {
  /** A short summary of the reasoning used by the model when generating
the response.
 */
  text: string;
  /** The type of the object. Always `summary_text`.
 */
  type: ReasoningItemSummaryItemType;
};

/**
 * A description of the chain of thought used by a reasoning model while generating
a response.

 */
export interface ReasoningItem {
  /** The unique identifier of the reasoning content.
 */
  id: string;
  /** The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.
 */
  status?: ReasoningItemStatus;
  /** Reasoning text contents.
 */
  summary: ReasoningItemSummaryItem[];
  /** The type of the object. Always `reasoning`.
 */
  type: ReasoningItemType;
}

/**
 * Content item used to generate a response.

 */
export type Item = InputMessage | OutputMessage | FileSearchToolCall | ComputerToolCall | WebSearchToolCall | FunctionToolCall | ReasoningItem;

export type InputItem = EasyInputMessage | Item;

/**
 * Method of Transmitting Audio Files for Lip-Sync. Required when mode is audio2video.
 */
export type KlingAudioUploadType = typeof KlingAudioUploadType[keyof typeof KlingAudioUploadType];


export const KlingAudioUploadType = {
  file: 'file',
  url: 'url',
} as const;

export interface KlingCameraConfig {
  /**
   * Controls camera's movement along horizontal axis (x-axis). Negative indicates left, positive indicates right.
   * @minimum -10
   * @maximum 10
   */
  horizontal?: number;
  /**
   * Controls camera's rotation in vertical plane (x-axis). Negative indicates downward rotation, positive indicates upward rotation.
   * @minimum -10
   * @maximum 10
   */
  pan?: number;
  /**
   * Controls camera's rolling amount (z-axis). Negative indicates counterclockwise, positive indicates clockwise.
   * @minimum -10
   * @maximum 10
   */
  roll?: number;
  /**
   * Controls camera's rotation in horizontal plane (y-axis). Negative indicates left rotation, positive indicates right rotation.
   * @minimum -10
   * @maximum 10
   */
  tilt?: number;
  /**
   * Controls camera's movement along vertical axis (y-axis). Negative indicates downward, positive indicates upward.
   * @minimum -10
   * @maximum 10
   */
  vertical?: number;
  /**
   * Controls change in camera's focal length. Negative indicates narrower field of view, positive indicates wider field of view.
   * @minimum -10
   * @maximum 10
   */
  zoom?: number;
}

/**
 * Predefined camera movements type. simple: Customizable camera movement. down_back: Camera descends and moves backward. forward_up: Camera moves forward and tilts up. right_turn_forward: Rotate right and move forward. left_turn_forward: Rotate left and move forward.
 */
export type KlingCameraControlType = typeof KlingCameraControlType[keyof typeof KlingCameraControlType];


export const KlingCameraControlType = {
  simple: 'simple',
  down_back: 'down_back',
  forward_up: 'forward_up',
  right_turn_forward: 'right_turn_forward',
  left_turn_forward: 'left_turn_forward',
} as const;

export interface KlingCameraControl {
  config?: KlingCameraConfig;
  type?: KlingCameraControlType;
}

/**
 * Model Name. Can be kling-v1, kling-v1-5, or kling-v1-6.
 */
export type KlingCharacterEffectModelName = typeof KlingCharacterEffectModelName[keyof typeof KlingCharacterEffectModelName];


export const KlingCharacterEffectModelName = {
  'kling-v1': 'kling-v1',
  'kling-v1-5': 'kling-v1-5',
  'kling-v1-6': 'kling-v1-6',
} as const;

/**
 * Video length in seconds
 */
export type KlingVideoGenDuration = typeof KlingVideoGenDuration[keyof typeof KlingVideoGenDuration];


export const KlingVideoGenDuration = {
  NUMBER_3: '3',
  NUMBER_4: '4',
  NUMBER_5: '5',
  NUMBER_6: '6',
  NUMBER_7: '7',
  NUMBER_8: '8',
  NUMBER_9: '9',
  NUMBER_10: '10',
  NUMBER_11: '11',
  NUMBER_12: '12',
  NUMBER_13: '13',
  NUMBER_14: '14',
  NUMBER_15: '15',
} as const;

/**
 * @minItems 2
 * @maxItems 2
 */
export type KlingDualCharacterImages = string[];

/**
 * Video generation mode. std: Standard Mode, which is cost-effective. pro: Professional Mode, generates videos with longer duration but higher quality output.
 */
export type KlingVideoGenMode = typeof KlingVideoGenMode[keyof typeof KlingVideoGenMode];


export const KlingVideoGenMode = {
  std: 'std',
  pro: 'pro',
} as const;

export interface KlingDualCharacterEffectInput {
  duration: KlingVideoGenDuration;
  images: KlingDualCharacterImages;
  mode?: KlingVideoGenMode;
  model_name?: KlingCharacterEffectModelName;
}

/**
 * Scene Name. Dual-character Effects (hug, kiss, heart_gesture).
 */
export type KlingDualCharacterEffectsScene = typeof KlingDualCharacterEffectsScene[keyof typeof KlingDualCharacterEffectsScene];


export const KlingDualCharacterEffectsScene = {
  hug: 'hug',
  kiss: 'kiss',
  heart_gesture: 'heart_gesture',
} as const;

export interface KlingErrorResponse {
  /** - 1000: Authentication failed
- 1001: Authorization is empty
- 1002: Authorization is invalid
- 1003: Authorization is not yet valid
- 1004: Authorization has expired
- 1100: Account exception
- 1101: Account in arrears (postpaid scenario)
- 1102: Resource pack depleted or expired (prepaid scenario)
- 1103: Unauthorized access to requested resource
- 1200: Invalid request parameters
- 1201: Invalid parameters
- 1202: Invalid request method
- 1203: Requested resource does not exist
- 1300: Trigger platform strategy
- 1301: Trigger content security policy
- 1302: API request too frequent
- 1303: Concurrency/QPS exceeds limit
- 1304: Trigger IP whitelist policy
- 5000: Internal server error
- 5001: Service temporarily unavailable
- 5002: Server internal timeout
 */
  code: number;
  /** Human-readable error message */
  message: string;
  /** Request ID for tracking and troubleshooting */
  request_id: string;
}

export type KlingImage2VideoRequestDynamicMasksItemTrajectoriesItem = {
  /** The horizontal coordinate of trajectory point. Based on bottom-left corner of image as origin (0,0). */
  x?: number;
  /** The vertical coordinate of trajectory point. Based on bottom-left corner of image as origin (0,0). */
  y?: number;
};

export type KlingImage2VideoRequestDynamicMasksItem = {
  /** Dynamic Brush Application Area (Mask image created by users using the motion brush). The aspect ratio must match the input image. */
  mask?: string;
  trajectories?: KlingImage2VideoRequestDynamicMasksItemTrajectoriesItem[];
};

export type KlingImage2VideoRequestElementListItem = {
  /** Element ID */
  element_id?: number;
};

export type KlingImage2VideoRequestMultiPromptItem = {
  /** Duration of this storyboard in seconds. Must not exceed total task duration and must not be less than 1. Sum of all storyboard durations equals total task duration. */
  duration?: string;
  /** Shot sequence number */
  index?: number;
  /**
   * Prompt word for this storyboard. Maximum length 512 characters.
   * @maxLength 512
   */
  prompt?: string;
};

/**
 * Storyboard method. Required when the multi_shot parameter is set to true.
 */
export type KlingImage2VideoRequestShotType = typeof KlingImage2VideoRequestShotType[keyof typeof KlingImage2VideoRequestShotType];


export const KlingImage2VideoRequestShotType = {
  customize: 'customize',
} as const;

/**
 * Whether to generate sound simultaneously when generating videos. Only V2.6 and subsequent versions of the model support this parameter.
 */
export type KlingImage2VideoRequestSound = typeof KlingImage2VideoRequestSound[keyof typeof KlingImage2VideoRequestSound];


export const KlingImage2VideoRequestSound = {
  on: 'on',
  off: 'off',
} as const;

/**
 * Whether to generate watermarked results simultaneously. Custom watermark is not supported at this time.
 */
export type KlingImage2VideoRequestWatermarkInfo = {
  /** true means generate watermark, false means do not generate. */
  enabled?: boolean;
};

/**
 * Video aspect ratio
 */
export type KlingVideoGenAspectRatio = typeof KlingVideoGenAspectRatio[keyof typeof KlingVideoGenAspectRatio];


export const KlingVideoGenAspectRatio = {
  '16:9': '16:9',
  '9:16': '9:16',
  '1:1': '1:1',
} as const;

/**
 * Flexibility in video generation. The higher the value, the lower the model's degree of flexibility, and the stronger the relevance to the user's prompt.
 * @minimum 0
 * @maximum 1
 */
export type KlingVideoGenCfgScale = number;

/**
 * Model Name
 */
export type KlingVideoGenModelName = typeof KlingVideoGenModelName[keyof typeof KlingVideoGenModelName];


export const KlingVideoGenModelName = {
  'kling-v1': 'kling-v1',
  'kling-v1-5': 'kling-v1-5',
  'kling-v1-6': 'kling-v1-6',
  'kling-v2-master': 'kling-v2-master',
  'kling-v2-1': 'kling-v2-1',
  'kling-v2-1-master': 'kling-v2-1-master',
  'kling-v2-5-turbo': 'kling-v2-5-turbo',
  'kling-v2-6': 'kling-v2-6',
  'kling-v3': 'kling-v3',
} as const;

export interface KlingImage2VideoRequest {
  aspect_ratio?: KlingVideoGenAspectRatio;
  /** The callback notification address. Server will notify when the task status changes. */
  callback_url?: string;
  camera_control?: KlingCameraControl;
  cfg_scale?: KlingVideoGenCfgScale;
  duration?: KlingVideoGenDuration;
  /** Dynamic Brush Configuration List (up to 6 groups). For 5-second videos, trajectory length must not exceed 77 coordinates. */
  dynamic_masks?: KlingImage2VideoRequestDynamicMasksItem[];
  /** Reference Element List based on element ID configuration. Supports up to 3 reference elements. The element_list and voice_list parameters are mutually exclusive. */
  element_list?: KlingImage2VideoRequestElementListItem[];
  /** Customized Task ID. Must be unique within a single user account. */
  external_task_id?: string;
  /** Reference Image - URL or Base64 encoded string, cannot exceed 10MB, resolution not less than 300*300px, aspect ratio between 1:2.5 ~ 2.5:1. Base64 should not include data:image prefix. */
  image?: string;
  /** Reference Image - End frame control. URL or Base64 encoded string, cannot exceed 10MB, resolution not less than 300*300px. Base64 should not include data:image prefix. Cannot be used simultaneously with dynamic_masks/static_mask or camera_control. */
  image_tail?: string;
  mode?: KlingVideoGenMode;
  model_name?: KlingVideoGenModelName;
  /** Information about each storyboard, such as prompts and duration. Supports up to 6 storyboards, with a minimum of 1. Required when multi_shot is true and shot_type is customize. */
  multi_prompt?: KlingImage2VideoRequestMultiPromptItem[];
  /** Whether to generate multi-shot video. When true, the prompt parameter is invalid. When false, the shot_type and multi_prompt parameters are invalid. */
  multi_shot?: boolean;
  /**
   * Negative text prompt. It is recommended to supplement negative prompt information through negative sentences directly within positive prompts.
   * @maxLength 2500
   */
  negative_prompt?: string;
  /**
   * Positive text prompt. Use <<<voice_1>>> to specify a voice matching the voice_list parameter order. A task can reference up to 2 tones. When specifying a tone, the sound parameter value must be on.
   * @maxLength 2500
   */
  prompt?: string;
  /** Storyboard method. Required when the multi_shot parameter is set to true. */
  shot_type?: KlingImage2VideoRequestShotType;
  /** Whether to generate sound simultaneously when generating videos. Only V2.6 and subsequent versions of the model support this parameter. */
  sound?: KlingImage2VideoRequestSound;
  /** Static Brush Application Area (Mask image created by users using the motion brush). The aspect ratio must match the input image. */
  static_mask?: string;
  /** Whether to generate watermarked results simultaneously. Custom watermark is not supported at this time. */
  watermark_info?: KlingImage2VideoRequestWatermarkInfo;
}

export type KlingImage2VideoResponseDataTaskInfo = {
  external_task_id?: string;
};

export interface KlingVideoResult {
  /** Total video duration in seconds */
  duration?: string;
  /** Generated video ID */
  id?: string;
  /** URL for generated video */
  url?: string;
  /** URL for generated video with watermark, hotlink protection format */
  watermark_url?: string;
}

export type KlingImage2VideoResponseDataTaskResult = {
  videos?: KlingVideoResult[];
};

export type KlingImage2VideoResponseDataWatermarkInfo = {
  enabled?: boolean;
};

/**
 * Task Status
 */
export type KlingTaskStatus = typeof KlingTaskStatus[keyof typeof KlingTaskStatus];


export const KlingTaskStatus = {
  submitted: 'submitted',
  processing: 'processing',
  succeed: 'succeed',
  failed: 'failed',
} as const;

export type KlingImage2VideoResponseData = {
  /** Task creation time, Unix timestamp in milliseconds */
  created_at?: number;
  /** The deduction units of task */
  final_unit_deduction?: string;
  /** Task ID */
  task_id?: string;
  task_info?: KlingImage2VideoResponseDataTaskInfo;
  task_result?: KlingImage2VideoResponseDataTaskResult;
  task_status?: KlingTaskStatus;
  /** Task status information, displaying the failure reason when the task fails */
  task_status_msg?: string;
  /** Task update time, Unix timestamp in milliseconds */
  updated_at?: number;
  watermark_info?: KlingImage2VideoResponseDataWatermarkInfo;
};

export interface KlingImage2VideoResponse {
  /** Error code */
  code?: number;
  data?: KlingImage2VideoResponseData;
  /** Error message */
  message?: string;
  /** Request ID */
  request_id?: string;
}

/**
 * Aspect ratio of the generated images
 */
export type KlingImageGenAspectRatio = typeof KlingImageGenAspectRatio[keyof typeof KlingImageGenAspectRatio];


export const KlingImageGenAspectRatio = {
  '16:9': '16:9',
  '9:16': '9:16',
  '1:1': '1:1',
  '4:3': '4:3',
  '3:4': '3:4',
  '3:2': '3:2',
  '2:3': '2:3',
  '21:9': '21:9',
} as const;

/**
 * Image reference type
 */
export type KlingImageGenImageReferenceType = typeof KlingImageGenImageReferenceType[keyof typeof KlingImageGenImageReferenceType];


export const KlingImageGenImageReferenceType = {
  subject: 'subject',
  face: 'face',
} as const;

/**
 * Model Name
 */
export type KlingImageGenModelName = typeof KlingImageGenModelName[keyof typeof KlingImageGenModelName];


export const KlingImageGenModelName = {
  'kling-v1': 'kling-v1',
  'kling-v1-5': 'kling-v1-5',
  'kling-v2': 'kling-v2',
  'kling-v3': 'kling-v3',
} as const;

export type KlingImageGenerationsRequestElementListItem = {
  /** Element ID */
  element_id?: number;
};

/**
 * Image generation resolution. 1k is 1K standard, 2k is 2K high-res.
 */
export type KlingImageGenerationsRequestResolution = typeof KlingImageGenerationsRequestResolution[keyof typeof KlingImageGenerationsRequestResolution];


export const KlingImageGenerationsRequestResolution = {
  '1k': '1k',
  '2k': '2k',
} as const;

export interface KlingImageGenerationsRequest {
  aspect_ratio?: KlingImageGenAspectRatio;
  /** The callback notification address */
  callback_url?: string;
  /** Reference Element List based on element ID configuration. The sum of reference elements and reference images shall not exceed 10. */
  element_list?: KlingImageGenerationsRequestElementListItem[];
  /** Customized Task ID. Must be unique within a single user account. */
  external_task_id?: string;
  /**
   * Subject reference similarity
   * @minimum 0
   * @maximum 1
   */
  human_fidelity?: number;
  /** Reference Image - Base64 encoded string or image URL. Supported formats include .jpg/.jpeg/.png. File size cannot exceed 10MB. Width and height dimensions shall not be less than 300px, aspect ratio between 1:2.5 ~ 2.5:1. Required when image_reference is not empty. */
  image?: string;
  /**
   * Reference intensity for user-uploaded images
   * @minimum 0
   * @maximum 1
   */
  image_fidelity?: number;
  image_reference?: KlingImageGenImageReferenceType;
  model_name?: KlingImageGenModelName;
  /**
   * Number of generated images. Value range [1,9].
   * @minimum 1
   * @maximum 9
   */
  n?: number;
  /**
   * Negative text prompt. Cannot exceed 2500 characters. It is recommended to supplement negative prompt information through negative sentences directly within positive prompts. Not supported in Image-to-Image scenario (when image field is not empty).
   * @maxLength 2500
   */
  negative_prompt?: string;
  /**
   * Positive text prompt. Must not exceed 2,500 characters.
   * @maxLength 2500
   */
  prompt: string;
  /** Image generation resolution. 1k is 1K standard, 2k is 2K high-res. */
  resolution?: KlingImageGenerationsRequestResolution;
}

export type KlingImageGenerationsResponseDataTaskInfo = {
  /** Customer-defined task ID */
  external_task_id?: string;
};

export interface KlingImageResult {
  /** Image Number (0-9) */
  index?: number;
  /** URL for generated image */
  url?: string;
}

export type KlingImageGenerationsResponseDataTaskResult = {
  images?: KlingImageResult[];
};

export type KlingImageGenerationsResponseData = {
  /** Task creation time, Unix timestamp in milliseconds */
  created_at?: number;
  /** The deduction units of task */
  final_unit_deduction?: string;
  /** Task ID */
  task_id?: string;
  task_info?: KlingImageGenerationsResponseDataTaskInfo;
  task_result?: KlingImageGenerationsResponseDataTaskResult;
  task_status?: KlingTaskStatus;
  /** Task status information, displaying the failure reason when the task fails */
  task_status_msg?: string;
  /** Task update time, Unix timestamp in milliseconds */
  updated_at?: number;
};

export interface KlingImageGenerationsResponse {
  /** Error code */
  code?: number;
  data?: KlingImageGenerationsResponseData;
  /** Error message */
  message?: string;
  /** Request ID */
  request_id?: string;
}

/**
 * Video Generation Mode. text2video: Text-to-video generation mode; audio2video: Audio-to-video generation mode
 */
export type KlingLipSyncMode = typeof KlingLipSyncMode[keyof typeof KlingLipSyncMode];


export const KlingLipSyncMode = {
  text2video: 'text2video',
  audio2video: 'audio2video',
} as const;

/**
 * The voice language corresponds to the Voice ID.
 */
export type KlingLipSyncVoiceLanguage = typeof KlingLipSyncVoiceLanguage[keyof typeof KlingLipSyncVoiceLanguage];


export const KlingLipSyncVoiceLanguage = {
  zh: 'zh',
  en: 'en',
} as const;

export interface KlingLipSyncInputObject {
  /** Local Path of Audio File. Supported formats: .mp3/.wav/.m4a/.aac, maximum file size of 5MB. Base64 code. */
  audio_file?: string;
  audio_type?: KlingAudioUploadType;
  /** Audio File Download URL. Supported formats: .mp3/.wav/.m4a/.aac, maximum file size of 5MB. */
  audio_url?: string;
  mode: KlingLipSyncMode;
  /** Text Content for Lip-Sync Video Generation. Required when mode is text2video. Maximum length is 120 characters. */
  text?: string;
  /** The ID of the video generated by Kling AI. Only supports 5-second and 10-second videos generated within the last 30 days. */
  video_id?: string;
  /** Get link for uploaded video. Video files support .mp4/.mov, file size does not exceed 100MB, video length between 2-10s. */
  video_url?: string;
  /** Voice ID. Required when mode is text2video. The system offers a variety of voice options to choose from. */
  voice_id?: string;
  voice_language?: KlingLipSyncVoiceLanguage;
  /**
   * Speech Rate. Valid range: 0.8~2.0, accurate to one decimal place.
   * @minimum 0.8
   * @maximum 2
   */
  voice_speed?: number;
}

export interface KlingLipSyncRequest {
  /** The callback notification address. Server will notify when the task status changes. */
  callback_url?: string;
  input: KlingLipSyncInputObject;
}

export type KlingLipSyncResponseDataTaskInfo = {
  external_task_id?: string;
};

export type KlingLipSyncResponseDataTaskResult = {
  videos?: KlingVideoResult[];
};

export type KlingLipSyncResponseData = {
  /** Task creation time */
  created_at?: number;
  /** Task ID */
  task_id?: string;
  task_info?: KlingLipSyncResponseDataTaskInfo;
  task_result?: KlingLipSyncResponseDataTaskResult;
  task_status?: KlingTaskStatus;
  /** Task update time */
  updated_at?: number;
};

export interface KlingLipSyncResponse {
  /** Error code */
  code?: number;
  data?: KlingLipSyncResponseData;
  /** Error message */
  message?: string;
  /** Request ID */
  request_id?: string;
}

/**
 * Generate the orientation of the characters in the video. image - same orientation as the person in the picture (reference video duration should not exceed 10 seconds). video - consistent with the orientation of the characters in the video (reference video duration should not exceed 30 seconds).
 */
export type KlingMotionControlRequestCharacterOrientation = typeof KlingMotionControlRequestCharacterOrientation[keyof typeof KlingMotionControlRequestCharacterOrientation];


export const KlingMotionControlRequestCharacterOrientation = {
  image: 'image',
  video: 'video',
} as const;

/**
 * Whether to keep the original sound of the video. Enumeration values - yes (Keep the original sound), no (do not retain the original video sound).
 */
export type KlingMotionControlRequestKeepOriginalSound = typeof KlingMotionControlRequestKeepOriginalSound[keyof typeof KlingMotionControlRequestKeepOriginalSound];


export const KlingMotionControlRequestKeepOriginalSound = {
  yes: 'yes',
  no: 'no',
} as const;

/**
 * Video generation mode. std - Standard Mode (cost-effective). pro - Professional Mode (longer duration but higher quality video output).
 */
export type KlingMotionControlRequestMode = typeof KlingMotionControlRequestMode[keyof typeof KlingMotionControlRequestMode];


export const KlingMotionControlRequestMode = {
  std: 'std',
  pro: 'pro',
} as const;

/**
 * Model name for motion control. Currently only supports kling-v2-6.
 */
export type KlingMotionControlRequestModelName = typeof KlingMotionControlRequestModelName[keyof typeof KlingMotionControlRequestModelName];


export const KlingMotionControlRequestModelName = {
  'kling-v2-6': 'kling-v2-6',
} as const;

export interface KlingMotionControlRequest {
  /** The callback notification address for the result of this task. If configured, the server will actively notify when the task status changes. */
  callback_url?: string;
  /** Generate the orientation of the characters in the video. image - same orientation as the person in the picture (reference video duration should not exceed 10 seconds). video - consistent with the orientation of the characters in the video (reference video duration should not exceed 30 seconds). */
  character_orientation: KlingMotionControlRequestCharacterOrientation;
  /** Customized Task ID. Users can provide a customized task ID, which will not overwrite the system-generated task ID but can be used for task queries. Must be unique within a single user account. */
  external_task_id?: string;
  /** Reference Image. The characters, backgrounds, and other elements in the generated video are based on the reference image. Supports inputting image Base64 encoding or image URL (ensure accessibility). Supported image formats include .jpg / .jpeg / .png. The image file size cannot exceed 10MB, and the width and height dimensions of the image range from 340px to 3850px, and the aspect ratio of the image should be between 1:2.5 ~ 2.5:1. */
  image_url: string;
  /** Whether to keep the original sound of the video. Enumeration values - yes (Keep the original sound), no (do not retain the original video sound). */
  keep_original_sound?: KlingMotionControlRequestKeepOriginalSound;
  /** Video generation mode. std - Standard Mode (cost-effective). pro - Professional Mode (longer duration but higher quality video output). */
  mode: KlingMotionControlRequestMode;
  /** Model name for motion control. Currently only supports kling-v2-6. */
  model_name?: KlingMotionControlRequestModelName;
  /**
   * Text prompt words, which can include positive and negative descriptions. Cannot exceed 2500 characters.
   * @maxLength 2500
   */
  prompt?: string;
  /** The URL of the reference video. The character actions in the generated video are consistent with the reference video. The video file supports .mp4/.mov, with a file size not exceeding 100MB, and only supports side lengths between 340px and 3850px. The lower limit of video duration should not be less than 3 seconds, and the upper limit depends on character_orientation. */
  video_url: string;
}

export type KlingMotionControlResponseDataTaskInfo = {
  /** Customer-defined task ID */
  external_task_id?: string;
};

export interface KlingMotionControlVideoResult {
  /** Total video duration, unit - s (seconds) */
  duration?: string;
  /** Generated video ID; globally unique */
  id?: string;
  /** URL for generating videos */
  url?: string;
}

export type KlingMotionControlResponseDataTaskResult = {
  videos?: KlingMotionControlVideoResult[];
};

export type KlingMotionControlResponseData = {
  /** Task creation time, Unix timestamp, unit ms */
  created_at?: number;
  /** Task ID */
  task_id?: string;
  task_info?: KlingMotionControlResponseDataTaskInfo;
  task_result?: KlingMotionControlResponseDataTaskResult;
  task_status?: KlingTaskStatus;
  /** Task status information, displaying the failure reason when the task fails */
  task_status_msg?: string;
  /** Task update time, Unix timestamp, unit ms */
  updated_at?: number;
};

export interface KlingMotionControlResponse {
  /** Error code */
  code?: number;
  data?: KlingMotionControlResponseData;
  /** Error message */
  message?: string;
  /** Request ID */
  request_id?: string;
}

/**
 * Aspect ratio of the generated images (width:height). auto is to intelligently generate images based on incoming content.
 */
export type KlingOmniImageRequestAspectRatio = typeof KlingOmniImageRequestAspectRatio[keyof typeof KlingOmniImageRequestAspectRatio];


export const KlingOmniImageRequestAspectRatio = {
  '16:9': '16:9',
  '9:16': '9:16',
  '1:1': '1:1',
  '4:3': '4:3',
  '3:4': '3:4',
  '3:2': '3:2',
  '2:3': '2:3',
  '21:9': '21:9',
  auto: 'auto',
} as const;

export type KlingOmniImageRequestElementListItem = {
  /** Element ID */
  element_id?: number;
};

export type KlingOmniImageRequestImageListItem = {
  /** Image Base64 encoding or image URL (ensure accessibility) */
  image?: string;
};

/**
 * Model Name
 */
export type KlingOmniImageRequestModelName = typeof KlingOmniImageRequestModelName[keyof typeof KlingOmniImageRequestModelName];


export const KlingOmniImageRequestModelName = {
  'kling-image-o1': 'kling-image-o1',
  'kling-v3-omni': 'kling-v3-omni',
} as const;

/**
 * Image generation resolution. 1k is 1K standard, 2k is 2K high-res, 4k is 4K high-res.
 */
export type KlingOmniImageRequestResolution = typeof KlingOmniImageRequestResolution[keyof typeof KlingOmniImageRequestResolution];


export const KlingOmniImageRequestResolution = {
  '1k': '1k',
  '2k': '2k',
  '4k': '4k',
} as const;

/**
 * Control whether to generate a single image or a series of images.
 */
export type KlingOmniImageRequestResultType = typeof KlingOmniImageRequestResultType[keyof typeof KlingOmniImageRequestResultType];


export const KlingOmniImageRequestResultType = {
  single: 'single',
  series: 'series',
} as const;

export interface KlingOmniImageRequest {
  /** Aspect ratio of the generated images (width:height). auto is to intelligently generate images based on incoming content. */
  aspect_ratio?: KlingOmniImageRequestAspectRatio;
  /** The callback notification address for the result of this task. If configured, the server will actively notify when the task status changes. */
  callback_url?: string;
  /** Reference Element List based on element ID configuration. The sum of reference elements and reference images shall not exceed 10. */
  element_list?: KlingOmniImageRequestElementListItem[];
  /** Customized Task ID. Must be unique within a single user account. */
  external_task_id?: string;
  /** Reference Image List. Supports inputting image Base64 encoding or image URL (ensure accessibility). Supported formats include .jpg/.jpeg/.png. File size cannot exceed 10MB. Width and height dimensions shall not be less than 300px, aspect ratio between 1:2.5 ~ 2.5:1. The sum of reference elements and reference images shall not exceed 10. */
  image_list?: KlingOmniImageRequestImageListItem[];
  /** Model Name */
  model_name?: KlingOmniImageRequestModelName;
  /**
   * Number of generated images. Value range [1,9].
   * @minimum 1
   * @maximum 9
   */
  n?: number;
  /**
   * Text prompt words, which can include positive and negative descriptions. Must not exceed 2,500 characters. The Omni model can achieve various capabilities through Prompt with elements and images. Specify an image in the format of <<<>>>, such as <<<image_1>>>.
   * @maxLength 2500
   */
  prompt: string;
  /** Image generation resolution. 1k is 1K standard, 2k is 2K high-res, 4k is 4K high-res. */
  resolution?: KlingOmniImageRequestResolution;
  /** Control whether to generate a single image or a series of images. */
  result_type?: KlingOmniImageRequestResultType;
  /**
   * Number of images in a series. Value range [2,9].
   * @minimum 2
   * @maximum 9
   */
  series_amount?: number;
}

export type KlingOmniImageResponseDataTaskInfo = {
  /** Customer-defined task ID */
  external_task_id?: string;
};

/**
 * Whether the result is a single image or a series of images
 */
export type KlingOmniImageResponseDataTaskResultResultType = typeof KlingOmniImageResponseDataTaskResultResultType[keyof typeof KlingOmniImageResponseDataTaskResultResultType];


export const KlingOmniImageResponseDataTaskResultResultType = {
  single: 'single',
  series: 'series',
} as const;

export type KlingOmniImageResponseDataTaskResultSeriesImagesItem = {
  /** Series-image sequence number */
  index?: number;
  /** URL for generated image */
  url?: string;
};

export type KlingOmniImageResponseDataTaskResult = {
  images?: KlingImageResult[];
  /** Whether the result is a single image or a series of images */
  result_type?: KlingOmniImageResponseDataTaskResultResultType;
  /** Series images result list */
  series_images?: KlingOmniImageResponseDataTaskResultSeriesImagesItem[];
};

export type KlingOmniImageResponseData = {
  /** Task creation time, Unix timestamp in milliseconds */
  created_at?: number;
  /** The deduction units of task */
  final_unit_deduction?: string;
  /** Task ID */
  task_id?: string;
  task_info?: KlingOmniImageResponseDataTaskInfo;
  task_result?: KlingOmniImageResponseDataTaskResult;
  task_status?: KlingTaskStatus;
  /** Task status information, displaying the failure reason when the task fails (such as triggering the content risk control of the platform, etc.) */
  task_status_msg?: string;
  /** Task update time, Unix timestamp in milliseconds */
  updated_at?: number;
};

export interface KlingOmniImageResponse {
  /** Error code */
  code?: number;
  data?: KlingOmniImageResponseData;
  /** Error message */
  message?: string;
  /** Request ID */
  request_id?: string;
}

/**
 * The aspect ratio of the generated video frame (width:height). Required when first-frame reference or video editing features are not used.
 */
export type KlingOmniVideoRequestAspectRatio = typeof KlingOmniVideoRequestAspectRatio[keyof typeof KlingOmniVideoRequestAspectRatio];


export const KlingOmniVideoRequestAspectRatio = {
  '16:9': '16:9',
  '9:16': '9:16',
  '1:1': '1:1',
} as const;

/**
 * Video Length in seconds. When using video editing function (refer_type: base), output duration is the same as input video and this parameter is invalid.
 */
export type KlingOmniVideoRequestDuration = typeof KlingOmniVideoRequestDuration[keyof typeof KlingOmniVideoRequestDuration];


export const KlingOmniVideoRequestDuration = {
  NUMBER_3: '3',
  NUMBER_4: '4',
  NUMBER_5: '5',
  NUMBER_6: '6',
  NUMBER_7: '7',
  NUMBER_8: '8',
  NUMBER_9: '9',
  NUMBER_10: '10',
  NUMBER_11: '11',
  NUMBER_12: '12',
  NUMBER_13: '13',
  NUMBER_14: '14',
  NUMBER_15: '15',
} as const;

export type KlingOmniVideoRequestElementListItem = {
  /** Element ID */
  element_id?: number;
};

/**
 * Whether the image is in the first or last frame. first_frame is the first frame, end_frame is the last frame. Currently does not support only the end frame.
 */
export type KlingOmniVideoRequestImageListItemType = typeof KlingOmniVideoRequestImageListItemType[keyof typeof KlingOmniVideoRequestImageListItemType];


export const KlingOmniVideoRequestImageListItemType = {
  first_frame: 'first_frame',
  end_frame: 'end_frame',
} as const;

export type KlingOmniVideoRequestImageListItem = {
  /** Image Base64 encoding or image URL (ensure accessibility). Supported formats include .jpg/.jpeg/.png. File size cannot exceed 10MB. Width and height dimensions shall not be less than 300px, aspect ratio between 1:2.5 ~ 2.5:1. */
  image_url?: string;
  /** Whether the image is in the first or last frame. first_frame is the first frame, end_frame is the last frame. Currently does not support only the end frame. */
  type?: KlingOmniVideoRequestImageListItemType;
};

/**
 * Video generation mode. std: Standard Mode, generating 720P videos, cost-effective. pro: Professional Mode, generating 1080P videos, higher quality video output.
 */
export type KlingOmniVideoRequestMode = typeof KlingOmniVideoRequestMode[keyof typeof KlingOmniVideoRequestMode];


export const KlingOmniVideoRequestMode = {
  pro: 'pro',
  std: 'std',
} as const;

/**
 * Model Name
 */
export type KlingOmniVideoRequestModelName = typeof KlingOmniVideoRequestModelName[keyof typeof KlingOmniVideoRequestModelName];


export const KlingOmniVideoRequestModelName = {
  'kling-video-o1': 'kling-video-o1',
  'kling-v3-omni': 'kling-v3-omni',
} as const;

export type KlingOmniVideoRequestMultiPromptItem = {
  /** Duration of this storyboard in seconds. Must not exceed total task duration and must not be less than 1. Sum of all storyboard durations equals total task duration. */
  duration?: string;
  /** Shot sequence number */
  index?: number;
  /**
   * Prompt word for this storyboard. Maximum length 512 characters.
   * @maxLength 512
   */
  prompt?: string;
};

/**
 * Storyboard method. Required when the multi_shot parameter is set to true.
 */
export type KlingOmniVideoRequestShotType = typeof KlingOmniVideoRequestShotType[keyof typeof KlingOmniVideoRequestShotType];


export const KlingOmniVideoRequestShotType = {
  customize: 'customize',
} as const;

/**
 * Whether sound is generated simultaneously when generating videos.
 */
export type KlingOmniVideoRequestSound = typeof KlingOmniVideoRequestSound[keyof typeof KlingOmniVideoRequestSound];


export const KlingOmniVideoRequestSound = {
  on: 'on',
  off: 'off',
} as const;

/**
 * Whether to keep the video original sound. yes indicates retention, no indicates non retention.
 */
export type KlingOmniVideoRequestVideoListItemKeepOriginalSound = typeof KlingOmniVideoRequestVideoListItemKeepOriginalSound[keyof typeof KlingOmniVideoRequestVideoListItemKeepOriginalSound];


export const KlingOmniVideoRequestVideoListItemKeepOriginalSound = {
  yes: 'yes',
  no: 'no',
} as const;

/**
 * Reference video type. feature is the feature reference video, base is the video to be edited.
 */
export type KlingOmniVideoRequestVideoListItemReferType = typeof KlingOmniVideoRequestVideoListItemReferType[keyof typeof KlingOmniVideoRequestVideoListItemReferType];


export const KlingOmniVideoRequestVideoListItemReferType = {
  feature: 'feature',
  base: 'base',
} as const;

export type KlingOmniVideoRequestVideoListItem = {
  /** Whether to keep the video original sound. yes indicates retention, no indicates non retention. */
  keep_original_sound?: KlingOmniVideoRequestVideoListItemKeepOriginalSound;
  /** Reference video type. feature is the feature reference video, base is the video to be edited. */
  refer_type?: KlingOmniVideoRequestVideoListItemReferType;
  /** URL of uploaded video. Only .mp4/.mov formats are supported. Duration between 3-10 seconds. Resolution must be between 720px and 2160px. Frame rates of 24-60 fps supported. Only 1 video can be uploaded, with size not exceeding 200MB. */
  video_url?: string;
};

/**
 * Whether to generate watermarked results simultaneously. Custom watermark is not supported at this time.
 */
export type KlingOmniVideoRequestWatermarkInfo = {
  /** true means generate watermark, false means do not generate. */
  enabled?: boolean;
};

export interface KlingOmniVideoRequest {
  /** The aspect ratio of the generated video frame (width:height). Required when first-frame reference or video editing features are not used. */
  aspect_ratio?: KlingOmniVideoRequestAspectRatio;
  /** The callback notification address for the result of this task. If configured, the server will actively notify when the task status changes. */
  callback_url?: string;
  /** Video Length in seconds. When using video editing function (refer_type: base), output duration is the same as input video and this parameter is invalid. */
  duration?: KlingOmniVideoRequestDuration;
  /** Reference Element List based on element ID configuration. */
  element_list?: KlingOmniVideoRequestElementListItem[];
  /** Customized Task ID. Must be unique within a single user account. */
  external_task_id?: string;
  /** Reference Image List. Can include reference images of the element, scene, style, etc., or be used as the first or last frame to generate videos. */
  image_list?: KlingOmniVideoRequestImageListItem[];
  /** Video generation mode. std: Standard Mode, generating 720P videos, cost-effective. pro: Professional Mode, generating 1080P videos, higher quality video output. */
  mode?: KlingOmniVideoRequestMode;
  /** Model Name */
  model_name?: KlingOmniVideoRequestModelName;
  /** Information about each storyboard, such as prompts and duration. Supports up to 6 storyboards, with a minimum of 1. Required when multi_shot is true and shot_type is customize. */
  multi_prompt?: KlingOmniVideoRequestMultiPromptItem[];
  /** Whether to generate multi-shot video. When true, the prompt parameter is invalid. When false, the shot_type and multi_prompt parameters are invalid. */
  multi_shot?: boolean;
  /**
   * Text prompt words, which can include positive and negative descriptions. Must not exceed 2,500 characters. Can specify elements, images, or videos in the format <<<>>> such as <<element_1>>, <<<image_1>>>, <<<video_1>>>.
   * @maxLength 2500
   */
  prompt?: string;
  /** Storyboard method. Required when the multi_shot parameter is set to true. */
  shot_type?: KlingOmniVideoRequestShotType;
  /** Whether sound is generated simultaneously when generating videos. */
  sound?: KlingOmniVideoRequestSound;
  /** Reference Video list. Can be used as a reference video for feature or as a video to be edited, with the default being the video to be edited. */
  video_list?: KlingOmniVideoRequestVideoListItem[];
  /** Whether to generate watermarked results simultaneously. Custom watermark is not supported at this time. */
  watermark_info?: KlingOmniVideoRequestWatermarkInfo;
}

export type KlingOmniVideoResponseDataTaskInfo = {
  external_task_id?: string;
};

export type KlingOmniVideoResponseDataTaskResult = {
  videos?: KlingVideoResult[];
};

export type KlingOmniVideoResponseDataWatermarkInfo = {
  enabled?: boolean;
};

export type KlingOmniVideoResponseData = {
  /** Task creation time, Unix timestamp in milliseconds */
  created_at?: number;
  /** The deduction units of task */
  final_unit_deduction?: string;
  /** Task ID */
  task_id?: string;
  task_info?: KlingOmniVideoResponseDataTaskInfo;
  task_result?: KlingOmniVideoResponseDataTaskResult;
  task_status?: KlingTaskStatus;
  /** Task status information, displaying the failure reason when the task fails */
  task_status_msg?: string;
  /** Task update time, Unix timestamp in milliseconds */
  updated_at?: number;
  watermark_info?: KlingOmniVideoResponseDataWatermarkInfo;
};

export interface KlingOmniVideoResponse {
  /** Error code */
  code?: number;
  data?: KlingOmniVideoResponseData;
  /** Error message */
  message?: string;
  /** Request ID */
  request_id?: string;
}

/**
 * Resource package type (decreasing_total=decreasing total, constant_period=constant periodicity)
 */
export type KlingResourcePackageResponseDataResourcePackSubscribeInfosItemResourcePackType = typeof KlingResourcePackageResponseDataResourcePackSubscribeInfosItemResourcePackType[keyof typeof KlingResourcePackageResponseDataResourcePackSubscribeInfosItemResourcePackType];


export const KlingResourcePackageResponseDataResourcePackSubscribeInfosItemResourcePackType = {
  decreasing_total: 'decreasing_total',
  constant_period: 'constant_period',
} as const;

/**
 * Resource Package Status
 */
export type KlingResourcePackageResponseDataResourcePackSubscribeInfosItemStatus = typeof KlingResourcePackageResponseDataResourcePackSubscribeInfosItemStatus[keyof typeof KlingResourcePackageResponseDataResourcePackSubscribeInfosItemStatus];


export const KlingResourcePackageResponseDataResourcePackSubscribeInfosItemStatus = {
  toBeOnline: 'toBeOnline',
  online: 'online',
  expired: 'expired',
  runOut: 'runOut',
} as const;

export type KlingResourcePackageResponseDataResourcePackSubscribeInfosItem = {
  /** Effective time, Unix timestamp in ms */
  effective_time?: number;
  /** Expiration time, Unix timestamp in ms */
  invalid_time?: number;
  /** Purchase time, Unix timestamp in ms */
  purchase_time?: number;
  /** Remaining quantity (updated with a 12-hour delay) */
  remaining_quantity?: number;
  /** Resource package ID */
  resource_pack_id?: string;
  /** Resource package name */
  resource_pack_name?: string;
  /** Resource package type (decreasing_total=decreasing total, constant_period=constant periodicity) */
  resource_pack_type?: KlingResourcePackageResponseDataResourcePackSubscribeInfosItemResourcePackType;
  /** Resource Package Status */
  status?: KlingResourcePackageResponseDataResourcePackSubscribeInfosItemStatus;
  /** Total quantity */
  total_quantity?: number;
};

export type KlingResourcePackageResponseData = {
  /** Error code; 0 indicates success */
  code?: number;
  /** Error information */
  msg?: string;
  /** Resource package list */
  resource_pack_subscribe_infos?: KlingResourcePackageResponseDataResourcePackSubscribeInfosItem[];
};

export interface KlingResourcePackageResponse {
  /** Error code; 0 indicates success */
  code?: number;
  data?: KlingResourcePackageResponseData;
  /** Error information */
  message?: string;
  /** Request ID, generated by the system, used to track requests and troubleshoot problems */
  request_id?: string;
}

/**
 * Video Length in seconds. Only 5-second videos are supported.
 */
export type KlingSingleImageEffectDuration = typeof KlingSingleImageEffectDuration[keyof typeof KlingSingleImageEffectDuration];


export const KlingSingleImageEffectDuration = {
  NUMBER_5: '5',
} as const;

/**
 * Model Name. Only kling-v1-6 is supported for single image effects.
 */
export type KlingSingleImageEffectModelName = typeof KlingSingleImageEffectModelName[keyof typeof KlingSingleImageEffectModelName];


export const KlingSingleImageEffectModelName = {
  'kling-v1-6': 'kling-v1-6',
} as const;

export interface KlingSingleImageEffectInput {
  duration: KlingSingleImageEffectDuration;
  /** Reference Image. URL or Base64 encoded string (without data:image prefix). File size cannot exceed 10MB, resolution not less than 300*300px, aspect ratio between 1:2.5 ~ 2.5:1. */
  image: string;
  model_name: KlingSingleImageEffectModelName;
}

/**
 * Scene Name. Single Image Effects (bloombloom, dizzydizzy, fuzzyfuzzy, squish, expansion).
 */
export type KlingSingleImageEffectsScene = typeof KlingSingleImageEffectsScene[keyof typeof KlingSingleImageEffectsScene];


export const KlingSingleImageEffectsScene = {
  bloombloom: 'bloombloom',
  dizzydizzy: 'dizzydizzy',
  fuzzyfuzzy: 'fuzzyfuzzy',
  squish: 'squish',
  expansion: 'expansion',
} as const;

export type KlingText2VideoRequestMultiPromptItem = {
  /** Duration of this storyboard in seconds. Must not exceed total task duration and must not be less than 1. Sum of all storyboard durations equals total task duration. */
  duration?: string;
  /** Shot sequence number */
  index?: number;
  /**
   * Prompt word for this storyboard. Maximum length 512 characters.
   * @maxLength 512
   */
  prompt?: string;
};

/**
 * Storyboard method. Required when the multi_shot parameter is set to true.
 */
export type KlingText2VideoRequestShotType = typeof KlingText2VideoRequestShotType[keyof typeof KlingText2VideoRequestShotType];


export const KlingText2VideoRequestShotType = {
  customize: 'customize',
} as const;

/**
 * Whether to generate sound simultaneously when generating videos. Only V2.6 and subsequent versions of the model support this parameter.
 */
export type KlingText2VideoRequestSound = typeof KlingText2VideoRequestSound[keyof typeof KlingText2VideoRequestSound];


export const KlingText2VideoRequestSound = {
  on: 'on',
  off: 'off',
} as const;

/**
 * Whether to generate watermarked results simultaneously. Custom watermark is not supported at this time.
 */
export type KlingText2VideoRequestWatermarkInfo = {
  /** true means generate watermark, false means do not generate. */
  enabled?: boolean;
};

/**
 * Model Name
 */
export type KlingTextToVideoModelName = typeof KlingTextToVideoModelName[keyof typeof KlingTextToVideoModelName];


export const KlingTextToVideoModelName = {
  'kling-v1': 'kling-v1',
  'kling-v1-5': 'kling-v1-5',
  'kling-v1-6': 'kling-v1-6',
  'kling-v2-master': 'kling-v2-master',
  'kling-v2-1-master': 'kling-v2-1-master',
  'kling-v2-5-turbo': 'kling-v2-5-turbo',
  'kling-v2-6': 'kling-v2-6',
  'kling-v3': 'kling-v3',
} as const;

export interface KlingText2VideoRequest {
  aspect_ratio?: KlingVideoGenAspectRatio;
  /** The callback notification address */
  callback_url?: string;
  camera_control?: KlingCameraControl;
  cfg_scale?: KlingVideoGenCfgScale;
  duration?: KlingVideoGenDuration;
  /** Customized Task ID */
  external_task_id?: string;
  mode?: KlingVideoGenMode;
  model_name?: KlingTextToVideoModelName;
  /** Information about each storyboard, such as prompts and duration. Supports up to 6 storyboards, with a minimum of 1. Required when multi_shot is true and shot_type is customize. */
  multi_prompt?: KlingText2VideoRequestMultiPromptItem[];
  /** Whether to generate multi-shot video. When true, the prompt parameter is invalid. When false, the shot_type and multi_prompt parameters are invalid. */
  multi_shot?: boolean;
  /**
   * Negative text prompt. It is recommended to supplement negative prompt information through negative sentences directly within positive prompts.
   * @maxLength 2500
   */
  negative_prompt?: string;
  /**
   * Positive text prompt. Use <<<voice_1>>> to specify a voice matching the voice_list parameter order. A task can reference up to 2 tones. When specifying a tone, the sound parameter value must be on.
   * @maxLength 2500
   */
  prompt?: string;
  /** Storyboard method. Required when the multi_shot parameter is set to true. */
  shot_type?: KlingText2VideoRequestShotType;
  /** Whether to generate sound simultaneously when generating videos. Only V2.6 and subsequent versions of the model support this parameter. */
  sound?: KlingText2VideoRequestSound;
  /** Whether to generate watermarked results simultaneously. Custom watermark is not supported at this time. */
  watermark_info?: KlingText2VideoRequestWatermarkInfo;
}

export type KlingText2VideoResponseDataTaskInfo = {
  external_task_id?: string;
};

export type KlingText2VideoResponseDataTaskResult = {
  videos?: KlingVideoResult[];
};

export type KlingText2VideoResponseDataWatermarkInfo = {
  enabled?: boolean;
};

export type KlingText2VideoResponseData = {
  /** Task creation time, Unix timestamp in milliseconds */
  created_at?: number;
  /** The deduction units of task */
  final_unit_deduction?: string;
  /** Task ID */
  task_id?: string;
  task_info?: KlingText2VideoResponseDataTaskInfo;
  task_result?: KlingText2VideoResponseDataTaskResult;
  task_status?: KlingTaskStatus;
  /** Task status information, displaying the failure reason when the task fails */
  task_status_msg?: string;
  /** Task update time, Unix timestamp in milliseconds */
  updated_at?: number;
  watermark_info?: KlingText2VideoResponseDataWatermarkInfo;
};

export interface KlingText2VideoResponse {
  /** Error code */
  code?: number;
  data?: KlingText2VideoResponseData;
  /** Error message */
  message?: string;
  /** Request ID */
  request_id?: string;
}

export type KlingVideoEffectsInput = KlingSingleImageEffectInput | KlingDualCharacterEffectInput;

export const KlingVideoEffectsRequestEffectScene = {...KlingDualCharacterEffectsScene,...KlingSingleImageEffectsScene,} as const
export interface KlingVideoEffectsRequest {
  /** The callback notification address for the result of this task. */
  callback_url?: string;
  effect_scene: typeof KlingVideoEffectsRequestEffectScene[keyof typeof KlingVideoEffectsRequestEffectScene];
  /** Customized Task ID. Must be unique within a single user account. */
  external_task_id?: string;
  input: KlingVideoEffectsInput;
}

export type KlingVideoEffectsResponseDataTaskInfo = {
  external_task_id?: string;
};

export type KlingVideoEffectsResponseDataTaskResult = {
  videos?: KlingVideoResult[];
};

export type KlingVideoEffectsResponseData = {
  /** Task creation time */
  created_at?: number;
  /** Task ID */
  task_id?: string;
  task_info?: KlingVideoEffectsResponseDataTaskInfo;
  task_result?: KlingVideoEffectsResponseDataTaskResult;
  task_status?: KlingTaskStatus;
  /** Task update time */
  updated_at?: number;
};

export interface KlingVideoEffectsResponse {
  /** Error code */
  code?: number;
  data?: KlingVideoEffectsResponseData;
  /** Error message */
  message?: string;
  /** Request ID */
  request_id?: string;
}

export interface KlingVideoExtendRequest {
  /** The callback notification address. Server will notify when the task status changes. */
  callback_url?: string;
  cfg_scale?: KlingVideoGenCfgScale;
  /**
   * Negative text prompt for elements to avoid in the extended video
   * @maxLength 2500
   */
  negative_prompt?: string;
  /**
   * Positive text prompt for guiding the video extension
   * @maxLength 2500
   */
  prompt?: string;
  /** The ID of the video to be extended. Supports videos generated by text-to-video, image-to-video, and previous video extension operations. Cannot exceed 3 minutes total duration after extension. */
  video_id?: string;
}

export type KlingVideoExtendResponseDataTaskInfo = {
  external_task_id?: string;
};

export type KlingVideoExtendResponseDataTaskResult = {
  videos?: KlingVideoResult[];
};

export type KlingVideoExtendResponseData = {
  /** Task creation time */
  created_at?: number;
  /** Task ID */
  task_id?: string;
  task_info?: KlingVideoExtendResponseDataTaskInfo;
  task_result?: KlingVideoExtendResponseDataTaskResult;
  task_status?: KlingTaskStatus;
  /** Task update time */
  updated_at?: number;
};

export interface KlingVideoExtendResponse {
  /** Error code */
  code?: number;
  data?: KlingVideoExtendResponseData;
  /** Error message */
  message?: string;
  /** Request ID */
  request_id?: string;
}

/**
 * Model Name
 */
export type KlingVirtualTryOnModelName = typeof KlingVirtualTryOnModelName[keyof typeof KlingVirtualTryOnModelName];


export const KlingVirtualTryOnModelName = {
  'kolors-virtual-try-on-v1': 'kolors-virtual-try-on-v1',
  'kolors-virtual-try-on-v1-5': 'kolors-virtual-try-on-v1-5',
} as const;

export interface KlingVirtualTryOnRequest {
  /** The callback notification address */
  callback_url?: string;
  /** Reference clothing image - Base64 encoded string or image URL */
  cloth_image?: string;
  /** Reference human image - Base64 encoded string or image URL */
  human_image: string;
  model_name?: KlingVirtualTryOnModelName;
}

export type KlingVirtualTryOnResponseDataTaskResult = {
  images?: KlingImageResult[];
};

export type KlingVirtualTryOnResponseData = {
  /** Task creation time */
  created_at?: number;
  /** Task ID */
  task_id?: string;
  task_result?: KlingVirtualTryOnResponseDataTaskResult;
  task_status?: KlingTaskStatus;
  /** Task status information */
  task_status_msg?: string;
  /** Task update time */
  updated_at?: number;
};

export interface KlingVirtualTryOnResponse {
  /** Error code */
  code?: number;
  data?: KlingVirtualTryOnResponseData;
  /** Error message */
  message?: string;
  /** Request ID */
  request_id?: string;
}

/**
 * Video duration in seconds
 */
export type LTXImage2VideoRequestDuration = typeof LTXImage2VideoRequestDuration[keyof typeof LTXImage2VideoRequestDuration];


export const LTXImage2VideoRequestDuration = {
  NUMBER_6: 6,
  NUMBER_8: 8,
  NUMBER_10: 10,
} as const;

/**
 * Frame rate in frames per second
 */
export type LTXImage2VideoRequestFps = typeof LTXImage2VideoRequestFps[keyof typeof LTXImage2VideoRequestFps];


export const LTXImage2VideoRequestFps = {
  NUMBER_25: 25,
  NUMBER_50: 50,
} as const;

/**
 * Model to use for generation
 */
export type LTXImage2VideoRequestModel = typeof LTXImage2VideoRequestModel[keyof typeof LTXImage2VideoRequestModel];


export const LTXImage2VideoRequestModel = {
  'ltx-2-fast': 'ltx-2-fast',
  'ltx-2-pro': 'ltx-2-pro',
} as const;

/**
 * Output video resolution
 */
export type LTXImage2VideoRequestResolution = typeof LTXImage2VideoRequestResolution[keyof typeof LTXImage2VideoRequestResolution];


export const LTXImage2VideoRequestResolution = {
  '1920x1080': '1920x1080',
  '2560x1440': '2560x1440',
  '3840x2160': '3840x2160',
} as const;

export interface LTXImage2VideoRequest {
  /** Video duration in seconds */
  duration: LTXImage2VideoRequestDuration;
  /** Frame rate in frames per second */
  fps?: LTXImage2VideoRequestFps;
  /** Generate audio for the video */
  generate_audio?: boolean;
  /** Image to be used as the first frame of the video (HTTPS URL or base64 data URI) */
  image_uri: string;
  /** Model to use for generation */
  model: LTXImage2VideoRequestModel;
  /**
   * Text description of how the image should be animated
   * @maxLength 10000
   */
  prompt: string;
  /** Output video resolution */
  resolution: LTXImage2VideoRequestResolution;
}

/**
 * Video duration in seconds
 */
export type LTXText2VideoRequestDuration = typeof LTXText2VideoRequestDuration[keyof typeof LTXText2VideoRequestDuration];


export const LTXText2VideoRequestDuration = {
  NUMBER_6: 6,
  NUMBER_8: 8,
  NUMBER_10: 10,
} as const;

/**
 * Frame rate in frames per second
 */
export type LTXText2VideoRequestFps = typeof LTXText2VideoRequestFps[keyof typeof LTXText2VideoRequestFps];


export const LTXText2VideoRequestFps = {
  NUMBER_25: 25,
  NUMBER_50: 50,
} as const;

/**
 * Model to use for generation
 */
export type LTXText2VideoRequestModel = typeof LTXText2VideoRequestModel[keyof typeof LTXText2VideoRequestModel];


export const LTXText2VideoRequestModel = {
  'ltx-2-fast': 'ltx-2-fast',
  'ltx-2-pro': 'ltx-2-pro',
} as const;

/**
 * Output video resolution
 */
export type LTXText2VideoRequestResolution = typeof LTXText2VideoRequestResolution[keyof typeof LTXText2VideoRequestResolution];


export const LTXText2VideoRequestResolution = {
  '1920x1080': '1920x1080',
  '2560x1440': '2560x1440',
  '3840x2160': '3840x2160',
} as const;

export interface LTXText2VideoRequest {
  /** Video duration in seconds */
  duration: LTXText2VideoRequestDuration;
  /** Frame rate in frames per second */
  fps?: LTXText2VideoRequestFps;
  /** Generate audio for the video */
  generate_audio?: boolean;
  /** Model to use for generation */
  model: LTXText2VideoRequestModel;
  /**
   * Text prompt describing the desired video content
   * @maxLength 10000
   */
  prompt: string;
  /** Output video resolution */
  resolution: LTXText2VideoRequestResolution;
}

/**
 * The aspect ratio of the generation
 */
export type LumaAspectRatio = typeof LumaAspectRatio[keyof typeof LumaAspectRatio];


export const LumaAspectRatio = {
  '1:1': '1:1',
  '16:9': '16:9',
  '9:16': '9:16',
  '4:3': '4:3',
  '3:4': '3:4',
  '21:9': '21:9',
  '9:21': '9:21',
} as const;

/**
 * The assets of the generation
 */
export interface LumaAssets {
  /** The URL of the image */
  image?: string;
  /** The URL of the progress video */
  progress_video?: string;
  /** The URL of the video */
  video?: string;
}

export type LumaAudioGenerationRequestGenerationType = typeof LumaAudioGenerationRequestGenerationType[keyof typeof LumaAudioGenerationRequestGenerationType];


export const LumaAudioGenerationRequestGenerationType = {
  add_audio: 'add_audio',
} as const;

/**
 * The audio generation request object
 */
export interface LumaAudioGenerationRequest {
  /** The callback URL for the audio */
  callback_url?: string;
  generation_type?: LumaAudioGenerationRequestGenerationType;
  /** The negative prompt of the audio */
  negative_prompt?: string;
  /** The prompt of the audio */
  prompt?: string;
}

/**
 * The error object
 */
export interface LumaError {
  /** The error message */
  detail?: string;
}

export type LumaGenerationType = typeof LumaGenerationType[keyof typeof LumaGenerationType];


export const LumaGenerationType = {
  video: 'video',
  image: 'image',
} as const;

export type LumaVideoModelOutputDuration = '5s' | '9s' | string;

export type LumaGenerationRequestGenerationType = typeof LumaGenerationRequestGenerationType[keyof typeof LumaGenerationRequestGenerationType];


export const LumaGenerationRequestGenerationType = {
  video: 'video',
} as const;

export type LumaGenerationReferenceType = typeof LumaGenerationReferenceType[keyof typeof LumaGenerationReferenceType];


export const LumaGenerationReferenceType = {
  generation: 'generation',
} as const;

/**
 * The generation reference object
 */
export interface LumaGenerationReference {
  /** The ID of the generation */
  id: string;
  type: LumaGenerationReferenceType;
}

export type LumaImageReferenceType = typeof LumaImageReferenceType[keyof typeof LumaImageReferenceType];


export const LumaImageReferenceType = {
  image: 'image',
} as const;

/**
 * The image object
 */
export interface LumaImageReference {
  type: LumaImageReferenceType;
  /** The URL of the image */
  url: string;
}

/**
 * A keyframe can be either a Generation reference, an Image, or a Video
 */
export type LumaKeyframe = LumaGenerationReference | LumaImageReference;

/**
 * The keyframes of the generation
 */
export interface LumaKeyframes {
  frame0?: LumaKeyframe;
  frame1?: LumaKeyframe;
}

/**
 * The video model used for the generation
 */
export type LumaVideoModel = typeof LumaVideoModel[keyof typeof LumaVideoModel];


export const LumaVideoModel = {
  'ray-2': 'ray-2',
  'ray-flash-2': 'ray-flash-2',
  'ray-1-6': 'ray-1-6',
} as const;

export type LumaVideoModelOutputResolution = '540p' | '720p' | '1080p' | '4k' | string;

/**
 * The generation request object
 */
export interface LumaGenerationRequest {
  aspect_ratio: LumaAspectRatio;
  /** The callback URL of the generation, a POST request with Generation object will be sent to the callback URL when the generation is dreaming, completed, or failed */
  callback_url?: string;
  duration: LumaVideoModelOutputDuration;
  generation_type?: LumaGenerationRequestGenerationType;
  keyframes?: LumaKeyframes;
  /** Whether to loop the video */
  loop?: boolean;
  model: LumaVideoModel;
  /** The prompt of the generation */
  prompt: string;
  resolution: LumaVideoModelOutputResolution;
}

/**
 * The image identity object
 */
export interface LumaImageIdentity {
  /** The URLs of the image identity */
  images?: string[];
}

export type LumaImageGenerationRequestGenerationType = typeof LumaImageGenerationRequestGenerationType[keyof typeof LumaImageGenerationRequestGenerationType];


export const LumaImageGenerationRequestGenerationType = {
  image: 'image',
} as const;

/**
 * The image reference object
 */
export interface LumaImageRef {
  /** The URL of the image reference */
  url?: string;
  /** The weight of the image reference */
  weight?: number;
}

/**
 * The image model used for the generation
 */
export type LumaImageModel = typeof LumaImageModel[keyof typeof LumaImageModel];


export const LumaImageModel = {
  'photon-1': 'photon-1',
  'photon-flash-1': 'photon-flash-1',
} as const;

/**
 * The modify image reference object
 */
export interface LumaModifyImageRef {
  /** The URL of the image reference */
  url?: string;
  /** The weight of the modify image reference */
  weight?: number;
}

export type LumaImageGenerationRequestCharacterRef = {
  identity0?: LumaImageIdentity;
};

/**
 * The image generation request object
 */
export interface LumaImageGenerationRequest {
  aspect_ratio?: LumaAspectRatio;
  /** The callback URL for the generation */
  callback_url?: string;
  character_ref?: LumaImageGenerationRequestCharacterRef;
  generation_type?: LumaImageGenerationRequestGenerationType;
  image_ref?: LumaImageRef[];
  model?: LumaImageModel;
  modify_image_ref?: LumaModifyImageRef;
  /** The prompt of the generation */
  prompt?: string;
  style_ref?: LumaImageRef[];
}

export type LumaUpscaleVideoGenerationRequestGenerationType = typeof LumaUpscaleVideoGenerationRequestGenerationType[keyof typeof LumaUpscaleVideoGenerationRequestGenerationType];


export const LumaUpscaleVideoGenerationRequestGenerationType = {
  upscale_video: 'upscale_video',
} as const;

/**
 * The upscale generation request object
 */
export interface LumaUpscaleVideoGenerationRequest {
  /** The callback URL for the upscale */
  callback_url?: string;
  generation_type?: LumaUpscaleVideoGenerationRequestGenerationType;
  resolution?: LumaVideoModelOutputResolution;
}

/**
 * The state of the generation
 */
export type LumaState = typeof LumaState[keyof typeof LumaState];


export const LumaState = {
  queued: 'queued',
  dreaming: 'dreaming',
  completed: 'completed',
  failed: 'failed',
} as const;

/**
 * The generation response object
 */
export interface LumaGeneration {
  assets?: LumaAssets;
  /** The date and time when the generation was created */
  created_at?: string;
  /** The reason for the state of the generation */
  failure_reason?: string;
  generation_type?: LumaGenerationType;
  /** The ID of the generation */
  id?: string;
  /** The model used for the generation */
  model?: string;
  /** The request of the generation */
  request?: LumaGenerationRequest | LumaImageGenerationRequest | LumaUpscaleVideoGenerationRequest | LumaAudioGenerationRequest;
  state?: LumaState;
}

/**
 * ID of the model to use.
 */
export type MeshyAiModel = typeof MeshyAiModel[keyof typeof MeshyAiModel];


export const MeshyAiModel = {
  'meshy-5': 'meshy-5',
  latest: 'latest',
} as const;

export interface MeshyAnimationCreateResponse {
  /** The task id of the newly created animation task. */
  result: string;
}

/**
 * The target frame rate. Default is 30. Applicable only when operation_type is change_fps.
 */
export type MeshyAnimationPostProcessFps = typeof MeshyAnimationPostProcessFps[keyof typeof MeshyAnimationPostProcessFps];


export const MeshyAnimationPostProcessFps = {
  NUMBER_24: 24,
  NUMBER_25: 25,
  NUMBER_30: 30,
  NUMBER_60: 60,
} as const;

/**
 * The type of operation to perform.
 */
export type MeshyAnimationPostProcessOperationType = typeof MeshyAnimationPostProcessOperationType[keyof typeof MeshyAnimationPostProcessOperationType];


export const MeshyAnimationPostProcessOperationType = {
  change_fps: 'change_fps',
  fbx2usdz: 'fbx2usdz',
  extract_armature: 'extract_armature',
} as const;

/**
 * Parameters for post-processing animation files.
 */
export interface MeshyAnimationPostProcess {
  /** The target frame rate. Default is 30. Applicable only when operation_type is change_fps. */
  fps?: MeshyAnimationPostProcessFps;
  /** The type of operation to perform. */
  operation_type: MeshyAnimationPostProcessOperationType;
}

export interface MeshyAnimationRequest {
  /** The identifier of the animation action to apply. */
  action_id: number;
  post_process?: MeshyAnimationPostProcess;
  /** The id of a successfully completed rigging task (from POST /openapi/v1/rigging). The character from this task will be animated. */
  rig_task_id: string;
}

/**
 * Contains the output animation URLs if the task SUCCEEDED.
 */
export interface MeshyAnimationResult {
  /** Downloadable URL for the animation in FBX format. */
  animation_fbx_url?: string;
  /** Downloadable URL for the animation in GLB format. */
  animation_glb_url?: string;
  /** Downloadable URL for the animation with changed FPS in FBX format. */
  processed_animation_fps_fbx_url?: string;
  /** Downloadable URL for the processed armature in FBX format. */
  processed_armature_fbx_url?: string;
  /** Downloadable URL for the processed animation in USDZ format. */
  processed_usdz_url?: string;
}

/**
 * Type of the Animation task.
 */
export type MeshyAnimationTaskType = typeof MeshyAnimationTaskType[keyof typeof MeshyAnimationTaskType];


export const MeshyAnimationTaskType = {
  animate: 'animate',
} as const;

/**
 * Status of the task.
 */
export type MeshyTaskStatus = typeof MeshyTaskStatus[keyof typeof MeshyTaskStatus];


export const MeshyTaskStatus = {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED',
} as const;

/**
 * Error object that contains the error message if the task failed.
 */
export interface MeshyTaskError {
  /** Detailed error message. */
  message?: string;
}

export interface MeshyAnimationTask {
  /** Timestamp of when the task was created, in milliseconds. */
  created_at?: number;
  /** Timestamp of when the task result expires, in milliseconds. */
  expires_at?: number;
  /** Timestamp of when the task was finished, in milliseconds. 0 if not finished. */
  finished_at?: number;
  /** Unique identifier for the task. */
  id: string;
  /** The count of preceding tasks. Only meaningful when status is PENDING. */
  preceding_tasks?: number;
  /**
   * Progress of the task (0-100).
   * @minimum 0
   * @maximum 100
   */
  progress?: number;
  result?: MeshyAnimationResult;
  /** Timestamp of when the task was started, in milliseconds. 0 if not started. */
  started_at?: number;
  status: MeshyTaskStatus;
  task_error?: MeshyTaskError;
  /** Type of the Animation task. */
  type?: MeshyAnimationTaskType;
}

/**
 * Describe your desired art style of the object.
 */
export type MeshyArtStyle = typeof MeshyArtStyle[keyof typeof MeshyArtStyle];


export const MeshyArtStyle = {
  realistic: 'realistic',
  sculpture: 'sculpture',
} as const;

export interface MeshyImageTo3DCreateResponse {
  /** The task id of the newly created Image to 3D task. */
  result: string;
}

/**
 * Downloadable URLs to the 3D model files generated by Meshy.
 */
export interface MeshyImageTo3DModelUrls {
  /** Downloadable URL to the FBX file. */
  fbx?: string;
  /** Downloadable URL to the GLB file. */
  glb?: string;
  /** Downloadable URL to the MTL file. */
  mtl?: string;
  /** Downloadable URL to the OBJ file. */
  obj?: string;
  /** Downloadable URL to the original GLB output before remeshing. Available only when should_remesh and save_pre_remeshed_model are both true. */
  pre_remeshed_glb?: string;
  /** Downloadable URL to the USDZ file. */
  usdz?: string;
}

/**
 * Specify the type of 3D mesh generation.
- standard: Regular high-detail 3D mesh generation.
- lowpoly: Generates low-poly mesh optimized for cleaner polygons.
When lowpoly is selected, ai_model, topology, target_polycount, should_remesh, save_pre_remeshed_model are ignored.

 */
export type MeshyImageTo3DRequestModelType = typeof MeshyImageTo3DRequestModelType[keyof typeof MeshyImageTo3DRequestModelType];


export const MeshyImageTo3DRequestModelType = {
  standard: 'standard',
  lowpoly: 'lowpoly',
} as const;

/**
 * Specify the pose mode for the generated model.
 */
export type MeshyPoseMode = typeof MeshyPoseMode[keyof typeof MeshyPoseMode];


export const MeshyPoseMode = {
  'a-pose': 'a-pose',
  't-pose': 't-pose',
  '': '',
} as const;

/**
 * Controls symmetry behavior during model generation.
 */
export type MeshySymmetryMode = typeof MeshySymmetryMode[keyof typeof MeshySymmetryMode];


export const MeshySymmetryMode = {
  off: 'off',
  auto: 'auto',
  on: 'on',
} as const;

/**
 * Specify the topology of the generated model.
 */
export type MeshyTopology = typeof MeshyTopology[keyof typeof MeshyTopology];


export const MeshyTopology = {
  quad: 'quad',
  triangle: 'triangle',
} as const;

export interface MeshyImageTo3DRequest {
  ai_model?: MeshyAiModel;
  /** Generate PBR Maps (metallic, roughness, normal) in addition to the base color. */
  enable_pbr?: boolean;
  /** Provide an image for Meshy to use in model creation. Supports .jpg, .jpeg, .png formats or base64-encoded data URI. */
  image_url: string;
  /** Deprecated. Use pose_mode instead. Whether to generate the model in an A/T pose. */
  is_a_t_pose?: boolean;
  /** Specify the type of 3D mesh generation.
- standard: Regular high-detail 3D mesh generation.
- lowpoly: Generates low-poly mesh optimized for cleaner polygons.
When lowpoly is selected, ai_model, topology, target_polycount, should_remesh, save_pre_remeshed_model are ignored.
 */
  model_type?: MeshyImageTo3DRequestModelType;
  /** When true, input content will be screened for potentially harmful content. */
  moderation?: boolean;
  pose_mode?: MeshyPoseMode;
  /** When true, stores an extra GLB file before the remesh phase completes. Only takes effect when should_remesh is true. */
  save_pre_remeshed_model?: boolean;
  /** Controls whether to enable the remesh phase. When false, returns highest-precision triangular mesh. */
  should_remesh?: boolean;
  /** Determines if textures are generated. When false, provides a mesh without textures. */
  should_texture?: boolean;
  symmetry_mode?: MeshySymmetryMode;
  /**
   * Specify the target number of polygons in the generated model. Valid range is 100 to 300,000.
   * @minimum 100
   * @maximum 300000
   */
  target_polycount?: number;
  /** Provide a 2d image to guide the texturing process. Supports .jpg, .jpeg, .png formats or base64-encoded data URI. */
  texture_image_url?: string;
  /**
   * Provide a text prompt to guide the texturing process. Maximum 600 characters.
   * @maxLength 600
   */
  texture_prompt?: string;
  topology?: MeshyTopology;
}

/**
 * Type of the Image to 3D task.
 */
export type MeshyImageTo3DTaskType = typeof MeshyImageTo3DTaskType[keyof typeof MeshyImageTo3DTaskType];


export const MeshyImageTo3DTaskType = {
  'image-to-3d': 'image-to-3d',
} as const;

/**
 * Texture URL object containing PBR maps.
 */
export interface MeshyTextureUrls {
  /** Downloadable URL to the base color map image. */
  base_color?: string;
  /** Downloadable URL to the metallic map image. */
  metallic?: string;
  /** Downloadable URL to the normal map image. */
  normal?: string;
  /** Downloadable URL to the roughness map image. */
  roughness?: string;
}

export interface MeshyImageTo3DTask {
  /** Timestamp of when the task was created, in milliseconds. */
  created_at?: number;
  /** Timestamp of when the task result expires, in milliseconds. */
  expires_at?: number;
  /** Timestamp of when the task was finished, in milliseconds. 0 if not finished. */
  finished_at?: number;
  /** Unique identifier for the task. */
  id: string;
  model_urls?: MeshyImageTo3DModelUrls;
  /** The count of preceding tasks. Only meaningful when status is PENDING. */
  preceding_tasks?: number;
  /**
   * Progress of the task. 0 if not started, 100 when succeeded.
   * @minimum 0
   * @maximum 100
   */
  progress?: number;
  /** Timestamp of when the task was started, in milliseconds. 0 if not started. */
  started_at?: number;
  status: MeshyTaskStatus;
  task_error?: MeshyTaskError;
  /** Downloadable URL to the texture image that was used to guide the texturing process. */
  texture_image_url?: string;
  /** The text prompt that was used to guide the texturing process. */
  texture_prompt?: string;
  /** An array of texture URL objects that are generated from the task. */
  texture_urls?: MeshyTextureUrls[];
  /** Downloadable URL to the thumbnail image of the model file. */
  thumbnail_url?: string;
  /** Type of the Image to 3D task. */
  type?: MeshyImageTo3DTaskType;
}

/**
 * Downloadable URLs to the textured 3D model files generated by Meshy.
 */
export interface MeshyModelUrls {
  /** Downloadable URL to the FBX file. */
  fbx?: string;
  /** Downloadable URL to the GLB file. */
  glb?: string;
  /** Downloadable URL to the MTL file. */
  mtl?: string;
  /** Downloadable URL to the OBJ file. */
  obj?: string;
  /** Downloadable URL to the USDZ file. */
  usdz?: string;
}

export interface MeshyMultiImageTo3DCreateResponse {
  /** The task id of the newly created Multi-Image to 3D task. */
  result: string;
}

/**
 * ID of the model to use.
 */
export type MeshyMultiImageTo3DRequestAiModel = typeof MeshyMultiImageTo3DRequestAiModel[keyof typeof MeshyMultiImageTo3DRequestAiModel];


export const MeshyMultiImageTo3DRequestAiModel = {
  'meshy-5': 'meshy-5',
  latest: 'latest',
} as const;

export interface MeshyMultiImageTo3DRequest {
  /** ID of the model to use. */
  ai_model?: MeshyMultiImageTo3DRequestAiModel;
  /** Generate PBR Maps (metallic, roughness, normal) in addition to the base color. */
  enable_pbr?: boolean;
  /**
   * Provide 1 to 4 images for Meshy to use in model creation. All images should depict the same object from different angles.
   * @minItems 1
   * @maxItems 4
   */
  image_urls: string[];
  /** Deprecated. Use pose_mode instead. Whether to generate the model in an A/T pose. */
  is_a_t_pose?: boolean;
  /** When true, input content will be screened for potentially harmful content. */
  moderation?: boolean;
  pose_mode?: MeshyPoseMode;
  /** When true, stores an extra GLB file before the remesh phase completes. Only takes effect when should_remesh is true. */
  save_pre_remeshed_model?: boolean;
  /** Controls whether to enable the remesh phase. When false, returns highest-precision triangular mesh. */
  should_remesh?: boolean;
  /** Determines if textures are generated. When false, provides a mesh without textures for 5 credits. */
  should_texture?: boolean;
  symmetry_mode?: MeshySymmetryMode;
  /**
   * Specify the target number of polygons in the generated model. Valid range is 100 to 300,000.
   * @minimum 100
   * @maximum 300000
   */
  target_polycount?: number;
  /** Provide a 2d image to guide the texturing process. Supports .jpg, .jpeg, .png formats or base64-encoded data URI. */
  texture_image_url?: string;
  /**
   * Provide a text prompt to guide the texturing process. Maximum 600 characters.
   * @maxLength 600
   */
  texture_prompt?: string;
  topology?: MeshyTopology;
}

/**
 * Type of the Multi-Image to 3D task.
 */
export type MeshyMultiImageTo3DTaskType = typeof MeshyMultiImageTo3DTaskType[keyof typeof MeshyMultiImageTo3DTaskType];


export const MeshyMultiImageTo3DTaskType = {
  'multi-image-to-3d': 'multi-image-to-3d',
} as const;

export interface MeshyMultiImageTo3DTask {
  /** Timestamp of when the task was created, in milliseconds. */
  created_at?: number;
  /** Timestamp of when the task result expires, in milliseconds. */
  expires_at?: number;
  /** Timestamp of when the task was finished, in milliseconds. 0 if not finished. */
  finished_at?: number;
  /** Unique identifier for the task. */
  id: string;
  model_urls?: MeshyImageTo3DModelUrls;
  /** The count of preceding tasks. Only meaningful when status is PENDING. */
  preceding_tasks?: number;
  /**
   * Progress of the task. 0 if not started, 100 when succeeded.
   * @minimum 0
   * @maximum 100
   */
  progress?: number;
  /** Timestamp of when the task was started, in milliseconds. 0 if not started. */
  started_at?: number;
  status: MeshyTaskStatus;
  task_error?: MeshyTaskError;
  /** The text prompt that was used to guide the texturing process. */
  texture_prompt?: string;
  /** An array of texture URL objects that are generated from the task. */
  texture_urls?: MeshyTextureUrls[];
  /** Downloadable URL to the thumbnail image of the model file. */
  thumbnail_url?: string;
  /** Type of the Multi-Image to 3D task. */
  type?: MeshyMultiImageTo3DTaskType;
}

export interface MeshyRemeshCreateResponse {
  /** The id of the newly created remesh task. */
  result: string;
}

/**
 * Downloadable URLs to the remeshed 3D model files.
 */
export interface MeshyRemeshModelUrls {
  /** Downloadable URL to the Blender file. */
  blend?: string;
  /** Downloadable URL to the FBX file. */
  fbx?: string;
  /** Downloadable URL to the GLB file. */
  glb?: string;
  /** Downloadable URL to the OBJ file. */
  obj?: string;
  /** Downloadable URL to the STL file. */
  stl?: string;
  /** Downloadable URL to the USDZ file. */
  usdz?: string;
}

/**
 * Position of the origin.
 */
export type MeshyRemeshRequestOriginAt = typeof MeshyRemeshRequestOriginAt[keyof typeof MeshyRemeshRequestOriginAt];


export const MeshyRemeshRequestOriginAt = {
  bottom: 'bottom',
  center: 'center',
  '': '',
} as const;

export type MeshyRemeshRequestTargetFormatsItem = typeof MeshyRemeshRequestTargetFormatsItem[keyof typeof MeshyRemeshRequestTargetFormatsItem];


export const MeshyRemeshRequestTargetFormatsItem = {
  glb: 'glb',
  fbx: 'fbx',
  obj: 'obj',
  usdz: 'usdz',
  blend: 'blend',
  stl: 'stl',
} as const;

export interface MeshyRemeshRequest {
  /** If true, only changes the format of the input model file, ignoring other inputs like topology, resize_height, and target_polycount. */
  convert_format_only?: boolean;
  /** The ID of the completed Image to 3D or Text to 3D task you wish to remesh. Required if model_url is not provided. */
  input_task_id?: string;
  /** A publicly accessible URL or data URI to a 3D model. Supported formats glb, gltf, obj, fbx, stl. Required if input_task_id is not provided. */
  model_url?: string;
  /** Position of the origin. */
  origin_at?: MeshyRemeshRequestOriginAt;
  /** Resize the model to a certain height measured in meters. 0 means no resizing. */
  resize_height?: number;
  /** A list of target formats for the remeshed model. */
  target_formats?: MeshyRemeshRequestTargetFormatsItem[];
  /**
   * Specify the target number of polygons in the generated model. Valid range is 100 to 300,000.
   * @minimum 100
   * @maximum 300000
   */
  target_polycount?: number;
  topology?: MeshyTopology;
}

/**
 * Type of the Remesh task.
 */
export type MeshyRemeshTaskType = typeof MeshyRemeshTaskType[keyof typeof MeshyRemeshTaskType];


export const MeshyRemeshTaskType = {
  remesh: 'remesh',
} as const;

/**
 * Status of the remesh task.
 */
export type MeshyRemeshTaskStatus = typeof MeshyRemeshTaskStatus[keyof typeof MeshyRemeshTaskStatus];


export const MeshyRemeshTaskStatus = {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
} as const;

export interface MeshyRemeshTask {
  /** Timestamp of when the task was created, in milliseconds. */
  created_at?: number;
  /** Timestamp of when the task was finished, in milliseconds. 0 if not finished. */
  finished_at?: number;
  /** Unique identifier for the task. */
  id: string;
  model_urls?: MeshyRemeshModelUrls;
  /** The count of preceding tasks. Only meaningful when status is PENDING. */
  preceding_tasks?: number;
  /**
   * Progress of the task. 0 if not started, 100 when succeeded.
   * @minimum 0
   * @maximum 100
   */
  progress?: number;
  /** Timestamp of when the task was started, in milliseconds. 0 if not started. */
  started_at?: number;
  status: MeshyRemeshTaskStatus;
  task_error?: MeshyTaskError;
  /** Type of the Remesh task. */
  type?: MeshyRemeshTaskType;
}

export interface MeshyRetextureCreateResponse {
  /** The task id of the newly created Retexture task. */
  result: string;
}

/**
 * Downloadable URLs to the textured 3D model files.
 */
export interface MeshyRetextureModelUrls {
  /** Downloadable URL to the FBX file. */
  fbx?: string;
  /** Downloadable URL to the GLB file. */
  glb?: string;
  /** Downloadable URL to the USDZ file. */
  usdz?: string;
}

export interface MeshyRetextureRequest {
  ai_model?: MeshyAiModel;
  /** Use the original UV of the model instead of generating new UVs. */
  enable_original_uv?: boolean;
  /** Generate PBR Maps (metallic, roughness, normal) in addition to the base color. */
  enable_pbr?: boolean;
  /** A 2d image to guide the texturing process. Supports jpg, jpeg, png formats or base64-encoded data URI. Required if text_style_prompt is not provided. */
  image_style_url?: string;
  /** The ID of the completed Image to 3D or Text to 3D task you wish to retexture. Required if model_url is not provided. */
  input_task_id?: string;
  /** A publicly accessible URL or Data URI to a 3D model. Supported formats glb, gltf, obj, fbx, stl. Required if input_task_id is not provided. */
  model_url?: string;
  /**
   * Describe your desired texture style of the object using text. Maximum 600 characters. Required if image_style_url is not provided.
   * @maxLength 600
   */
  text_style_prompt?: string;
}

/**
 * Type of the Retexture task.
 */
export type MeshyRetextureTaskType = typeof MeshyRetextureTaskType[keyof typeof MeshyRetextureTaskType];


export const MeshyRetextureTaskType = {
  retexture: 'retexture',
} as const;

export interface MeshyRetextureTask {
  /** Timestamp of when the task was created, in milliseconds. */
  created_at?: number;
  /** Timestamp of when the task result expires, in milliseconds. */
  expires_at?: number;
  /** Timestamp of when the task was finished, in milliseconds. 0 if not finished. */
  finished_at?: number;
  /** Unique identifier for the task. */
  id: string;
  /** The image input that was used to create the texturing task. */
  image_style_url?: string;
  model_urls?: MeshyRetextureModelUrls;
  /** The count of preceding tasks. Only meaningful when status is PENDING. */
  preceding_tasks?: number;
  /**
   * Progress of the task. 0 if not started, 100 when succeeded.
   * @minimum 0
   * @maximum 100
   */
  progress?: number;
  /** Timestamp of when the task was started, in milliseconds. 0 if not started. */
  started_at?: number;
  status: MeshyTaskStatus;
  task_error?: MeshyTaskError;
  /** The text prompt that was used to create the texturing task. */
  text_style_prompt?: string;
  /** An array of texture URL objects that are generated from the task. */
  texture_urls?: MeshyTextureUrls[];
  /** Downloadable URL to the thumbnail image of the model file. */
  thumbnail_url?: string;
  /** Type of the Retexture task. */
  type?: MeshyRetextureTaskType;
}

/**
 * Contains URLs for default animations.
 */
export interface MeshyRiggingBasicAnimations {
  /** Downloadable URL for running animation armature in GLB format. */
  running_armature_glb_url?: string;
  /** Downloadable URL for running animation in FBX format (with skin). */
  running_fbx_url?: string;
  /** Downloadable URL for running animation in GLB format (with skin). */
  running_glb_url?: string;
  /** Downloadable URL for walking animation armature in GLB format. */
  walking_armature_glb_url?: string;
  /** Downloadable URL for walking animation in FBX format (with skin). */
  walking_fbx_url?: string;
  /** Downloadable URL for walking animation in GLB format (with skin). */
  walking_glb_url?: string;
}

export interface MeshyRiggingCreateResponse {
  /** The task id of the newly created rigging task. */
  result: string;
}

export interface MeshyRiggingRequest {
  /** The approximate height of the character model in meters. Must be a positive number. */
  height_meters?: number;
  /** The input task that needs to be rigged. Required if model_url is not provided. */
  input_task_id?: string;
  /** A publicly accessible URL or Data URI to a textured humanoid GLB file. Required if input_task_id is not provided. */
  model_url?: string;
  /** The model's UV-unwrapped base color texture image. Publicly accessible URL or Data URI. Supports .png format. */
  texture_image_url?: string;
}

/**
 * Contains the output asset URLs if the task SUCCEEDED.
 */
export interface MeshyRiggingResult {
  basic_animations?: MeshyRiggingBasicAnimations;
  /** Downloadable URL for the rigged character in FBX format. */
  rigged_character_fbx_url?: string;
  /** Downloadable URL for the rigged character in GLB format. */
  rigged_character_glb_url?: string;
}

/**
 * Type of the Rigging task.
 */
export type MeshyRiggingTaskType = typeof MeshyRiggingTaskType[keyof typeof MeshyRiggingTaskType];


export const MeshyRiggingTaskType = {
  rig: 'rig',
} as const;

export interface MeshyRiggingTask {
  /** Timestamp of when the task was created, in milliseconds. */
  created_at?: number;
  /** Timestamp of when the task result expires, in milliseconds. */
  expires_at?: number;
  /** Timestamp of when the task was finished, in milliseconds. 0 if not finished. */
  finished_at?: number;
  /** Unique identifier for the task. */
  id: string;
  /** The count of preceding tasks. Only meaningful when status is PENDING. */
  preceding_tasks?: number;
  /**
   * Progress of the task (0-100). 0 if not started, 100 if succeeded.
   * @minimum 0
   * @maximum 100
   */
  progress?: number;
  result?: MeshyRiggingResult;
  /** Timestamp of when the task was started, in milliseconds. 0 if not started. */
  started_at?: number;
  status: MeshyTaskStatus;
  task_error?: MeshyTaskError;
  /** Type of the Rigging task. */
  type?: MeshyRiggingTaskType;
}

export interface MeshyTextTo3DCreateResponse {
  /** The task id of the newly created Text to 3D task. */
  result: string;
}

/**
 * This field should be set to "preview" when creating a preview task.
 */
export type MeshyTextTo3DPreviewRequestMode = typeof MeshyTextTo3DPreviewRequestMode[keyof typeof MeshyTextTo3DPreviewRequestMode];


export const MeshyTextTo3DPreviewRequestMode = {
  preview: 'preview',
} as const;

export interface MeshyTextTo3DPreviewRequest {
  ai_model?: MeshyAiModel;
  art_style?: MeshyArtStyle;
  /** Deprecated. Use pose_mode instead. Whether to generate the model in an A/T pose. */
  is_a_t_pose?: boolean;
  /** This field should be set to "preview" when creating a preview task. */
  mode: MeshyTextTo3DPreviewRequestMode;
  /** When true, input content will be screened for potentially harmful content. */
  moderation?: boolean;
  pose_mode?: MeshyPoseMode;
  /**
   * Describe what kind of object the 3D model is. Maximum 600 characters.
   * @maxLength 600
   */
  prompt: string;
  /** Controls whether to enable the remesh phase. When false, returns highest-precision triangular mesh. */
  should_remesh?: boolean;
  symmetry_mode?: MeshySymmetryMode;
  /**
   * Specify the target number of polygons in the generated model. Valid range is 100 to 300,000.
   * @minimum 100
   * @maximum 300000
   */
  target_polycount?: number;
  topology?: MeshyTopology;
}

/**
 * This field should be set to "refine" when creating a refine task.
 */
export type MeshyTextTo3DRefineRequestMode = typeof MeshyTextTo3DRefineRequestMode[keyof typeof MeshyTextTo3DRefineRequestMode];


export const MeshyTextTo3DRefineRequestMode = {
  refine: 'refine',
} as const;

export interface MeshyTextTo3DRefineRequest {
  ai_model?: MeshyAiModel;
  /** Generate PBR Maps (metallic, roughness, normal) in addition to the base color. Note that enable_pbr should be set to false when using Sculpture style. */
  enable_pbr?: boolean;
  /** This field should be set to "refine" when creating a refine task. */
  mode: MeshyTextTo3DRefineRequestMode;
  /** When true, input content will be screened for potentially harmful content. */
  moderation?: boolean;
  /** The corresponding preview task id. The status of the given preview task must be SUCCEEDED. */
  preview_task_id: string;
  /** Provide a 2d image to guide the texturing process. Supports .jpg, .jpeg, .png formats or base64-encoded data URI. */
  texture_image_url?: string;
  /**
   * Provide an additional text prompt to guide the texturing process. Maximum 600 characters.
   * @maxLength 600
   */
  texture_prompt?: string;
}

export type MeshyTextTo3DRequest = MeshyTextTo3DPreviewRequest | MeshyTextTo3DRefineRequest;

/**
 * Type of the Text to 3D task.
 */
export type MeshyTextTo3DTaskType = typeof MeshyTextTo3DTaskType[keyof typeof MeshyTextTo3DTaskType];


export const MeshyTextTo3DTaskType = {
  'text-to-3d-preview': 'text-to-3d-preview',
  'text-to-3d-refine': 'text-to-3d-refine',
} as const;

export interface MeshyTextTo3DTask {
  /** The unmodified art_style that was used to create the preview task. */
  art_style?: string;
  /** Timestamp of when the task was created, in milliseconds. */
  created_at?: number;
  /** Timestamp of when the task was finished, in milliseconds. 0 if not finished. */
  finished_at?: number;
  /** Unique identifier for the task. */
  id: string;
  model_urls?: MeshyModelUrls;
  /** Deprecated field maintained for backward compatibility. */
  negative_prompt?: string;
  /** The count of preceding tasks. Only meaningful when status is PENDING. */
  preceding_tasks?: number;
  /**
   * Progress of the task. 0 if not started, 100 when succeeded.
   * @minimum 0
   * @maximum 100
   */
  progress?: number;
  /** The unmodified prompt that was used to create the task. */
  prompt?: string;
  /** Timestamp of when the task was started, in milliseconds. 0 if not started. */
  started_at?: number;
  status: MeshyTaskStatus;
  task_error?: MeshyTaskError;
  /** Downloadable URL to the texture image that was used to guide the texturing process. */
  texture_image_url?: string;
  /** Additional text prompt provided to guide the texturing process during the refine stage. */
  texture_prompt?: string;
  /** Deprecated field maintained for backward compatibility. */
  texture_richness?: string;
  /** An array of texture URL objects that are generated from the task. */
  texture_urls?: MeshyTextureUrls[];
  /** Downloadable URL to the thumbnail image of the model file. */
  thumbnail_url?: string;
  /** Type of the Text to 3D task. */
  type?: MeshyTextTo3DTaskType;
  /** Deprecated field returning the downloadable URL to the preview video. */
  video_url?: string;
}

/**
 * Common response structure used by Minimax APIs
 */
export interface MinimaxBaseResponse {
  /** Status code. 0 indicates success, other values indicate errors. */
  status_code: number;
  /** Specific error details or success message. */
  status_msg: string;
}

export type MinimaxFileRetrieveResponseFile = {
  /** File size in bytes */
  bytes?: number;
  /** Unix timestamp when the file was created, in seconds */
  created_at?: number;
  /** The URL to download the video */
  download_url?: string;
  /** Unique identifier for the file */
  file_id?: number;
  /** The name of the file */
  filename?: string;
  /** The purpose of using the file */
  purpose?: string;
};

/**
 * Response from retrieving a Minimax file download URL.
 */
export interface MinimaxFileRetrieveResponse {
  base_resp: MinimaxBaseResponse;
  file: MinimaxFileRetrieveResponseFile;
}

/**
 * Task status: 'Queueing' (in queue), 'Preparing' (task is preparing), 'Processing' (generating), 'Success' (task completed successfully), or 'Fail' (task failed).
 */
export type MinimaxTaskResultResponseStatus = typeof MinimaxTaskResultResponseStatus[keyof typeof MinimaxTaskResultResponseStatus];


export const MinimaxTaskResultResponseStatus = {
  Queueing: 'Queueing',
  Preparing: 'Preparing',
  Processing: 'Processing',
  Success: 'Success',
  Fail: 'Fail',
} as const;

/**
 * Response from querying a Minimax video generation task status.
 */
export interface MinimaxTaskResultResponse {
  base_resp: MinimaxBaseResponse;
  /** After the task status changes to Success, this field returns the file ID corresponding to the generated video. */
  file_id?: string;
  /** Task status: 'Queueing' (in queue), 'Preparing' (task is preparing), 'Processing' (generating), 'Success' (task completed successfully), or 'Fail' (task failed). */
  status: MinimaxTaskResultResponseStatus;
  /** The task ID being queried. */
  task_id: string;
}

/**
 * Video length in seconds. Only available for MiniMax-Hailuo-02
 */
export type MinimaxVideoGenerationRequestDuration = typeof MinimaxVideoGenerationRequestDuration[keyof typeof MinimaxVideoGenerationRequestDuration];


export const MinimaxVideoGenerationRequestDuration = {
  NUMBER_6: 6,
  NUMBER_10: 10,
} as const;

/**
 * Required. ID of model. Options: MiniMax-Hailuo-02, T2V-01-Director, I2V-01-Director, S2V-01, I2V-01, I2V-01-live, T2V-01
 */
export type MinimaxVideoGenerationRequestModel = typeof MinimaxVideoGenerationRequestModel[keyof typeof MinimaxVideoGenerationRequestModel];


export const MinimaxVideoGenerationRequestModel = {
  'MiniMax-Hailuo-02': 'MiniMax-Hailuo-02',
  'T2V-01-Director': 'T2V-01-Director',
  'I2V-01-Director': 'I2V-01-Director',
  'S2V-01': 'S2V-01',
  'I2V-01': 'I2V-01',
  'I2V-01-live': 'I2V-01-live',
  'T2V-01': 'T2V-01',
} as const;

/**
 * Video resolution. Only available for MiniMax-Hailuo-02.
 */
export type MinimaxVideoGenerationRequestResolution = typeof MinimaxVideoGenerationRequestResolution[keyof typeof MinimaxVideoGenerationRequestResolution];


export const MinimaxVideoGenerationRequestResolution = {
  '768P': '768P',
  '1080P': '1080P',
} as const;

export type MinimaxVideoGenerationRequestSubjectReferenceItem = {
  /** URL or base64 encoding of the subject reference image. */
  image?: string;
  /** URL or base64 encoding of the mask for the subject reference image. */
  mask?: string;
};

/**
 * Parameters for the Minimax video generation proxy request.
 */
export interface MinimaxVideoGenerationRequest {
  /** Optional. URL to receive real-time status updates about the video generation task. */
  callback_url?: string;
  /** Video length in seconds. Only available for MiniMax-Hailuo-02 */
  duration?: MinimaxVideoGenerationRequestDuration;
  /** URL or base64 encoding of the first frame image. Required when model is I2V-01, I2V-01-Director, or I2V-01-live. */
  first_frame_image?: string;
  /** Required. ID of model. Options: MiniMax-Hailuo-02, T2V-01-Director, I2V-01-Director, S2V-01, I2V-01, I2V-01-live, T2V-01 */
  model: MinimaxVideoGenerationRequestModel;
  /**
   * Description of the video. Should be less than 2000 characters. Supports camera movement instructions in [brackets].
   * @maxLength 2000
   */
  prompt?: string;
  /** If true (default), the model will automatically optimize the prompt. Set to false for more precise control. */
  prompt_optimizer?: boolean;
  /** Video resolution. Only available for MiniMax-Hailuo-02. */
  resolution?: MinimaxVideoGenerationRequestResolution;
  /** Only available when model is S2V-01. The model will generate a video based on the subject uploaded through this parameter. */
  subject_reference?: MinimaxVideoGenerationRequestSubjectReferenceItem[];
}

/**
 * Response from the Minimax video generation API.
 */
export interface MinimaxVideoGenerationResponse {
  base_resp: MinimaxBaseResponse;
  /** The task ID for the asynchronous video generation task. */
  task_id: string;
}

export type MoonvalleyImageToVideoRequestKeyframes = {[key: string]: {
  image_url?: string;
}};

export interface MoonvalleyTextToVideoInferenceParams {
  /** Guidance scale for generation control */
  guidance_scale?: number;
  /** Height of the generated video in pixels */
  height?: number;
  /** Negative prompt text */
  negative_prompt?: string;
  /** Random seed for generation (default: random) */
  seed?: number;
  /** Number of denoising steps */
  steps?: number;
  /** Whether to use negative prompts */
  use_negative_prompts?: boolean;
  /** Width of the generated video in pixels */
  width?: number;
}

export interface MoonvalleyTextToVideoRequest {
  image_url?: string;
  inference_params?: MoonvalleyTextToVideoInferenceParams;
  prompt_text?: string;
  webhook_url?: string;
}

export type MoonvalleyImageToVideoRequest = MoonvalleyTextToVideoRequest & {
  keyframes?: MoonvalleyImageToVideoRequestKeyframes;
};

export type MoonvalleyPromptResponseError = { [key: string]: unknown };

export type MoonvalleyPromptResponseFrameConditioning = { [key: string]: unknown };

export type MoonvalleyPromptResponseInferenceParams = { [key: string]: unknown };

export type MoonvalleyPromptResponseMeta = { [key: string]: unknown };

export type MoonvalleyPromptResponseModelParams = { [key: string]: unknown };

export interface MoonvalleyPromptResponse {
  error?: MoonvalleyPromptResponseError;
  frame_conditioning?: MoonvalleyPromptResponseFrameConditioning;
  id?: string;
  inference_params?: MoonvalleyPromptResponseInferenceParams;
  meta?: MoonvalleyPromptResponseMeta;
  model_params?: MoonvalleyPromptResponseModelParams;
  output_url?: string;
  prompt_text?: string;
  status?: string;
}

/**
 * Supported types for video control
 */
export type MoonvalleyVideoToVideoRequestControlType = typeof MoonvalleyVideoToVideoRequestControlType[keyof typeof MoonvalleyVideoToVideoRequestControlType];


export const MoonvalleyVideoToVideoRequestControlType = {
  motion_control: 'motion_control',
  pose_control: 'pose_control',
} as const;

export type MoonvalleyVideoToVideoInferenceParamsControlParams = {
  /** Intensity of motion control */
  motion_intensity?: number;
};

export interface MoonvalleyVideoToVideoInferenceParams {
  control_params?: MoonvalleyVideoToVideoInferenceParamsControlParams;
  /** Guidance scale for generation control */
  guidance_scale?: number;
  /** Negative prompt text */
  negative_prompt?: string;
  /** Random seed for generation (default: random) */
  seed?: number;
  /** Number of denoising steps */
  steps?: number;
  /** Whether to use negative prompts */
  use_negative_prompts?: boolean;
}

export interface MoonvalleyVideoToVideoRequest {
  /** Supported types for video control */
  control_type: MoonvalleyVideoToVideoRequestControlType;
  /** Url to control image */
  image_url?: string;
  inference_params?: MoonvalleyVideoToVideoInferenceParams;
  /** Describes the video to generate */
  prompt_text: string;
  /** Url to control video */
  video_url: string;
  /** Optional webhook URL for notifications */
  webhook_url?: string;
}

export type MoonvalleyResizeVideoRequest = MoonvalleyVideoToVideoRequest & {
  /**
   * @minItems 2
   * @maxItems 2
   */
  frame_position?: number[];
  /**
   * @minItems 2
   * @maxItems 2
   */
  frame_resolution?: number[];
  /**
   * @minItems 2
   * @maxItems 2
   */
  scale?: number[];
};

export interface MoonvalleyTextToImageRequest {
  image_url?: string;
  inference_params?: MoonvalleyTextToVideoInferenceParams;
  prompt_text?: string;
  webhook_url?: string;
}

export interface MoonvalleyUploadFileRequest {
  file?: string;
}

export interface MoonvalleyUploadFileResponse {
  access_url?: string;
}

/**
 * Translations of node metadata in different languages.
 */
export type NodeTranslations = {[key: string]: { [key: string]: unknown }};

export interface PublisherUser {
  /** The email address for this user. */
  email?: string;
  /** The unique id for this user. */
  id?: string;
  /** The name for this user. */
  name?: string;
}

export interface PublisherMember {
  /** The unique identifier for the publisher member. */
  id?: string;
  /** The role of the user in the publisher. */
  role?: string;
  user?: PublisherUser;
}

export type PublisherStatus = typeof PublisherStatus[keyof typeof PublisherStatus];


export const PublisherStatus = {
  PublisherStatusActive: 'PublisherStatusActive',
  PublisherStatusBanned: 'PublisherStatusBanned',
} as const;

export interface Publisher {
  /** The date and time the publisher was created. */
  createdAt?: string;
  description?: string;
  /** The unique identifier for the publisher. It's akin to a username. Should be lowercase. */
  id?: string;
  /** URL to the publisher's logo. */
  logo?: string;
  /** A list of members in the publisher. */
  members?: PublisherMember[];
  name?: string;
  source_code_repo?: string;
  status?: PublisherStatus;
  support?: string;
  website?: string;
}

export type NodeStatus = typeof NodeStatus[keyof typeof NodeStatus];


export const NodeStatus = {
  NodeStatusActive: 'NodeStatusActive',
  NodeStatusDeleted: 'NodeStatusDeleted',
  NodeStatusBanned: 'NodeStatusBanned',
} as const;

export interface Node {
  author?: string;
  /** URL to the node's banner. */
  banner_url?: string;
  /**
   * DEPRECATED: The category of the node. Use 'tags' field instead. This field will be removed in a future version.
   * @deprecated
   */
  category?: string;
  /** The date and time when the node was created */
  created_at?: string;
  description?: string;
  /** The number of downloads of the node. */
  downloads?: number;
  /** Number of stars on the GitHub repository. */
  github_stars?: number;
  /** URL to the node's icon. */
  icon?: string;
  /** The unique identifier of the node. */
  id?: string;
  latest_version?: NodeVersion;
  /** The path to the LICENSE file in the node's repository. */
  license?: string;
  /** The display name of the node. */
  name?: string;
  /** A list of Comfy node names that are preempted by this node. */
  preempted_comfy_node_names?: string[];
  publisher?: Publisher;
  /** The average rating of the node. */
  rating?: number;
  /** URL to the node's repository. */
  repository?: string;
  /** A numerical value representing the node's search ranking, used for sorting search results. */
  search_ranking?: number;
  status?: NodeStatus;
  /** The status detail of the node. */
  status_detail?: string;
  /** List of accelerators (e.g. CUDA, DirectML, ROCm) that this node supports */
  supported_accelerators?: string[];
  /** Supported versions of ComfyUI frontend */
  supported_comfyui_frontend_version?: string;
  /** Supported versions of ComfyUI */
  supported_comfyui_version?: string;
  /** List of operating systems that this node supports */
  supported_os?: string[];
  tags?: string[];
  /** Admin-only tags for security warnings and admin metadata */
  tags_admin?: string[];
  /** Translations of node metadata in different languages. */
  translations?: NodeTranslations;
}

export interface NodeVersionUpdateRequest {
  /** The changelog describing the version changes. */
  changelog?: string;
  /** Whether the version is deprecated. */
  deprecated?: boolean;
}

export type OpenAIModels = typeof OpenAIModels[keyof typeof OpenAIModels];


export const OpenAIModels = {
  'gpt-4': 'gpt-4',
  'gpt-4-0314': 'gpt-4-0314',
  'gpt-4-0613': 'gpt-4-0613',
  'gpt-4-32k': 'gpt-4-32k',
  'gpt-4-32k-0314': 'gpt-4-32k-0314',
  'gpt-4-32k-0613': 'gpt-4-32k-0613',
  'gpt-4-0125-preview': 'gpt-4-0125-preview',
  'gpt-4-turbo': 'gpt-4-turbo',
  'gpt-4-turbo-2024-04-09': 'gpt-4-turbo-2024-04-09',
  'gpt-4-turbo-preview': 'gpt-4-turbo-preview',
  'gpt-4-1106-preview': 'gpt-4-1106-preview',
  'gpt-4-vision-preview': 'gpt-4-vision-preview',
  'gpt-35-turbo': 'gpt-3.5-turbo',
  'gpt-35-turbo-16k': 'gpt-3.5-turbo-16k',
  'gpt-35-turbo-0301': 'gpt-3.5-turbo-0301',
  'gpt-35-turbo-0613': 'gpt-3.5-turbo-0613',
  'gpt-35-turbo-1106': 'gpt-3.5-turbo-1106',
  'gpt-35-turbo-0125': 'gpt-3.5-turbo-0125',
  'gpt-35-turbo-16k-0613': 'gpt-3.5-turbo-16k-0613',
  'gpt-41': 'gpt-4.1',
  'gpt-41-mini': 'gpt-4.1-mini',
  'gpt-41-nano': 'gpt-4.1-nano',
  'gpt-41-2025-04-14': 'gpt-4.1-2025-04-14',
  'gpt-41-mini-2025-04-14': 'gpt-4.1-mini-2025-04-14',
  'gpt-41-nano-2025-04-14': 'gpt-4.1-nano-2025-04-14',
  o1: 'o1',
  'o1-mini': 'o1-mini',
  'o1-preview': 'o1-preview',
  'o1-pro': 'o1-pro',
  'o1-2024-12-17': 'o1-2024-12-17',
  'o1-preview-2024-09-12': 'o1-preview-2024-09-12',
  'o1-mini-2024-09-12': 'o1-mini-2024-09-12',
  'o1-pro-2025-03-19': 'o1-pro-2025-03-19',
  o3: 'o3',
  'o3-mini': 'o3-mini',
  'o3-2025-04-16': 'o3-2025-04-16',
  'o3-mini-2025-01-31': 'o3-mini-2025-01-31',
  'o4-mini': 'o4-mini',
  'o4-mini-2025-04-16': 'o4-mini-2025-04-16',
  'gpt-4o': 'gpt-4o',
  'gpt-4o-mini': 'gpt-4o-mini',
  'gpt-4o-2024-11-20': 'gpt-4o-2024-11-20',
  'gpt-4o-2024-08-06': 'gpt-4o-2024-08-06',
  'gpt-4o-2024-05-13': 'gpt-4o-2024-05-13',
  'gpt-4o-mini-2024-07-18': 'gpt-4o-mini-2024-07-18',
  'gpt-4o-audio-preview': 'gpt-4o-audio-preview',
  'gpt-4o-audio-preview-2024-10-01': 'gpt-4o-audio-preview-2024-10-01',
  'gpt-4o-audio-preview-2024-12-17': 'gpt-4o-audio-preview-2024-12-17',
  'gpt-4o-mini-audio-preview': 'gpt-4o-mini-audio-preview',
  'gpt-4o-mini-audio-preview-2024-12-17': 'gpt-4o-mini-audio-preview-2024-12-17',
  'gpt-4o-search-preview': 'gpt-4o-search-preview',
  'gpt-4o-mini-search-preview': 'gpt-4o-mini-search-preview',
  'gpt-4o-search-preview-2025-03-11': 'gpt-4o-search-preview-2025-03-11',
  'gpt-4o-mini-search-preview-2025-03-11': 'gpt-4o-mini-search-preview-2025-03-11',
  'computer-use-preview': 'computer-use-preview',
  'computer-use-preview-2025-03-11': 'computer-use-preview-2025-03-11',
  'gpt-5': 'gpt-5',
  'gpt-5-mini': 'gpt-5-mini',
  'gpt-5-nano': 'gpt-5-nano',
  'chatgpt-4o-latest': 'chatgpt-4o-latest',
} as const;

/**
 * **o-series models only**

Constrains effort on reasoning for
[reasoning models](https://platform.openai.com/docs/guides/reasoning).
Currently supported values are `low`, `medium`, and `high`. Reducing
reasoning effort can result in faster responses and fewer tokens used
on reasoning in a response.

 */
export type ReasoningEffort = typeof ReasoningEffort[keyof typeof ReasoningEffort];


export const ReasoningEffort = {
  low: 'low',
  medium: 'medium',
  high: 'high',
} as const;

/**
 * **Deprecated:** use `summary` instead.

A summary of the reasoning performed by the model. This can be
useful for debugging and understanding the model's reasoning process.
One of `auto`, `concise`, or `detailed`.

 * @deprecated
 */
export type ReasoningGenerateSummary = typeof ReasoningGenerateSummary[keyof typeof ReasoningGenerateSummary];


export const ReasoningGenerateSummary = {
  auto: 'auto',
  concise: 'concise',
  detailed: 'detailed',
} as const;

/**
 * A summary of the reasoning performed by the model. This can be
useful for debugging and understanding the model's reasoning process.
One of `auto`, `concise`, or `detailed`.

 */
export type ReasoningSummary = typeof ReasoningSummary[keyof typeof ReasoningSummary];


export const ReasoningSummary = {
  auto: 'auto',
  concise: 'concise',
  detailed: 'detailed',
} as const;

/**
 * **o-series models only**

Configuration options for
[reasoning models](https://platform.openai.com/docs/guides/reasoning).

 */
export interface Reasoning {
  effort?: ReasoningEffort;
  /**
   * **Deprecated:** use `summary` instead.

A summary of the reasoning performed by the model. This can be
useful for debugging and understanding the model's reasoning process.
One of `auto`, `concise`, or `detailed`.

   * @deprecated
   */
  generate_summary?: ReasoningGenerateSummary;
  /** A summary of the reasoning performed by the model. This can be
useful for debugging and understanding the model's reasoning process.
One of `auto`, `concise`, or `detailed`.
 */
  summary?: ReasoningSummary;
}

/**
 * The type of response format being defined. Always `text`.
 */
export type ResponseFormatTextType = typeof ResponseFormatTextType[keyof typeof ResponseFormatTextType];


export const ResponseFormatTextType = {
  text: 'text',
} as const;

/**
 * Default response format. Used to generate text responses.

 */
export interface ResponseFormatText {
  /** The type of response format being defined. Always `text`. */
  type: ResponseFormatTextType;
}

/**
 * The schema for the response format, described as a JSON Schema object.
Learn how to build JSON schemas [here](https://json-schema.org/).

 */
export interface ResponseFormatJsonSchemaSchema { [key: string]: unknown }

/**
 * The type of response format being defined. Always `json_schema`.
 */
export type TextResponseFormatJsonSchemaType = typeof TextResponseFormatJsonSchemaType[keyof typeof TextResponseFormatJsonSchemaType];


export const TextResponseFormatJsonSchemaType = {
  json_schema: 'json_schema',
} as const;

/**
 * JSON Schema response format. Used to generate structured JSON responses.
Learn more about [Structured Outputs](/docs/guides/structured-outputs).

 */
export interface TextResponseFormatJsonSchema {
  /** A description of what the response format is for, used by the model to
determine how to respond in the format.
 */
  description?: string;
  /** The name of the response format. Must be a-z, A-Z, 0-9, or contain
underscores and dashes, with a maximum length of 64.
 */
  name: string;
  schema: ResponseFormatJsonSchemaSchema;
  /** Whether to enable strict schema adherence when generating the output.
If set to true, the model will always follow the exact schema defined
in the `schema` field. Only a subset of JSON Schema is supported when
`strict` is `true`. To learn more, read the [Structured Outputs
guide](/docs/guides/structured-outputs).
 */
  strict?: boolean;
  /** The type of response format being defined. Always `json_schema`. */
  type: TextResponseFormatJsonSchemaType;
}

/**
 * The type of response format being defined. Always `json_object`.
 */
export type ResponseFormatJsonObjectType = typeof ResponseFormatJsonObjectType[keyof typeof ResponseFormatJsonObjectType];


export const ResponseFormatJsonObjectType = {
  json_object: 'json_object',
} as const;

/**
 * JSON object response format. An older method of generating JSON responses.
Using `json_schema` is recommended for models that support it. Note that the
model will not generate JSON without a system or user message instructing it
to do so.

 */
export interface ResponseFormatJsonObject {
  /** The type of response format being defined. Always `json_object`. */
  type: ResponseFormatJsonObjectType;
}

/**
 * An object specifying the format that the model must output.

Configuring `{ "type": "json_schema" }` enables Structured Outputs,
which ensures the model will match your supplied JSON schema. Learn more in the
[Structured Outputs guide](/docs/guides/structured-outputs).

The default format is `{ "type": "text" }` with no additional options.

**Not recommended for gpt-4o and newer models:**

Setting to `{ "type": "json_object" }` enables the older JSON mode, which
ensures the message the model generates is valid JSON. Using `json_schema`
is preferred for models that support it.

 */
export type TextResponseFormatConfiguration = ResponseFormatText | TextResponseFormatJsonSchema | ResponseFormatJsonObject;

/**
 * Controls which (if any) tool is called by the model.

`none` means the model will not call any tool and instead generates a message.

`auto` means the model can pick between generating a message or calling one or
more tools.

`required` means the model must call one or more tools.

 */
export type ToolChoiceOptions = typeof ToolChoiceOptions[keyof typeof ToolChoiceOptions];


export const ToolChoiceOptions = {
  none: 'none',
  auto: 'auto',
  required: 'required',
} as const;

/**
 * The type of hosted tool the model should to use. Learn more about
[built-in tools](/docs/guides/tools).

Allowed values are:
- `file_search`
- `web_search_preview`
- `computer_use_preview`

 */
export type ToolChoiceTypesType = typeof ToolChoiceTypesType[keyof typeof ToolChoiceTypesType];


export const ToolChoiceTypesType = {
  file_search: 'file_search',
  web_search_preview: 'web_search_preview',
  computer_use_preview: 'computer_use_preview',
  web_search_preview_2025_03_11: 'web_search_preview_2025_03_11',
} as const;

/**
 * Indicates that the model should use a built-in tool to generate a response.
[Learn more about built-in tools](/docs/guides/tools).

 */
export interface ToolChoiceTypes {
  /** The type of hosted tool the model should to use. Learn more about
[built-in tools](/docs/guides/tools).

Allowed values are:
- `file_search`
- `web_search_preview`
- `computer_use_preview`
 */
  type: ToolChoiceTypesType;
}

/**
 * For function calling, the type is always `function`.
 */
export type ToolChoiceFunctionType = typeof ToolChoiceFunctionType[keyof typeof ToolChoiceFunctionType];


export const ToolChoiceFunctionType = {
  function: 'function',
} as const;

/**
 * Use this option to force the model to call a specific function.

 */
export interface ToolChoiceFunction {
  /** The name of the function to call. */
  name: string;
  /** For function calling, the type is always `function`. */
  type: ToolChoiceFunctionType;
}

/**
 * High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default.
 */
export type WebSearchPreviewToolSearchContextSize = typeof WebSearchPreviewToolSearchContextSize[keyof typeof WebSearchPreviewToolSearchContextSize];


export const WebSearchPreviewToolSearchContextSize = {
  low: 'low',
  medium: 'medium',
  high: 'high',
} as const;

/**
 * The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`.
 */
export type WebSearchPreviewToolType = typeof WebSearchPreviewToolType[keyof typeof WebSearchPreviewToolType];


export const WebSearchPreviewToolType = {
  web_search_preview: 'web_search_preview',
  web_search_preview_2025_03_11: 'web_search_preview_2025_03_11',
} as const;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search).
 */
export interface WebSearchPreviewTool {
  /** High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default. */
  search_context_size?: WebSearchPreviewToolSearchContextSize;
  /** The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`. */
  type: WebSearchPreviewToolType;
}

export type Tool = FileSearchTool | FunctionTool | WebSearchPreviewTool | ComputerUsePreviewTool;

/**
 * The truncation strategy to use for the model response.
- `auto`: If the context of this response and previous ones exceeds
  the model's context window size, the model will truncate the
  response to fit the context window by dropping input items in the
  middle of the conversation.
- `disabled` (default): If a model response will exceed the context window
  size for a model, the request will fail with a 400 error.

 */
export type ResponsePropertiesTruncation = typeof ResponsePropertiesTruncation[keyof typeof ResponsePropertiesTruncation];


export const ResponsePropertiesTruncation = {
  auto: 'auto',
  disabled: 'disabled',
} as const;

export type ResponsePropertiesText = {
  format?: TextResponseFormatConfiguration;
};

export interface ResponseProperties {
  /** Inserts a system (or developer) message as the first item in the model's context.

When using along with `previous_response_id`, the instructions from a previous
response will not be carried over to the next response. This makes it simple
to swap out system (or developer) messages in new responses.
 */
  instructions?: string;
  /** An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).
 */
  max_output_tokens?: number;
  model?: OpenAIModels;
  /** The unique ID of the previous response to the model. Use this to
create multi-turn conversations. Learn more about
[conversation state](/docs/guides/conversation-state).
 */
  previous_response_id?: string;
  reasoning?: Reasoning;
  text?: ResponsePropertiesText;
  /** How the model should select which tool (or tools) to use when generating
a response. See the `tools` parameter to see how to specify which tools
the model can call.
 */
  tool_choice?: ToolChoiceOptions | ToolChoiceTypes | ToolChoiceFunction;
  tools?: Tool[];
  /** The truncation strategy to use for the model response.
- `auto`: If the context of this response and previous ones exceeds
  the model's context window size, the model will truncate the
  response to fit the context window by dropping input items in the
  middle of the conversation.
- `disabled` (default): If a model response will exceed the context window
  size for a model, the request will fail with a 400 error.
 */
  truncation?: ResponsePropertiesTruncation;
}

/**
 * A detailed breakdown of the input tokens.
 */
export type ResponseUsageInputTokensDetails = {
  /** The number of tokens that were retrieved from the cache.
[More on prompt caching](/docs/guides/prompt-caching).
 */
  cached_tokens: number;
};

/**
 * A detailed breakdown of the output tokens.
 */
export type ResponseUsageOutputTokensDetails = {
  /** The number of reasoning tokens. */
  reasoning_tokens: number;
};

/**
 * Represents token usage details including input tokens, output tokens,
a breakdown of output tokens, and the total tokens used.

 */
export interface ResponseUsage {
  /** The number of input tokens. */
  input_tokens: number;
  /** A detailed breakdown of the input tokens. */
  input_tokens_details: ResponseUsageInputTokensDetails;
  /** The number of output tokens. */
  output_tokens: number;
  /** A detailed breakdown of the output tokens. */
  output_tokens_details: ResponseUsageOutputTokensDetails;
  /** The total number of tokens used. */
  total_tokens: number;
}

export type OpenAICreateResponse = CreateModelResponseProperties & ResponseProperties & ({
  /**
   * Specify additional output data to include in the model response. Currently
supported values are:
- `file_search_call.results`: Include the search results of
  the file search tool call.
- `message.input_image.image_url`: Include image urls from the input message.
- `computer_call_output.output.image_url`: Include image urls from the computer call output.

   * @nullable
   */
  include?: Includable[] | null;
  /** Text, image, or file inputs to the model, used to generate a response.

Learn more:
- [Text inputs and outputs](/docs/guides/text)
- [Image inputs](/docs/guides/images)
- [File inputs](/docs/guides/pdf-files)
- [Conversation state](/docs/guides/conversation-state)
- [Function calling](/docs/guides/function-calling)
 */
  input: string | InputItem[];
  /**
   * Whether to allow the model to run tool calls in parallel.

   * @nullable
   */
  parallel_tool_calls?: boolean | null;
  /**
   * Whether to store the generated model response for later retrieval via
API.

   * @nullable
   */
  store?: boolean | null;
  /**
   * If set to true, the model response data will be streamed to the client
as it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).
See the [Streaming section below](/docs/api-reference/responses-streaming)
for more information.

   * @nullable
   */
  stream?: boolean | null;
  usage?: ResponseUsage;
});

/**
 * Content moderation setting
 */
export type OpenAIImageEditRequestModeration = typeof OpenAIImageEditRequestModeration[keyof typeof OpenAIImageEditRequestModeration];


export const OpenAIImageEditRequestModeration = {
  low: 'low',
  auto: 'auto',
} as const;

/**
 * Format of the output image
 */
export type OpenAIImageEditRequestOutputFormat = typeof OpenAIImageEditRequestOutputFormat[keyof typeof OpenAIImageEditRequestOutputFormat];


export const OpenAIImageEditRequestOutputFormat = {
  png: 'png',
  webp: 'webp',
  jpeg: 'jpeg',
} as const;

export interface OpenAIImageEditRequest {
  /** Background transparency */
  background?: string;
  /** The model to use for image editing */
  model: string;
  /** Content moderation setting */
  moderation?: OpenAIImageEditRequestModeration;
  /** The number of images to generate */
  n?: number;
  /** Compression level for JPEG or WebP (0-100) */
  output_compression?: number;
  /** Format of the output image */
  output_format?: OpenAIImageEditRequestOutputFormat;
  /** A text description of the desired edit */
  prompt: string;
  /** The quality of the edited image */
  quality?: string;
  /** Size of the output image */
  size?: string;
  /** A unique identifier for end-user monitoring */
  user?: string;
}

/**
 * Background transparency
 */
export type OpenAIImageGenerationRequestBackground = typeof OpenAIImageGenerationRequestBackground[keyof typeof OpenAIImageGenerationRequestBackground];


export const OpenAIImageGenerationRequestBackground = {
  transparent: 'transparent',
  opaque: 'opaque',
} as const;

/**
 * Content moderation setting
 */
export type OpenAIImageGenerationRequestModeration = typeof OpenAIImageGenerationRequestModeration[keyof typeof OpenAIImageGenerationRequestModeration];


export const OpenAIImageGenerationRequestModeration = {
  low: 'low',
  auto: 'auto',
} as const;

/**
 * Format of the output image
 */
export type OpenAIImageGenerationRequestOutputFormat = typeof OpenAIImageGenerationRequestOutputFormat[keyof typeof OpenAIImageGenerationRequestOutputFormat];


export const OpenAIImageGenerationRequestOutputFormat = {
  png: 'png',
  webp: 'webp',
  jpeg: 'jpeg',
} as const;

/**
 * The quality of the generated image
 */
export type OpenAIImageGenerationRequestQuality = typeof OpenAIImageGenerationRequestQuality[keyof typeof OpenAIImageGenerationRequestQuality];


export const OpenAIImageGenerationRequestQuality = {
  low: 'low',
  medium: 'medium',
  high: 'high',
  standard: 'standard',
  hd: 'hd',
} as const;

/**
 * Response format of image data
 */
export type OpenAIImageGenerationRequestResponseFormat = typeof OpenAIImageGenerationRequestResponseFormat[keyof typeof OpenAIImageGenerationRequestResponseFormat];


export const OpenAIImageGenerationRequestResponseFormat = {
  url: 'url',
  b64_json: 'b64_json',
} as const;

/**
 * Style of the image (only for dall-e-3)
 */
export type OpenAIImageGenerationRequestStyle = typeof OpenAIImageGenerationRequestStyle[keyof typeof OpenAIImageGenerationRequestStyle];


export const OpenAIImageGenerationRequestStyle = {
  vivid: 'vivid',
  natural: 'natural',
} as const;

export interface OpenAIImageGenerationRequest {
  /** Background transparency */
  background?: OpenAIImageGenerationRequestBackground;
  /** The model to use for image generation */
  model?: string;
  /** Content moderation setting */
  moderation?: OpenAIImageGenerationRequestModeration;
  /** The number of images to generate (1-10). Only 1 supported for dall-e-3. */
  n?: number;
  /** Compression level for JPEG or WebP (0-100) */
  output_compression?: number;
  /** Format of the output image */
  output_format?: OpenAIImageGenerationRequestOutputFormat;
  /** A text description of the desired image */
  prompt: string;
  /** The quality of the generated image */
  quality?: OpenAIImageGenerationRequestQuality;
  /** Response format of image data */
  response_format?: OpenAIImageGenerationRequestResponseFormat;
  /** Size of the image (e.g., 1024x1024, 1536x1024, auto) */
  size?: string;
  /** Style of the image (only for dall-e-3) */
  style?: OpenAIImageGenerationRequestStyle;
  /** A unique identifier for end-user monitoring */
  user?: string;
}

export type OpenAIImageGenerationResponseDataItem = {
  /** Base64 encoded image data */
  b64_json?: string;
  /** Revised prompt */
  revised_prompt?: string;
  /** URL of the image */
  url?: string;
};

export type OpenAIImageGenerationResponseUsageInputTokensDetails = {
  image_tokens?: number;
  text_tokens?: number;
};

export type OpenAIImageGenerationResponseUsageOutputTokensDetails = {
  image_tokens?: number;
  text_tokens?: number;
};

export type OpenAIImageGenerationResponseUsage = {
  input_tokens?: number;
  input_tokens_details?: OpenAIImageGenerationResponseUsageInputTokensDetails;
  output_tokens?: number;
  output_tokens_details?: OpenAIImageGenerationResponseUsageOutputTokensDetails;
  total_tokens?: number;
};

export interface OpenAIImageGenerationResponse {
  data?: OpenAIImageGenerationResponseDataItem[];
  usage?: OpenAIImageGenerationResponseUsage;
}

/**
 * Details about why the response is incomplete.

 * @nullable
 */
export type OpenAIResponseIncompleteDetails = {
  /** The reason why the response is incomplete. */
  reason?: 'max_output_tokens' | 'content_filter';
} | null;

/**
 * The object type of this resource - always set to `response`.
 */
export type OpenAIResponseObject = typeof OpenAIResponseObject[keyof typeof OpenAIResponseObject];


export const OpenAIResponseObject = {
  response: 'response',
} as const;

/**
 * The status of the response generation. One of `completed`, `failed`, `in_progress`, or `incomplete`.
 */
export type OpenAIResponseStatus = typeof OpenAIResponseStatus[keyof typeof OpenAIResponseStatus];


export const OpenAIResponseStatus = {
  completed: 'completed',
  failed: 'failed',
  in_progress: 'in_progress',
  incomplete: 'incomplete',
} as const;

/**
 * The error code for the response.
 */
export type ResponseErrorCode = typeof ResponseErrorCode[keyof typeof ResponseErrorCode];


export const ResponseErrorCode = {
  server_error: 'server_error',
  rate_limit_exceeded: 'rate_limit_exceeded',
  invalid_prompt: 'invalid_prompt',
  vector_store_timeout: 'vector_store_timeout',
  invalid_image: 'invalid_image',
  invalid_image_format: 'invalid_image_format',
  invalid_base64_image: 'invalid_base64_image',
  invalid_image_url: 'invalid_image_url',
  image_too_large: 'image_too_large',
  image_too_small: 'image_too_small',
  image_parse_error: 'image_parse_error',
  image_content_policy_violation: 'image_content_policy_violation',
  invalid_image_mode: 'invalid_image_mode',
  image_file_too_large: 'image_file_too_large',
  unsupported_image_media_type: 'unsupported_image_media_type',
  empty_image_file: 'empty_image_file',
  failed_to_download_image: 'failed_to_download_image',
  image_file_not_found: 'image_file_not_found',
} as const;

/**
 * An error object returned when the model fails to generate a Response.
 */
export interface ResponseError {
  code: ResponseErrorCode;
  /** A human-readable description of the error. */
  message: string;
}

export type OutputItem = OutputMessage | FileSearchToolCall | FunctionToolCall | WebSearchToolCall | ComputerToolCall | ReasoningItem;

/**
 * A response from the model
 */
export type OpenAIResponse = ModelResponseProperties & ResponseProperties & ({
  /** Unix timestamp (in seconds) of when this Response was created. */
  created_at?: number;
  error?: ResponseError;
  /** Unique identifier for this Response. */
  id?: string;
  /**
   * Details about why the response is incomplete.

   * @nullable
   */
  incomplete_details?: OpenAIResponseIncompleteDetails;
  /** The object type of this resource - always set to `response`. */
  object?: OpenAIResponseObject;
  /** An array of content items generated by the model.

- The length and order of items in the `output` array is dependent
  on the model's response.
- Rather than accessing the first item in the `output` array and
  assuming it's an `assistant` message with the content generated by
  the model, you might consider using the `output_text` property where
  supported in SDKs.
 */
  output?: OutputItem[];
  /**
   * SDK-only convenience property that contains the aggregated text output
from all `output_text` items in the `output` array, if any are present.
Supported in the Python and JavaScript SDKs.

   * @nullable
   */
  output_text?: string | null;
  /** Whether to allow the model to run tool calls in parallel.
 */
  parallel_tool_calls?: boolean;
  /** The status of the response generation. One of `completed`, `failed`, `in_progress`, or `incomplete`. */
  status?: OpenAIResponseStatus;
  usage?: ResponseUsage;
});

/**
 * The type of the event. Always `response.created`.
 */
export type ResponseCreatedEventType = typeof ResponseCreatedEventType[keyof typeof ResponseCreatedEventType];


export const ResponseCreatedEventType = {
  responsecreated: 'response.created',
} as const;

/**
 * An event that is emitted when a response is created.
 */
export interface ResponseCreatedEvent {
  response: OpenAIResponse;
  /** The type of the event. Always `response.created`. */
  type: ResponseCreatedEventType;
}

/**
 * The type of the event. Always `response.in_progress`.

 */
export type ResponseInProgressEventType = typeof ResponseInProgressEventType[keyof typeof ResponseInProgressEventType];


export const ResponseInProgressEventType = {
  responsein_progress: 'response.in_progress',
} as const;

/**
 * Emitted when the response is in progress.
 */
export interface ResponseInProgressEvent {
  response: OpenAIResponse;
  /** The type of the event. Always `response.in_progress`.
 */
  type: ResponseInProgressEventType;
}

/**
 * The type of the event. Always `response.completed`.
 */
export type ResponseCompletedEventType = typeof ResponseCompletedEventType[keyof typeof ResponseCompletedEventType];


export const ResponseCompletedEventType = {
  responsecompleted: 'response.completed',
} as const;

/**
 * Emitted when the model response is complete.
 */
export interface ResponseCompletedEvent {
  response: OpenAIResponse;
  /** The type of the event. Always `response.completed`. */
  type: ResponseCompletedEventType;
}

/**
 * The type of the event. Always `response.failed`.

 */
export type ResponseFailedEventType = typeof ResponseFailedEventType[keyof typeof ResponseFailedEventType];


export const ResponseFailedEventType = {
  responsefailed: 'response.failed',
} as const;

/**
 * An event that is emitted when a response fails.

 */
export interface ResponseFailedEvent {
  response: OpenAIResponse;
  /** The type of the event. Always `response.failed`.
 */
  type: ResponseFailedEventType;
}

/**
 * The type of the event. Always `response.incomplete`.

 */
export type ResponseIncompleteEventType = typeof ResponseIncompleteEventType[keyof typeof ResponseIncompleteEventType];


export const ResponseIncompleteEventType = {
  responseincomplete: 'response.incomplete',
} as const;

/**
 * An event that is emitted when a response finishes as incomplete.

 */
export interface ResponseIncompleteEvent {
  response: OpenAIResponse;
  /** The type of the event. Always `response.incomplete`.
 */
  type: ResponseIncompleteEventType;
}

/**
 * The type of the event. Always `response.output_item.added`.

 */
export type ResponseOutputItemAddedEventType = typeof ResponseOutputItemAddedEventType[keyof typeof ResponseOutputItemAddedEventType];


export const ResponseOutputItemAddedEventType = {
  responseoutput_itemadded: 'response.output_item.added',
} as const;

/**
 * Emitted when a new output item is added.
 */
export interface ResponseOutputItemAddedEvent {
  item: OutputItem;
  /** The index of the output item that was added.
 */
  output_index: number;
  /** The type of the event. Always `response.output_item.added`.
 */
  type: ResponseOutputItemAddedEventType;
}

/**
 * The type of the event. Always `response.output_item.done`.

 */
export type ResponseOutputItemDoneEventType = typeof ResponseOutputItemDoneEventType[keyof typeof ResponseOutputItemDoneEventType];


export const ResponseOutputItemDoneEventType = {
  responseoutput_itemdone: 'response.output_item.done',
} as const;

/**
 * Emitted when an output item is marked done.
 */
export interface ResponseOutputItemDoneEvent {
  item: OutputItem;
  /** The index of the output item that was marked done.
 */
  output_index: number;
  /** The type of the event. Always `response.output_item.done`.
 */
  type: ResponseOutputItemDoneEventType;
}

/**
 * The type of the event. Always `response.content_part.added`.
 */
export type ResponseContentPartAddedEventType = typeof ResponseContentPartAddedEventType[keyof typeof ResponseContentPartAddedEventType];


export const ResponseContentPartAddedEventType = {
  responsecontent_partadded: 'response.content_part.added',
} as const;

/**
 * Emitted when a new content part is added.
 */
export interface ResponseContentPartAddedEvent {
  /** The index of the content part that was added. */
  content_index: number;
  /** The ID of the output item that the content part was added to. */
  item_id: string;
  /** The index of the output item that the content part was added to. */
  output_index: number;
  part: OutputContent;
  /** The type of the event. Always `response.content_part.added`. */
  type: ResponseContentPartAddedEventType;
}

/**
 * The type of the event. Always `response.content_part.done`.
 */
export type ResponseContentPartDoneEventType = typeof ResponseContentPartDoneEventType[keyof typeof ResponseContentPartDoneEventType];


export const ResponseContentPartDoneEventType = {
  responsecontent_partdone: 'response.content_part.done',
} as const;

/**
 * Emitted when a content part is done.
 */
export interface ResponseContentPartDoneEvent {
  /** The index of the content part that is done. */
  content_index: number;
  /** The ID of the output item that the content part was added to. */
  item_id: string;
  /** The index of the output item that the content part was added to. */
  output_index: number;
  part: OutputContent;
  /** The type of the event. Always `response.content_part.done`. */
  type: ResponseContentPartDoneEventType;
}

/**
 * The type of the event. Always `error`.

 */
export type ResponseErrorEventType = typeof ResponseErrorEventType[keyof typeof ResponseErrorEventType];


export const ResponseErrorEventType = {
  error: 'error',
} as const;

/**
 * Emitted when an error occurs.
 */
export interface ResponseErrorEvent {
  /** The error code.
 */
  code: string;
  /** The error message.
 */
  message: string;
  /** The error parameter.
 */
  param: string;
  /** The type of the event. Always `error`.
 */
  type: ResponseErrorEventType;
}

/**
 * Events that can be emitted during response streaming
 */
export type OpenAIResponseStreamEvent = ResponseCreatedEvent | ResponseInProgressEvent | ResponseCompletedEvent | ResponseFailedEvent | ResponseIncompleteEvent | ResponseOutputItemAddedEvent | ResponseOutputItemDoneEvent | ResponseContentPartAddedEvent | ResponseContentPartDoneEvent | ResponseErrorEvent;

/**
 * The video generation model to use
 */
export type OpenAIVideoCreateRequestModel = typeof OpenAIVideoCreateRequestModel[keyof typeof OpenAIVideoCreateRequestModel];


export const OpenAIVideoCreateRequestModel = {
  'sora-2': 'sora-2',
  'sora-2-pro': 'sora-2-pro',
} as const;

/**
 * Clip duration in seconds
 */
export type OpenAIVideoCreateRequestSeconds = typeof OpenAIVideoCreateRequestSeconds[keyof typeof OpenAIVideoCreateRequestSeconds];


export const OpenAIVideoCreateRequestSeconds = {
  NUMBER_4: '4',
  NUMBER_8: '8',
  NUMBER_12: '12',
} as const;

/**
 * Output resolution formatted as width x height
 */
export type OpenAIVideoCreateRequestSize = typeof OpenAIVideoCreateRequestSize[keyof typeof OpenAIVideoCreateRequestSize];


export const OpenAIVideoCreateRequestSize = {
  '720x1280': '720x1280',
  '1280x720': '1280x720',
  '1024x1792': '1024x1792',
  '1792x1024': '1792x1024',
} as const;

export interface OpenAIVideoCreateRequest {
  /** Optional image or video reference that guides generation */
  input_reference?: string;
  /** The video generation model to use */
  model?: OpenAIVideoCreateRequestModel;
  /** Text prompt that describes the video to generate */
  prompt: string;
  /** Clip duration in seconds */
  seconds?: OpenAIVideoCreateRequestSeconds;
  /** Output resolution formatted as width x height */
  size?: OpenAIVideoCreateRequestSize;
}

/**
 * Error payload that explains why generation failed, if applicable
 */
export type OpenAIVideoJobError = {
  /** Error code */
  code?: string;
  /** Human-readable error message */
  message?: string;
};

/**
 * The object type, which is always video
 */
export type OpenAIVideoJobObject = typeof OpenAIVideoJobObject[keyof typeof OpenAIVideoJobObject];


export const OpenAIVideoJobObject = {
  video: 'video',
} as const;

/**
 * Current lifecycle status of the video job
 */
export type OpenAIVideoJobStatus = typeof OpenAIVideoJobStatus[keyof typeof OpenAIVideoJobStatus];


export const OpenAIVideoJobStatus = {
  queued: 'queued',
  in_progress: 'in_progress',
  completed: 'completed',
  failed: 'failed',
} as const;

export interface OpenAIVideoJob {
  /** Unix timestamp (seconds) for when the job completed, if finished */
  completed_at?: number;
  /** Unix timestamp (seconds) for when the job was created */
  created_at?: number;
  /** Error payload that explains why generation failed, if applicable */
  error?: OpenAIVideoJobError;
  /** Unix timestamp (seconds) for when the downloadable assets expire, if set */
  expires_at?: number;
  /** Unique identifier for the video job */
  id?: string;
  /** The video generation model that produced the job */
  model?: string;
  /** The object type, which is always video */
  object?: OpenAIVideoJobObject;
  /** Approximate completion percentage for the generation task */
  progress?: number;
  /** Quality of the generated video */
  quality?: string;
  /** Identifier of the source video if this video is a remix */
  remixed_from_video_id?: string;
  /** Duration of the generated clip in seconds */
  seconds?: string;
  /** The resolution of the generated video */
  size?: string;
  /** Current lifecycle status of the video job */
  status?: OpenAIVideoJobStatus;
}

export interface PersonalAccessToken {
  /** [Output Only]The date and time the token was created. */
  createdAt?: string;
  /** Optional. A more detailed description of the token's intended use. */
  description?: string;
  /** Unique identifier for the GitCommit */
  id?: string;
  /** Required. The name of the token. Can be a simple description. */
  name?: string;
  /** [Output Only]. The personal access token. Only returned during creation. */
  token?: string;
}

export type PikaBodyGenerate22C2vGenerate22PikascenesPostIngredientsMode = typeof PikaBodyGenerate22C2vGenerate22PikascenesPostIngredientsMode[keyof typeof PikaBodyGenerate22C2vGenerate22PikascenesPostIngredientsMode];


export const PikaBodyGenerate22C2vGenerate22PikascenesPostIngredientsMode = {
  creative: 'creative',
  precise: 'precise',
} as const;

export interface PikaBodyGenerate22C2vGenerate22PikascenesPost {
  /** Aspect ratio (width / height) */
  aspectRatio?: number;
  duration?: number;
  images?: string[];
  ingredientsMode: PikaBodyGenerate22C2vGenerate22PikascenesPostIngredientsMode;
  negativePrompt?: string;
  promptText?: string;
  resolution?: string;
  seed?: number;
}

export type PikaDurationEnum = typeof PikaDurationEnum[keyof typeof PikaDurationEnum];


export const PikaDurationEnum = {
  NUMBER_5: 5,
  NUMBER_10: 10,
} as const;

export type PikaResolutionEnum = typeof PikaResolutionEnum[keyof typeof PikaResolutionEnum];


export const PikaResolutionEnum = {
  '1080p': '1080p',
  '720p': '720p',
} as const;

export interface PikaBodyGenerate22I2vGenerate22I2vPost {
  duration?: PikaDurationEnum;
  /** @nullable */
  image?: Blob | null;
  /** @nullable */
  negativePrompt?: string | null;
  /** @nullable */
  promptText?: string | null;
  resolution?: PikaResolutionEnum;
  /** @nullable */
  seed?: number | null;
}

export interface PikaBodyGenerate22KeyframeGenerate22PikaframesPost {
  /**
   * @minimum 5
   * @maximum 10
   */
  duration?: number;
  /** Array of keyframe images */
  keyFrames?: string[];
  negativePrompt?: string;
  promptText: string;
  resolution?: PikaResolutionEnum;
  seed?: number;
}

export interface PikaBodyGenerate22T2vGenerate22T2vPost {
  /**
   * Aspect ratio (width / height)
   * @minimum 0.4
   * @maximum 2.5
   */
  aspectRatio?: number;
  duration?: PikaDurationEnum;
  /** @nullable */
  negativePrompt?: string | null;
  promptText: string;
  resolution?: PikaResolutionEnum;
  /** @nullable */
  seed?: number | null;
}

export interface PikaBodyGeneratePikadditionsGeneratePikadditionsPost {
  image?: string;
  negativePrompt?: string;
  promptText?: string;
  seed?: number;
  video?: string;
}

export type Pikaffect = typeof Pikaffect[keyof typeof Pikaffect];


export const Pikaffect = {
  'Cake-ify': 'Cake-ify',
  Crumble: 'Crumble',
  Crush: 'Crush',
  Decapitate: 'Decapitate',
  Deflate: 'Deflate',
  Dissolve: 'Dissolve',
  Explode: 'Explode',
  'Eye-pop': 'Eye-pop',
  Inflate: 'Inflate',
  Levitate: 'Levitate',
  Melt: 'Melt',
  Peel: 'Peel',
  Poke: 'Poke',
  Squish: 'Squish',
  'Ta-da': 'Ta-da',
  Tear: 'Tear',
} as const;

export interface PikaBodyGeneratePikaffectsGeneratePikaffectsPost {
  image?: string;
  negativePrompt?: string;
  pikaffect?: Pikaffect;
  promptText?: string;
  seed?: number;
}

export interface PikaBodyGeneratePikaswapsGeneratePikaswapsPost {
  image?: string;
  /** A mask image that specifies the region to modify, where the mask is white and the background is black */
  modifyRegionMask?: string;
  /** Plaintext description of the object / region to modify */
  modifyRegionRoi?: string;
  negativePrompt?: string;
  promptText?: string;
  seed?: number;
  video?: string;
}

export interface PikaGenerateResponse {
  video_id: string;
}

export interface PikaValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
}

export interface PikaHTTPValidationError {
  detail?: PikaValidationError[];
}

export type PikaStatusEnum = typeof PikaStatusEnum[keyof typeof PikaStatusEnum];


export const PikaStatusEnum = {
  queued: 'queued',
  started: 'started',
  finished: 'finished',
} as const;

export interface PikaVideoResponse {
  id: string;
  /** @nullable */
  progress?: number | null;
  status: PikaStatusEnum;
  /** @nullable */
  url?: string | null;
}

export type PixverseImageUploadResponseResp = {
  img_id?: number;
};

export interface PixverseImageUploadResponse {
  ErrCode?: number;
  ErrMsg?: string;
  Resp?: PixverseImageUploadResponseResp;
}

export type PixverseImageVideoRequestDuration = typeof PixverseImageVideoRequestDuration[keyof typeof PixverseImageVideoRequestDuration];


export const PixverseImageVideoRequestDuration = {
  NUMBER_5: 5,
  NUMBER_8: 8,
} as const;

export type PixverseImageVideoRequestModel = typeof PixverseImageVideoRequestModel[keyof typeof PixverseImageVideoRequestModel];


export const PixverseImageVideoRequestModel = {
  v35: 'v3.5',
} as const;

export type PixverseImageVideoRequestMotionMode = typeof PixverseImageVideoRequestMotionMode[keyof typeof PixverseImageVideoRequestMotionMode];


export const PixverseImageVideoRequestMotionMode = {
  normal: 'normal',
  fast: 'fast',
} as const;

export type PixverseImageVideoRequestQuality = typeof PixverseImageVideoRequestQuality[keyof typeof PixverseImageVideoRequestQuality];


export const PixverseImageVideoRequestQuality = {
  '360p': '360p',
  '540p': '540p',
  '720p': '720p',
  '1080p': '1080p',
} as const;

export type PixverseImageVideoRequestStyle = typeof PixverseImageVideoRequestStyle[keyof typeof PixverseImageVideoRequestStyle];


export const PixverseImageVideoRequestStyle = {
  anime: 'anime',
  '3d_animation': '3d_animation',
  clay: 'clay',
  comic: 'comic',
  cyberpunk: 'cyberpunk',
} as const;

export interface PixverseImageVideoRequest {
  duration: PixverseImageVideoRequestDuration;
  img_id: number;
  model: PixverseImageVideoRequestModel;
  motion_mode?: PixverseImageVideoRequestMotionMode;
  prompt: string;
  quality: PixverseImageVideoRequestQuality;
  seed?: number;
  style?: PixverseImageVideoRequestStyle;
  template_id?: number;
  water_mark?: boolean;
}

export type PixverseTextVideoRequestAspectRatio = typeof PixverseTextVideoRequestAspectRatio[keyof typeof PixverseTextVideoRequestAspectRatio];


export const PixverseTextVideoRequestAspectRatio = {
  '16:9': '16:9',
  '4:3': '4:3',
  '1:1': '1:1',
  '3:4': '3:4',
  '9:16': '9:16',
} as const;

export type PixverseTextVideoRequestDuration = typeof PixverseTextVideoRequestDuration[keyof typeof PixverseTextVideoRequestDuration];


export const PixverseTextVideoRequestDuration = {
  NUMBER_5: 5,
  NUMBER_8: 8,
} as const;

export type PixverseTextVideoRequestModel = typeof PixverseTextVideoRequestModel[keyof typeof PixverseTextVideoRequestModel];


export const PixverseTextVideoRequestModel = {
  v35: 'v3.5',
} as const;

export type PixverseTextVideoRequestMotionMode = typeof PixverseTextVideoRequestMotionMode[keyof typeof PixverseTextVideoRequestMotionMode];


export const PixverseTextVideoRequestMotionMode = {
  normal: 'normal',
  fast: 'fast',
} as const;

export type PixverseTextVideoRequestQuality = typeof PixverseTextVideoRequestQuality[keyof typeof PixverseTextVideoRequestQuality];


export const PixverseTextVideoRequestQuality = {
  '360p': '360p',
  '540p': '540p',
  '720p': '720p',
  '1080p': '1080p',
} as const;

export type PixverseTextVideoRequestStyle = typeof PixverseTextVideoRequestStyle[keyof typeof PixverseTextVideoRequestStyle];


export const PixverseTextVideoRequestStyle = {
  anime: 'anime',
  '3d_animation': '3d_animation',
  clay: 'clay',
  comic: 'comic',
  cyberpunk: 'cyberpunk',
} as const;

export interface PixverseTextVideoRequest {
  aspect_ratio: PixverseTextVideoRequestAspectRatio;
  duration: PixverseTextVideoRequestDuration;
  model: PixverseTextVideoRequestModel;
  motion_mode?: PixverseTextVideoRequestMotionMode;
  negative_prompt?: string;
  prompt: string;
  quality: PixverseTextVideoRequestQuality;
  seed?: number;
  style?: PixverseTextVideoRequestStyle;
  template_id?: number;
  water_mark?: boolean;
}

export type PixverseTransitionVideoRequestDuration = typeof PixverseTransitionVideoRequestDuration[keyof typeof PixverseTransitionVideoRequestDuration];


export const PixverseTransitionVideoRequestDuration = {
  NUMBER_5: 5,
  NUMBER_8: 8,
} as const;

export type PixverseTransitionVideoRequestModel = typeof PixverseTransitionVideoRequestModel[keyof typeof PixverseTransitionVideoRequestModel];


export const PixverseTransitionVideoRequestModel = {
  v35: 'v3.5',
} as const;

export type PixverseTransitionVideoRequestMotionMode = typeof PixverseTransitionVideoRequestMotionMode[keyof typeof PixverseTransitionVideoRequestMotionMode];


export const PixverseTransitionVideoRequestMotionMode = {
  normal: 'normal',
  fast: 'fast',
} as const;

export type PixverseTransitionVideoRequestQuality = typeof PixverseTransitionVideoRequestQuality[keyof typeof PixverseTransitionVideoRequestQuality];


export const PixverseTransitionVideoRequestQuality = {
  '360p': '360p',
  '540p': '540p',
  '720p': '720p',
  '1080p': '1080p',
} as const;

export type PixverseTransitionVideoRequestStyle = typeof PixverseTransitionVideoRequestStyle[keyof typeof PixverseTransitionVideoRequestStyle];


export const PixverseTransitionVideoRequestStyle = {
  anime: 'anime',
  '3d_animation': '3d_animation',
  clay: 'clay',
  comic: 'comic',
  cyberpunk: 'cyberpunk',
} as const;

export interface PixverseTransitionVideoRequest {
  duration: PixverseTransitionVideoRequestDuration;
  first_frame_img: number;
  last_frame_img: number;
  model: PixverseTransitionVideoRequestModel;
  motion_mode: PixverseTransitionVideoRequestMotionMode;
  prompt: string;
  quality: PixverseTransitionVideoRequestQuality;
  seed: number;
  style?: PixverseTransitionVideoRequestStyle;
  template_id?: number;
  water_mark?: boolean;
}

export type PixverseVideoResponseResp = {
  video_id?: number;
};

export interface PixverseVideoResponse {
  ErrCode?: number;
  ErrMsg?: string;
  Resp?: PixverseVideoResponseResp;
}

/**
 * Video generation status codes:
* 1 - Generation successful
* 5 - Generating
* 6 - Deleted
* 7 - Contents moderation failed
* 8 - Generation failed

 */
export type PixverseVideoResultResponseRespStatus = typeof PixverseVideoResultResponseRespStatus[keyof typeof PixverseVideoResultResponseRespStatus];


export const PixverseVideoResultResponseRespStatus = {
  NUMBER_1: 1,
  NUMBER_5: 5,
  NUMBER_6: 6,
  NUMBER_7: 7,
  NUMBER_8: 8,
} as const;

export type PixverseVideoResultResponseResp = {
  create_time?: string;
  id?: number;
  modify_time?: string;
  negative_prompt?: string;
  outputHeight?: number;
  outputWidth?: number;
  prompt?: string;
  resolution_ratio?: number;
  seed?: number;
  size?: number;
  /** Video generation status codes:
* 1 - Generation successful
* 5 - Generating
* 6 - Deleted
* 7 - Contents moderation failed
* 8 - Generation failed
 */
  status?: PixverseVideoResultResponseRespStatus;
  style?: string;
  url?: string;
};

export interface PixverseVideoResultResponse {
  ErrCode?: number;
  ErrMsg?: string;
  Resp?: PixverseVideoResultResponseResp;
}

/**
 * Set of key-value pairs for storing additional information
 */
export type PromoCodeResponseMetadata = {[key: string]: string};

export interface PromoCodeResponse {
  /** Whether the promo code is currently active */
  active: boolean;
  /** The generated promotional code */
  code: string;
  /** The Stripe coupon ID associated with this promo code */
  coupon_id: string;
  /** Unix timestamp when the promo code expires */
  expires_at?: number;
  /** The Stripe promotion code ID */
  id: string;
  /** Maximum number of times this code can be redeemed */
  max_redemptions?: number;
  /** Set of key-value pairs for storing additional information */
  metadata?: PromoCodeResponseMetadata;
  /** Number of times this code has been redeemed */
  times_redeemed?: number;
}

/**
 * RGB color values
 */
export interface RGBColor {
  /**
   * @minItems 3
   * @maxItems 3
   */
  rgb: number[];
}

/**
 * The base style of the generated images
 */
export type RecraftCreateStyleRequestStyle = typeof RecraftCreateStyleRequestStyle[keyof typeof RecraftCreateStyleRequestStyle];


export const RecraftCreateStyleRequestStyle = {
  realistic_image: 'realistic_image',
  digital_illustration: 'digital_illustration',
  vector_illustration: 'vector_illustration',
  icon: 'icon',
} as const;

/**
 * Request body for creating a Recraft style reference
 */
export interface RecraftCreateStyleRequest {
  /** First image file (PNG, JPG, or WEBP) */
  file1: string;
  /** Second image file (PNG, JPG, or WEBP) */
  file2?: string;
  /** Third image file (PNG, JPG, or WEBP) */
  file3?: string;
  /** Fourth image file (PNG, JPG, or WEBP) */
  file4?: string;
  /** Fifth image file (PNG, JPG, or WEBP) */
  file5?: string;
  /** The base style of the generated images */
  style: RecraftCreateStyleRequestStyle;
}

/**
 * Response containing the created style ID
 */
export interface RecraftCreateStyleResponse {
  /** The unique identifier of the created style */
  id: string;
}

export interface RecraftImageFeatures {
  nsfw_score?: number;
}

export interface RecraftImage {
  b64_json?: string;
  features?: RecraftImageFeatures;
  image_id: string;
  revised_prompt?: string;
  url?: string;
}

export interface RecraftGenerateImageResponse {
  created: number;
  credits: number;
  data: RecraftImage[];
}

export interface RecraftImageColor {
  rgb?: number[];
  std?: number[];
  weight?: number;
}

export type RecraftImageFormat = typeof RecraftImageFormat[keyof typeof RecraftImageFormat];


export const RecraftImageFormat = {
  webp: 'webp',
  png: 'png',
} as const;

/**
 * The controls for the generated image
 */
export type RecraftImageGenerationRequestControls = {
  /**
   * Defines artistic tone of your image. At a simple level, the person looks straight at the camera in a static and clean style. Dynamic and eccentric levels introduce movement and creativity.
   * @minimum 0
   * @maximum 5
   * @nullable
   */
  artistic_level?: number | null;
  background_color?: RGBColor;
  /** An array of preferable colors */
  colors?: RGBColor[];
  /** Do not embed text layouts */
  no_text?: boolean;
};

/**
 * Parameters for the Recraft image generation proxy request.
 */
export interface RecraftImageGenerationRequest {
  /** The controls for the generated image */
  controls?: RecraftImageGenerationRequestControls;
  /** The model to use for generation (e.g., "recraftv3") */
  model: string;
  /**
   * The number of images to generate
   * @minimum 1
   * @maximum 4
   */
  n: number;
  /** The text prompt describing the image to generate */
  prompt: string;
  /** The size of the generated image (e.g., "1024x1024") */
  size: string;
  /** The style to apply to the generated image (e.g., "digital_illustration") */
  style?: string;
  /** The style ID to apply to the generated image (e.g., "123e4567-e89b-12d3-a456-426614174000"). If style_id is provided, style should not be provided. */
  style_id?: string;
}

export type RecraftImageGenerationResponseDataItem = {
  /** Unique identifier for the generated image */
  image_id?: string;
  /** URL to access the generated image */
  url?: string;
};

/**
 * Response from the Recraft image generation API.
 */
export interface RecraftImageGenerationResponse {
  /** Unix timestamp when the generation was created */
  created: number;
  /** Number of credits used for the generation */
  credits: number;
  /** Array of generated image information */
  data: RecraftImageGenerationResponseDataItem[];
}

export type RecraftImageStyle = typeof RecraftImageStyle[keyof typeof RecraftImageStyle];


export const RecraftImageStyle = {
  digital_illustration: 'digital_illustration',
  icon: 'icon',
  realistic_image: 'realistic_image',
  vector_illustration: 'vector_illustration',
} as const;

export type RecraftImageSubStyle = typeof RecraftImageSubStyle[keyof typeof RecraftImageSubStyle];


export const RecraftImageSubStyle = {
  '2d_art_poster': '2d_art_poster',
  '3d': '3d',
  '80s': '80s',
  glow: 'glow',
  grain: 'grain',
  hand_drawn: 'hand_drawn',
  infantile_sketch: 'infantile_sketch',
  kawaii: 'kawaii',
  pixel_art: 'pixel_art',
  psychedelic: 'psychedelic',
  seamless: 'seamless',
  voxel: 'voxel',
  watercolor: 'watercolor',
  broken_line: 'broken_line',
  colored_outline: 'colored_outline',
  colored_shapes: 'colored_shapes',
  colored_shapes_gradient: 'colored_shapes_gradient',
  doodle_fill: 'doodle_fill',
  doodle_offset_fill: 'doodle_offset_fill',
  offset_fill: 'offset_fill',
  outline: 'outline',
  outline_gradient: 'outline_gradient',
  uneven_fill: 'uneven_fill',
  '70s': '70s',
  cartoon: 'cartoon',
  doodle_line_art: 'doodle_line_art',
  engraving: 'engraving',
  flat_2: 'flat_2',
  line_art: 'line_art',
  linocut: 'linocut',
  b_and_w: 'b_and_w',
  enterprise: 'enterprise',
  hard_flash: 'hard_flash',
  hdr: 'hdr',
  motion_blur: 'motion_blur',
  natural_light: 'natural_light',
  studio_portrait: 'studio_portrait',
  line_circuit: 'line_circuit',
  '2d_art_poster_2': '2d_art_poster_2',
  engraving_color: 'engraving_color',
  flat_air_art: 'flat_air_art',
  hand_drawn_outline: 'hand_drawn_outline',
  handmade_3d: 'handmade_3d',
  stickers_drawings: 'stickers_drawings',
  plastic: 'plastic',
  pictogram: 'pictogram',
} as const;

export interface RecraftUserControls {
  artistic_level?: number;
  background_color?: RecraftImageColor;
  colors?: RecraftImageColor[];
  no_text?: boolean;
}

export type RecraftTransformModel = typeof RecraftTransformModel[keyof typeof RecraftTransformModel];


export const RecraftTransformModel = {
  refm1: 'refm1',
  recraft20b: 'recraft20b',
  recraftv2: 'recraftv2',
  recraftv3: 'recraftv3',
  flux1_1pro: 'flux1_1pro',
  flux1dev: 'flux1dev',
  imagen3: 'imagen3',
  hidream_i1_dev: 'hidream_i1_dev',
} as const;

export type RecraftResponseFormat = typeof RecraftResponseFormat[keyof typeof RecraftResponseFormat];


export const RecraftResponseFormat = {
  url: 'url',
  b64_json: 'b64_json',
} as const;

export interface RecraftTextLayoutItem {
  bbox: number[][];
  text: string;
}

export type RecraftTextLayout = RecraftTextLayoutItem[];

export interface RecraftImageToImageRequest {
  block_nsfw?: boolean;
  calculate_features?: boolean;
  controls?: RecraftUserControls;
  image: string;
  image_format?: RecraftImageFormat;
  model?: RecraftTransformModel;
  n?: number;
  negative_prompt?: string;
  prompt: string;
  response_format?: RecraftResponseFormat;
  strength: number;
  style?: RecraftImageStyle;
  style_id?: string;
  substyle?: RecraftImageSubStyle;
  text_layout?: RecraftTextLayout;
}

export interface RecraftProcessImageRequest {
  image: string;
  image_format?: RecraftImageFormat;
  response_format?: RecraftResponseFormat;
}

export interface RecraftProcessImageResponse {
  created: number;
  credits: number;
  image: RecraftImage;
}

export interface RecraftTransformImageWithMaskRequest {
  block_nsfw?: boolean;
  calculate_features?: boolean;
  image: string;
  image_format?: RecraftImageFormat;
  mask: string;
  model?: RecraftTransformModel;
  n?: number;
  negative_prompt?: string;
  prompt: string;
  response_format?: RecraftResponseFormat;
  style?: RecraftImageStyle;
  style_id?: string;
  substyle?: RecraftImageSubStyle;
  text_layout?: RecraftTextLayout;
}

/**
 * The attention level for this release
 */
export type ReleaseNoteAttention = typeof ReleaseNoteAttention[keyof typeof ReleaseNoteAttention];


export const ReleaseNoteAttention = {
  low: 'low',
  medium: 'medium',
  high: 'high',
} as const;

/**
 * The project this release note belongs to
 */
export type ReleaseNoteProject = typeof ReleaseNoteProject[keyof typeof ReleaseNoteProject];


export const ReleaseNoteProject = {
  comfyui: 'comfyui',
  comfyui_frontend: 'comfyui_frontend',
  desktop: 'desktop',
  cloud: 'cloud',
} as const;

export interface ReleaseNote {
  /** The attention level for this release */
  attention: ReleaseNoteAttention;
  /** The content of the release note in markdown format */
  content: string;
  /** Unique identifier for the release note */
  id: number;
  /** The project this release note belongs to */
  project: ReleaseNoteProject;
  /** When the release note was published */
  published_at: string;
  /** The version of the release */
  version: string;
}

export interface Rodin3DCheckStatusRequest {
  /** subscription from generate endpoint */
  subscription_key: string;
}

export type RodinStatusOptions = typeof RodinStatusOptions[keyof typeof RodinStatusOptions];


export const RodinStatusOptions = {
  Done: 'Done',
  Failed: 'Failed',
  Generating: 'Generating',
  Waiting: 'Waiting',
} as const;

export interface RodinCheckStatusJobItem {
  status?: RodinStatusOptions;
  /** sub uuid */
  uuid?: string;
}

export interface Rodin3DCheckStatusResponse {
  /** Details for the generation status. */
  jobs?: RodinCheckStatusJobItem[];
}

export interface Rodin3DDownloadRequest {
  /** Task UUID */
  task_uuid: string;
}

export interface RodinResourceItem {
  /** File name */
  name?: string;
  /** Download url */
  url?: string;
}

export interface Rodin3DDownloadResponse {
  list?: RodinResourceItem[];
}

/**
 * Rodin Material para options
 */
export type RodinMaterialType = typeof RodinMaterialType[keyof typeof RodinMaterialType];


export const RodinMaterialType = {
  PBR: 'PBR',
  Shaded: 'Shaded',
} as const;

/**
 * Rodin Mesh_Mode para options
 */
export type RodinMeshModeType = typeof RodinMeshModeType[keyof typeof RodinMeshModeType];


export const RodinMeshModeType = {
  Quad: 'Quad',
  Raw: 'Raw',
} as const;

/**
 * Rodin Quality para options
 */
export type RodinQualityType = typeof RodinQualityType[keyof typeof RodinQualityType];


export const RodinQualityType = {
  'extra-low': 'extra-low',
  low: 'low',
  medium: 'medium',
  high: 'high',
} as const;

/**
 * Rodin Tier para options
 */
export type RodinTierType = typeof RodinTierType[keyof typeof RodinTierType];


export const RodinTierType = {
  Regular: 'Regular',
  Sketch: 'Sketch',
  Detail: 'Detail',
  Smooth: 'Smooth',
} as const;

export interface Rodin3DGenerateRequest {
  /** The reference images to generate 3D Assets. */
  images: string;
  material?: RodinMaterialType;
  mesh_mode?: RodinMeshModeType;
  quality?: RodinQualityType;
  /** Seed. */
  seed?: number;
  tier?: RodinTierType;
}

export interface RodinGenerateJobsData {
  /** Subscription Key. */
  subscription_key?: string;
  /** subjobs uuid. */
  uuids?: string[];
}

export interface Rodin3DGenerateResponse {
  jobs?: RodinGenerateJobsData;
  /** message */
  message?: string;
  /** prompt */
  prompt?: string;
  /** Time */
  submit_time?: string;
  /** Task UUID */
  uuid?: string;
}

export type RunwayAspectRatioEnum = typeof RunwayAspectRatioEnum[keyof typeof RunwayAspectRatioEnum];


export const RunwayAspectRatioEnum = {
  '1280:720': '1280:720',
  '720:1280': '720:1280',
  '1104:832': '1104:832',
  '832:1104': '832:1104',
  '960:960': '960:960',
  '1584:672': '1584:672',
  '1280:768': '1280:768',
  '768:1280': '768:1280',
} as const;

export type RunwayDurationEnum = typeof RunwayDurationEnum[keyof typeof RunwayDurationEnum];


export const RunwayDurationEnum = {
  NUMBER_5: 5,
  NUMBER_10: 10,
} as const;

/**
 * Available Runway models for generation.
 */
export type RunwayModelEnum = typeof RunwayModelEnum[keyof typeof RunwayModelEnum];


export const RunwayModelEnum = {
  gen4_turbo: 'gen4_turbo',
  gen3a_turbo: 'gen3a_turbo',
} as const;

/**
 * The position of the image in the output video. 'last' is currently supported for gen3a_turbo only.
 */
export type RunwayPromptImageDetailedObjectPosition = typeof RunwayPromptImageDetailedObjectPosition[keyof typeof RunwayPromptImageDetailedObjectPosition];


export const RunwayPromptImageDetailedObjectPosition = {
  first: 'first',
  last: 'last',
} as const;

/**
 * Represents an image with its position in the video sequence.
 */
export interface RunwayPromptImageDetailedObject {
  /** The position of the image in the output video. 'last' is currently supported for gen3a_turbo only. */
  position: RunwayPromptImageDetailedObjectPosition;
  /** A HTTPS URL or data URI containing an encoded image. */
  uri: string;
}

/**
 * Image(s) to use for the video generation. Can be a single URI or an array of image objects with positions.
 */
export type RunwayPromptImageObject = string | RunwayPromptImageDetailedObject[];

export interface RunwayImageToVideoRequest {
  duration: RunwayDurationEnum;
  model: RunwayModelEnum;
  promptImage: RunwayPromptImageObject;
  /**
   * Text prompt for the generation
   * @maxLength 1000
   */
  promptText?: string;
  ratio: RunwayAspectRatioEnum;
  /**
   * Random seed for generation
   * @minimum 0
   * @maximum 4294967295
   */
  seed: number;
}

export interface RunwayImageToVideoResponse {
  /** Task ID */
  id?: string;
}

/**
 * Possible statuses for a Runway task.
 */
export type RunwayTaskStatusEnum = typeof RunwayTaskStatusEnum[keyof typeof RunwayTaskStatusEnum];


export const RunwayTaskStatusEnum = {
  SUCCEEDED: 'SUCCEEDED',
  RUNNING: 'RUNNING',
  FAILED: 'FAILED',
  PENDING: 'PENDING',
  CANCELLED: 'CANCELLED',
  THROTTLED: 'THROTTLED',
} as const;

export interface RunwayTaskStatusResponse {
  /** Task creation timestamp */
  createdAt: string;
  /** Task ID */
  id: string;
  /** Array of output video URLs */
  output?: string[];
  /**
   * Float value between 0 and 1 representing the progress of the task. Only available if status is RUNNING.
   * @minimum 0
   * @maximum 1
   */
  progress?: number;
  status: RunwayTaskStatusEnum;
}

export type RunwayTextToImageAspectRatioEnum = typeof RunwayTextToImageAspectRatioEnum[keyof typeof RunwayTextToImageAspectRatioEnum];


export const RunwayTextToImageAspectRatioEnum = {
  '1920:1080': '1920:1080',
  '1080:1920': '1080:1920',
  '1024:1024': '1024:1024',
  '1360:768': '1360:768',
  '1080:1080': '1080:1080',
  '1168:880': '1168:880',
  '1440:1080': '1440:1080',
  '1080:1440': '1080:1440',
  '1808:768': '1808:768',
  '2112:912': '2112:912',
} as const;

/**
 * Model to use for generation
 */
export type RunwayTextToImageRequestModel = typeof RunwayTextToImageRequestModel[keyof typeof RunwayTextToImageRequestModel];


export const RunwayTextToImageRequestModel = {
  gen4_image: 'gen4_image',
} as const;

export type RunwayTextToImageRequestReferenceImagesItem = {
  /** A HTTPS URL or data URI containing an encoded image */
  uri?: string;
};

export interface RunwayTextToImageRequest {
  /** Model to use for generation */
  model: RunwayTextToImageRequestModel;
  /**
   * Text prompt for the image generation
   * @maxLength 1000
   */
  promptText: string;
  ratio: RunwayTextToImageAspectRatioEnum;
  /** Array of reference images to guide the generation */
  referenceImages?: RunwayTextToImageRequestReferenceImagesItem[];
}

export interface RunwayTextToImageResponse {
  /** Task ID */
  id?: string;
}

/**
 * Our content moderation system has flagged some part of your request and subsequently denied it.  You were not charged for this request.  While this may at times be frustrating, it is necessary to maintain the integrity of our platform and ensure a safe experience for all users. If you would like to provide feedback, please use the [Support Form](https://kb.stability.ai/knowledge-base/kb-tickets/new).
 * @minLength 1
 */
export type StabilityContentModerationResponseName = typeof StabilityContentModerationResponseName[keyof typeof StabilityContentModerationResponseName];


export const StabilityContentModerationResponseName = {
  content_moderation: 'content_moderation',
} as const;

/**
 * Your request was flagged by our content moderation system.
 */
export interface StabilityContentModerationResponse {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Our content moderation system has flagged some part of your request and subsequently denied it.  You were not charged for this request.  While this may at times be frustrating, it is necessary to maintain the integrity of our platform and ensure a safe experience for all users. If you would like to provide feedback, please use the [Support Form](https://kb.stability.ai/knowledge-base/kb-tickets/new).
   * @minLength 1
   */
  name: StabilityContentModerationResponseName;
}

/**
 * Controls the likelihood of creating additional details not heavily conditioned by the init image.
 * @minimum 0.2
 * @maximum 0.5
 */
export type StabilityCreativity = number;

export interface StabilityError {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.

   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

/**
 * The `id` of a generation, typically used for async generations, that can be used to check the status of the generation or retrieve the result.
 * @minLength 64
 * @maxLength 64
 */
export type StabilityGenerationID = string;

export type StabilityGetResultResponse202Status = typeof StabilityGetResultResponse202Status[keyof typeof StabilityGetResultResponse202Status];


export const StabilityGetResultResponse202Status = {
  'in-progress': 'in-progress',
} as const;

export interface StabilityGetResultResponse202 {
  /** The ID of the generation result. */
  id?: string;
  status?: StabilityGetResultResponse202Status;
}

/**
 * Controls the aspect ratio of the generated image. Defaults to 1:1.

> **Important:** This parameter is only valid for **text-to-image** requests.
 */
export type StabilityImageGenerationSD3RequestAspectRatio = typeof StabilityImageGenerationSD3RequestAspectRatio[keyof typeof StabilityImageGenerationSD3RequestAspectRatio];


export const StabilityImageGenerationSD3RequestAspectRatio = {
  '21:9': '21:9',
  '16:9': '16:9',
  '3:2': '3:2',
  '5:4': '5:4',
  '1:1': '1:1',
  '4:5': '4:5',
  '2:3': '2:3',
  '9:16': '9:16',
  '9:21': '9:21',
} as const;

/**
 * Controls whether this is a text-to-image or image-to-image generation, which affects which parameters are required:
- **text-to-image** requires only the `prompt` parameter
- **image-to-image** requires the `prompt`, `image`, and `strength` parameters
 */
export type StabilityImageGenerationSD3RequestMode = typeof StabilityImageGenerationSD3RequestMode[keyof typeof StabilityImageGenerationSD3RequestMode];


export const StabilityImageGenerationSD3RequestMode = {
  'text-to-image': 'text-to-image',
  'image-to-image': 'image-to-image',
} as const;

/**
 * The model to use for generation.

- `sd3.5-large` requires 6.5 credits per generation
- `sd3.5-large-turbo` requires 4 credits per generation
- `sd3.5-medium` requires 3.5 credits per generation
- As of the April 17, 2025, `sd3-large`, `sd3-large-turbo` and `sd3-medium`



  are re-routed to their `sd3.5-[model version]` equivalent, at the same price.
 */
export type StabilityImageGenerationSD3RequestModel = typeof StabilityImageGenerationSD3RequestModel[keyof typeof StabilityImageGenerationSD3RequestModel];


export const StabilityImageGenerationSD3RequestModel = {
  'sd35-large': 'sd3.5-large',
  'sd35-large-turbo': 'sd3.5-large-turbo',
  'sd35-medium': 'sd3.5-medium',
} as const;

/**
 * Dictates the `content-type` of the generated image.
 */
export type StabilityImageGenerationSD3RequestOutputFormat = typeof StabilityImageGenerationSD3RequestOutputFormat[keyof typeof StabilityImageGenerationSD3RequestOutputFormat];


export const StabilityImageGenerationSD3RequestOutputFormat = {
  png: 'png',
  jpeg: 'jpeg',
} as const;

/**
 * Guides the image model towards a particular style.
 */
export type StabilityImageGenerationSD3RequestStylePreset = typeof StabilityImageGenerationSD3RequestStylePreset[keyof typeof StabilityImageGenerationSD3RequestStylePreset];


export const StabilityImageGenerationSD3RequestStylePreset = {
  enhance: 'enhance',
  anime: 'anime',
  photographic: 'photographic',
  'digital-art': 'digital-art',
  'comic-book': 'comic-book',
  'fantasy-art': 'fantasy-art',
  'line-art': 'line-art',
  'analog-film': 'analog-film',
  'neon-punk': 'neon-punk',
  isometric: 'isometric',
  'low-poly': 'low-poly',
  origami: 'origami',
  'modeling-compound': 'modeling-compound',
  cinematic: 'cinematic',
  '3d-model': '3d-model',
  'pixel-art': 'pixel-art',
  'tile-texture': 'tile-texture',
} as const;

export interface StabilityImageGenerationSD3Request {
  /** Controls the aspect ratio of the generated image. Defaults to 1:1.

> **Important:** This parameter is only valid for **text-to-image** requests. */
  aspect_ratio?: StabilityImageGenerationSD3RequestAspectRatio;
  /**
   * How strictly the diffusion process adheres to the prompt text (higher values keep your image closer to your prompt). The _Large_ and _Medium_ models use a default of `4`. The _Turbo_ model uses a default of `1`.
   * @minimum 1
   * @maximum 10
   */
  cfg_scale?: number;
  /** The image to use as the starting point for the generation.

Supported formats:



  - jpeg
  - png
  - webp

Supported dimensions:



  - Every side must be at least 64 pixels

> **Important:** This parameter is only valid for **image-to-image** requests. */
  image?: string;
  /** Controls whether this is a text-to-image or image-to-image generation, which affects which parameters are required:
- **text-to-image** requires only the `prompt` parameter
- **image-to-image** requires the `prompt`, `image`, and `strength` parameters */
  mode?: StabilityImageGenerationSD3RequestMode;
  /** The model to use for generation.

- `sd3.5-large` requires 6.5 credits per generation
- `sd3.5-large-turbo` requires 4 credits per generation
- `sd3.5-medium` requires 3.5 credits per generation
- As of the April 17, 2025, `sd3-large`, `sd3-large-turbo` and `sd3-medium`



  are re-routed to their `sd3.5-[model version]` equivalent, at the same price. */
  model?: StabilityImageGenerationSD3RequestModel;
  /**
   * Keywords of what you **do not** wish to see in the output image.
This is an advanced feature.
   * @maxLength 10000
   */
  negative_prompt?: string;
  /** Dictates the `content-type` of the generated image. */
  output_format?: StabilityImageGenerationSD3RequestOutputFormat;
  /**
   * What you wish to see in the output image. A strong, descriptive prompt that clearly defines
elements, colors, and subjects will lead to better results.
   * @minLength 1
   * @maxLength 10000
   */
  prompt: string;
  /**
   * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
  /**
   * Sometimes referred to as _denoising_, this parameter controls how much influence the
`image` parameter has on the generated image.  A value of 0 would yield an image that
is identical to the input.  A value of 1 would be as if you passed in no image at all.

> **Important:** This parameter is only valid for **image-to-image** requests.
   * @minimum 0
   * @maximum 1
   */
  strength?: number;
  /** Guides the image model towards a particular style. */
  style_preset?: StabilityImageGenerationSD3RequestStylePreset;
}

/**
 * The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result.
 */
export type StabilityImageGenrationSD3Response200FinishReason = typeof StabilityImageGenrationSD3Response200FinishReason[keyof typeof StabilityImageGenrationSD3Response200FinishReason];


export const StabilityImageGenrationSD3Response200FinishReason = {
  SUCCESS: 'SUCCESS',
  CONTENT_FILTERED: 'CONTENT_FILTERED',
} as const;

export interface StabilityImageGenrationSD3Response200 {
  /** The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result. */
  finish_reason: StabilityImageGenrationSD3Response200FinishReason;
  /** The generated image, encoded to base64. */
  image: string;
  /**
   * The seed used as random noise for this generation.
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
}

export interface StabilityImageGenrationSD3Response400 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationSD3Response413 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationSD3Response422 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationSD3Response429 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationSD3Response500 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

/**
 * Dictates the `content-type` of the generated image.
 */
export type StabilityImageGenrationUpscaleConservativeRequestOutputFormat = typeof StabilityImageGenrationUpscaleConservativeRequestOutputFormat[keyof typeof StabilityImageGenrationUpscaleConservativeRequestOutputFormat];


export const StabilityImageGenrationUpscaleConservativeRequestOutputFormat = {
  jpeg: 'jpeg',
  png: 'png',
  webp: 'webp',
} as const;

export interface StabilityImageGenrationUpscaleConservativeRequest {
  creativity?: StabilityCreativity;
  /** The image you wish to upscale.

Supported Formats:
- jpeg
- png
- webp

Validation Rules:
- Every side must be at least 64 pixels
- Total pixel count must be between 4,096 and 9,437,184 pixels
- The aspect ratio must be between 1:2.5 and 2.5:1 */
  image: string;
  /**
   * A blurb of text describing what you **do not** wish to see in the output image.
This is an advanced feature.
   * @maxLength 10000
   */
  negative_prompt?: string;
  /** Dictates the `content-type` of the generated image. */
  output_format?: StabilityImageGenrationUpscaleConservativeRequestOutputFormat;
  /**
   * What you wish to see in the output image. A strong, descriptive prompt that clearly defines
elements, colors, and subjects will lead to better results.

To control the weight of a given word use the format `(word:weight)`,
where `word` is the word you'd like to control the weight of and `weight`
is a value between 0 and 1. For example: `The sky was a crisp (blue:0.3) and (green:0.8)`
would convey a sky that was blue and green, but more green than blue.
   * @minLength 1
   * @maxLength 10000
   */
  prompt: string;
  /**
   * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
}

/**
 * The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result.
 */
export type StabilityImageGenrationUpscaleConservativeResponse200FinishReason = typeof StabilityImageGenrationUpscaleConservativeResponse200FinishReason[keyof typeof StabilityImageGenrationUpscaleConservativeResponse200FinishReason];


export const StabilityImageGenrationUpscaleConservativeResponse200FinishReason = {
  SUCCESS: 'SUCCESS',
  CONTENT_FILTERED: 'CONTENT_FILTERED',
} as const;

export interface StabilityImageGenrationUpscaleConservativeResponse200 {
  /** The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result. */
  finish_reason: StabilityImageGenrationUpscaleConservativeResponse200FinishReason;
  /** The generated image, encoded to base64. */
  image: string;
  /**
   * The seed used as random noise for this generation.
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
}

export interface StabilityImageGenrationUpscaleConservativeResponse400 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleConservativeResponse413 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleConservativeResponse422 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleConservativeResponse429 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleConservativeResponse500 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

/**
 * Dictates the `content-type` of the generated image.
 */
export type StabilityImageGenrationUpscaleCreativeRequestOutputFormat = typeof StabilityImageGenrationUpscaleCreativeRequestOutputFormat[keyof typeof StabilityImageGenrationUpscaleCreativeRequestOutputFormat];


export const StabilityImageGenrationUpscaleCreativeRequestOutputFormat = {
  jpeg: 'jpeg',
  png: 'png',
  webp: 'webp',
} as const;

/**
 * Guides the image model towards a particular style.
 */
export type StabilityImageGenrationUpscaleCreativeRequestStylePreset = typeof StabilityImageGenrationUpscaleCreativeRequestStylePreset[keyof typeof StabilityImageGenrationUpscaleCreativeRequestStylePreset];


export const StabilityImageGenrationUpscaleCreativeRequestStylePreset = {
  enhance: 'enhance',
  anime: 'anime',
  photographic: 'photographic',
  'digital-art': 'digital-art',
  'comic-book': 'comic-book',
  'fantasy-art': 'fantasy-art',
  'line-art': 'line-art',
  'analog-film': 'analog-film',
  'neon-punk': 'neon-punk',
  isometric: 'isometric',
  'low-poly': 'low-poly',
  origami: 'origami',
  'modeling-compound': 'modeling-compound',
  cinematic: 'cinematic',
  '3d-model': '3d-model',
  'pixel-art': 'pixel-art',
  'tile-texture': 'tile-texture',
} as const;

export interface StabilityImageGenrationUpscaleCreativeRequest {
  /**
   * Indicates how creative the model should be when upscaling an image.
Higher values will result in more details being added to the image during upscaling.
   * @minimum 0.1
   * @maximum 0.5
   */
  creativity?: number;
  /** The image you wish to upscale.

Supported Formats:
- jpeg
- png
- webp

Validation Rules:
- Every side must be at least 64 pixels
- Total pixel count must be between 4,096 and 1,048,576 pixels */
  image: string;
  /**
   * A blurb of text describing what you **do not** wish to see in the output image.
This is an advanced feature.
   * @maxLength 10000
   */
  negative_prompt?: string;
  /** Dictates the `content-type` of the generated image. */
  output_format?: StabilityImageGenrationUpscaleCreativeRequestOutputFormat;
  /**
   * What you wish to see in the output image. A strong, descriptive prompt that clearly defines
elements, colors, and subjects will lead to better results.

To control the weight of a given word use the format `(word:weight)`,
where `word` is the word you'd like to control the weight of and `weight`
is a value between 0 and 1. For example: `The sky was a crisp (blue:0.3) and (green:0.8)`
would convey a sky that was blue and green, but more green than blue.
   * @minLength 1
   * @maxLength 10000
   */
  prompt: string;
  /**
   * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
  /** Guides the image model towards a particular style. */
  style_preset?: StabilityImageGenrationUpscaleCreativeRequestStylePreset;
}

export interface StabilityImageGenrationUpscaleCreativeResponse200 {
  id: StabilityGenerationID;
}

export interface StabilityImageGenrationUpscaleCreativeResponse400 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleCreativeResponse413 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleCreativeResponse422 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleCreativeResponse429 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleCreativeResponse500 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

/**
 * Dictates the `content-type` of the generated image.
 */
export type StabilityImageGenrationUpscaleFastRequestOutputFormat = typeof StabilityImageGenrationUpscaleFastRequestOutputFormat[keyof typeof StabilityImageGenrationUpscaleFastRequestOutputFormat];


export const StabilityImageGenrationUpscaleFastRequestOutputFormat = {
  jpeg: 'jpeg',
  png: 'png',
  webp: 'webp',
} as const;

export interface StabilityImageGenrationUpscaleFastRequest {
  /** The image you wish to upscale.

Supported Formats:
- jpeg
- png
- webp

Validation Rules:
- Width must be between 32 and 1,536 pixels
- Height must be between 32 and 1,536 pixels
- Total pixel count must be between 1,024 and 1,048,576 pixels */
  image: string;
  /** Dictates the `content-type` of the generated image. */
  output_format?: StabilityImageGenrationUpscaleFastRequestOutputFormat;
}

/**
 * The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result.
 */
export type StabilityImageGenrationUpscaleFastResponse200FinishReason = typeof StabilityImageGenrationUpscaleFastResponse200FinishReason[keyof typeof StabilityImageGenrationUpscaleFastResponse200FinishReason];


export const StabilityImageGenrationUpscaleFastResponse200FinishReason = {
  SUCCESS: 'SUCCESS',
  CONTENT_FILTERED: 'CONTENT_FILTERED',
} as const;

export interface StabilityImageGenrationUpscaleFastResponse200 {
  /** The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result. */
  finish_reason: StabilityImageGenrationUpscaleFastResponse200FinishReason;
  /** The generated image, encoded to base64. */
  image: string;
  /**
   * The seed used as random noise for this generation.
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
}

export interface StabilityImageGenrationUpscaleFastResponse400 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleFastResponse413 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleFastResponse422 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleFastResponse429 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

export interface StabilityImageGenrationUpscaleFastResponse500 {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
}

/**
 * The name of your application, used to help us communicate app-specific debugging or moderation issues to you.
 * @maxLength 256
 */
export type StabilityStabilityClientID = string;

/**
 * A unique identifier for your end user. Used to help us communicate user-specific debugging or moderation issues to you. Feel free to obfuscate this value to protect user privacy.
 * @maxLength 256
 */
export type StabilityStabilityClientUserID = string;

/**
 * The version of your application, used to help us communicate version-specific debugging or moderation issues to you.
 * @maxLength 256
 */
export type StabilityStabilityClientVersion = string;

/**
 * Reason for completion
 */
export type StableAudio25AudioResponseFinishReason = typeof StableAudio25AudioResponseFinishReason[keyof typeof StableAudio25AudioResponseFinishReason];


export const StableAudio25AudioResponseFinishReason = {
  SUCCESS: 'SUCCESS',
  ERROR: 'ERROR',
  CONTENT_FILTERED: 'CONTENT_FILTERED',
} as const;

/**
 * Response from Stable Audio 2.5 audio generation
 */
export interface StableAudio25AudioResponse {
  /** Base64-encoded audio data */
  audio?: string;
  /** Reason for completion */
  finish_reason?: StableAudio25AudioResponseFinishReason;
  /** Unique identifier for the generation request */
  id?: string;
}

/**
 * The model to use for generation
 */
export type StableAudio25Model = typeof StableAudio25Model[keyof typeof StableAudio25Model];


export const StableAudio25Model = {
  'stable-audio-25': 'stable-audio-2.5',
} as const;

/**
 * Dictates the content-type of the generated audio
 */
export type StableAudio25OutputFormat = typeof StableAudio25OutputFormat[keyof typeof StableAudio25OutputFormat];


export const StableAudio25OutputFormat = {
  mp3: 'mp3',
  wav: 'wav',
} as const;

/**
 * Request parameters for Stable Audio audio-to-audio transformation
 */
export interface StableAudio25AudioToAudioRequest {
  /** The audio to be used as the starting point for the generation. Supported formats - mp3, wav. Audio must be between 6 and 190 seconds long. */
  audio: string;
  /**
   * How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt). Defaults to 7 for stable-audio-2 and 1 for stable-audio-2.5.
   * @minimum 1
   * @maximum 25
   */
  cfg_scale?: number;
  /**
   * Controls the duration in seconds of the generated audio.
   * @minimum 1
   * @maximum 190
   */
  duration?: number;
  model: StableAudio25Model;
  output_format?: StableAudio25OutputFormat;
  /**
   * What you wish the output audio to be. A strong, descriptive prompt that clearly defines instruments, moods, styles, and genre will lead to better results.
   * @maxLength 10000
   */
  prompt: string;
  /**
   * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass 0 to use a random seed.)
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
  /**
   * Controls the number of sampling steps. For stable-audio-2.5 accepts steps between 4 and 8 (defaults to 8).
   * @minimum 4
   * @maximum 8
   */
  steps?: number;
  /**
   * Controls how much influence the audio parameter has on the generated audio. A value of 0 would yield audio that is identical to the input. A value of 1 would be as if you passed in no audio at all. Minimum value for stable-audio-2.5 is 0.01.
   * @minimum 0
   * @maximum 1
   */
  strength?: number;
}

/**
 * Request parameters for Stable Audio 2.5 audio inpainting
 */
export interface StableAudio25InpaintRequest {
  /** The audio to be used as the starting point for the generation. Supported formats - mp3, wav. Audio must be between 6 and 190 seconds long. */
  audio: string;
  /**
   * Controls the duration in seconds of the generated audio.
   * @minimum 1
   * @maximum 190
   */
  duration?: number;
  /**
   * End time in seconds for the audio segment to be inpainted.
   * @minimum 0
   * @maximum 190
   */
  mask_end?: number;
  /**
   * Start time in seconds for the audio segment to be inpainted.
   * @minimum 0
   * @maximum 190
   */
  mask_start?: number;
  output_format?: StableAudio25OutputFormat;
  /**
   * What you wish the output audio to be. A strong, descriptive prompt that clearly defines instruments, moods, styles, and genre will lead to better results.
   * @maxLength 10000
   */
  prompt: string;
  /**
   * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass 0 to use a random seed.)
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
  /**
   * Controls the number of sampling steps.
   * @minimum 4
   * @maximum 8
   */
  steps?: number;
}

/**
 * Request parameters for Stable Audio 2.5 text-to-audio generation
 */
export interface StableAudio25TextToAudioRequest {
  /**
   * How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt). Defaults to 1 for stable-audio-2.5.
   * @minimum 1
   * @maximum 25
   */
  cfg_scale?: number;
  /**
   * Controls the duration in seconds of the generated audio.
   * @minimum 1
   * @maximum 190
   */
  duration?: number;
  model: StableAudio25Model;
  output_format?: StableAudio25OutputFormat;
  /**
   * What you wish the output audio to be. A strong, descriptive prompt that clearly defines instruments, moods, styles, and genre will lead to better results.
   * @maxLength 10000
   */
  prompt: string;
  /**
   * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass 0 to use a random seed.)
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
  /**
   * Controls the number of sampling steps. For stable-audio-2.5 accepts steps between 4 and 8 (defaults to 8).
   * @minimum 4
   * @maximum 8
   */
  steps?: number;
}

export type StripeEventDataObject = { [key: string]: unknown };

export type StripeEventData = {
  object?: StripeEventDataObject;
};

export type StripeEventObject = typeof StripeEventObject[keyof typeof StripeEventObject];


export const StripeEventObject = {
  event: 'event',
} as const;

export type StripeEventType = typeof StripeEventType[keyof typeof StripeEventType];


export const StripeEventType = {
  invoicepaid: 'invoice.paid',
} as const;

export interface StripeEvent {
  data: StripeEventData;
  id: string;
  object: StripeEventObject;
  type: StripeEventType;
}

/**
 * The subscription billing duration
 */
export type SubscriptionDuration = typeof SubscriptionDuration[keyof typeof SubscriptionDuration];


export const SubscriptionDuration = {
  MONTHLY: 'MONTHLY',
  ANNUAL: 'ANNUAL',
} as const;

/**
 * The subscription tier level
 */
export type SubscriptionTier = typeof SubscriptionTier[keyof typeof SubscriptionTier];


export const SubscriptionTier = {
  STANDARD: 'STANDARD',
  CREATOR: 'CREATOR',
  PRO: 'PRO',
  FOUNDERS_EDITION: 'FOUNDERS_EDITION',
} as const;

export type TencentErrorResponseResponseError = {
  /** Error code */
  Code?: string;
  /** Error message */
  Message?: string;
};

export type TencentErrorResponseResponse = {
  Error?: TencentErrorResponseResponseError;
  /** Unique request ID for troubleshooting */
  RequestId?: string;
};

/**
 * Error response from Tencent API
 */
export interface TencentErrorResponse {
  Response?: TencentErrorResponseResponse;
}

/**
 * 3D file format
 */
export type TencentFile3DType = typeof TencentFile3DType[keyof typeof TencentFile3DType];


export const TencentFile3DType = {
  GLB: 'GLB',
  OBJ: 'OBJ',
} as const;

/**
 * 3D file information
 */
export interface TencentFile3D {
  /** Preview image URL */
  PreviewImageUrl?: string;
  /** 3D file format */
  Type?: TencentFile3DType;
  /** File URL (valid for 24 hours) */
  Url?: string;
}

/**
 * Generation task type:
- Normal: generates a geometric model with textures (default)
- LowPoly: model generated after intelligent polygon reduction
- Geometry: generate model without textures (white model)
- Sketch: generative model from sketch or line drawing

 */
export type TencentHunyuan3DProRequestGenerateType = typeof TencentHunyuan3DProRequestGenerateType[keyof typeof TencentHunyuan3DProRequestGenerateType];


export const TencentHunyuan3DProRequestGenerateType = {
  Normal: 'Normal',
  LowPoly: 'LowPoly',
  Geometry: 'Geometry',
  Sketch: 'Sketch',
} as const;

/**
 * Tencent HY 3D Global model version.
Defaults to 3.0, with optional choices: 3.0, 3.1.
When selecting version 3.1, the LowPoly parameter is unavailable.

 */
export type TencentHunyuan3DProRequestModel = typeof TencentHunyuan3DProRequestModel[keyof typeof TencentHunyuan3DProRequestModel];


export const TencentHunyuan3DProRequestModel = {
  '30': '3.0',
  '31': '3.1',
} as const;

/**
 * Polygon type (only effective when GenerateType is LowPoly).
- triangle: triangular faces (default)
- quadrilateral: mix of quadrangle and triangle faces

 */
export type TencentHunyuan3DProRequestPolygonType = typeof TencentHunyuan3DProRequestPolygonType[keyof typeof TencentHunyuan3DProRequestPolygonType];


export const TencentHunyuan3DProRequestPolygonType = {
  triangle: 'triangle',
  quadrilateral: 'quadrilateral',
} as const;

/**
 * The viewing angle type for this image.
- left: Left view
- right: Right view
- back: Rear view
- top: Top view (only supported in Model 3.1)
- bottom: Bottom view (only supported in Model 3.1)
- left_front: Left front 45 degree view (only supported in Model 3.1)
- right_front: Right front 45 degree view (only supported in Model 3.1)

 */
export type TencentViewImageViewType = typeof TencentViewImageViewType[keyof typeof TencentViewImageViewType];


export const TencentViewImageViewType = {
  left: 'left',
  right: 'right',
  back: 'back',
  top: 'top',
  bottom: 'bottom',
  left_front: 'left_front',
  right_front: 'right_front',
} as const;

/**
 * A view image for multi-perspective 3D generation
 */
export interface TencentViewImage {
  /** Base64 encoded image for this view.
Resolution: min 128px, max 5000px per side.
Max size: 8MB.
Supported formats: JPG, PNG.
 */
  ViewImageBase64?: string;
  /** URL of the image for this view.
Resolution: min 128px, max 5000px per side.
Max size: 8MB.
Supported formats: JPG, PNG.
 */
  ViewImageUrl?: string;
  /** The viewing angle type for this image.
- left: Left view
- right: Right view
- back: Rear view
- top: Top view (only supported in Model 3.1)
- bottom: Bottom view (only supported in Model 3.1)
- left_front: Left front 45 degree view (only supported in Model 3.1)
- right_front: Right front 45 degree view (only supported in Model 3.1)
 */
  ViewType?: TencentViewImageViewType;
}

/**
 * Request body for Tencent Hunyuan 3D Pro generation
 */
export interface TencentHunyuan3DProRequest {
  /** Whether to enable PBR material generation. */
  EnablePBR?: boolean;
  /**
   * Face count for 3D model generation.
   * @minimum 40000
   * @maximum 1500000
   */
  FaceCount?: number;
  /** Generation task type:
- Normal: generates a geometric model with textures (default)
- LowPoly: model generated after intelligent polygon reduction
- Geometry: generate model without textures (white model)
- Sketch: generative model from sketch or line drawing
 */
  GenerateType?: TencentHunyuan3DProRequestGenerateType;
  /** Base64 encoded image for image-to-3D generation.
Resolution: min 128px, max 5000px per side.
Max size: 8MB (recommend 6MB before encoding).
Supported formats: jpg, png, jpeg, webp.
Either ImageBase64/ImageUrl or Prompt is required.
 */
  ImageBase64?: string;
  /** URL of input image for image-to-3D generation.
Resolution: min 128px, max 5000px per side.
Max size: 8MB.
Supported formats: jpg, png, jpeg, webp.
Either ImageBase64/ImageUrl or Prompt is required.
 */
  ImageUrl?: string;
  /** Tencent HY 3D Global model version.
Defaults to 3.0, with optional choices: 3.0, 3.1.
When selecting version 3.1, the LowPoly parameter is unavailable.
 */
  Model?: TencentHunyuan3DProRequestModel;
  /** Multi-perspective model images for 3D generation.
Each perspective is limited to one image.
Image size limit: max 8MB after encoding.
Image resolution: min 128px, max 5000px per side.
Supported formats: JPG, PNG.
 */
  MultiViewImages?: TencentViewImage[];
  /** Polygon type (only effective when GenerateType is LowPoly).
- triangle: triangular faces (default)
- quadrilateral: mix of quadrangle and triangle faces
 */
  PolygonType?: TencentHunyuan3DProRequestPolygonType;
  /**
   * Text description for 3D content generation.
Supports up to 1024 utf-8 characters.
Either Prompt or ImageBase64/ImageUrl is required, but not both.

   * @maxLength 1024
   */
  Prompt?: string;
}

/**
 * Error object (present when request fails)
 */
export type TencentHunyuan3DProResponseResponseError = {
  /** Error code */
  Code?: string;
  /** Error message */
  Message?: string;
};

export type TencentHunyuan3DProResponseResponse = {
  /** Error object (present when request fails) */
  Error?: TencentHunyuan3DProResponseResponseError;
  /** Task ID (valid for 24 hours) */
  JobId?: string;
  /** Unique request ID for troubleshooting */
  RequestId?: string;
};

/**
 * Response from Tencent Hunyuan 3D Pro submit endpoint
 */
export interface TencentHunyuan3DProResponse {
  Response?: TencentHunyuan3DProResponseResponse;
}

export interface TencentHunyuan3DQueryRequest {
  /** The JobId returned from the submit endpoint */
  JobId: string;
}

/**
 * Task status:
- WAIT: waiting
- RUN: running
- FAIL: failed
- DONE: successful

 */
export type TencentHunyuan3DQueryResponseResponseStatus = typeof TencentHunyuan3DQueryResponseResponseStatus[keyof typeof TencentHunyuan3DQueryResponseResponseStatus];


export const TencentHunyuan3DQueryResponseResponseStatus = {
  WAIT: 'WAIT',
  RUN: 'RUN',
  FAIL: 'FAIL',
  DONE: 'DONE',
} as const;

export type TencentHunyuan3DQueryResponseResponse = {
  /** Error code (empty string if no error) */
  ErrorCode?: string;
  /** Error message if task failed (empty string if no error) */
  ErrorMessage?: string;
  /** Unique request ID for troubleshooting */
  RequestId?: string;
  /** Array of generated 3D files */
  ResultFile3Ds?: TencentFile3D[];
  /** Task status:
- WAIT: waiting
- RUN: running
- FAIL: failed
- DONE: successful
 */
  Status?: TencentHunyuan3DQueryResponseResponseStatus;
};

/**
 * Response from Tencent Hunyuan 3D query endpoint
 */
export interface TencentHunyuan3DQueryResponse {
  Response?: TencentHunyuan3DQueryResponseResponse;
}

/**
 * 3D file format type
 */
export type TencentInputFile3DType = typeof TencentInputFile3DType[keyof typeof TencentInputFile3DType];


export const TencentInputFile3DType = {
  FBX: 'FBX',
  OBJ: 'OBJ',
  GLB: 'GLB',
} as const;

/**
 * 3D file input for UV unwrapping
 */
export interface TencentInputFile3D {
  /** 3D file format type */
  Type: TencentInputFile3DType;
  /** URL of the 3D file that needs UV unwrapping */
  Url: string;
}

/**
 * Reference image - Base64 data or image URL
 */
export interface TencentImageInfo {
  /** Base64 encoded image. Resolution 128-4096 per side, converted Base64 less than 10MB. Formats jpg, jpeg, png. */
  ImageBase64?: string;
  /** Image URL. If both Base64 and Url provided, Url prevails. */
  ImageUrl?: string;
}

/**
 * Request body for Tencent Hunyuan 3D texture edit
 */
export interface TencentHunyuan3DTextureEditRequest {
  /** Whether to enable the PBR texture parameter; only supported when using Prompt. */
  EnablePBR?: boolean;
  File3D: TencentInputFile3D;
  Image?: TencentImageInfo;
  /**
   * Describes texture editing. Either Image or Prompt is required; they cannot coexist.
   * @maxLength 1024
   */
  Prompt?: string;
}

/**
 * Request body for Tencent Hunyuan 3D UV unfolding
 */
export interface TencentHunyuan3DUVRequest {
  File?: TencentInputFile3D;
}

/**
 * Error object (present when request fails)
 */
export type TencentHunyuan3DUVResponseResponseError = {
  /** Error code */
  Code?: string;
  /** Error message */
  Message?: string;
};

export type TencentHunyuan3DUVResponseResponse = {
  /** Error object (present when request fails) */
  Error?: TencentHunyuan3DUVResponseResponseError;
  /** Task ID for the UV unwrapping job */
  JobId?: string;
  /** Unique request ID for troubleshooting */
  RequestId?: string;
};

/**
 * Response from Tencent Hunyuan 3D UV submit endpoint
 */
export interface TencentHunyuan3DUVResponse {
  Response?: TencentHunyuan3DUVResponseResponse;
}

export interface TopazCredentialsS3 {
  /** Kind of like a secret string for extra layer of security */
  externalId: string;
  /** AWS ARN of the role to assume */
  roleArn: string;
}

export type TopazExternalStorageProvider = typeof TopazExternalStorageProvider[keyof typeof TopazExternalStorageProvider];


export const TopazExternalStorageProvider = {
  s3: 's3',
} as const;

export interface TopazExternalStorage {
  bucketName: string;
  credentials: TopazCredentialsS3;
  /** The example includes the standard specifier for image sequence requests, with optional directory path. It must begin with "%" and end with the integer specifier "d". The "0" in the example indicates left-padding with zeroes, and "6" indicates the number of digits in the file name.
Keys for video requests must be valid characters supported by S3.
 */
  key: string;
  provider: TopazExternalStorageProvider;
}

/**
 * Parameter mode of the selected model
 */
export type TopazVideoEnhancementFilterAuto = typeof TopazVideoEnhancementFilterAuto[keyof typeof TopazVideoEnhancementFilterAuto];


export const TopazVideoEnhancementFilterAuto = {
  Auto: 'Auto',
  Manual: 'Manual',
  Relative: 'Relative',
} as const;

/**
 * Creativity level for Starlight Creative (slc-1) only
 */
export type TopazVideoEnhancementFilterCreativity = typeof TopazVideoEnhancementFilterCreativity[keyof typeof TopazVideoEnhancementFilterCreativity];


export const TopazVideoEnhancementFilterCreativity = {
  low: 'low',
  high: 'high',
} as const;

/**
 * Optional specification of field order for interlaced input videos
 */
export type TopazVideoEnhancementFilterFieldOrder = typeof TopazVideoEnhancementFilterFieldOrder[keyof typeof TopazVideoEnhancementFilterFieldOrder];


export const TopazVideoEnhancementFilterFieldOrder = {
  TopFirst: 'TopFirst',
  BottomFirst: 'BottomFirst',
  Auto: 'Auto',
} as const;

/**
 * Downscales video input for stronger correction of blurred subjects
 */
export type TopazVideoEnhancementFilterFocusFixLevel = typeof TopazVideoEnhancementFilterFocusFixLevel[keyof typeof TopazVideoEnhancementFilterFocusFixLevel];


export const TopazVideoEnhancementFilterFocusFixLevel = {
  None: 'None',
  Normal: 'Normal',
  Strong: 'Strong',
} as const;

/**
 * Short code name for AI model
 */
export type TopazVideoEnhancementFilterModel = typeof TopazVideoEnhancementFilterModel[keyof typeof TopazVideoEnhancementFilterModel];


export const TopazVideoEnhancementFilterModel = {
  'aaa-9': 'aaa-9',
  'ahq-12': 'ahq-12',
  'alq-13': 'alq-13',
  'alqs-2': 'alqs-2',
  'amq-13': 'amq-13',
  'amqs-2': 'amqs-2',
  'ddv-3': 'ddv-3',
  'dtd-4': 'dtd-4',
  'dtds-2': 'dtds-2',
  'dtv-4': 'dtv-4',
  'dtvs-2': 'dtvs-2',
  'gcg-5': 'gcg-5',
  'ghq-5': 'ghq-5',
  'iris-2': 'iris-2',
  'iris-3': 'iris-3',
  'nxf-1': 'nxf-1',
  'nyx-3': 'nyx-3',
  'prob-4': 'prob-4',
  'rhea-1': 'rhea-1',
  'rxl-1': 'rxl-1',
  'thd-3': 'thd-3',
  'thf-4': 'thf-4',
  'thm-2': 'thm-2',
  'slf-1': 'slf-1',
  'slc-1': 'slc-1',
} as const;

/**
 * Frame/field type of the video
 */
export type TopazVideoEnhancementFilterVideoType = typeof TopazVideoEnhancementFilterVideoType[keyof typeof TopazVideoEnhancementFilterVideoType];


export const TopazVideoEnhancementFilterVideoType = {
  Progressive: 'Progressive',
  Interlaced: 'Interlaced',
  ProgressiveInterlaced: 'ProgressiveInterlaced',
} as const;

export interface TopazVideoEnhancementFilter {
  /** Parameter mode of the selected model */
  auto?: TopazVideoEnhancementFilterAuto;
  /**
   * Amount of sharpness applied
   * @minimum -1
   * @maximum 1
   */
  blur?: number;
  /**
   * Adjust strength of compression recovery
   * @minimum -1
   * @maximum 1
   */
  compression?: number;
  /** Creativity level for Starlight Creative (slc-1) only */
  creativity?: TopazVideoEnhancementFilterCreativity;
  /**
   * Amount of detail reconstruction
   * @minimum -1
   * @maximum 1
   */
  details?: number;
  /** Optional specification of field order for interlaced input videos */
  fieldOrder?: TopazVideoEnhancementFilterFieldOrder;
  /** Downscales video input for stronger correction of blurred subjects */
  focusFixLevel?: TopazVideoEnhancementFilterFocusFixLevel;
  /**
   * Adds grain after AI model processing
   * @minimum 0
   * @maximum 0.1
   */
  grain?: number;
  /**
   * Size of generated grain
   * @minimum 0
   * @maximum 5
   */
  grainSize?: number;
  /**
   * Amount of halo reduction
   * @minimum -1
   * @maximum 1
   */
  halo?: number;
  /** Set to true for Starlight Creative (slc-1) only */
  isOptimizedMode?: boolean;
  /** Short code name for AI model */
  model: TopazVideoEnhancementFilterModel;
  /**
   * Amount of noise reduction
   * @minimum -1
   * @maximum 1
   */
  noise?: number;
  /**
   * Adjust anti-aliasing and deblurring strength
   * @minimum -1
   * @maximum 1
   */
  preblur?: number;
  /**
   * Adds noise to input to reduce over-smoothing
   * @minimum 0
   * @maximum 0.1
   */
  prenoise?: number;
  /**
   * Reintroduce source details into the output video
   * @minimum 0
   * @maximum 1
   */
  recoverOriginalDetailValue?: number;
  /** Frame/field type of the video */
  videoType?: TopazVideoEnhancementFilterVideoType;
}

/**
 * Short code name for AI model
 */
export type TopazVideoFrameInterpolationFilterModel = typeof TopazVideoFrameInterpolationFilterModel[keyof typeof TopazVideoFrameInterpolationFilterModel];


export const TopazVideoFrameInterpolationFilterModel = {
  'aion-1': 'aion-1',
  'apf-2': 'apf-2',
  'apo-8': 'apo-8',
  'chf-3': 'chf-3',
  'chr-2': 'chr-2',
} as const;

export interface TopazVideoFrameInterpolationFilter {
  /** Analyze input for duplicate frames and remove them */
  duplicate?: boolean;
  /**
   * Sensitivity of detection for duplicate frames
   * @minimum 0.001
   * @maximum 0.1
   */
  duplicateThreshold?: number;
  /**
   * Output frame rate, does not increase duration
   * @minimum 15
   * @maximum 240
   */
  fps?: number;
  /** Short code name for AI model */
  model: TopazVideoFrameInterpolationFilterModel;
  /**
   * Slow motion factor applied to input video
   * @minimum 1
   * @maximum 16
   */
  slowmo?: number;
}

/**
 * Array of EnhancementFilter or FrameInterpolationFilter objects
 */
export type TopazInputFilters = (TopazVideoEnhancementFilter | TopazVideoFrameInterpolationFilter)[];

/**
 * __Required if audioTransfer is Copy or Convert.__
 */
export type TopazOutputInformationVideoAudioCodec = typeof TopazOutputInformationVideoAudioCodec[keyof typeof TopazOutputInformationVideoAudioCodec];


export const TopazOutputInformationVideoAudioCodec = {
  AAC: 'AAC',
  AC3: 'AC3',
  PCM: 'PCM',
} as const;

export type TopazOutputInformationVideoAudioTransfer = typeof TopazOutputInformationVideoAudioTransfer[keyof typeof TopazOutputInformationVideoAudioTransfer];


export const TopazOutputInformationVideoAudioTransfer = {
  Copy: 'Copy',
  Convert: 'Convert',
  None: 'None',
} as const;

/**
 * Desired output container
 */
export type TopazOutputInformationVideoContainer = typeof TopazOutputInformationVideoContainer[keyof typeof TopazOutputInformationVideoContainer];


export const TopazOutputInformationVideoContainer = {
  mp4: 'mp4',
  mov: 'mov',
  mkv: 'mkv',
} as const;

/**
 * __Required if videoBitrate is not provided.__ Automatic CQP selection.
 */
export type TopazOutputInformationVideoDynamicCompressionLevel = typeof TopazOutputInformationVideoDynamicCompressionLevel[keyof typeof TopazOutputInformationVideoDynamicCompressionLevel];


export const TopazOutputInformationVideoDynamicCompressionLevel = {
  Low: 'Low',
  Mid: 'Mid',
  High: 'High',
} as const;

export type TopazOutputInformationVideoVideoEncoder = typeof TopazOutputInformationVideoVideoEncoder[keyof typeof TopazOutputInformationVideoVideoEncoder];


export const TopazOutputInformationVideoVideoEncoder = {
  AV1: 'AV1',
  FFV1: 'FFV1',
  H264: 'H264',
  H265: 'H265',
  ProRes: 'ProRes',
  QuickTime_Animation: 'QuickTime Animation',
  QuickTime_R210: 'QuickTime R210',
  QuickTime_V210: 'QuickTime V210',
  VP9: 'VP9',
} as const;

/**
 * Desired output resolution
 */
export type TopazOutputInformationVideoResolution = {
  /** Height in pixels. The maximum size depends on the encoder and can be referenced using the table below <table> <tr> <td>H264</td> <td>H265</td> <td>ProRes <td>AV1 <td>VP9 </tr> <tr> <td>4096</td> <td>8192</td> <td>16386</td> <td>8704</td> <td>8192</td> </tr> </table> */
  height: number;
  /** Width in pixels. The maximum size depends on the encoder and can be referenced using the table below <table> <tr> <td>H264</td> <td>H265</td> <td>ProRes <td>AV1 <td>VP9 </tr> <tr> <td>4096</td> <td>8192</td> <td>16386</td> <td>16384</td> <td>8192</td> </tr> </table> */
  width: number;
};

export interface TopazOutputInformationVideo {
  /** Audio bitrate, if audioTransfer is Copy or Convert. Default values for the codec are used if not provided. */
  audioBitrate?: string;
  /** __Required if audioTransfer is Copy or Convert.__ */
  audioCodec: TopazOutputInformationVideoAudioCodec;
  audioTransfer: TopazOutputInformationVideoAudioTransfer;
  /** Video codec ID, if known. Defaults to videoEncoder. */
  codecId?: string;
  /** Desired output container */
  container?: TopazOutputInformationVideoContainer;
  /** Center cropping to fit the output dimensions */
  cropToFit?: boolean;
  /** __Required if videoBitrate is not provided.__ Automatic CQP selection. */
  dynamicCompressionLevel?: TopazOutputInformationVideoDynamicCompressionLevel;
  /** Frame rate */
  frameRate: number;
  /** Desired output resolution */
  resolution: TopazOutputInformationVideoResolution;
  /** __Required if dynamicCompressionLevel is not provided.__ Constant bitrate, suffixed with "k" for kilobits or "m" for megabits per second. */
  videoBitrate?: string;
  videoEncoder?: TopazOutputInformationVideoVideoEncoder;
  /** Codec profile specific to videoEncoder. The following are some combinations of available profiles based on the 'videoEncoder' selection <table> <tr> <td>H264</td> <td>H265</td> <td>ProRes <td>AV1 <td>VP9 </tr> <tr> <td>High</td> <td>Main, Main10</td> <td>422 Proxy, 422 LT, 422 Std, 422 HQ</td> <td>8-bit, 10-bit</td> <td>Good, Best</td> </tr> </table> */
  videoProfile?: string;
}

/**
 * The container format of the video file
 */
export type TopazCreateRequestVideoSchemaSourceContainer = typeof TopazCreateRequestVideoSchemaSourceContainer[keyof typeof TopazCreateRequestVideoSchemaSourceContainer];


export const TopazCreateRequestVideoSchemaSourceContainer = {
  mp4: 'mp4',
  mov: 'mov',
  mkv: 'mkv',
} as const;

export type TopazCreateRequestVideoSchemaDestination = {
  external?: TopazExternalStorage;
};

export type TopazCreateRequestVideoSchemaOverrides = {
  isPaidDiffusion?: boolean;
};

/**
 * Resolution details of the video
 */
export type TopazCreateRequestVideoSchemaSourceResolution = {
  /** Height of the video in pixels */
  height: number;
  /** Width of the video in pixels */
  width: number;
};

/**
 * Source details for the video
 */
export type TopazCreateRequestVideoSchemaSource = {
  /** The container format of the video file */
  container: TopazCreateRequestVideoSchemaSourceContainer;
  /** Duration of the video file in seconds */
  duration: number;
  external?: TopazExternalStorage;
  /** Total number of frames in the video */
  frameCount: number;
  /** Frame rate of the video */
  frameRate: number;
  /** Resolution details of the video */
  resolution: TopazCreateRequestVideoSchemaSourceResolution;
  /** Size of the video file in bytes */
  size: number;
};

export interface TopazCreateRequestVideoSchema {
  destination?: TopazCreateRequestVideoSchemaDestination;
  filters: TopazInputFilters;
  output: TopazOutputInformationVideo;
  overrides?: TopazCreateRequestVideoSchemaOverrides;
  /** Source details for the video */
  source: TopazCreateRequestVideoSchemaSource;
}

/**
 * Desired output container, defaults to the input container
 */
export type TopazOutputInformationImageSequenceContainer = typeof TopazOutputInformationImageSequenceContainer[keyof typeof TopazOutputInformationImageSequenceContainer];


export const TopazOutputInformationImageSequenceContainer = {
  DPX: 'DPX',
  EXR: 'EXR',
  JPEG: 'JPEG',
  PNG: 'PNG',
  TIFF: 'TIFF',
} as const;

export type TopazOutputInformationImageSequenceVideoEncoder = typeof TopazOutputInformationImageSequenceVideoEncoder[keyof typeof TopazOutputInformationImageSequenceVideoEncoder];


export const TopazOutputInformationImageSequenceVideoEncoder = {
  DPX: 'DPX',
  EXR: 'EXR',
  JPEG: 'JPEG',
  PNG: 'PNG',
  TIFF: 'TIFF',
} as const;

/**
 * Desired output resolution
 */
export type TopazOutputInformationImageSequenceResolution = {
  /** Height in pixels. The maximum size depends on the encoder and can be referenced using the table below <table> <tr> <td>H264</td> <td>H265</td> <td>ProRes <td>AV1 <td>VP9 </tr> <tr> <td>4096</td> <td>8192</td> <td>16386</td> <td>8704</td> <td>8192</td> </tr> </table> */
  height: number;
  /** Width in pixels. The maximum size depends on the encoder and can be referenced using the table below <table> <tr> <td>H264</td> <td>H265</td> <td>ProRes <td>AV1 <td>VP9 </tr> <tr> <td>4096</td> <td>8192</td> <td>16386</td> <td>16384</td> <td>8192</td> </tr> </table> */
  width: number;
};

export interface TopazOutputInformationImageSequence {
  /** Video codec ID, if known. Defaults to videoEncoder. */
  codecId?: string;
  /** Desired output container, defaults to the input container */
  container?: TopazOutputInformationImageSequenceContainer;
  /** Center cropping to fit the output dimensions */
  cropToFit?: boolean;
  /** Frame rate */
  frameRate: number;
  /** Desired output resolution */
  resolution: TopazOutputInformationImageSequenceResolution;
  videoEncoder?: TopazOutputInformationImageSequenceVideoEncoder;
  /** Codec profile specific to videoEncoder */
  videoProfile?: string;
}

/**
 * The container format of the image files
 */
export type TopazCreateRequestImageSequenceSchemaSourceContainer = typeof TopazCreateRequestImageSequenceSchemaSourceContainer[keyof typeof TopazCreateRequestImageSequenceSchemaSourceContainer];


export const TopazCreateRequestImageSequenceSchemaSourceContainer = {
  DPX: 'DPX',
  EXR: 'EXR',
  JPEG: 'JPEG',
  PNG: 'PNG',
  TIFF: 'TIFF',
} as const;

export type TopazCreateRequestImageSequenceSchemaDestination = {
  external?: TopazExternalStorage;
};

/**
 * Resolution details of the image
 */
export type TopazCreateRequestImageSequenceSchemaSourceResolution = {
  /** Height of the image in pixels */
  height: number;
  /** Width of the image in pixels */
  width: number;
};

/**
 * Source details for the video
 */
export type TopazCreateRequestImageSequenceSchemaSource = {
  /** The container format of the image files */
  container: TopazCreateRequestImageSequenceSchemaSourceContainer;
  /** Optional ending frame number for image sequences */
  endNumber?: number;
  external: TopazExternalStorage;
  /** Total number of frames in the video, in this case, equal to the number of image files. */
  frameCount: number;
  /** Frame rate of the video */
  frameRate: number;
  /** Resolution details of the image */
  resolution: TopazCreateRequestImageSequenceSchemaSourceResolution;
  /** Optional starting frame number for image sequences */
  startNumber?: number;
};

export interface TopazCreateRequestImageSequenceSchema {
  destination: TopazCreateRequestImageSequenceSchemaDestination;
  filters: TopazInputFilters;
  output: TopazOutputInformationImageSequence;
  /** Source details for the video */
  source: TopazCreateRequestImageSequenceSchemaSource;
}

export type TopazCombinedCreateRequest = TopazCreateRequestVideoSchema | TopazCreateRequestImageSequenceSchema;

export interface TopazDownloadResponse {
  /** Presigned URL to download the image */
  download_url: string;
  /** Expiration time of the presigned URLs in Unix timestamp */
  expiry: number;
  /** Presigned URL to get image metadata */
  head_url?: string;
}

/**
 * To preserve the original color - available for Reimagine only (must be string "true" or "false" due to Topaz API requirement)
 */
export type TopazEnhanceGenRequestColorPreservation = typeof TopazEnhanceGenRequestColorPreservation[keyof typeof TopazEnhanceGenRequestColorPreservation];


export const TopazEnhanceGenRequestColorPreservation = {
  true: 'true',
  false: 'false',
} as const;

/**
 * To preserve the identity of characters - available for Reimagine only (must be string "true" or "false" due to Topaz API requirement)
 */
export type TopazEnhanceGenRequestFacePreservation = typeof TopazEnhanceGenRequestFacePreservation[keyof typeof TopazEnhanceGenRequestFacePreservation];


export const TopazEnhanceGenRequestFacePreservation = {
  true: 'true',
  false: 'false',
} as const;

/**
 * The model to use for processing the image (Bloom - Creative Upscale)
 */
export type TopazEnhanceGenRequestModel = typeof TopazEnhanceGenRequestModel[keyof typeof TopazEnhanceGenRequestModel];


export const TopazEnhanceGenRequestModel = {
  Reimagine: 'Reimagine',
} as const;

/**
 * The desired format of the output image
 */
export type TopazEnhanceGenRequestOutputFormat = typeof TopazEnhanceGenRequestOutputFormat[keyof typeof TopazEnhanceGenRequestOutputFormat];


export const TopazEnhanceGenRequestOutputFormat = {
  jpeg: 'jpeg',
  jpg: 'jpg',
  png: 'png',
  tiff: 'tiff',
  tif: 'tif',
} as const;

/**
 * Specifies whether you want to detect all subjects in the image, only the foreground subject, or only the background for the AI model to run on
 */
export type TopazEnhanceGenRequestSubjectDetection = typeof TopazEnhanceGenRequestSubjectDetection[keyof typeof TopazEnhanceGenRequestSubjectDetection];


export const TopazEnhanceGenRequestSubjectDetection = {
  All: 'All',
  Foreground: 'Foreground',
  Background: 'Background',
} as const;

export interface TopazEnhanceGenRequest {
  /** To preserve the original color - available for Reimagine only (must be string "true" or "false" due to Topaz API requirement) */
  color_preservation?: TopazEnhanceGenRequestColorPreservation;
  /**
   * Creativity settings range from 1 to 9 -  - available for Reimagine only
   * @minimum 1
   * @maximum 9
   */
  creativity?: number;
  /** Default behavior is to letterbox the image if a differing aspect ratio is chosen. Enable crop_to_fill by setting this to true if you instead want to crop the image to fill the dimensions */
  crop_to_fill?: boolean;
  /** By default, faces (if any) are enhanced during image processing as well. Set face_enhancement to false if you don't want this */
  face_enhancement?: boolean;
  /**
   * Choose the level of creativity for face enhancement from 0 to 1. Defaults to 0, and is ignored if face_enhancement is false
   * @minimum 0
   * @maximum 1
   */
  face_enhancement_creativity?: number;
  /**
   * Control how sharp the enhanced faces are relative to the background from 0 to 1. Defaults to 0.8, and is ignored if face_enhancement is false
   * @minimum 0
   * @maximum 1
   */
  face_enhancement_strength?: number;
  /** To preserve the identity of characters - available for Reimagine only (must be string "true" or "false" due to Topaz API requirement) */
  face_preservation?: TopazEnhanceGenRequestFacePreservation;
  /** The image file to be processed. Supported formats - jpeg (or jpg), png, tiff (or tif) */
  image?: string;
  /** The model to use for processing the image (Bloom - Creative Upscale) */
  model: TopazEnhanceGenRequestModel;
  /** The desired format of the output image */
  output_format?: TopazEnhanceGenRequestOutputFormat;
  /**
   * The desired height of the output image in pixels
   * @minimum 1
   * @maximum 32000
   */
  output_height?: number;
  /**
   * The desired width of the output image in pixels
   * @minimum 1
   * @maximum 32000
   */
  output_width?: number;
  /** Text prompt for creative upscaling guidance - available for Reimagine only */
  prompt?: string;
  /** Unique identifier of the source image */
  source_id?: string;
  /** The URL of the source image */
  source_url?: string;
  /** Specifies whether you want to detect all subjects in the image, only the foreground subject, or only the background for the AI model to run on */
  subject_detection?: TopazEnhanceGenRequestSubjectDetection;
}

export interface TopazEnhanceGenResponse {
  /** Expected completion time in Unix timestamp */
  eta: number;
  /** Unique identifier for the processing job */
  process_id: string;
  /** Unique identifier of the source image */
  source_id?: string;
}

/**
 * Current status of the processing job
 */
export type TopazStatusResponseStatus = typeof TopazStatusResponseStatus[keyof typeof TopazStatusResponseStatus];


export const TopazStatusResponseStatus = {
  Pending: 'Pending',
  Processing: 'Processing',
  Completed: 'Completed',
  Failed: 'Failed',
  Cancelled: 'Cancelled',
} as const;

export interface TopazStatusResponse {
  /** Processing category (e.g., "Enhance") */
  category?: string;
  /** Creation time in Unix timestamp */
  creation_time?: number;
  /** Credits consumed for this job */
  credits: number;
  /** Whether crop to fill is enabled */
  crop_to_fill?: boolean;
  /** Expected completion time in Unix timestamp */
  eta?: number;
  /** Whether face enhancement is enabled */
  face_enhancement?: boolean;
  /** Face enhancement creativity level */
  face_enhancement_creativity?: number;
  /** Face enhancement strength level */
  face_enhancement_strength?: number;
  /** Original filename without extension */
  filename?: string;
  /** Format of the input image */
  input_format?: string;
  /** Height of the input image in pixels */
  input_height?: number;
  /** Width of the input image in pixels */
  input_width?: number;
  /** Specific model used (e.g., "Reimagine") */
  model?: string;
  /** Type of model used (e.g., "Generative") */
  model_type?: string;
  /** Last modification time in Unix timestamp */
  modification_time?: number;
  /** JSON string containing additional options */
  options_json?: string;
  /** Format of the output image */
  output_format?: string;
  /** Height of the output image in pixels */
  output_height?: number;
  /** Width of the output image in pixels */
  output_width?: number;
  /** Unique identifier for the processing job */
  process_id: string;
  /**
   * Progress percentage (0-100)
   * @minimum 0
   * @maximum 100
   */
  progress?: number;
  /** Unique identifier of the source image */
  source_id?: string;
  /** Current status of the processing job */
  status: TopazStatusResponseStatus;
  /** Subject detection setting */
  subject_detection?: string;
  /** Whether this was a synchronous request */
  sync?: boolean;
}

export interface TopazVideoAcceptResponse {
  /** Response message */
  message?: string;
  /** Upload ID for completing multi-part upload */
  uploadId: string;
  /** URLs to PUT the parts to */
  urls: string[];
}

export type TopazVideoCompleteUploadRequestUploadResultsItem = {
  /** eTag value returned by S3 upon upload of the part */
  eTag: string;
  /** Part number of the uploaded part, starting from 1 */
  partNum: number;
};

export interface TopazVideoCompleteUploadRequest {
  /** MD5 hash of the source video file in hex */
  md5Hash?: string;
  /** An array of part number and ETag pairs of the uploaded parts. ETags are returned by S3 upon upload of the part. */
  uploadResults: TopazVideoCompleteUploadRequestUploadResultsItem[];
}

export interface TopazVideoCompleteUploadResponse {
  /** Confirmation message */
  message: string;
}

export type TopazVideoCreateRequest = TopazCreateRequestVideoSchema | TopazCreateRequestImageSequenceSchema;

/**
 * Lower and upper bound estimates
 */
export interface TopazVideoRequestEstimates {
  /** Cost range in credits */
  cost?: number[];
  /** Time range in seconds */
  time?: number[];
}

export interface TopazVideoCreateResponse {
  estimates: TopazVideoRequestEstimates;
  /** Unique identifier for the video processing request */
  requestId: string;
}

/**
 * Signed download URL to the enhanced video file
 */
export interface TopazVideoEnhancedDownload {
  /** Time in milliseconds since UTC epoch */
  expiresAt?: number;
  /** TTL in milliseconds */
  expiresIn?: number;
  url?: string;
}

/**
 * Current status of the video processing
 */
export type TopazVideoStatusResponseStatus = typeof TopazVideoStatusResponseStatus[keyof typeof TopazVideoStatusResponseStatus];


export const TopazVideoStatusResponseStatus = {
  requested: 'requested',
  accepted: 'accepted',
  initializing: 'initializing',
  preprocessing: 'preprocessing',
  processing: 'processing',
  postprocessing: 'postprocessing',
  complete: 'complete',
  canceling: 'canceling',
  canceled: 'canceled',
  failed: 'failed',
} as const;

export interface TopazVideoStatusResponse {
  /** Average processing speed of each node */
  averageFps?: number;
  /** Combined processing speed of all nodes */
  combinedFps?: number;
  download?: TopazVideoEnhancedDownload;
  estimates?: TopazVideoRequestEstimates;
  message?: string;
  /** Size of output video */
  outputSize?: string;
  /**
   * Total progress percentage
   * @minimum 0
   * @maximum 100
   */
  progress?: number;
  /** Current status of the video processing */
  status: TopazVideoStatusResponseStatus;
}

export type TripoAnimation = typeof TripoAnimation[keyof typeof TripoAnimation];


export const TripoAnimation = {
  'preset:idle': 'preset:idle',
  'preset:walk': 'preset:walk',
  'preset:climb': 'preset:climb',
  'preset:jump': 'preset:jump',
  'preset:run': 'preset:run',
  'preset:slash': 'preset:slash',
  'preset:shoot': 'preset:shoot',
  'preset:hurt': 'preset:hurt',
  'preset:fall': 'preset:fall',
  'preset:turn': 'preset:turn',
} as const;

export interface TripoBalance {
  balance: number;
  frozen: number;
}

export type TripoConvertFormat = typeof TripoConvertFormat[keyof typeof TripoConvertFormat];


export const TripoConvertFormat = {
  GLTF: 'GLTF',
  USDZ: 'USDZ',
  FBX: 'FBX',
  OBJ: 'OBJ',
  STL: 'STL',
  '3MF': '3MF',
} as const;

export type TripoErrorResponseCode = typeof TripoErrorResponseCode[keyof typeof TripoErrorResponseCode];


export const TripoErrorResponseCode = {
  NUMBER_1001: 1001,
  NUMBER_2000: 2000,
  NUMBER_2001: 2001,
  NUMBER_2002: 2002,
  NUMBER_2003: 2003,
  NUMBER_2004: 2004,
  NUMBER_2006: 2006,
  NUMBER_2007: 2007,
  NUMBER_2008: 2008,
  NUMBER_2010: 2010,
} as const;

export interface TripoErrorResponse {
  code: TripoErrorResponseCode;
  message: string;
  suggestion: string;
}

export type TripoGeometryQuality = typeof TripoGeometryQuality[keyof typeof TripoGeometryQuality];


export const TripoGeometryQuality = {
  standard: 'standard',
  detailed: 'detailed',
} as const;

/**
 * Task type for Tripo image-to-model generation.
 */
export type TripoImageToModel = typeof TripoImageToModel[keyof typeof TripoImageToModel];


export const TripoImageToModel = {
  image_to_model: 'image_to_model',
} as const;

/**
 * Style for the Tripo model generation.
 */
export type TripoModelStyle = typeof TripoModelStyle[keyof typeof TripoModelStyle];


export const TripoModelStyle = {
  'person:person2cartoon': 'person:person2cartoon',
  'animal:venom': 'animal:venom',
  'object:clay': 'object:clay',
  'object:steampunk': 'object:steampunk',
  'object:christmas': 'object:christmas',
  'object:barbie': 'object:barbie',
  gold: 'gold',
  ancient_bronze: 'ancient_bronze',
} as const;

/**
 * Version of the Tripo model.
 */
export type TripoModelVersion = typeof TripoModelVersion[keyof typeof TripoModelVersion];


export const TripoModelVersion = {
  'v25-20250123': 'v2.5-20250123',
  'v20-20240919': 'v2.0-20240919',
  'v14-20240625': 'v1.4-20240625',
} as const;

/**
 * Mode for multiview generation, specifying view orientation.
 */
export type TripoMultiviewMode = typeof TripoMultiviewMode[keyof typeof TripoMultiviewMode];


export const TripoMultiviewMode = {
  LEFT: 'LEFT',
  RIGHT: 'RIGHT',
} as const;

/**
 * Task type for Tripo multiview-to-model generation.
 */
export type TripoMultiviewToModel = typeof TripoMultiviewToModel[keyof typeof TripoMultiviewToModel];


export const TripoMultiviewToModel = {
  multiview_to_model: 'multiview_to_model',
} as const;

export type TripoOrientation = typeof TripoOrientation[keyof typeof TripoOrientation];


export const TripoOrientation = {
  align_image: 'align_image',
  default: 'default',
} as const;

/**
 * Standard success code for Tripo API responses. Typically 0 for success.
 */
export type TripoResponseSuccessCode = number;

export type TripoSpec = typeof TripoSpec[keyof typeof TripoSpec];


export const TripoSpec = {
  mixamo: 'mixamo',
  tripo: 'tripo',
} as const;

export type TripoStandardFormat = typeof TripoStandardFormat[keyof typeof TripoStandardFormat];


export const TripoStandardFormat = {
  glb: 'glb',
  fbx: 'fbx',
} as const;

export type TripoStylizeOptions = typeof TripoStylizeOptions[keyof typeof TripoStylizeOptions];


export const TripoStylizeOptions = {
  lego: 'lego',
  voxel: 'voxel',
  voronoi: 'voronoi',
  minecraft: 'minecraft',
} as const;

export type TripoSuccessTaskCode = typeof TripoSuccessTaskCode[keyof typeof TripoSuccessTaskCode];


export const TripoSuccessTaskCode = {
  NUMBER_0: 0,
} as const;

export type TripoSuccessTaskData = {
  /** used for getTask */
  task_id: string;
};

export interface TripoSuccessTask {
  code: TripoSuccessTaskCode;
  data: TripoSuccessTaskData;
}

export type TripoTaskInput = { [key: string]: unknown };

export type TripoTaskOutputTopology = typeof TripoTaskOutputTopology[keyof typeof TripoTaskOutputTopology];


export const TripoTaskOutputTopology = {
  bip: 'bip',
  quad: 'quad',
} as const;

export type TripoTaskOutput = {
  base_model?: string;
  model?: string;
  pbr_model?: string;
  rendered_image?: string;
  riggable?: boolean;
  topology?: TripoTaskOutputTopology;
};

export type TripoTaskStatus = typeof TripoTaskStatus[keyof typeof TripoTaskStatus];


export const TripoTaskStatus = {
  queued: 'queued',
  running: 'running',
  success: 'success',
  failed: 'failed',
  cancelled: 'cancelled',
  unknown: 'unknown',
  banned: 'banned',
  expired: 'expired',
} as const;

export interface TripoTask {
  create_time: number;
  input: TripoTaskInput;
  output: TripoTaskOutput;
  /**
   * @minimum 0
   * @maximum 100
   */
  progress: number;
  status: TripoTaskStatus;
  task_id: string;
  type: string;
}

/**
 * The type of the Tripo task, specifically for text-to-model operations.
 */
export type TripoTextToModel = typeof TripoTextToModel[keyof typeof TripoTextToModel];


export const TripoTextToModel = {
  text_to_model: 'text_to_model',
} as const;

export type TripoTextureAlignment = typeof TripoTextureAlignment[keyof typeof TripoTextureAlignment];


export const TripoTextureAlignment = {
  original_image: 'original_image',
  geometry: 'geometry',
} as const;

export type TripoTextureFormat = typeof TripoTextureFormat[keyof typeof TripoTextureFormat];


export const TripoTextureFormat = {
  BMP: 'BMP',
  DPX: 'DPX',
  HDR: 'HDR',
  JPEG: 'JPEG',
  OPEN_EXR: 'OPEN_EXR',
  PNG: 'PNG',
  TARGA: 'TARGA',
  TIFF: 'TIFF',
  WEBP: 'WEBP',
} as const;

export type TripoTextureQuality = typeof TripoTextureQuality[keyof typeof TripoTextureQuality];


export const TripoTextureQuality = {
  standard: 'standard',
  detailed: 'detailed',
} as const;

export type TripoTopology = typeof TripoTopology[keyof typeof TripoTopology];


export const TripoTopology = {
  bip: 'bip',
  quad: 'quad',
} as const;

export type TripoTypeAnimatePrerigcheck = typeof TripoTypeAnimatePrerigcheck[keyof typeof TripoTypeAnimatePrerigcheck];


export const TripoTypeAnimatePrerigcheck = {
  animate_prerigcheck: 'animate_prerigcheck',
} as const;

export type TripoTypeAnimateRetarget = typeof TripoTypeAnimateRetarget[keyof typeof TripoTypeAnimateRetarget];


export const TripoTypeAnimateRetarget = {
  animate_retarget: 'animate_retarget',
} as const;

export type TripoTypeAnimateRig = typeof TripoTypeAnimateRig[keyof typeof TripoTypeAnimateRig];


export const TripoTypeAnimateRig = {
  animate_rig: 'animate_rig',
} as const;

export type TripoTypeConvertModel = typeof TripoTypeConvertModel[keyof typeof TripoTypeConvertModel];


export const TripoTypeConvertModel = {
  convert_model: 'convert_model',
} as const;

export type TripoTypeRefineModel = typeof TripoTypeRefineModel[keyof typeof TripoTypeRefineModel];


export const TripoTypeRefineModel = {
  refine_model: 'refine_model',
} as const;

export type TripoTypeStylizeModel = typeof TripoTypeStylizeModel[keyof typeof TripoTypeStylizeModel];


export const TripoTypeStylizeModel = {
  stylize_model: 'stylize_model',
} as const;

export type TripoTypeTextureModel = typeof TripoTypeTextureModel[keyof typeof TripoTypeTextureModel];


export const TripoTypeTextureModel = {
  texture_model: 'texture_model',
} as const;

/**
 * Set of key-value pairs for storing additional information
 */
export type UpdateCouponRequestMetadata = {[key: string]: string};

export interface UpdateCouponRequest {
  /** Set of key-value pairs for storing additional information */
  metadata?: UpdateCouponRequestMetadata;
  /** Name of the coupon displayed to customers */
  name?: string;
}

/**
 * Set of key-value pairs for storing additional information
 */
export type UpdatePromoCodeRequestMetadata = {[key: string]: string};

export interface UpdatePromoCodeRequest {
  /** Whether the promo code is active */
  active?: boolean;
  /** Set of key-value pairs for storing additional information */
  metadata?: UpdatePromoCodeRequestMetadata;
}

export interface User {
  /** The email address for this user. */
  email?: string;
  /** The unique id for this user. */
  id?: string;
  /** Indicates if the user has admin privileges. */
  isAdmin?: boolean;
  /** Indicates if the user is approved. */
  isApproved?: boolean;
  /** The name for this user. */
  name?: string;
}

export interface Veo2GenVidPollRequest {
  /** Full operation name (from predict response) */
  operationName: string;
}

/**
 * Error details if operation failed
 */
export type Veo2GenVidPollResponseError = {
  /** Error code */
  code?: number;
  /** Error message */
  message?: string;
};

export type Veo2GenVidPollResponseResponseVideosItem = {
  /** Base64-encoded video content */
  bytesBase64Encoded?: string;
  /** Cloud Storage URI of the video */
  gcsUri?: string;
  /** Video MIME type */
  mimeType?: string;
};

/**
 * The actual prediction response if done is true
 */
export type Veo2GenVidPollResponseResponse = {
  '@type'?: string;
  /** Count of media filtered by responsible AI policies */
  raiMediaFilteredCount?: number;
  /** Reasons why media was filtered by responsible AI policies */
  raiMediaFilteredReasons?: string[];
  videos?: Veo2GenVidPollResponseResponseVideosItem[];
};

export interface Veo2GenVidPollResponse {
  done?: boolean;
  /** Error details if operation failed */
  error?: Veo2GenVidPollResponseError;
  name?: string;
  /** The actual prediction response if done is true */
  response?: Veo2GenVidPollResponseResponse;
}

/**
 * Optional image to guide video generation
 */
export type Veo2GenVidRequestInstancesItemImage = (unknown & {
  bytesBase64Encoded?: string;
  gcsUri?: string;
  mimeType?: string;
});

export type Veo2GenVidRequestInstancesItem = {
  /** Optional image to guide video generation */
  image?: Veo2GenVidRequestInstancesItemImage;
  /** Text description of the video */
  prompt: string;
};

export type Veo2GenVidRequestParametersPersonGeneration = typeof Veo2GenVidRequestParametersPersonGeneration[keyof typeof Veo2GenVidRequestParametersPersonGeneration];


export const Veo2GenVidRequestParametersPersonGeneration = {
  ALLOW: 'ALLOW',
  BLOCK: 'BLOCK',
} as const;

export type Veo2GenVidRequestParameters = {
  aspectRatio?: string;
  durationSeconds?: number;
  enhancePrompt?: boolean;
  negativePrompt?: string;
  personGeneration?: Veo2GenVidRequestParametersPersonGeneration;
  sampleCount?: number;
  seed?: number;
  /** Optional Cloud Storage URI to upload the video */
  storageUri?: string;
};

export interface Veo2GenVidRequest {
  instances?: Veo2GenVidRequestInstancesItem[];
  parameters?: Veo2GenVidRequestParameters;
}

export interface Veo2GenVidResponse {
  /** Operation resource name */
  name: string;
}

export interface VeoGenVidPollRequest {
  /** Full operation name (from predict response) */
  operationName: string;
}

/**
 * Error details if operation failed
 */
export type VeoGenVidPollResponseError = {
  /** Error code */
  code?: number;
  /** Error message */
  message?: string;
};

export type VeoGenVidPollResponseResponseVideosItem = {
  /** Base64-encoded video content */
  bytesBase64Encoded?: string;
  /** Cloud Storage URI of the video */
  gcsUri?: string;
  /** Video MIME type */
  mimeType?: string;
};

/**
 * The actual prediction response if done is true
 */
export type VeoGenVidPollResponseResponse = {
  '@type'?: string;
  /** Count of media filtered by responsible AI policies */
  raiMediaFilteredCount?: number;
  /** Reasons why media was filtered by responsible AI policies */
  raiMediaFilteredReasons?: string[];
  videos?: VeoGenVidPollResponseResponseVideosItem[];
};

export interface VeoGenVidPollResponse {
  done?: boolean;
  /** Error details if operation failed */
  error?: VeoGenVidPollResponseError;
  name?: string;
  /** The actual prediction response if done is true */
  response?: VeoGenVidPollResponseResponse;
}

/**
 * Optional image to guide video generation
 */
export type VeoGenVidRequestInstancesItemImage = (unknown & {
  bytesBase64Encoded?: string;
  gcsUri?: string;
  mimeType?: string;
});

/**
 * Optional last frame image to guide video generation
 */
export type VeoGenVidRequestInstancesItemLastFrame = (unknown & {
  bytesBase64Encoded?: string;
  gcsUri?: string;
  mimeType?: string;
});

export type VeoGenVidRequestInstancesItem = {
  /** Optional image to guide video generation */
  image?: VeoGenVidRequestInstancesItemImage;
  /** Optional last frame image to guide video generation */
  lastFrame?: VeoGenVidRequestInstancesItemLastFrame;
  /** Text description of the video */
  prompt: string;
};

export type VeoGenVidRequestParametersPersonGeneration = typeof VeoGenVidRequestParametersPersonGeneration[keyof typeof VeoGenVidRequestParametersPersonGeneration];


export const VeoGenVidRequestParametersPersonGeneration = {
  ALLOW: 'ALLOW',
  BLOCK: 'BLOCK',
} as const;

export type VeoGenVidRequestParameters = {
  aspectRatio?: string;
  durationSeconds?: number;
  enhancePrompt?: boolean;
  /** Generate audio for the video. Only supported by veo 3 models. */
  generateAudio?: boolean;
  negativePrompt?: string;
  personGeneration?: VeoGenVidRequestParametersPersonGeneration;
  sampleCount?: number;
  seed?: number;
  /** Optional Cloud Storage URI to upload the video */
  storageUri?: string;
};

export interface VeoGenVidRequest {
  instances?: VeoGenVidRequestInstancesItem[];
  parameters?: VeoGenVidRequestParameters;
}

export interface VeoGenVidResponse {
  /** Operation resource name */
  name: string;
}

export interface ViduCreation {
  cover_url?: string;
  id?: string;
  moderation_url?: string[];
  url?: string;
  watermarked_url?: string;
}

export type ViduState = typeof ViduState[keyof typeof ViduState];


export const ViduState = {
  created: 'created',
  processing: 'processing',
  queueing: 'queueing',
  success: 'success',
  failed: 'failed',
} as const;

export interface ViduExtendReply {
  created_at?: string;
  credits: number;
  duration?: number;
  images?: string[];
  model?: string;
  payload?: string;
  prompt?: string;
  resolution?: string;
  state: ViduState;
  task_id: string;
  video_creation_id?: string;
  video_url?: string;
}

export interface ViduExtendRequest {
  /** Callback URL for task status updates */
  callback_url?: string;
  /** Extended duration in seconds (1-7, default 5) */
  duration?: number;
  /** Extended reference image to the end frame (only accepts 1 image) */
  images?: string[];
  /** Model name (viduq2-pro or viduq2-turbo) */
  model: string;
  /** Transparent transmission parameters (max 1048576 characters) */
  payload?: string;
  /** Text prompt for video generation (max 2000 characters) */
  prompt?: string;
  /** Resolution (540p, 720p, 1080p) */
  resolution?: string;
  /** Vidu video_creation_id, required with video_url */
  video_creation_id?: string;
  /** Any video URL, required with video_creation_id */
  video_url?: string;
}

export interface ViduGetCreationsReply {
  creations?: ViduCreation[];
  err_code?: string;
  id?: string;
  state?: ViduState;
}

export interface ViduImageSetting {
  /** Duration between key frames in seconds (2-7, default 5) */
  duration?: number;
  /** Reference image for each key frame */
  key_image: string;
  /** Prompt for extending the previous frame */
  prompt?: string;
}

export interface ViduMultiframeReply {
  created_at?: string;
  credits: number;
  image_settings?: ViduImageSetting[];
  model?: string;
  payload?: string;
  resolution?: string;
  start_image?: string;
  state: ViduState;
  task_id: string;
}

export interface ViduMultiframeRequest {
  /** Callback URL for task status updates */
  callback_url?: string;
  /** Configuration for intelligent multi-frame generation (2-9 frames) */
  image_settings: ViduImageSetting[];
  /** Model name (viduq2-pro or viduq2-turbo) */
  model: string;
  /** Transparent transmission parameters (max 1048576 characters) */
  payload?: string;
  /** Video resolution (540p, 720p, 1080p) */
  resolution?: string;
  /** The first frame image (Base64 or URL) */
  start_image: string;
}

export type ViduTaskReplyMovementAmplitude = typeof ViduTaskReplyMovementAmplitude[keyof typeof ViduTaskReplyMovementAmplitude];


export const ViduTaskReplyMovementAmplitude = {
  auto: 'auto',
  small: 'small',
  medium: 'medium',
  large: 'large',
} as const;

export type ViduTaskReplyStyle = typeof ViduTaskReplyStyle[keyof typeof ViduTaskReplyStyle];


export const ViduTaskReplyStyle = {
  general: 'general',
  anime: 'anime',
} as const;

export interface ViduTaskReply {
  aspect_ratio?: string;
  /** Whether background music was added */
  bgm?: boolean;
  created_at?: string;
  credits: number;
  duration?: number;
  images?: string[];
  model?: string;
  movement_amplitude?: ViduTaskReplyMovementAmplitude;
  /** Off peak mode status */
  off_peak?: boolean;
  /** Transparent transmission parameters */
  payload?: string;
  prompt?: string;
  resolution?: string;
  seed?: number;
  state: ViduState;
  style?: ViduTaskReplyStyle;
  task_id: string;
  /** Whether watermark was added */
  watermark?: boolean;
}

/**
 * Audio type when audio is true: all (sound effects + vocals), speech_only, sound_effect_only. Ineffective for q3 model
 */
export type ViduTaskRequestAudioType = typeof ViduTaskRequestAudioType[keyof typeof ViduTaskRequestAudioType];


export const ViduTaskRequestAudioType = {
  all: 'all',
  speech_only: 'speech_only',
  sound_effect_only: 'sound_effect_only',
} as const;

/**
 * Movement amplitude of objects in frame (ineffective for q2, q3 models)
 */
export type ViduTaskRequestMovementAmplitude = typeof ViduTaskRequestMovementAmplitude[keyof typeof ViduTaskRequestMovementAmplitude];


export const ViduTaskRequestMovementAmplitude = {
  auto: 'auto',
  small: 'small',
  medium: 'medium',
  large: 'large',
} as const;

export type ViduTaskRequestStyle = typeof ViduTaskRequestStyle[keyof typeof ViduTaskRequestStyle];


export const ViduTaskRequestStyle = {
  general: 'general',
  anime: 'anime',
} as const;

export interface ViduTaskRequest {
  aspect_ratio?: string;
  /** Enable direct audio-video generation capability (default true for q3 model) */
  audio?: boolean;
  /** Audio type when audio is true: all (sound effects + vocals), speech_only, sound_effect_only. Ineffective for q3 model */
  audio_type?: ViduTaskRequestAudioType;
  /** Add background music to generated video (ineffective for q3 model) */
  bgm?: boolean;
  /** Callback URL for task status updates */
  callback_url?: string;
  /** Video duration in seconds. viduq3-pro: 1-16, viduq2-pro-fast: 1-10, viduq2-pro/turbo: 1-8 */
  duration?: number;
  enhance?: boolean;
  /** Images for img2video (accepts 1 image as start frame) */
  images?: string[];
  /** Use recommended prompt (consumes additional 10 credits) */
  is_rec?: boolean;
  /** Metadata identification, JSON format string for custom metadata */
  meta_data?: string;
  /** Model name: viduq3-pro, viduq2-pro-fast, viduq2-pro, viduq2-turbo, viduq1, viduq1-classic, vidu2.0 */
  model?: string;
  /** Movement amplitude of objects in frame (ineffective for q2, q3 models) */
  movement_amplitude?: ViduTaskRequestMovementAmplitude;
  /** Off peak mode (lower cost, tasks generated within 48 hours) */
  off_peak?: boolean;
  /** Transparent transmission parameters (max 1048576 characters) */
  payload?: string;
  priority?: number;
  /** Text prompt for video generation (max 2000 characters) */
  prompt?: string;
  /** Resolution: 360p, 540p, 720p, 1080p, 2K (availability depends on model and duration) */
  resolution?: string;
  /** Random seed (defaults to random if not specified) */
  seed?: number;
  style?: ViduTaskRequestStyle;
  /** Voice ID for audio (ineffective for q3 model) */
  voice_id?: string;
  /** Add watermark to video (default false) */
  watermark?: boolean;
  /** Watermark position: 1 (top left), 2 (top right), 3 (bottom right, default), 4 (bottom left) */
  wm_position?: number;
  /** Watermark image URL (uses default watermark if not provided) */
  wm_url?: string;
}

/**
 * Enter basic information, such as prompt words, images, etc.
 */
export type WanImage2ImageGenerationRequestInput = {
  /**
   * Array of image URLs for image-to-image generation
   * @minItems 1
   * @maxItems 2
   */
  images: string[];
  /**
   * Reverse prompt words to describe content that you do not want to see in the image
   * @maxLength 500
   */
  negative_prompt?: string;
  /**
   * Positive prompt words to describe expected image elements and visual features. Support Chinese and English, length not exceeding 2000 characters
   * @maxLength 2000
   */
  prompt: string;
};

/**
 * The ID of the model to call for image-to-image generation
 */
export type WanImage2ImageGenerationRequestModel = typeof WanImage2ImageGenerationRequestModel[keyof typeof WanImage2ImageGenerationRequestModel];


export const WanImage2ImageGenerationRequestModel = {
  'wan25-i2i-preview': 'wan2.5-i2i-preview',
} as const;

/**
 * Image processing parameters
 */
export type WanImage2ImageGenerationRequestParameters = {
  /**
   * Number of generated images. Range 1-4, default is 1
   * @minimum 1
   * @maximum 4
   */
  n?: number;
  /**
   * Random number seed to control randomness. Range [0, 2147483647]
   * @minimum 0
   * @maximum 2147483647
   */
  seed?: number;
  /** Output image resolution. Default is 1280*1280. Width and height must be between 384 and 5000 pixels. */
  size?: string;
  /** Whether to add watermark logo in lower right corner */
  watermark?: boolean;
};

export interface WanImage2ImageGenerationRequest {
  /** Enter basic information, such as prompt words, images, etc. */
  input: WanImage2ImageGenerationRequestInput;
  /** The ID of the model to call for image-to-image generation */
  model: WanImage2ImageGenerationRequestModel;
  /** Image processing parameters */
  parameters?: WanImage2ImageGenerationRequestParameters;
}

/**
 * Task status
 */
export type WanImage2ImageGenerationResponseOutputTaskStatus = typeof WanImage2ImageGenerationResponseOutputTaskStatus[keyof typeof WanImage2ImageGenerationResponseOutputTaskStatus];


export const WanImage2ImageGenerationResponseOutputTaskStatus = {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED',
  UNKNOWN: 'UNKNOWN',
} as const;

export type WanImage2ImageGenerationResponseOutput = {
  /** Task ID */
  task_id: string;
  /** Task status */
  task_status: WanImage2ImageGenerationResponseOutputTaskStatus;
};

export interface WanImage2ImageGenerationResponse {
  /** The error code for the failed request (not returned if request is successful) */
  code?: string;
  /** Detailed information about the failed request (not returned if request is successful) */
  message?: string;
  output: WanImage2ImageGenerationResponseOutput;
  /** Unique request identifier */
  request_id: string;
}

/**
 * Enter basic information, such as prompt words, etc.
 */
export type WanImageGenerationRequestInput = {
  /** Reverse prompt words to describe content that you do not want to see in the image */
  negative_prompt?: string;
  /** Positive prompt words to describe expected image elements and visual features. Support Chinese and English, length not exceeding 800 characters */
  prompt: string;
};

/**
 * The ID of the model to call for text-to-image generation
 */
export type WanImageGenerationRequestModel = typeof WanImageGenerationRequestModel[keyof typeof WanImageGenerationRequestModel];


export const WanImageGenerationRequestModel = {
  'wan25-t2i-preview': 'wan2.5-t2i-preview',
} as const;

/**
 * Image processing parameters
 */
export type WanImageGenerationRequestParameters = {
  /**
   * Number of generated images. Range 1-4, default is 4
   * @minimum 1
   * @maximum 4
   */
  n?: number;
  /** Enable prompt intelligent rewriting. Default is true */
  prompt_extend?: boolean;
  /**
   * Random number seed to control randomness. Range [0, 2147483647]
   * @minimum 0
   * @maximum 2147483647
   */
  seed?: number;
  /** Output image resolution. Default is 1024*1024. Pixel range [512, 1440], up to 200 megapixels */
  size?: string;
  /** Whether to add watermark logo in lower right corner */
  watermark?: boolean;
};

export interface WanImageGenerationRequest {
  /** Enter basic information, such as prompt words, etc. */
  input: WanImageGenerationRequestInput;
  /** The ID of the model to call for text-to-image generation */
  model: WanImageGenerationRequestModel;
  /** Image processing parameters */
  parameters?: WanImageGenerationRequestParameters;
}

/**
 * Task status
 */
export type WanImageGenerationResponseOutputTaskStatus = typeof WanImageGenerationResponseOutputTaskStatus[keyof typeof WanImageGenerationResponseOutputTaskStatus];


export const WanImageGenerationResponseOutputTaskStatus = {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED',
  UNKNOWN: 'UNKNOWN',
} as const;

export type WanImageGenerationResponseOutput = {
  /** Task ID */
  task_id: string;
  /** Task status */
  task_status: WanImageGenerationResponseOutputTaskStatus;
};

export interface WanImageGenerationResponse {
  /** The error code for the failed request (not returned if request is successful) */
  code?: string;
  /** Detailed information about the failed request (not returned if request is successful) */
  message?: string;
  output: WanImageGenerationResponseOutput;
  /** Unique request identifier */
  request_id: string;
}

export type WanTaskQueryResponseOutputResultsItem = {
  /** Actual prompt after intelligent rewriting (if enabled) */
  actual_prompt?: string;
  /** Image error code (returned when some tasks fail) */
  code?: string;
  /** Image error information (returned when some tasks fail) */
  message?: string;
  /** Original input prompt */
  orig_prompt?: string;
  /** Generated image URL address */
  url?: string;
};

/**
 * Task result statistics for image generation tasks
 */
export type WanTaskQueryResponseOutputTaskMetrics = {
  /** Number of failed tasks */
  FAILED?: number;
  /** Number of successful tasks */
  SUCCEEDED?: number;
  /** Total number of tasks */
  TOTAL?: number;
};

/**
 * Task status
 */
export type WanTaskQueryResponseOutputTaskStatus = typeof WanTaskQueryResponseOutputTaskStatus[keyof typeof WanTaskQueryResponseOutputTaskStatus];


export const WanTaskQueryResponseOutputTaskStatus = {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED',
  UNKNOWN: 'UNKNOWN',
} as const;

export type WanTaskQueryResponseOutput = {
  /** Actual prompt after intelligent rewriting (for video tasks) */
  actual_prompt?: string;
  /** Audio URL for I2V tasks with audio generation */
  check_audio?: string;
  /** The error code for the failed request (not returned if request is successful) */
  code?: string;
  /** Task completion time */
  end_time?: string;
  /** Detailed information about the failed request (not returned if request is successful) */
  message?: string;
  /** Original input prompt (for video tasks) */
  orig_prompt?: string;
  /** List of task results for image generation tasks */
  results?: WanTaskQueryResponseOutputResultsItem[];
  /** Task execution time */
  scheduled_time?: string;
  /** Task submission time */
  submit_time?: string;
  /** Task ID */
  task_id: string;
  /** Task result statistics for image generation tasks */
  task_metrics?: WanTaskQueryResponseOutputTaskMetrics;
  /** Task status */
  task_status: WanTaskQueryResponseOutputTaskStatus;
  /** Video URL for completed video generation tasks. Link validity period 24 hours */
  video_url?: string;
};

/**
 * Output information statistics. Only successful results are counted
 */
export type WanTaskQueryResponseUsage = {
  /** Video resolution level (I2V tasks) */
  SR?: number;
  /** Duration of generated video in seconds (I2V tasks) */
  duration?: number;
  /** Number of generated images (T2I tasks) */
  image_count?: number;
  /** Image resolution (T2I tasks) */
  size?: string;
  /** Number of generated videos (T2V tasks) */
  video_count?: number;
  /** Duration of generated video in seconds (T2V tasks) */
  video_duration?: number;
  /** Video resolution ratio (T2V tasks) */
  video_ratio?: string;
};

export interface WanTaskQueryResponse {
  output: WanTaskQueryResponseOutput;
  /** Unique request identifier */
  request_id: string;
  /** Output information statistics. Only successful results are counted */
  usage?: WanTaskQueryResponseUsage;
}

/**
 * Enter basic information, such as prompt words, etc.
 */
export type WanVideoGenerationRequestInput = {
  /** Audio file download URL. Supported formats: mp3 and wav. Cannot be used with reference_video_urls. */
  audio_url?: string;
  /** First frame image URL or Base64 encoded data. Required for I2V models. Image formats: JPEG, JPG, PNG, BMP, WEBP. Resolution: 360-2000 pixels. File size: max 10MB. */
  img_url?: string;
  /**
   * Reverse prompt words are used to describe content that you do not want to see in the video screen
   * @maxLength 500
   */
  negative_prompt?: string;
  /**
   * Text prompt words. Support Chinese and English, length not exceeding 800 characters.
For wan2.6-r2v with multiple reference videos, use 'character1', 'character2', etc. to refer to subjects
in the order of reference videos. Example: "Character1 sings on the roadside, Character2 dances beside it"

   * @maxLength 800
   */
  prompt: string;
  /**
   * Reference video URLs for wan2.6-r2v model only. Array of 1-3 video URLs.
Input restrictions:
- Format: mp4, mov
- Quantity: 1-3 videos
- Single video length: 2-30 seconds
- Single file size: max 30MB
- Cannot be used with audio_url
Reference duration: Single video max 5s, two videos max 2.5s each, three videos proportionally less.
Billing: Based on actual reference duration used.

   * @minItems 1
   * @maxItems 3
   */
  reference_video_urls?: string[];
  /** Video effect template name. Optional. Currently supported: squish, flying, carousel. When used, prompt parameter is ignored. */
  template?: string;
};

/**
 * The ID of the model to call
 */
export type WanVideoGenerationRequestModel = typeof WanVideoGenerationRequestModel[keyof typeof WanVideoGenerationRequestModel];


export const WanVideoGenerationRequestModel = {
  'wan25-t2v-preview': 'wan2.5-t2v-preview',
  'wan25-i2v-preview': 'wan2.5-i2v-preview',
  'wan26-t2v': 'wan2.6-t2v',
  'wan26-i2v': 'wan2.6-i2v',
  'wan26-r2v': 'wan2.6-r2v',
} as const;

/**
 * The duration of the video generated, in seconds:
- wan2.5 models: 5 or 10 seconds
- wan2.6-t2v, wan2.6-i2v: 5, 10, or 15 seconds
- wan2.6-r2v: 5 or 10 seconds only (no 15s support)

 */
export type WanVideoGenerationRequestParametersDuration = typeof WanVideoGenerationRequestParametersDuration[keyof typeof WanVideoGenerationRequestParametersDuration];


export const WanVideoGenerationRequestParametersDuration = {
  NUMBER_5: 5,
  NUMBER_10: 10,
  NUMBER_15: 15,
} as const;

/**
 * Resolution level for I2V models. Supported values vary by model:
- wan2.5-i2v-preview: 480P, 720P, 1080P
- wan2.6-i2v: 720P, 1080P only (no 480P support)

 */
export type WanVideoGenerationRequestParametersResolution = typeof WanVideoGenerationRequestParametersResolution[keyof typeof WanVideoGenerationRequestParametersResolution];


export const WanVideoGenerationRequestParametersResolution = {
  '480P': '480P',
  '720P': '720P',
  '1080P': '1080P',
} as const;

/**
 * Intelligent multi-lens control. Only active when prompt_extend is enabled.
For wan2.6 models only.
- multi: Intelligent disassembly into multiple lenses (default)
- single: Single lens generation

 */
export type WanVideoGenerationRequestParametersShotType = typeof WanVideoGenerationRequestParametersShotType[keyof typeof WanVideoGenerationRequestParametersShotType];


export const WanVideoGenerationRequestParametersShotType = {
  multi: 'multi',
  single: 'single',
} as const;

/**
 * Video processing parameters
 */
export type WanVideoGenerationRequestParameters = {
  /** Whether to add audio to the video */
  audio?: boolean;
  /** The duration of the video generated, in seconds:
- wan2.5 models: 5 or 10 seconds
- wan2.6-t2v, wan2.6-i2v: 5, 10, or 15 seconds
- wan2.6-r2v: 5 or 10 seconds only (no 15s support)
 */
  duration?: WanVideoGenerationRequestParametersDuration;
  /** Is it enabled prompt intelligent rewriting. Default is true */
  prompt_extend?: boolean;
  /** Resolution level for I2V models. Supported values vary by model:
- wan2.5-i2v-preview: 480P, 720P, 1080P
- wan2.6-i2v: 720P, 1080P only (no 480P support)
 */
  resolution?: WanVideoGenerationRequestParametersResolution;
  /**
   * Random number seed, used to control the randomness of the model generated content
   * @minimum 0
   * @maximum 2147483647
   */
  seed?: number;
  /** Intelligent multi-lens control. Only active when prompt_extend is enabled.
For wan2.6 models only.
- multi: Intelligent disassembly into multiple lenses (default)
- single: Single lens generation
 */
  shot_type?: WanVideoGenerationRequestParametersShotType;
  /** Video resolution in format width*height. Supported resolutions vary by model:
For wan2.5 T2V: 480P (480*832, 832*480, 624*624), 720P, 1080P sizes
For wan2.6 T2V/R2V (no 480P):
  720P: 1280*720, 720*1280, 960*960, 1088*832, 832*1088
  1080P: 1920*1080, 1080*1920, 1440*1440, 1632*1248, 1248*1632
 */
  size?: string;
  /** Whether to add a watermark logo, the watermark is located in the lower right corner */
  watermark?: boolean;
};

export interface WanVideoGenerationRequest {
  /** Enter basic information, such as prompt words, etc. */
  input: WanVideoGenerationRequestInput;
  /** The ID of the model to call */
  model: WanVideoGenerationRequestModel;
  /** Video processing parameters */
  parameters?: WanVideoGenerationRequestParameters;
}

/**
 * Task status
 */
export type WanVideoGenerationResponseOutputTaskStatus = typeof WanVideoGenerationResponseOutputTaskStatus[keyof typeof WanVideoGenerationResponseOutputTaskStatus];


export const WanVideoGenerationResponseOutputTaskStatus = {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED',
  UNKNOWN: 'UNKNOWN',
} as const;

export type WanVideoGenerationResponseOutput = {
  /** Task ID */
  task_id: string;
  /** Task status */
  task_status: WanVideoGenerationResponseOutputTaskStatus;
};

export interface WanVideoGenerationResponse {
  /** The error code for the failed request (not returned if request is successful) */
  code?: string;
  /** Detailed information about the failed request (not returned if request is successful) */
  message?: string;
  output: WanVideoGenerationResponseOutput;
  /** Unique request identifier */
  request_id: string;
}

/**
 * Target resolution to upscale to.
 */
export type WavespeedFlashVSRRequestTargetResolution = typeof WavespeedFlashVSRRequestTargetResolution[keyof typeof WavespeedFlashVSRRequestTargetResolution];


export const WavespeedFlashVSRRequestTargetResolution = {
  '720p': '720p',
  '1080p': '1080p',
  '2k': '2k',
  '4k': '4k',
} as const;

/**
 * Request body for WavespeedAI FlashVSR video upscaling
 */
export interface WavespeedFlashVSRRequest {
  /** Duration of the video in seconds
 */
  duration: number;
  /** Target resolution to upscale to. */
  target_resolution?: WavespeedFlashVSRRequestTargetResolution;
  /** The video to upscale. Can be a URL to the video file or a base64-encoded video.
 */
  video: string;
}

/**
 * The format of the output image.
 */
export type WavespeedSeedVR2ImageRequestOutputFormat = typeof WavespeedSeedVR2ImageRequestOutputFormat[keyof typeof WavespeedSeedVR2ImageRequestOutputFormat];


export const WavespeedSeedVR2ImageRequestOutputFormat = {
  jpeg: 'jpeg',
  png: 'png',
  webp: 'webp',
} as const;

/**
 * The target resolution of the output image.
 */
export type WavespeedSeedVR2ImageRequestTargetResolution = typeof WavespeedSeedVR2ImageRequestTargetResolution[keyof typeof WavespeedSeedVR2ImageRequestTargetResolution];


export const WavespeedSeedVR2ImageRequestTargetResolution = {
  '2k': '2k',
  '4k': '4k',
  '8k': '8k',
} as const;

/**
 * Request body for WavespeedAI SeedVR2 image upscaling
 */
export interface WavespeedSeedVR2ImageRequest {
  /** If enabled, the output will be encoded into a BASE64 string instead of a URL. */
  enable_base64_output?: boolean;
  /** The URL of the image to upscale. */
  image: string;
  /** The format of the output image. */
  output_format?: WavespeedSeedVR2ImageRequestOutputFormat;
  /** The target resolution of the output image. */
  target_resolution?: WavespeedSeedVR2ImageRequestTargetResolution;
}

/**
 * Status of the task
 */
export type WavespeedTaskResponseDataStatus = typeof WavespeedTaskResponseDataStatus[keyof typeof WavespeedTaskResponseDataStatus];


export const WavespeedTaskResponseDataStatus = {
  created: 'created',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed',
} as const;

export type WavespeedTaskResponseDataTimings = {
  /** Inference time in milliseconds */
  inference?: number;
};

export type WavespeedTaskResponseDataUrls = {
  /** URL to retrieve the prediction result */
  get?: string;
};

export type WavespeedTaskResponseData = {
  /** ISO timestamp of when the request was created */
  created_at?: string;
  /** Error message (empty if no error occurred) */
  error?: string;
  /** Array of boolean values indicating NSFW detection for each output */
  has_nsfw_contents?: boolean[];
  /** Unique identifier for the prediction/task */
  id?: string;
  /** Model ID used for the prediction */
  model?: string;
  /** Array of URLs to the generated content (empty when status is not completed) */
  outputs?: string[];
  /** Status of the task */
  status?: WavespeedTaskResponseDataStatus;
  timings?: WavespeedTaskResponseDataTimings;
  urls?: WavespeedTaskResponseDataUrls;
};

/**
 * Response from WavespeedAI task submission
 */
export interface WavespeedTaskResponse {
  /** HTTP status code (e.g., 200 for success) */
  code?: number;
  data?: WavespeedTaskResponseData;
  /** Status message (e.g., "success") */
  message?: string;
}

/**
 * Status of the task
 */
export type WavespeedTaskResultResponseDataStatus = typeof WavespeedTaskResultResponseDataStatus[keyof typeof WavespeedTaskResultResponseDataStatus];


export const WavespeedTaskResultResponseDataStatus = {
  created: 'created',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed',
} as const;

export type WavespeedTaskResultResponseDataTimings = {
  /** Inference time in milliseconds */
  inference?: number;
};

export type WavespeedTaskResultResponseDataUrls = {
  /** URL to retrieve the prediction result */
  get?: string;
};

export type WavespeedTaskResultResponseData = {
  /** ISO timestamp of when the request was created */
  created_at?: string;
  /** Error message (empty if no error occurred) */
  error?: string;
  /** Unique identifier for the prediction/task */
  id?: string;
  /** Model ID used for the prediction */
  model?: string;
  /** Array of URLs to the generated content (empty when status is not completed) */
  outputs?: string[];
  /** Status of the task */
  status?: WavespeedTaskResultResponseDataStatus;
  timings?: WavespeedTaskResultResponseDataTimings;
  urls?: WavespeedTaskResultResponseDataUrls;
};

/**
 * Response from WavespeedAI task result query
 */
export interface WavespeedTaskResultResponse {
  /** HTTP status code (e.g., 200 for success) */
  code?: number;
  data?: WavespeedTaskResultResponseData;
  /** Status message (e.g., "success") */
  message?: string;
}

/**
 * A generated image from xAI
 */
export interface XAIGeneratedImage {
  /** Base64-encoded image (if response_format is b64_json) */
  b64_json?: string;
  /** The enhanced prompt used for generation */
  revised_prompt?: string;
  /** URL to the generated image (if response_format is url) */
  url?: string;
}

/**
 * A generated video from xAI
 */
export interface XAIGeneratedVideo {
  /** Duration of the generated video in seconds */
  duration?: number;
  /** The enhanced prompt used for generation */
  upsampled_prompt?: string;
  /** URL to the generated video (MP4) */
  url?: string;
}

/**
 * Resolution of the output image
 */
export type XAIImageEditRequestResolution = typeof XAIImageEditRequestResolution[keyof typeof XAIImageEditRequestResolution];


export const XAIImageEditRequestResolution = {
  '1k': '1k',
} as const;

/**
 * Return format
 */
export type XAIImageEditRequestResponseFormat = typeof XAIImageEditRequestResponseFormat[keyof typeof XAIImageEditRequestResponseFormat];


export const XAIImageEditRequestResponseFormat = {
  url: 'url',
  b64_json: 'b64_json',
} as const;

/**
 * Input image object for xAI endpoints
 */
export interface XAIImageObject {
  /** URL of the input image (public URL or base64-encoded data URI) */
  url: string;
}

/**
 * Request body for xAI Grok Imagine image editing
 */
export interface XAIImageEditRequest {
  image: XAIImageObject;
  /** Model to use for editing */
  model?: string;
  /**
   * Number of edited images to generate (1-10)
   * @minimum 1
   * @maximum 10
   */
  n?: number;
  /**
   * Text description of the desired edit. Max 10,000 characters.
   * @maxLength 10000
   */
  prompt: string;
  /** Resolution of the output image */
  resolution?: XAIImageEditRequestResolution;
  /** Return format */
  response_format?: XAIImageEditRequestResponseFormat;
}

/**
 * Aspect ratio of the generated image
 */
export type XAIImageGenerationRequestAspectRatio = typeof XAIImageGenerationRequestAspectRatio[keyof typeof XAIImageGenerationRequestAspectRatio];


export const XAIImageGenerationRequestAspectRatio = {
  '1:1': '1:1',
  '2:3': '2:3',
  '3:2': '3:2',
  '3:4': '3:4',
  '4:3': '4:3',
  '9:16': '9:16',
  '16:9': '16:9',
  '9:195': '9:19.5',
  '195:9': '19.5:9',
  '9:20': '9:20',
  '20:9': '20:9',
  '1:2': '1:2',
  '2:1': '2:1',
} as const;

/**
 * Return format
 */
export type XAIImageGenerationRequestResponseFormat = typeof XAIImageGenerationRequestResponseFormat[keyof typeof XAIImageGenerationRequestResponseFormat];


export const XAIImageGenerationRequestResponseFormat = {
  url: 'url',
  b64_json: 'b64_json',
} as const;

/**
 * Request body for xAI Grok Imagine image generation
 */
export interface XAIImageGenerationRequest {
  /** Aspect ratio of the generated image */
  aspect_ratio?: XAIImageGenerationRequestAspectRatio;
  /** Model to use for generation */
  model?: string;
  /**
   * Number of images to generate (1-10)
   * @minimum 1
   * @maximum 10
   */
  n?: number;
  /**
   * Text description of the desired image. Max 10,000 characters.
   * @maxLength 10000
   */
  prompt: string;
  /** Return format */
  response_format?: XAIImageGenerationRequestResponseFormat;
}

/**
 * Response from xAI image generation or editing
 */
export interface XAIImageGenerationResponse {
  data?: XAIGeneratedImage[];
}

/**
 * Response from xAI video generation or editing (async operation)
 */
export interface XAIVideoAsyncResponse {
  /** Unique identifier to poll for the completed video */
  request_id?: string;
}

/**
 * Input video object for xAI endpoints
 */
export interface XAIVideoObject {
  /** URL of the input video (public URL or base64-encoded data URI) */
  url: string;
}

/**
 * Request body for xAI Grok Imagine video editing
 */
export interface XAIVideoEditRequest {
  /** Model to use for editing */
  model?: string;
  /** Text description of the desired edit (e.g., "Make it snowy", "Change the car to red") */
  prompt: string;
  video: XAIVideoObject;
}

/**
 * Aspect ratio of the generated video
 */
export type XAIVideoGenerationRequestAspectRatio = typeof XAIVideoGenerationRequestAspectRatio[keyof typeof XAIVideoGenerationRequestAspectRatio];


export const XAIVideoGenerationRequestAspectRatio = {
  '1:1': '1:1',
  '16:9': '16:9',
  '9:16': '9:16',
  '4:3': '4:3',
  '3:4': '3:4',
  '3:2': '3:2',
  '2:3': '2:3',
} as const;

/**
 * Resolution of the output video
 */
export type XAIVideoGenerationRequestResolution = typeof XAIVideoGenerationRequestResolution[keyof typeof XAIVideoGenerationRequestResolution];


export const XAIVideoGenerationRequestResolution = {
  '480p': '480p',
  '720p': '720p',
} as const;

/**
 * Request body for xAI Grok Imagine video generation
 */
export interface XAIVideoGenerationRequest {
  /** Aspect ratio of the generated video */
  aspect_ratio?: XAIVideoGenerationRequestAspectRatio;
  /**
   * Video duration in seconds (1-15)
   * @minimum 1
   * @maximum 15
   */
  duration?: number;
  image?: XAIImageObject;
  /** Model to use for generation */
  model?: string;
  /** Text description of the desired video */
  prompt: string;
  /** Resolution of the output video */
  resolution?: XAIVideoGenerationRequestResolution;
}

/**
 * Current status
 */
export type XAIVideoPendingResponseStatus = typeof XAIVideoPendingResponseStatus[keyof typeof XAIVideoPendingResponseStatus];


export const XAIVideoPendingResponseStatus = {
  pending: 'pending',
} as const;

/**
 * Response when video generation is still pending
 */
export interface XAIVideoPendingResponse {
  /** Current status */
  status?: XAIVideoPendingResponseStatus;
}

/**
 * Response when video generation is complete
 */
export interface XAIVideoResultResponse {
  /** The model used to generate the video */
  model?: string;
  video?: XAIGeneratedVideo;
}

/**
 * Unique UUID for each request.
 */
export type PixverseAiTraceIdParameter = string;

export type PostAdminArchiveMetronomeData200 = {
  /** Success message */
  message?: string;
};

export type GetAdminCustomerBalance200 = {
  amount_micros: number;
  cloud_credit_balance_micros?: number;
  currency: string;
  effective_balance_micros?: number;
  pending_charges_micros?: number;
  prepaid_balance_micros?: number;
};

export type GetAdminCustomerCloudSubscriptionStatus200 = {
  /**
   * The date when the subscription is set to end (ISO 8601 format)
   * @nullable
   */
  end_date?: string | null;
  /** Whether the customer has funds/credits available */
  has_fund?: boolean;
  /** Whether the customer has an active cloud subscription */
  is_active?: boolean;
  /**
   * The next renewal date for the subscription (ISO 8601 format)
   * @nullable
   */
  renewal_date?: string | null;
  subscription_duration?: SubscriptionDuration | null;
  /**
   * The active subscription ID if one exists
   * @nullable
   */
  subscription_id?: string | null;
  subscription_tier?: SubscriptionTier | null;
};

export type DeleteAdminCustomerStripeData200 = {
  /** Success message */
  message?: string;
};

export type GenerateAdminToken200 = {
  /** When the token expires */
  expires_at: string;
  /** The JWT admin token */
  token: string;
};

export type AdminUpdateNodeVersionBody = {
  status?: NodeVersionStatus;
  /** The reason for the status change. */
  status_reason?: string;
  /** List of accelerators (e.g. CUDA, DirectML, ROCm) that this node supports */
  supported_accelerators?: string[];
  /** Supported versions of ComfyUI frontend */
  supported_comfyui_frontend_version?: string;
  /** Supported versions of ComfyUI */
  supported_comfyui_version?: string;
  /** List of operating systems that this node supports */
  supported_os?: string[];
};

export type VerifyApiKeyBody = {
  /** The ComfyUI API key to verify (e.g., comfy_xxx...) */
  api_key: string;
};

export type VerifyApiKey200 = {
  /** The customer's email address */
  email?: string;
  /** The Firebase UID of the user */
  firebase_uid: string;
  /** Whether the customer is an admin */
  is_admin?: boolean;
  /** The customer's name */
  name?: string;
  /** Whether the API key is valid */
  valid: boolean;
};

export type GetBranchParams = {
/**
 * The repo to filter by.
 */
repo_name?: string;
};

export type GetBranch200 = {
  branches?: string[];
};

export type ListAllComfyNodesParams = {
pageSize?: number;
/**
 * Page number (1-based indexing)
 */
page?: number;
/**
 * Filter by node ID
 */
node_id?: string;
/**
 * Filter by node version
 */
node_version?: string;
/**
 * Filter by ComfyUI node name
 */
comfy_node_name?: string;
};

export type ListAllComfyNodes200 = {
  comfy_nodes?: ComfyNode[];
  /** Total number of comfy nodes */
  total?: number;
};

export type ComfyNodesBackfillParams = {
max_node?: number;
};

export type SearchCustomersParams = {
/**
 * Email address to search for
 */
email?: string;
/**
 * Customer name to search for
 */
name?: string;
/**
 * Stripe customer ID to search for
 */
stripe_id?: string;
/**
 * Metronome customer ID to search for\
 */
metronome_id?: string;
/**
 * Page number to retrieve
 */
page?: number;
/**
 * Number of customers to return per page
 */
limit?: number;
};

export type SearchCustomers200 = {
  customers?: Customer[];
  /** Number of customers per page */
  limit?: number;
  /** Current page number */
  page?: number;
  /** Total number of matching customers */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

export type ListCouponsParams = {
/**
 * Number of coupons to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type ListCoupons200 = {
  coupons: CouponResponse[];
  /** Whether there are more results available */
  has_more?: boolean;
};

export type DeleteCoupon200 = {
  /** The deleted coupon ID */
  coupon_id: string;
  /** Success message */
  message: string;
};

export type ListPromoCodesParams = {
/**
 * Filter by active status
 */
active?: boolean;
/**
 * Number of promo codes to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type ListPromoCodes200 = {
  /** Whether there are more results available */
  has_more?: boolean;
  promo_codes: PromoCodeResponse[];
};

export type DeletePromoCode200 = {
  /** Success message */
  message: string;
  /** The deactivated promo code ID */
  promo_code_id: string;
};

export type ListCustomerAPIKeys200 = {
  api_keys?: APIKey[];
};

export type CreateCustomerAPIKey201 = {
  api_key?: APIKeyWithPlaintext;
};

export type GetCustomerBalance200 = {
  /** The total remaining balance in microamount (1/1,000,000 of the currency unit) */
  amount_micros: number;
  /** The remaining balance from cloud credits in microamount */
  cloud_credit_balance_micros?: number;
  /** The currency code (e.g., "usd") */
  currency: string;
  /** The effective balance (total balance minus pending charges). Can be negative if pending charges exceed the balance. Only included when the show_negative_balances feature flag is enabled. */
  effective_balance_micros?: number;
  /** The total amount of pending/unbilled charges from draft invoices in microamount. Only included when the show_negative_balances feature flag is enabled. */
  pending_charges_micros?: number;
  /** The remaining balance from prepaid commits in microamount */
  prepaid_balance_micros?: number;
};

/**
 * Optional target subscription tier. When provided, creates a deep link directly to the subscription update confirmation screen with this tier pre-selected.
 */
export type AccessBillingPortalBodyTargetTier = typeof AccessBillingPortalBodyTargetTier[keyof typeof AccessBillingPortalBodyTargetTier];


export const AccessBillingPortalBodyTargetTier = {
  standard: 'standard',
  creator: 'creator',
  pro: 'pro',
  'standard-yearly': 'standard-yearly',
  'creator-yearly': 'creator-yearly',
  'pro-yearly': 'pro-yearly',
} as const;

export type AccessBillingPortalBody = {
  /** Optional URL to redirect the customer after they're done with the billing portal */
  return_url?: string;
  /** Optional target subscription tier. When provided, creates a deep link directly to the subscription update confirmation screen with this tier pre-selected. */
  target_tier?: AccessBillingPortalBodyTargetTier;
};

export type AccessBillingPortal200 = {
  /** The URL to redirect the customer to the billing portal */
  billing_portal_url?: string;
};

export type CreateCloudSubscriptionCheckoutBody = {
  /** Impact.com click ID for affiliate conversion tracking */
  im_ref?: string;
};

export type CreateCloudSubscriptionCheckout201 = {
  /** The URL to redirect the customer to complete subscription */
  checkout_url?: string;
};

export type CreateCloudSubscriptionCheckoutTierBody = {
  /** Impact.com click ID for affiliate conversion tracking */
  im_ref?: string;
};

export type CreateCloudSubscriptionCheckoutTier201 = {
  /** The URL to redirect the customer to complete subscription */
  checkout_url?: string;
};

export type GetCloudSubscriptionStatus200 = {
  /**
   * The date when the subscription is set to end (ISO 8601 format)
   * @nullable
   */
  end_date?: string | null;
  /** Whether the customer has funds/credits available */
  has_fund?: boolean;
  /** Whether the customer has an active cloud subscription */
  is_active?: boolean;
  /**
   * The next renewal date for the subscription (ISO 8601 format)
   * @nullable
   */
  renewal_date?: string | null;
  subscription_duration?: SubscriptionDuration | null;
  /**
   * The active subscription ID if one exists
   * @nullable
   */
  subscription_id?: string | null;
  subscription_tier?: SubscriptionTier | null;
};

export type InitiateCreditPurchaseBody = {
  /** the amount of the checkout transaction in micro value */
  amount_micros: number;
  /** the currency used in the checkout transaction */
  currency: string;
};

export type InitiateCreditPurchase201 = {
  /** the url to redirect the customer */
  checkout_url?: string;
};

export type GetCustomerEventsParams = {
/**
 * Page number of the nodes list
 */
page?: number;
/**
 * Number of nodes to return per page
 */
limit?: number;
/**
 * Event type to filter
 */
filter?: string;
/**
 * Start date for filtering events (RFC3339 format, e.g., 2025-01-01T00:00:00Z)
 */
start_date?: string;
/**
 * End date for filtering events (RFC3339 format, e.g., 2025-01-31T23:59:59Z)
 */
end_date?: string;
};

export type GetCustomerEvents200 = {
  events?: AuditLog[];
  /** Maximum number of nodes per page */
  limit?: number;
  /** Current page number */
  page?: number;
  /** Total number of events available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

export type CreateCustomerStorageResourceBody = {
  /** The content type of the file (e.g., 'image/png') */
  content_type?: string;
  /** The hash of the file. If provided, an existing file with the same hash may be returned. */
  file_hash?: string;
  /** The desired name of the file (e.g., 'profile.jpg') */
  file_name: string;
};

/**
 * The color property to override
 */
export type GetCustomerUsageBodyColorOverridesItemName = typeof GetCustomerUsageBodyColorOverridesItemName[keyof typeof GetCustomerUsageBodyColorOverridesItemName];


export const GetCustomerUsageBodyColorOverridesItemName = {
  Gray_dark: 'Gray_dark',
  Gray_medium: 'Gray_medium',
  Gray_light: 'Gray_light',
  Gray_extralight: 'Gray_extralight',
  White: 'White',
  Primary_medium: 'Primary_medium',
  Primary_light: 'Primary_light',
  UsageLine_0: 'UsageLine_0',
  UsageLine_1: 'UsageLine_1',
  UsageLine_2: 'UsageLine_2',
  UsageLine_3: 'UsageLine_3',
  UsageLine_4: 'UsageLine_4',
  UsageLine_5: 'UsageLine_5',
  UsageLine_6: 'UsageLine_6',
  UsageLine_7: 'UsageLine_7',
  UsageLine_8: 'UsageLine_8',
  UsageLine_9: 'UsageLine_9',
  Primary_green: 'Primary_green',
  Primary_red: 'Primary_red',
  Progress_bar: 'Progress_bar',
  Progress_bar_background: 'Progress_bar_background',
} as const;

export type GetCustomerUsageBodyColorOverridesItem = {
  /** The color property to override */
  name: GetCustomerUsageBodyColorOverridesItemName;
  /**
   * Hex color code (e.g., "#FF5733")
   * @pattern ^#[0-9A-Fa-f]{6}$
   */
  value: string;
};

/**
 * The type of dashboard to retrieve
 */
export type GetCustomerUsageBodyDashboardType = typeof GetCustomerUsageBodyDashboardType[keyof typeof GetCustomerUsageBodyDashboardType];


export const GetCustomerUsageBodyDashboardType = {
  invoices: 'invoices',
  usage: 'usage',
  credits: 'credits',
  commits_and_credits: 'commits_and_credits',
} as const;

export type GetCustomerUsageBody = {
  /** Optional list of colors to override for branding */
  color_overrides?: GetCustomerUsageBodyColorOverridesItem[];
  /** The type of dashboard to retrieve */
  dashboard_type?: GetCustomerUsageBodyDashboardType;
};

export type GetCustomerUsage200 = {
  /** The dashboard URL for the customer's usage */
  url?: string;
};

export type GetCustomerById200 = {
  customer?: CustomerAdmin;
};

export type GetCustomerBalanceById200 = {
  /** The total remaining balance in microamount (1/1,000,000 of the currency unit) */
  amount_micros: number;
  /** The remaining balance from cloud credits in microamount */
  cloud_credit_balance_micros?: number;
  /** The currency code (e.g., "usd") */
  currency: string;
  /** The effective balance (total balance minus pending charges). Can be negative if pending charges exceed the balance. Only included when the show_negative_balances feature flag is enabled. */
  effective_balance_micros?: number;
  /** The total amount of pending/unbilled charges from draft invoices in microamount. Only included when the show_negative_balances feature flag is enabled. */
  pending_charges_micros?: number;
  /** The remaining balance from prepaid commits in microamount */
  prepaid_balance_micros?: number;
};

export type GetCustomerEventsByIdParams = {
/**
 * Page number of the nodes list
 */
page?: number;
/**
 * Number of nodes to return per page
 */
limit?: number;
/**
 * Event type to filter
 */
filter?: string;
/**
 * Start date for filtering events (RFC3339 format, e.g., 2025-01-01T00:00:00Z)
 */
start_date?: string;
/**
 * End date for filtering events (RFC3339 format, e.g., 2025-01-31T23:59:59Z)
 */
end_date?: string;
};

export type GetCustomerEventsById200 = {
  events?: AuditLog[];
  /** Maximum number of nodes per page */
  limit?: number;
  /** Current page number */
  page?: number;
  /** Total number of events available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

/**
 * Custom parameters for the usage event
 */
export type TrackCustomerUsageBodyParams = { [key: string]: unknown };

export type TrackCustomerUsageBody = {
  /** Custom parameters for the usage event */
  params: TrackCustomerUsageBodyParams;
  /** Timestamp of the usage event (RFC3339 format) */
  timestamp?: string;
  /** Unique transaction ID for this usage event */
  transaction_id: string;
};

export type TrackCustomerUsage200 = {
  /** Success message */
  message?: string;
};

export type GetGitcommitParams = {
/**
 * The ID of the commit to fetch data for.
 */
commitId?: string;
/**
 * The operating system to filter the CI data by.
 */
operatingSystem?: string;
/**
 * The name of the workflow to filter the CI data by.
 */
workflowName?: string;
/**
 * The branch of the gitcommit to filter the CI data by.
 */
branch?: string;
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * The number of items to include per page.
 */
pageSize?: number;
/**
 * The repo to filter by.
 */
repoName?: string;
};

export type GetGitcommit200 = {
  jobResults?: ActionJobResult[];
  totalNumberOfPages?: number;
};

export type GetGitcommitsummaryParams = {
/**
 * The repository name to filter the git commits by.
 */
repoName?: string;
/**
 * The branch name to filter the git commits by.
 */
branchName?: string;
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * The number of items to include per page.
 */
pageSize?: number;
};

export type GetGitcommitsummary200 = {
  commitSummaries?: GitCommitSummary[];
  totalNumberOfPages?: number;
};

export type GetGitcommitsummary500 = {
  message?: string;
};

export type ListAllNodesParams = {
/**
 * Page number of the nodes list
 */
page?: number;
/**
 * Number of nodes to return per page
 */
limit?: number;
/**
 * Filter nodes by supported operating systems
 */
supported_os?: string;
/**
 * Filter nodes by supported accelerator
 */
supported_accelerator?: string;
/**
 * Number of nodes to return per page
 */
include_banned?: boolean;
/**
 * Retrieve nodes created or updated after this timestamp (ISO 8601 format)
 */
timestamp?: string;
/**
 * Whether to fetch fresh result from database or use cached one if false
 */
latest?: boolean;
/**
 * Database column to use as ascending ordering. Add `;desc` as suffix on each column for descending sort
 */
sort?: string[];
/**
 * node_id to use as filter
 */
node_id?: string[];
/**
 * Comfy UI version
 */
comfyui_version?: string;
/**
 * The platform requesting the nodes
 */
form_factor?: string;
};

export type ListAllNodes200 = {
  /** Maximum number of nodes per page */
  limit?: number;
  nodes?: Node[];
  /** Current page number */
  page?: number;
  /** Total number of nodes available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

export type ReindexNodesParams = {
/**
 * Maximum number of nodes to send to algolia at a time
 */
max_batch?: number;
};

export type SearchNodesParams = {
/**
 * Page number of the nodes list
 */
page?: number;
/**
 * Number of nodes to return per page
 */
limit?: number;
/**
 * Keyword to search the nodes
 */
search?: string;
/**
 * Keyword to search the nodes by repository URL
 */
repository_url_search?: string;
/**
 * Keyword to search the nodes by comfy node name
 */
comfy_node_search?: string;
/**
 * Filter nodes by supported operating systems
 */
supported_os?: string;
/**
 * Filter nodes by supported accelerator
 */
supported_accelerator?: string;
/**
 * Number of nodes to return per page
 */
include_banned?: boolean;
};

export type SearchNodes200 = {
  /** Maximum number of nodes per page */
  limit?: number;
  nodes?: Node[];
  /** Current page number */
  page?: number;
  /** Total number of nodes available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

export type UpdateGithubStarsParams = {
/**
 * Maximum number of nodes to update in one batch
 */
max_batch?: number;
};

export type GetNodeParams = {
/**
 * Whether to include the translation or not
 */
include_translations?: boolean;
};

export type InstallNodeParams = {
/**
 * Specific version of the node to retrieve. If omitted, the latest version is returned.
 * @pattern ^\d+\.\d+\.\d+$
 */
version?: string;
};

export type PostNodeReviewParams = {
/**
 * number of star given to the node version
 */
star: number;
};

export type CreateNodeTranslationsBodyData = {[key: string]: { [key: string]: unknown }};

export type CreateNodeTranslationsBody = {
  data?: CreateNodeTranslationsBodyData;
};

export type ListNodeVersionsParams = {
statuses?: NodeVersionStatus[];
include_status_reason?: boolean;
};

export type ListComfyNodesParams = {
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * The number of items to include per page.
 */
limit?: number;
};

export type ListComfyNodes200 = {
  comfy_nodes?: ComfyNode[];
  totalNumberOfPages?: number;
};

export type CreateComfyNodesBodyNodes = {[key: string]: ComfyNode};

export type CreateComfyNodesBody = {
  cloud_build_info?: ComfyNodeCloudBuildInfo;
  nodes?: CreateComfyNodesBodyNodes;
  reason?: string;
  status?: string;
  success?: boolean;
};

export type DummyProxyBody = {
  message?: string;
};

export type KlingQueryResourcePackagesParams = {
/**
 * Start time for the query, Unix timestamp in ms
 */
start_time: number;
/**
 * End time for the query, Unix timestamp in ms
 */
end_time: number;
/**
 * Resource package name for precise querying of a specific package
 */
resource_pack_name?: string;
};

export type KlingImageGenerationsQueryTaskListParams = {
/**
 * Page number
 * @minimum 1
 * @maximum 1000
 */
pageNum?: number;
/**
 * Data volume per page
 * @minimum 1
 * @maximum 500
 */
pageSize?: number;
};

export type KlingVirtualTryOnQueryTaskListParams = {
/**
 * Page number
 * @minimum 1
 * @maximum 1000
 */
pageNum?: number;
/**
 * Data volume per page
 * @minimum 1
 * @maximum 500
 */
pageSize?: number;
};

export type KlingVideoEffectsQueryTaskListParams = {
/**
 * Page number
 * @minimum 1
 * @maximum 1000
 */
pageNum?: number;
/**
 * Data volume per page
 * @minimum 1
 * @maximum 500
 */
pageSize?: number;
};

export type KlingImage2VideoQueryTaskListParams = {
/**
 * Page number
 * @minimum 1
 * @maximum 1000
 */
pageNum?: number;
/**
 * Data volume per page
 * @minimum 1
 * @maximum 500
 */
pageSize?: number;
};

export type KlingLipSyncQueryTaskListParams = {
/**
 * Page number
 * @minimum 1
 * @maximum 1000
 */
pageNum?: number;
/**
 * Data volume per page
 * @minimum 1
 * @maximum 500
 */
pageSize?: number;
};

export type KlingText2VideoQueryTaskListParams = {
/**
 * Page number
 * @minimum 1
 * @maximum 1000
 */
pageNum?: number;
/**
 * Data volume per page
 * @minimum 1
 * @maximum 500
 */
pageSize?: number;
};

export type KlingVideoExtendQueryTaskListParams = {
/**
 * Page number
 * @minimum 1
 * @maximum 1000
 */
pageNum?: number;
/**
 * Data volume per page
 * @minimum 1
 * @maximum 500
 */
pageSize?: number;
};

export type RetrieveMinimaxFileParams = {
/**
 * Unique identifier for the file, obtained from the generation response
 */
file_id: number;
};

export type GetMinimaxVideoGenerationParams = {
/**
 * The task ID to be queried
 */
task_id: string;
};

export type GetOpenAIResponseParams = {
/**
 * Additional fields to include in the response. See the `include`
parameter for Response creation above for more information.

 */
include?: Includable[];
};

export type OpenAIDownloadVideoContentParams = {
/**
 * Which downloadable asset to return
 */
variant?: string;
};

export type PixverseUploadImageBody = {
  image?: Blob;
};

export type RecraftCrispUpscaleBody = {
  /** Image file to process */
  file: Blob;
};

export type RecraftRemoveBackgroundBody = {
  /** Image file to process */
  file: Blob;
};

export type RecraftRemoveBackground200Image = {
  /** URL of the processed image */
  url?: string;
};

export type RecraftRemoveBackground200 = {
  image?: RecraftRemoveBackground200Image;
};

export type RecraftVectorizeBody = {
  /** Image file to process */
  file: Blob;
};

/**
 * The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
  policy and has been blurred as a result.
 */
export type StabilityGetResult200OneFinishReason = typeof StabilityGetResult200OneFinishReason[keyof typeof StabilityGetResult200OneFinishReason];


export const StabilityGetResult200OneFinishReason = {
  SUCCESS: 'SUCCESS',
  CONTENT_FILTERED: 'CONTENT_FILTERED',
} as const;

export type StabilityGetResult200One = {
  /** The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
  policy and has been blurred as a result. */
  finish_reason: StabilityGetResult200OneFinishReason;
  /** The generated image, encoded to base64. */
  image: string;
  /**
   * The seed used as random noise for this generation.
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
};

/**
 * Controls the aspect ratio of the generated image.
 */
export type StabilityImageGenrationUltraBodyAspectRatio = typeof StabilityImageGenrationUltraBodyAspectRatio[keyof typeof StabilityImageGenrationUltraBodyAspectRatio];


export const StabilityImageGenrationUltraBodyAspectRatio = {
  '21:9': '21:9',
  '16:9': '16:9',
  '3:2': '3:2',
  '5:4': '5:4',
  '1:1': '1:1',
  '4:5': '4:5',
  '2:3': '2:3',
  '9:16': '9:16',
  '9:21': '9:21',
} as const;

/**
 * Dictates the `content-type` of the generated image.
 */
export type StabilityImageGenrationUltraBodyOutputFormat = typeof StabilityImageGenrationUltraBodyOutputFormat[keyof typeof StabilityImageGenrationUltraBodyOutputFormat];


export const StabilityImageGenrationUltraBodyOutputFormat = {
  jpeg: 'jpeg',
  png: 'png',
  webp: 'webp',
} as const;

/**
 * Guides the image model towards a particular style.
 */
export type StabilityImageGenrationUltraBodyStylePreset = typeof StabilityImageGenrationUltraBodyStylePreset[keyof typeof StabilityImageGenrationUltraBodyStylePreset];


export const StabilityImageGenrationUltraBodyStylePreset = {
  enhance: 'enhance',
  anime: 'anime',
  photographic: 'photographic',
  'digital-art': 'digital-art',
  'comic-book': 'comic-book',
  'fantasy-art': 'fantasy-art',
  'line-art': 'line-art',
  'analog-film': 'analog-film',
  'neon-punk': 'neon-punk',
  isometric: 'isometric',
  'low-poly': 'low-poly',
  origami: 'origami',
  'modeling-compound': 'modeling-compound',
  cinematic: 'cinematic',
  '3d-model': '3d-model',
  'pixel-art': 'pixel-art',
  'tile-texture': 'tile-texture',
} as const;

export type StabilityImageGenrationUltraBody = {
  /** Controls the aspect ratio of the generated image. */
  aspect_ratio?: StabilityImageGenrationUltraBodyAspectRatio;
  /** The image to use as the starting point for the generation. > **Important:** The `strength` parameter is required when `image` is provided. Supported Formats: - jpeg - png - webp Validation Rules: - Width must be between 64 and 16,384 pixels - Height must be between 64 and 16,384 pixels - Total pixel count must be at least 4,096 pixels */
  image?: Blob;
  /**
   * A blurb of text describing what you **do not** wish to see in the output image. This is an advanced feature.
   * @maxLength 10000
   */
  negative_prompt?: string;
  /** Dictates the `content-type` of the generated image. */
  output_format?: StabilityImageGenrationUltraBodyOutputFormat;
  /**
   * What you wish to see in the output image. A strong, descriptive prompt that clearly defines elements, colors, and subjects will lead to better results. To control the weight of a given word use the format `(word:weight)`, where `word` is the word you'd like to control the weight of and `weight` is a value between 0 and 1. For example: `The sky was a crisp (blue:0.3) and (green:0.8)` would convey a sky that was blue and green, but more green than blue.
   * @minLength 1
   * @maxLength 10000
   */
  prompt: string;
  /**
   * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
  /**
   * Sometimes referred to as _denoising_, this parameter controls how much influence the 
`image` parameter has on the generated image.  A value of 0 would yield an image that 
is identical to the input.  A value of 1 would be as if you passed in no image at all.

> **Important:** This parameter is required when `image` is provided.
   * @minimum 0
   * @maximum 1
   */
  strength?: number;
  /** Guides the image model towards a particular style. */
  style_preset?: StabilityImageGenrationUltraBodyStylePreset;
};

/**
 * The reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result.
 */
export type StabilityImageGenrationUltra200OneFinishReason = typeof StabilityImageGenrationUltra200OneFinishReason[keyof typeof StabilityImageGenrationUltra200OneFinishReason];


export const StabilityImageGenrationUltra200OneFinishReason = {
  SUCCESS: 'SUCCESS',
  CONTENT_FILTERED: 'CONTENT_FILTERED',
} as const;

export type StabilityImageGenrationUltra200One = {
  /** The reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result. */
  finish_reason: StabilityImageGenrationUltra200OneFinishReason;
  /** The generated image, encoded to base64. */
  image: string;
  /**
   * The seed used as random noise for this generation.
   * @minimum 0
   * @maximum 4294967294
   */
  seed?: number;
};

export type StabilityImageGenrationUltra400 = {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
};

export type StabilityImageGenrationUltra413 = {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
};

export type StabilityImageGenrationUltra422 = {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
};

export type StabilityImageGenrationUltra429 = {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
};

export type StabilityImageGenrationUltra500 = {
  /**
   * One or more error messages indicating what went wrong.
   * @minItems 1
   */
  errors: string[];
  /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
  id: string;
  /**
   * Short-hand name for an error, useful for discriminating between errors with the same status code.
   * @minLength 1
   */
  name: string;
};

export type TripoCreateTaskBody = {
  auto_size?: boolean;
  face_limit?: number;
  geometry_quality?: TripoGeometryQuality;
  model_seed?: number;
  model_version?: TripoModelVersion;
  /** @maxLength 1024 */
  negative_prompt?: string;
  pbr?: boolean;
  /** @maxLength 1024 */
  prompt: string;
  quad?: boolean;
  style?: TripoModelStyle;
  text_seed?: number;
  texture?: boolean;
  texture_quality?: TripoTextureQuality;
  texture_seed?: number;
  type: TripoTextToModel;
} | {
  auto_size?: boolean;
  face_limit?: number;
  file: {
  file_token: string;
  type: string;
};
  geometry_quality?: TripoGeometryQuality;
  model_seed?: number;
  model_version?: TripoModelVersion;
  orientation?: TripoOrientation;
  pbr?: boolean;
  quad?: boolean;
  style?: TripoModelStyle;
  texture?: boolean;
  texture_alignment?: TripoTextureAlignment;
  texture_quality?: TripoTextureQuality;
  texture_seed?: number;
  type: TripoImageToModel;
} | {
  auto_size?: boolean;
  face_limit?: number;
  files: {
  file_token: string;
  type: string;
}[];
  geometry_quality?: TripoGeometryQuality;
  mode?: TripoMultiviewMode;
  model_seed?: number;
  model_version?: TripoModelVersion;
  orientation?: TripoOrientation;
  orthographic_projection?: boolean;
  pbr?: boolean;
  quad?: boolean;
  texture?: boolean;
  texture_alignment?: TripoTextureAlignment;
  texture_quality?: TripoTextureQuality;
  texture_seed?: number;
  type: TripoMultiviewToModel;
} | {
  model_seed?: number;
  original_model_task_id: string;
  pbr?: boolean;
  texture?: boolean;
  texture_alignment?: TripoTextureAlignment;
  texture_quality?: TripoTextureQuality;
  texture_seed?: number;
  type: TripoTypeTextureModel;
} | {
  draft_model_task_id: string;
  type: TripoTypeRefineModel;
} | {
  original_model_task_id: string;
  type: TripoTypeAnimatePrerigcheck;
} | {
  original_model_task_id: string;
  out_format?: TripoStandardFormat;
  spec?: TripoSpec;
  topology?: TripoTopology;
  type: TripoTypeAnimateRig;
} | {
  animation: TripoAnimation;
  bake_animation?: boolean;
  original_model_task_id: string;
  out_format?: TripoStandardFormat;
  type: TripoTypeAnimateRetarget;
} | {
  block_size?: number;
  original_model_task_id: string;
  style: TripoStylizeOptions;
  type: TripoTypeStylizeModel;
} | {
  face_limit?: number;
  flatten_bottom?: boolean;
  flatten_bottom_threshold?: number;
  force_symmetry?: boolean;
  format: TripoConvertFormat;
  original_model_task_id: string;
  pivot_to_center_bottom?: boolean;
  quad?: boolean;
  texture_format?: TripoTextureFormat;
  texture_size?: number;
  type: TripoTypeConvertModel;
};

export type TripoGetTask200 = {
  code: TripoResponseSuccessCode;
  data: TripoTask;
};

export type TripoUploadFileBody = {
  file: Blob;
};

export type TripoUploadFile200Data = {
  image_token: string;
};

export type TripoUploadFile200 = {
  code: TripoResponseSuccessCode;
  data: TripoUploadFile200Data;
};

export type TripoGetBalance200 = {
  code: TripoResponseSuccessCode;
  data: TripoBalance;
};

export type ValidatePublisherParams = {
/**
 * The publisher username to validate.
 */
username: string;
};

export type ValidatePublisher200 = {
  /** True if the username is available, false otherwise. */
  isAvailable?: boolean;
};

export type ListNodesForPublisherParams = {
/**
 * Number of nodes to return per page
 */
include_banned?: boolean;
};

export type ListNodesForPublisherV2Params = {
/**
 * Number of nodes to return per page
 */
include_banned?: boolean;
/**
 * Page number of the nodes list
 */
page?: number;
/**
 * Number of nodes to return per page
 */
limit?: number;
};

export type ListNodesForPublisherV2200 = {
  /** Maximum number of nodes per page */
  limit?: number;
  nodes?: Node[];
  /** Current page number */
  page?: number;
  /** Total number of nodes available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

export type GetPermissionOnPublisherNodes200 = {
  canEdit?: boolean;
};

export type PublishNodeVersionBody = {
  node: Node;
  node_version: NodeVersion;
  personal_access_token: string;
};

export type PublishNodeVersion201 = {
  node_version?: NodeVersion;
  /** The signed URL to upload the node version token. */
  signedUrl?: string;
};

export type GetPermissionOnPublisher200 = {
  canEdit?: boolean;
};

export type CreatePersonalAccessToken201 = {
  /** The newly created personal access token. */
  token?: string;
};

export type GetReleaseNotesParams = {
/**
 * The project to get release notes for
 */
project: GetReleaseNotesProject;
/**
 * The current version to filter release notes
 */
current_version?: string;
/**
 * The locale for the release notes
 */
locale?: GetReleaseNotesLocale;
/**
 * The platform requesting the release notes
 */
form_factor?: string;
};

export type GetReleaseNotesProject = typeof GetReleaseNotesProject[keyof typeof GetReleaseNotesProject];


export const GetReleaseNotesProject = {
  comfyui: 'comfyui',
  comfyui_frontend: 'comfyui_frontend',
  desktop: 'desktop',
  cloud: 'cloud',
} as const;

export type GetReleaseNotesLocale = typeof GetReleaseNotesLocale[keyof typeof GetReleaseNotesLocale];


export const GetReleaseNotesLocale = {
  en: 'en',
  es: 'es',
  fr: 'fr',
  ja: 'ja',
  ko: 'ko',
  ru: 'ru',
  zh: 'zh',
} as const;

export type SecurityScanParams = {
minAge?: string;
minSecurityScanAge?: string;
maxNodes?: number;
};

export type PostUploadArtifactBody = {
  /** The author of the commit */
  author: string;
  /** The average amount of VRAM used in the run. */
  avg_vram?: number;
  branch_name: string;
  /** The name of the bucket where the output files are stored */
  bucket_name?: string;
  /** The path to ComfyUI logs. eg. gs://bucket-name/logs */
  comfy_logs_gcs_path?: string;
  /** The flags used in the comfy run */
  comfy_run_flags?: string;
  commit_hash: string;
  /** The commit message */
  commit_message: string;
  /** The time of the commit in the format of "YYYY-MM-DDTHH:MM:SSZ" (2016-10-10T00:00:00Z) */
  commit_time: string;
  /** Cuda version. */
  cuda_version?: string;
  /** The end time of the job as a Unix timestamp. */
  end_time: number;
  /** Unique identifier for the job */
  job_id: string;
  /** The user who triggered the job */
  job_trigger_user: string;
  machine_stats?: MachineStats;
  /** Operating system used in the run */
  os: string;
  /** A comma separated string that contains GCS path(s) to output files. eg. gs://bucket-name/output, gs://bucket-name/output2 */
  output_files_gcs_paths?: string;
  /** The peak amount of VRAM used in the run. */
  peak_vram?: number;
  /** The pull request number */
  pr_number: string;
  /** The python version used in the run */
  python_version: string;
  /** The pytorch version used in the run */
  pytorch_version?: string;
  /** Repository name */
  repo: string;
  /** Unique identifier for the run */
  run_id: string;
  /** The start time of the job as a Unix timestamp. */
  start_time: number;
  status: WorkflowRunStatus;
  /** The name of the workflow */
  workflow_name: string;
};

export type PostUploadArtifact200 = {
  message?: string;
};

export type ListAllNodeVersionsParams = {
nodeId?: string;
statuses?: NodeVersionStatus[];
include_status_reason?: boolean;
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * The number of items to include per page.
 */
pageSize?: number;
/**
 * search for status_reason, case insensitive
 */
status_reason?: string;
};

export type ListAllNodeVersions200 = {
  /** Current page number */
  page?: number;
  /** Maximum number of node versions per page. Maximum is 100. */
  pageSize?: number;
  /** Total number of node versions available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
  versions?: NodeVersion[];
};

export type MetronomeZeroBalanceBodyProperties = {
  /** the metronome customer id */
  customer_id?: string;
  /** the customer remaining balance */
  remaining_balance?: number;
};

export type MetronomeZeroBalanceBody = {
  /** the id of the webhook */
  id: string;
  properties: MetronomeZeroBalanceBodyProperties;
  /** the type of the webhook */
  type: string;
};

/**
 * Generic Stripe webhook event payload
 */
export type StripeSubscriptionWebhookBody = { [key: string]: unknown };

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 419 | 420 | 421 | 422 | 423 | 424 | 426 | 428 | 429 | 431 | 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes = HTTPStatusCode1xx | HTTPStatusCode2xx | HTTPStatusCode3xx | HTTPStatusCode4xx | HTTPStatusCode5xx;


/**
 * Archives metronome data. See https://docs.metronome.com/api-reference/customers/archive-a-customer
 * @summary Archive customer Metronome data
 */
export type postAdminArchiveMetronomeDataResponse200 = {
  data: PostAdminArchiveMetronomeData200
  status: 200
}

export type postAdminArchiveMetronomeDataResponse400 = {
  data: ErrorResponse
  status: 400
}

export type postAdminArchiveMetronomeDataResponse401 = {
  data: void
  status: 401
}

export type postAdminArchiveMetronomeDataResponse404 = {
  data: void
  status: 404
}

export type postAdminArchiveMetronomeDataResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type postAdminArchiveMetronomeDataResponseSuccess = (postAdminArchiveMetronomeDataResponse200) & {
  headers: Headers;
};
export type postAdminArchiveMetronomeDataResponseError = (postAdminArchiveMetronomeDataResponse400 | postAdminArchiveMetronomeDataResponse401 | postAdminArchiveMetronomeDataResponse404 | postAdminArchiveMetronomeDataResponse500) & {
  headers: Headers;
};

export type postAdminArchiveMetronomeDataResponse = (postAdminArchiveMetronomeDataResponseSuccess | postAdminArchiveMetronomeDataResponseError)

export const getPostAdminArchiveMetronomeDataUrl = (customerId: string,) => {


  

  return `/admin/customers/${customerId}/archive-metronome-data`
}

export const postAdminArchiveMetronomeData = async (customerId: string, options?: RequestInit): Promise<postAdminArchiveMetronomeDataResponse> => {
  
  return customInstance<postAdminArchiveMetronomeDataResponse>(getPostAdminArchiveMetronomeDataUrl(customerId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getPostAdminArchiveMetronomeDataMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAdminArchiveMetronomeData>>, TError,{customerId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAdminArchiveMetronomeData>>, TError,{customerId: string}, TContext> => {

const mutationKey = ['postAdminArchiveMetronomeData'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAdminArchiveMetronomeData>>, {customerId: string}> = (props) => {
          const {customerId} = props ?? {};

          return  postAdminArchiveMetronomeData(customerId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostAdminArchiveMetronomeDataMutationResult = NonNullable<Awaited<ReturnType<typeof postAdminArchiveMetronomeData>>>
    
    export type PostAdminArchiveMetronomeDataMutationError = ErrorResponse | void

    /**
 * @summary Archive customer Metronome data
 */
export const usePostAdminArchiveMetronomeData = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAdminArchiveMetronomeData>>, TError,{customerId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAdminArchiveMetronomeData>>,
        TError,
        {customerId: string},
        TContext
      > => {
      return useMutation(getPostAdminArchiveMetronomeDataMutationOptions(options), queryClient);
    }
    
/**
 * Returns the specified customer's current remaining balance in microamount and its currency.
 * @summary Admin get customer's remaining balance
 */
export type getAdminCustomerBalanceResponse200 = {
  data: GetAdminCustomerBalance200
  status: 200
}

export type getAdminCustomerBalanceResponse401 = {
  data: ErrorResponse
  status: 401
}

export type getAdminCustomerBalanceResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getAdminCustomerBalanceResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getAdminCustomerBalanceResponseSuccess = (getAdminCustomerBalanceResponse200) & {
  headers: Headers;
};
export type getAdminCustomerBalanceResponseError = (getAdminCustomerBalanceResponse401 | getAdminCustomerBalanceResponse404 | getAdminCustomerBalanceResponse500) & {
  headers: Headers;
};

export type getAdminCustomerBalanceResponse = (getAdminCustomerBalanceResponseSuccess | getAdminCustomerBalanceResponseError)

export const getGetAdminCustomerBalanceUrl = (customerId: string,) => {


  

  return `/admin/customers/${customerId}/balance`
}

export const getAdminCustomerBalance = async (customerId: string, options?: RequestInit): Promise<getAdminCustomerBalanceResponse> => {
  
  return customInstance<getAdminCustomerBalanceResponse>(getGetAdminCustomerBalanceUrl(customerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAdminCustomerBalanceQueryKey = (customerId: string,) => {
    return [
    `/admin/customers/${customerId}/balance`
    ] as const;
    }

    
export const getGetAdminCustomerBalanceQueryOptions = <TData = Awaited<ReturnType<typeof getAdminCustomerBalance>>, TError = ErrorResponse>(customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerBalance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminCustomerBalanceQueryKey(customerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminCustomerBalance>>> = ({ signal }) => getAdminCustomerBalance(customerId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerBalance>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdminCustomerBalanceQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminCustomerBalance>>>
export type GetAdminCustomerBalanceQueryError = ErrorResponse


export function useGetAdminCustomerBalance<TData = Awaited<ReturnType<typeof getAdminCustomerBalance>>, TError = ErrorResponse>(
 customerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerBalance>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminCustomerBalance>>,
          TError,
          Awaited<ReturnType<typeof getAdminCustomerBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdminCustomerBalance<TData = Awaited<ReturnType<typeof getAdminCustomerBalance>>, TError = ErrorResponse>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerBalance>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminCustomerBalance>>,
          TError,
          Awaited<ReturnType<typeof getAdminCustomerBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdminCustomerBalance<TData = Awaited<ReturnType<typeof getAdminCustomerBalance>>, TError = ErrorResponse>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerBalance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Admin get customer's remaining balance
 */

export function useGetAdminCustomerBalance<TData = Awaited<ReturnType<typeof getAdminCustomerBalance>>, TError = ErrorResponse>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerBalance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdminCustomerBalanceQueryOptions(customerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Allows an admin to inspect a specific customer's cloud subscription status.
 * @summary Admin check cloud subscription status
 */
export type getAdminCustomerCloudSubscriptionStatusResponse200 = {
  data: GetAdminCustomerCloudSubscriptionStatus200
  status: 200
}

export type getAdminCustomerCloudSubscriptionStatusResponse401 = {
  data: void
  status: 401
}

export type getAdminCustomerCloudSubscriptionStatusResponse404 = {
  data: void
  status: 404
}

export type getAdminCustomerCloudSubscriptionStatusResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getAdminCustomerCloudSubscriptionStatusResponseSuccess = (getAdminCustomerCloudSubscriptionStatusResponse200) & {
  headers: Headers;
};
export type getAdminCustomerCloudSubscriptionStatusResponseError = (getAdminCustomerCloudSubscriptionStatusResponse401 | getAdminCustomerCloudSubscriptionStatusResponse404 | getAdminCustomerCloudSubscriptionStatusResponse500) & {
  headers: Headers;
};

export type getAdminCustomerCloudSubscriptionStatusResponse = (getAdminCustomerCloudSubscriptionStatusResponseSuccess | getAdminCustomerCloudSubscriptionStatusResponseError)

export const getGetAdminCustomerCloudSubscriptionStatusUrl = (customerId: string,) => {


  

  return `/admin/customers/${customerId}/cloud-subscription-status`
}

export const getAdminCustomerCloudSubscriptionStatus = async (customerId: string, options?: RequestInit): Promise<getAdminCustomerCloudSubscriptionStatusResponse> => {
  
  return customInstance<getAdminCustomerCloudSubscriptionStatusResponse>(getGetAdminCustomerCloudSubscriptionStatusUrl(customerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAdminCustomerCloudSubscriptionStatusQueryKey = (customerId: string,) => {
    return [
    `/admin/customers/${customerId}/cloud-subscription-status`
    ] as const;
    }

    
export const getGetAdminCustomerCloudSubscriptionStatusQueryOptions = <TData = Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>, TError = void | ErrorResponse>(customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminCustomerCloudSubscriptionStatusQueryKey(customerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>> = ({ signal }) => getAdminCustomerCloudSubscriptionStatus(customerId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdminCustomerCloudSubscriptionStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>>
export type GetAdminCustomerCloudSubscriptionStatusQueryError = void | ErrorResponse


export function useGetAdminCustomerCloudSubscriptionStatus<TData = Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>, TError = void | ErrorResponse>(
 customerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>,
          TError,
          Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdminCustomerCloudSubscriptionStatus<TData = Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>, TError = void | ErrorResponse>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>,
          TError,
          Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdminCustomerCloudSubscriptionStatus<TData = Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>, TError = void | ErrorResponse>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Admin check cloud subscription status
 */

export function useGetAdminCustomerCloudSubscriptionStatus<TData = Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>, TError = void | ErrorResponse>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminCustomerCloudSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdminCustomerCloudSubscriptionStatusQueryOptions(customerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Deletes the Stripe customer data associated with the given customer ID.
 * @summary Delete customer Stripe data
 */
export type deleteAdminCustomerStripeDataResponse200 = {
  data: DeleteAdminCustomerStripeData200
  status: 200
}

export type deleteAdminCustomerStripeDataResponse400 = {
  data: ErrorResponse
  status: 400
}

export type deleteAdminCustomerStripeDataResponse401 = {
  data: void
  status: 401
}

export type deleteAdminCustomerStripeDataResponse404 = {
  data: void
  status: 404
}

export type deleteAdminCustomerStripeDataResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type deleteAdminCustomerStripeDataResponseSuccess = (deleteAdminCustomerStripeDataResponse200) & {
  headers: Headers;
};
export type deleteAdminCustomerStripeDataResponseError = (deleteAdminCustomerStripeDataResponse400 | deleteAdminCustomerStripeDataResponse401 | deleteAdminCustomerStripeDataResponse404 | deleteAdminCustomerStripeDataResponse500) & {
  headers: Headers;
};

export type deleteAdminCustomerStripeDataResponse = (deleteAdminCustomerStripeDataResponseSuccess | deleteAdminCustomerStripeDataResponseError)

export const getDeleteAdminCustomerStripeDataUrl = (customerId: string,) => {


  

  return `/admin/customers/${customerId}/stripe-data`
}

export const deleteAdminCustomerStripeData = async (customerId: string, options?: RequestInit): Promise<deleteAdminCustomerStripeDataResponse> => {
  
  return customInstance<deleteAdminCustomerStripeDataResponse>(getDeleteAdminCustomerStripeDataUrl(customerId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteAdminCustomerStripeDataMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdminCustomerStripeData>>, TError,{customerId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAdminCustomerStripeData>>, TError,{customerId: string}, TContext> => {

const mutationKey = ['deleteAdminCustomerStripeData'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAdminCustomerStripeData>>, {customerId: string}> = (props) => {
          const {customerId} = props ?? {};

          return  deleteAdminCustomerStripeData(customerId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAdminCustomerStripeDataMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAdminCustomerStripeData>>>
    
    export type DeleteAdminCustomerStripeDataMutationError = ErrorResponse | void

    /**
 * @summary Delete customer Stripe data
 */
export const useDeleteAdminCustomerStripeData = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdminCustomerStripeData>>, TError,{customerId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAdminCustomerStripeData>>,
        TError,
        {customerId: string},
        TContext
      > => {
      return useMutation(getDeleteAdminCustomerStripeDataMutationOptions(options), queryClient);
    }
    
/**
 * Generates a short-lived JWT admin token for browser-based admin operations.
The user must already be authenticated with Firebase and have admin privileges.
The generated token expires after 1 hour.

 * @summary Generate a short-lived JWT admin token
 */
export type generateAdminTokenResponse200 = {
  data: GenerateAdminToken200
  status: 200
}

export type generateAdminTokenResponse401 = {
  data: ErrorResponse
  status: 401
}

export type generateAdminTokenResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type generateAdminTokenResponseSuccess = (generateAdminTokenResponse200) & {
  headers: Headers;
};
export type generateAdminTokenResponseError = (generateAdminTokenResponse401 | generateAdminTokenResponse500) & {
  headers: Headers;
};

export type generateAdminTokenResponse = (generateAdminTokenResponseSuccess | generateAdminTokenResponseError)

export const getGenerateAdminTokenUrl = () => {


  

  return `/admin/generate-token`
}

export const generateAdminToken = async ( options?: RequestInit): Promise<generateAdminTokenResponse> => {
  
  return customInstance<generateAdminTokenResponse>(getGenerateAdminTokenUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getGenerateAdminTokenMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateAdminToken>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof generateAdminToken>>, TError,void, TContext> => {

const mutationKey = ['generateAdminToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateAdminToken>>, void> = () => {
          

          return  generateAdminToken(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateAdminTokenMutationResult = NonNullable<Awaited<ReturnType<typeof generateAdminToken>>>
    
    export type GenerateAdminTokenMutationError = ErrorResponse

    /**
 * @summary Generate a short-lived JWT admin token
 */
export const useGenerateAdminToken = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateAdminToken>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateAdminToken>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getGenerateAdminTokenMutationOptions(options), queryClient);
    }
    
/**
 * @summary Create a new custom node using admin priviledge
 */
export type adminCreateNodeResponse201 = {
  data: Node
  status: 201
}

export type adminCreateNodeResponse400 = {
  data: ErrorResponse
  status: 400
}

export type adminCreateNodeResponse401 = {
  data: void
  status: 401
}

export type adminCreateNodeResponse409 = {
  data: ErrorResponse
  status: 409
}

export type adminCreateNodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type adminCreateNodeResponseSuccess = (adminCreateNodeResponse201) & {
  headers: Headers;
};
export type adminCreateNodeResponseError = (adminCreateNodeResponse400 | adminCreateNodeResponse401 | adminCreateNodeResponse409 | adminCreateNodeResponse500) & {
  headers: Headers;
};

export type adminCreateNodeResponse = (adminCreateNodeResponseSuccess | adminCreateNodeResponseError)

export const getAdminCreateNodeUrl = () => {


  

  return `/admin/nodes`
}

export const adminCreateNode = async (node: Node, options?: RequestInit): Promise<adminCreateNodeResponse> => {
  
  return customInstance<adminCreateNodeResponse>(getAdminCreateNodeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      node,)
  }
);}




export const getAdminCreateNodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminCreateNode>>, TError,{data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminCreateNode>>, TError,{data: Node}, TContext> => {

const mutationKey = ['adminCreateNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminCreateNode>>, {data: Node}> = (props) => {
          const {data} = props ?? {};

          return  adminCreateNode(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminCreateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof adminCreateNode>>>
    export type AdminCreateNodeMutationBody = Node
    export type AdminCreateNodeMutationError = ErrorResponse | void

    /**
 * @summary Create a new custom node using admin priviledge
 */
export const useAdminCreateNode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminCreateNode>>, TError,{data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminCreateNode>>,
        TError,
        {data: Node},
        TContext
      > => {
      return useMutation(getAdminCreateNodeMutationOptions(options), queryClient);
    }
    
/**
 * Only admins can update a node with admin privileges.
 * @summary Admin Update Node
 */
export type adminUpdateNodeResponse200 = {
  data: Node
  status: 200
}

export type adminUpdateNodeResponse400 = {
  data: ErrorResponse
  status: 400
}

export type adminUpdateNodeResponse401 = {
  data: void
  status: 401
}

export type adminUpdateNodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type adminUpdateNodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type adminUpdateNodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type adminUpdateNodeResponseSuccess = (adminUpdateNodeResponse200) & {
  headers: Headers;
};
export type adminUpdateNodeResponseError = (adminUpdateNodeResponse400 | adminUpdateNodeResponse401 | adminUpdateNodeResponse403 | adminUpdateNodeResponse404 | adminUpdateNodeResponse500) & {
  headers: Headers;
};

export type adminUpdateNodeResponse = (adminUpdateNodeResponseSuccess | adminUpdateNodeResponseError)

export const getAdminUpdateNodeUrl = (nodeId: string,) => {


  

  return `/admin/nodes/${nodeId}`
}

export const adminUpdateNode = async (nodeId: string,
    node: Node, options?: RequestInit): Promise<adminUpdateNodeResponse> => {
  
  return customInstance<adminUpdateNodeResponse>(getAdminUpdateNodeUrl(nodeId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      node,)
  }
);}




export const getAdminUpdateNodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNode>>, TError,{nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNode>>, TError,{nodeId: string;data: Node}, TContext> => {

const mutationKey = ['adminUpdateNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminUpdateNode>>, {nodeId: string;data: Node}> = (props) => {
          const {nodeId,data} = props ?? {};

          return  adminUpdateNode(nodeId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminUpdateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof adminUpdateNode>>>
    export type AdminUpdateNodeMutationBody = Node
    export type AdminUpdateNodeMutationError = ErrorResponse | void

    /**
 * @summary Admin Update Node
 */
export const useAdminUpdateNode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNode>>, TError,{nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminUpdateNode>>,
        TError,
        {nodeId: string;data: Node},
        TContext
      > => {
      return useMutation(getAdminUpdateNodeMutationOptions(options), queryClient);
    }
    
/**
 * Only admins can approve a node version.
 * @summary Admin Update Node Version Status
 */
export type adminUpdateNodeVersionResponse200 = {
  data: NodeVersion
  status: 200
}

export type adminUpdateNodeVersionResponse400 = {
  data: ErrorResponse
  status: 400
}

export type adminUpdateNodeVersionResponse401 = {
  data: void
  status: 401
}

export type adminUpdateNodeVersionResponse403 = {
  data: ErrorResponse
  status: 403
}

export type adminUpdateNodeVersionResponse404 = {
  data: ErrorResponse
  status: 404
}

export type adminUpdateNodeVersionResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type adminUpdateNodeVersionResponseSuccess = (adminUpdateNodeVersionResponse200) & {
  headers: Headers;
};
export type adminUpdateNodeVersionResponseError = (adminUpdateNodeVersionResponse400 | adminUpdateNodeVersionResponse401 | adminUpdateNodeVersionResponse403 | adminUpdateNodeVersionResponse404 | adminUpdateNodeVersionResponse500) & {
  headers: Headers;
};

export type adminUpdateNodeVersionResponse = (adminUpdateNodeVersionResponseSuccess | adminUpdateNodeVersionResponseError)

export const getAdminUpdateNodeVersionUrl = (nodeId: string,
    versionNumber: string,) => {


  

  return `/admin/nodes/${nodeId}/versions/${versionNumber}`
}

export const adminUpdateNodeVersion = async (nodeId: string,
    versionNumber: string,
    adminUpdateNodeVersionBody: AdminUpdateNodeVersionBody, options?: RequestInit): Promise<adminUpdateNodeVersionResponse> => {
  
  return customInstance<adminUpdateNodeVersionResponse>(getAdminUpdateNodeVersionUrl(nodeId,versionNumber),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminUpdateNodeVersionBody,)
  }
);}




export const getAdminUpdateNodeVersionMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, TError,{nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, TError,{nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}, TContext> => {

const mutationKey = ['adminUpdateNodeVersion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, {nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}> = (props) => {
          const {nodeId,versionNumber,data} = props ?? {};

          return  adminUpdateNodeVersion(nodeId,versionNumber,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AdminUpdateNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof adminUpdateNodeVersion>>>
    export type AdminUpdateNodeVersionMutationBody = AdminUpdateNodeVersionBody
    export type AdminUpdateNodeVersionMutationError = ErrorResponse | void

    /**
 * @summary Admin Update Node Version Status
 */
export const useAdminUpdateNodeVersion = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, TError,{nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminUpdateNodeVersion>>,
        TError,
        {nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody},
        TContext
      > => {
      return useMutation(getAdminUpdateNodeVersionMutationOptions(options), queryClient);
    }
    
/**
 * Validates a ComfyUI API key and returns the associated customer information.
This endpoint is used by cloud.comfy.org to authenticate users via API keys
instead of Firebase tokens.

 * @summary Verify a ComfyUI API key and return customer details
 */
export type verifyApiKeyResponse200 = {
  data: VerifyApiKey200
  status: 200
}

export type verifyApiKeyResponse401 = {
  data: void
  status: 401
}

export type verifyApiKeyResponse404 = {
  data: ErrorResponse
  status: 404
}

export type verifyApiKeyResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type verifyApiKeyResponseSuccess = (verifyApiKeyResponse200) & {
  headers: Headers;
};
export type verifyApiKeyResponseError = (verifyApiKeyResponse401 | verifyApiKeyResponse404 | verifyApiKeyResponse500) & {
  headers: Headers;
};

export type verifyApiKeyResponse = (verifyApiKeyResponseSuccess | verifyApiKeyResponseError)

export const getVerifyApiKeyUrl = () => {


  

  return `/admin/verify-api-key`
}

export const verifyApiKey = async (verifyApiKeyBody: VerifyApiKeyBody, options?: RequestInit): Promise<verifyApiKeyResponse> => {
  
  return customInstance<verifyApiKeyResponse>(getVerifyApiKeyUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      verifyApiKeyBody,)
  }
);}




export const getVerifyApiKeyMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyApiKey>>, TError,{data: VerifyApiKeyBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof verifyApiKey>>, TError,{data: VerifyApiKeyBody}, TContext> => {

const mutationKey = ['verifyApiKey'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyApiKey>>, {data: VerifyApiKeyBody}> = (props) => {
          const {data} = props ?? {};

          return  verifyApiKey(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyApiKeyMutationResult = NonNullable<Awaited<ReturnType<typeof verifyApiKey>>>
    export type VerifyApiKeyMutationBody = VerifyApiKeyBody
    export type VerifyApiKeyMutationError = void | ErrorResponse

    /**
 * @summary Verify a ComfyUI API key and return customer details
 */
export const useVerifyApiKey = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyApiKey>>, TError,{data: VerifyApiKeyBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof verifyApiKey>>,
        TError,
        {data: VerifyApiKeyBody},
        TContext
      > => {
      return useMutation(getVerifyApiKeyMutationOptions(options), queryClient);
    }
    
/**
 * Returns all branches for a given repo.
 * @summary Retrieve all distinct branches for a given repo
 */
export type getBranchResponse200 = {
  data: GetBranch200
  status: 200
}

export type getBranchResponse404 = {
  data: void
  status: 404
}

export type getBranchResponse500 = {
  data: void
  status: 500
}
    
export type getBranchResponseSuccess = (getBranchResponse200) & {
  headers: Headers;
};
export type getBranchResponseError = (getBranchResponse404 | getBranchResponse500) & {
  headers: Headers;
};

export type getBranchResponse = (getBranchResponseSuccess | getBranchResponseError)

export const getGetBranchUrl = (params: GetBranchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/branch?${stringifiedParams}` : `/branch`
}

export const getBranch = async (params: GetBranchParams, options?: RequestInit): Promise<getBranchResponse> => {
  
  return customInstance<getBranchResponse>(getGetBranchUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetBranchQueryKey = (params?: GetBranchParams,) => {
    return [
    `/branch`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetBranchQueryOptions = <TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranch>>> = ({ signal }) => getBranch(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBranchQueryResult = NonNullable<Awaited<ReturnType<typeof getBranch>>>
export type GetBranchQueryError = void


export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(
 params: GetBranchParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranch>>,
          TError,
          Awaited<ReturnType<typeof getBranch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(
 params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranch>>,
          TError,
          Awaited<ReturnType<typeof getBranch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(
 params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve all distinct branches for a given repo
 */

export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(
 params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBranchQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Retrieve multiple node versions in a single request
 */
export type getBulkNodeVersionsResponse200 = {
  data: BulkNodeVersionsResponse
  status: 200
}

export type getBulkNodeVersionsResponse400 = {
  data: ErrorResponse
  status: 400
}

export type getBulkNodeVersionsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getBulkNodeVersionsResponseSuccess = (getBulkNodeVersionsResponse200) & {
  headers: Headers;
};
export type getBulkNodeVersionsResponseError = (getBulkNodeVersionsResponse400 | getBulkNodeVersionsResponse500) & {
  headers: Headers;
};

export type getBulkNodeVersionsResponse = (getBulkNodeVersionsResponseSuccess | getBulkNodeVersionsResponseError)

export const getGetBulkNodeVersionsUrl = () => {


  

  return `/bulk/nodes/versions`
}

export const getBulkNodeVersions = async (bulkNodeVersionsRequest: BulkNodeVersionsRequest, options?: RequestInit): Promise<getBulkNodeVersionsResponse> => {
  
  return customInstance<getBulkNodeVersionsResponse>(getGetBulkNodeVersionsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bulkNodeVersionsRequest,)
  }
);}




export const getGetBulkNodeVersionsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getBulkNodeVersions>>, TError,{data: BulkNodeVersionsRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getBulkNodeVersions>>, TError,{data: BulkNodeVersionsRequest}, TContext> => {

const mutationKey = ['getBulkNodeVersions'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getBulkNodeVersions>>, {data: BulkNodeVersionsRequest}> = (props) => {
          const {data} = props ?? {};

          return  getBulkNodeVersions(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type GetBulkNodeVersionsMutationResult = NonNullable<Awaited<ReturnType<typeof getBulkNodeVersions>>>
    export type GetBulkNodeVersionsMutationBody = BulkNodeVersionsRequest
    export type GetBulkNodeVersionsMutationError = ErrorResponse

    /**
 * @summary Retrieve multiple node versions in a single request
 */
export const useGetBulkNodeVersions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getBulkNodeVersions>>, TError,{data: BulkNodeVersionsRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getBulkNodeVersions>>,
        TError,
        {data: BulkNodeVersionsRequest},
        TContext
      > => {
      return useMutation(getGetBulkNodeVersionsMutationOptions(options), queryClient);
    }
    
/**
 * @summary list all comfy-nodes
 */
export type listAllComfyNodesResponse200 = {
  data: ListAllComfyNodes200
  status: 200
}

export type listAllComfyNodesResponse400 = {
  data: ErrorResponse
  status: 400
}

export type listAllComfyNodesResponse401 = {
  data: void
  status: 401
}

export type listAllComfyNodesResponse403 = {
  data: ErrorResponse
  status: 403
}

export type listAllComfyNodesResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listAllComfyNodesResponseSuccess = (listAllComfyNodesResponse200) & {
  headers: Headers;
};
export type listAllComfyNodesResponseError = (listAllComfyNodesResponse400 | listAllComfyNodesResponse401 | listAllComfyNodesResponse403 | listAllComfyNodesResponse500) & {
  headers: Headers;
};

export type listAllComfyNodesResponse = (listAllComfyNodesResponseSuccess | listAllComfyNodesResponseError)

export const getListAllComfyNodesUrl = (params?: ListAllComfyNodesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/comfy-nodes?${stringifiedParams}` : `/comfy-nodes`
}

export const listAllComfyNodes = async (params?: ListAllComfyNodesParams, options?: RequestInit): Promise<listAllComfyNodesResponse> => {
  
  return customInstance<listAllComfyNodesResponse>(getListAllComfyNodesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListAllComfyNodesQueryKey = (params?: ListAllComfyNodesParams,) => {
    return [
    `/comfy-nodes`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListAllComfyNodesQueryOptions = <TData = Awaited<ReturnType<typeof listAllComfyNodes>>, TError = ErrorResponse | void>(params?: ListAllComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllComfyNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAllComfyNodesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllComfyNodes>>> = ({ signal }) => listAllComfyNodes(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAllComfyNodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAllComfyNodesQueryResult = NonNullable<Awaited<ReturnType<typeof listAllComfyNodes>>>
export type ListAllComfyNodesQueryError = ErrorResponse | void


export function useListAllComfyNodes<TData = Awaited<ReturnType<typeof listAllComfyNodes>>, TError = ErrorResponse | void>(
 params: undefined |  ListAllComfyNodesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllComfyNodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllComfyNodes>>,
          TError,
          Awaited<ReturnType<typeof listAllComfyNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAllComfyNodes<TData = Awaited<ReturnType<typeof listAllComfyNodes>>, TError = ErrorResponse | void>(
 params?: ListAllComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllComfyNodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllComfyNodes>>,
          TError,
          Awaited<ReturnType<typeof listAllComfyNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAllComfyNodes<TData = Awaited<ReturnType<typeof listAllComfyNodes>>, TError = ErrorResponse | void>(
 params?: ListAllComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllComfyNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary list all comfy-nodes
 */

export function useListAllComfyNodes<TData = Awaited<ReturnType<typeof listAllComfyNodes>>, TError = ErrorResponse | void>(
 params?: ListAllComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllComfyNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListAllComfyNodesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary trigger comfy nodes backfill
 */
export type comfyNodesBackfillResponse204 = {
  data: void
  status: 204
}

export type comfyNodesBackfillResponse400 = {
  data: ErrorResponse
  status: 400
}

export type comfyNodesBackfillResponse401 = {
  data: void
  status: 401
}

export type comfyNodesBackfillResponse403 = {
  data: ErrorResponse
  status: 403
}

export type comfyNodesBackfillResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type comfyNodesBackfillResponseSuccess = (comfyNodesBackfillResponse204) & {
  headers: Headers;
};
export type comfyNodesBackfillResponseError = (comfyNodesBackfillResponse400 | comfyNodesBackfillResponse401 | comfyNodesBackfillResponse403 | comfyNodesBackfillResponse500) & {
  headers: Headers;
};

export type comfyNodesBackfillResponse = (comfyNodesBackfillResponseSuccess | comfyNodesBackfillResponseError)

export const getComfyNodesBackfillUrl = (params?: ComfyNodesBackfillParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/comfy-nodes/backfill?${stringifiedParams}` : `/comfy-nodes/backfill`
}

export const comfyNodesBackfill = async (params?: ComfyNodesBackfillParams, options?: RequestInit): Promise<comfyNodesBackfillResponse> => {
  
  return customInstance<comfyNodesBackfillResponse>(getComfyNodesBackfillUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getComfyNodesBackfillMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof comfyNodesBackfill>>, TError,{params?: ComfyNodesBackfillParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof comfyNodesBackfill>>, TError,{params?: ComfyNodesBackfillParams}, TContext> => {

const mutationKey = ['comfyNodesBackfill'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof comfyNodesBackfill>>, {params?: ComfyNodesBackfillParams}> = (props) => {
          const {params} = props ?? {};

          return  comfyNodesBackfill(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ComfyNodesBackfillMutationResult = NonNullable<Awaited<ReturnType<typeof comfyNodesBackfill>>>
    
    export type ComfyNodesBackfillMutationError = ErrorResponse | void

    /**
 * @summary trigger comfy nodes backfill
 */
export const useComfyNodesBackfill = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof comfyNodesBackfill>>, TError,{params?: ComfyNodesBackfillParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof comfyNodesBackfill>>,
        TError,
        {params?: ComfyNodesBackfillParams},
        TContext
      > => {
      return useMutation(getComfyNodesBackfillMutationOptions(options), queryClient);
    }
    
/**
 * Returns the node that contains a ComfyUI node with the specified name
 * @summary Retrieve a node by ComfyUI node name
 */
export type getNodeByComfyNodeNameResponse200 = {
  data: Node
  status: 200
}

export type getNodeByComfyNodeNameResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getNodeByComfyNodeNameResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getNodeByComfyNodeNameResponseSuccess = (getNodeByComfyNodeNameResponse200) & {
  headers: Headers;
};
export type getNodeByComfyNodeNameResponseError = (getNodeByComfyNodeNameResponse404 | getNodeByComfyNodeNameResponse500) & {
  headers: Headers;
};

export type getNodeByComfyNodeNameResponse = (getNodeByComfyNodeNameResponseSuccess | getNodeByComfyNodeNameResponseError)

export const getGetNodeByComfyNodeNameUrl = (comfyNodeName: string,) => {


  

  return `/comfy-nodes/${comfyNodeName}/node`
}

export const getNodeByComfyNodeName = async (comfyNodeName: string, options?: RequestInit): Promise<getNodeByComfyNodeNameResponse> => {
  
  return customInstance<getNodeByComfyNodeNameResponse>(getGetNodeByComfyNodeNameUrl(comfyNodeName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetNodeByComfyNodeNameQueryKey = (comfyNodeName: string,) => {
    return [
    `/comfy-nodes/${comfyNodeName}/node`
    ] as const;
    }

    
export const getGetNodeByComfyNodeNameQueryOptions = <TData = Awaited<ReturnType<typeof getNodeByComfyNodeName>>, TError = ErrorResponse>(comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeByComfyNodeName>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeByComfyNodeNameQueryKey(comfyNodeName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeByComfyNodeName>>> = ({ signal }) => getNodeByComfyNodeName(comfyNodeName, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(comfyNodeName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNodeByComfyNodeName>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNodeByComfyNodeNameQueryResult = NonNullable<Awaited<ReturnType<typeof getNodeByComfyNodeName>>>
export type GetNodeByComfyNodeNameQueryError = ErrorResponse


export function useGetNodeByComfyNodeName<TData = Awaited<ReturnType<typeof getNodeByComfyNodeName>>, TError = ErrorResponse>(
 comfyNodeName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeByComfyNodeName>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
          TError,
          Awaited<ReturnType<typeof getNodeByComfyNodeName>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNodeByComfyNodeName<TData = Awaited<ReturnType<typeof getNodeByComfyNodeName>>, TError = ErrorResponse>(
 comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeByComfyNodeName>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
          TError,
          Awaited<ReturnType<typeof getNodeByComfyNodeName>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNodeByComfyNodeName<TData = Awaited<ReturnType<typeof getNodeByComfyNodeName>>, TError = ErrorResponse>(
 comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeByComfyNodeName>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a node by ComfyUI node name
 */

export function useGetNodeByComfyNodeName<TData = Awaited<ReturnType<typeof getNodeByComfyNodeName>>, TError = ErrorResponse>(
 comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeByComfyNodeName>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNodeByComfyNodeNameQueryOptions(comfyNodeName,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Search for customers by email, name, Stripe ID, or Metronome ID.
 * @summary Search for customers
 */
export type searchCustomersResponse200 = {
  data: SearchCustomers200
  status: 200
}

export type searchCustomersResponse400 = {
  data: ErrorResponse
  status: 400
}

export type searchCustomersResponse401 = {
  data: void
  status: 401
}

export type searchCustomersResponse403 = {
  data: ErrorResponse
  status: 403
}

export type searchCustomersResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type searchCustomersResponseSuccess = (searchCustomersResponse200) & {
  headers: Headers;
};
export type searchCustomersResponseError = (searchCustomersResponse400 | searchCustomersResponse401 | searchCustomersResponse403 | searchCustomersResponse500) & {
  headers: Headers;
};

export type searchCustomersResponse = (searchCustomersResponseSuccess | searchCustomersResponseError)

export const getSearchCustomersUrl = (params?: SearchCustomersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/customers?${stringifiedParams}` : `/customers`
}

export const searchCustomers = async (params?: SearchCustomersParams, options?: RequestInit): Promise<searchCustomersResponse> => {
  
  return customInstance<searchCustomersResponse>(getSearchCustomersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getSearchCustomersQueryKey = (params?: SearchCustomersParams,) => {
    return [
    `/customers`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getSearchCustomersQueryOptions = <TData = Awaited<ReturnType<typeof searchCustomers>>, TError = ErrorResponse | void>(params?: SearchCustomersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchCustomers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchCustomersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchCustomers>>> = ({ signal }) => searchCustomers(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchCustomers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchCustomersQueryResult = NonNullable<Awaited<ReturnType<typeof searchCustomers>>>
export type SearchCustomersQueryError = ErrorResponse | void


export function useSearchCustomers<TData = Awaited<ReturnType<typeof searchCustomers>>, TError = ErrorResponse | void>(
 params: undefined |  SearchCustomersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchCustomers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchCustomers>>,
          TError,
          Awaited<ReturnType<typeof searchCustomers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchCustomers<TData = Awaited<ReturnType<typeof searchCustomers>>, TError = ErrorResponse | void>(
 params?: SearchCustomersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchCustomers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchCustomers>>,
          TError,
          Awaited<ReturnType<typeof searchCustomers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchCustomers<TData = Awaited<ReturnType<typeof searchCustomers>>, TError = ErrorResponse | void>(
 params?: SearchCustomersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchCustomers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search for customers
 */

export function useSearchCustomers<TData = Awaited<ReturnType<typeof searchCustomers>>, TError = ErrorResponse | void>(
 params?: SearchCustomersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchCustomers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchCustomersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Creates a new customer using the provided token. No request body is needed as user information is extracted from the token.
 * @summary Create a new customer
 */
export type createCustomerResponse200 = {
  data: Customer
  status: 200
}

export type createCustomerResponse201 = {
  data: Customer
  status: 201
}

export type createCustomerResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createCustomerResponse401 = {
  data: void
  status: 401
}

export type createCustomerResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createCustomerResponseSuccess = (createCustomerResponse200 | createCustomerResponse201) & {
  headers: Headers;
};
export type createCustomerResponseError = (createCustomerResponse400 | createCustomerResponse401 | createCustomerResponse500) & {
  headers: Headers;
};

export type createCustomerResponse = (createCustomerResponseSuccess | createCustomerResponseError)

export const getCreateCustomerUrl = () => {


  

  return `/customers`
}

export const createCustomer = async ( options?: RequestInit): Promise<createCustomerResponse> => {
  
  return customInstance<createCustomerResponse>(getCreateCustomerUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getCreateCustomerMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomer>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCustomer>>, TError,void, TContext> => {

const mutationKey = ['createCustomer'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCustomer>>, void> = () => {
          

          return  createCustomer(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCustomerMutationResult = NonNullable<Awaited<ReturnType<typeof createCustomer>>>
    
    export type CreateCustomerMutationError = ErrorResponse | void

    /**
 * @summary Create a new customer
 */
export const useCreateCustomer = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomer>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCustomer>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getCreateCustomerMutationOptions(options), queryClient);
    }
    
/**
 * Retrieves a list of all coupons from Stripe. Only admins can list coupons.
 * @summary List all coupons
 */
export type listCouponsResponse200 = {
  data: ListCoupons200
  status: 200
}

export type listCouponsResponse401 = {
  data: void
  status: 401
}

export type listCouponsResponse403 = {
  data: ErrorResponse
  status: 403
}

export type listCouponsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listCouponsResponseSuccess = (listCouponsResponse200) & {
  headers: Headers;
};
export type listCouponsResponseError = (listCouponsResponse401 | listCouponsResponse403 | listCouponsResponse500) & {
  headers: Headers;
};

export type listCouponsResponse = (listCouponsResponseSuccess | listCouponsResponseError)

export const getListCouponsUrl = (params?: ListCouponsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/customers/admin/coupons?${stringifiedParams}` : `/customers/admin/coupons`
}

export const listCoupons = async (params?: ListCouponsParams, options?: RequestInit): Promise<listCouponsResponse> => {
  
  return customInstance<listCouponsResponse>(getListCouponsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListCouponsQueryKey = (params?: ListCouponsParams,) => {
    return [
    `/customers/admin/coupons`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListCouponsQueryOptions = <TData = Awaited<ReturnType<typeof listCoupons>>, TError = void | ErrorResponse>(params?: ListCouponsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCoupons>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListCouponsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listCoupons>>> = ({ signal }) => listCoupons(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listCoupons>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListCouponsQueryResult = NonNullable<Awaited<ReturnType<typeof listCoupons>>>
export type ListCouponsQueryError = void | ErrorResponse


export function useListCoupons<TData = Awaited<ReturnType<typeof listCoupons>>, TError = void | ErrorResponse>(
 params: undefined |  ListCouponsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCoupons>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCoupons>>,
          TError,
          Awaited<ReturnType<typeof listCoupons>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCoupons<TData = Awaited<ReturnType<typeof listCoupons>>, TError = void | ErrorResponse>(
 params?: ListCouponsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCoupons>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCoupons>>,
          TError,
          Awaited<ReturnType<typeof listCoupons>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCoupons<TData = Awaited<ReturnType<typeof listCoupons>>, TError = void | ErrorResponse>(
 params?: ListCouponsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCoupons>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all coupons
 */

export function useListCoupons<TData = Awaited<ReturnType<typeof listCoupons>>, TError = void | ErrorResponse>(
 params?: ListCouponsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCoupons>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListCouponsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Creates a new coupon in Stripe. Only admins can create coupons.
 * @summary Create a new Stripe coupon
 */
export type createCouponResponse201 = {
  data: CouponResponse
  status: 201
}

export type createCouponResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createCouponResponse401 = {
  data: void
  status: 401
}

export type createCouponResponse403 = {
  data: ErrorResponse
  status: 403
}

export type createCouponResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createCouponResponseSuccess = (createCouponResponse201) & {
  headers: Headers;
};
export type createCouponResponseError = (createCouponResponse400 | createCouponResponse401 | createCouponResponse403 | createCouponResponse500) & {
  headers: Headers;
};

export type createCouponResponse = (createCouponResponseSuccess | createCouponResponseError)

export const getCreateCouponUrl = () => {


  

  return `/customers/admin/coupons`
}

export const createCoupon = async (createCouponRequest: CreateCouponRequest, options?: RequestInit): Promise<createCouponResponse> => {
  
  return customInstance<createCouponResponse>(getCreateCouponUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createCouponRequest,)
  }
);}




export const getCreateCouponMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCoupon>>, TError,{data: CreateCouponRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCoupon>>, TError,{data: CreateCouponRequest}, TContext> => {

const mutationKey = ['createCoupon'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCoupon>>, {data: CreateCouponRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCoupon(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCouponMutationResult = NonNullable<Awaited<ReturnType<typeof createCoupon>>>
    export type CreateCouponMutationBody = CreateCouponRequest
    export type CreateCouponMutationError = ErrorResponse | void

    /**
 * @summary Create a new Stripe coupon
 */
export const useCreateCoupon = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCoupon>>, TError,{data: CreateCouponRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCoupon>>,
        TError,
        {data: CreateCouponRequest},
        TContext
      > => {
      return useMutation(getCreateCouponMutationOptions(options), queryClient);
    }
    
/**
 * Deletes a coupon in Stripe. Only admins can delete coupons.
 * @summary Delete a coupon
 */
export type deleteCouponResponse200 = {
  data: DeleteCoupon200
  status: 200
}

export type deleteCouponResponse401 = {
  data: void
  status: 401
}

export type deleteCouponResponse403 = {
  data: ErrorResponse
  status: 403
}

export type deleteCouponResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deleteCouponResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type deleteCouponResponseSuccess = (deleteCouponResponse200) & {
  headers: Headers;
};
export type deleteCouponResponseError = (deleteCouponResponse401 | deleteCouponResponse403 | deleteCouponResponse404 | deleteCouponResponse500) & {
  headers: Headers;
};

export type deleteCouponResponse = (deleteCouponResponseSuccess | deleteCouponResponseError)

export const getDeleteCouponUrl = (couponId: string,) => {


  

  return `/customers/admin/coupons/${couponId}`
}

export const deleteCoupon = async (couponId: string, options?: RequestInit): Promise<deleteCouponResponse> => {
  
  return customInstance<deleteCouponResponse>(getDeleteCouponUrl(couponId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteCouponMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCoupon>>, TError,{couponId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCoupon>>, TError,{couponId: string}, TContext> => {

const mutationKey = ['deleteCoupon'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCoupon>>, {couponId: string}> = (props) => {
          const {couponId} = props ?? {};

          return  deleteCoupon(couponId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCouponMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCoupon>>>
    
    export type DeleteCouponMutationError = void | ErrorResponse

    /**
 * @summary Delete a coupon
 */
export const useDeleteCoupon = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCoupon>>, TError,{couponId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCoupon>>,
        TError,
        {couponId: string},
        TContext
      > => {
      return useMutation(getDeleteCouponMutationOptions(options), queryClient);
    }
    
/**
 * Retrieves details of a specific coupon from Stripe. Only admins can view coupons.
 * @summary Get a specific coupon
 */
export type getCouponResponse200 = {
  data: CouponResponse
  status: 200
}

export type getCouponResponse401 = {
  data: void
  status: 401
}

export type getCouponResponse403 = {
  data: ErrorResponse
  status: 403
}

export type getCouponResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getCouponResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getCouponResponseSuccess = (getCouponResponse200) & {
  headers: Headers;
};
export type getCouponResponseError = (getCouponResponse401 | getCouponResponse403 | getCouponResponse404 | getCouponResponse500) & {
  headers: Headers;
};

export type getCouponResponse = (getCouponResponseSuccess | getCouponResponseError)

export const getGetCouponUrl = (couponId: string,) => {


  

  return `/customers/admin/coupons/${couponId}`
}

export const getCoupon = async (couponId: string, options?: RequestInit): Promise<getCouponResponse> => {
  
  return customInstance<getCouponResponse>(getGetCouponUrl(couponId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCouponQueryKey = (couponId: string,) => {
    return [
    `/customers/admin/coupons/${couponId}`
    ] as const;
    }

    
export const getGetCouponQueryOptions = <TData = Awaited<ReturnType<typeof getCoupon>>, TError = void | ErrorResponse>(couponId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoupon>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCouponQueryKey(couponId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoupon>>> = ({ signal }) => getCoupon(couponId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(couponId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCoupon>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCouponQueryResult = NonNullable<Awaited<ReturnType<typeof getCoupon>>>
export type GetCouponQueryError = void | ErrorResponse


export function useGetCoupon<TData = Awaited<ReturnType<typeof getCoupon>>, TError = void | ErrorResponse>(
 couponId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoupon>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCoupon>>,
          TError,
          Awaited<ReturnType<typeof getCoupon>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCoupon<TData = Awaited<ReturnType<typeof getCoupon>>, TError = void | ErrorResponse>(
 couponId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoupon>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCoupon>>,
          TError,
          Awaited<ReturnType<typeof getCoupon>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCoupon<TData = Awaited<ReturnType<typeof getCoupon>>, TError = void | ErrorResponse>(
 couponId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoupon>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific coupon
 */

export function useGetCoupon<TData = Awaited<ReturnType<typeof getCoupon>>, TError = void | ErrorResponse>(
 couponId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoupon>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCouponQueryOptions(couponId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Updates a coupon in Stripe. Only admins can update coupons.
 * @summary Update a coupon
 */
export type updateCouponResponse200 = {
  data: CouponResponse
  status: 200
}

export type updateCouponResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateCouponResponse401 = {
  data: void
  status: 401
}

export type updateCouponResponse403 = {
  data: ErrorResponse
  status: 403
}

export type updateCouponResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateCouponResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type updateCouponResponseSuccess = (updateCouponResponse200) & {
  headers: Headers;
};
export type updateCouponResponseError = (updateCouponResponse400 | updateCouponResponse401 | updateCouponResponse403 | updateCouponResponse404 | updateCouponResponse500) & {
  headers: Headers;
};

export type updateCouponResponse = (updateCouponResponseSuccess | updateCouponResponseError)

export const getUpdateCouponUrl = (couponId: string,) => {


  

  return `/customers/admin/coupons/${couponId}`
}

export const updateCoupon = async (couponId: string,
    updateCouponRequest: UpdateCouponRequest, options?: RequestInit): Promise<updateCouponResponse> => {
  
  return customInstance<updateCouponResponse>(getUpdateCouponUrl(couponId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateCouponRequest,)
  }
);}




export const getUpdateCouponMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCoupon>>, TError,{couponId: string;data: UpdateCouponRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateCoupon>>, TError,{couponId: string;data: UpdateCouponRequest}, TContext> => {

const mutationKey = ['updateCoupon'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCoupon>>, {couponId: string;data: UpdateCouponRequest}> = (props) => {
          const {couponId,data} = props ?? {};

          return  updateCoupon(couponId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCouponMutationResult = NonNullable<Awaited<ReturnType<typeof updateCoupon>>>
    export type UpdateCouponMutationBody = UpdateCouponRequest
    export type UpdateCouponMutationError = ErrorResponse | void

    /**
 * @summary Update a coupon
 */
export const useUpdateCoupon = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCoupon>>, TError,{couponId: string;data: UpdateCouponRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCoupon>>,
        TError,
        {couponId: string;data: UpdateCouponRequest},
        TContext
      > => {
      return useMutation(getUpdateCouponMutationOptions(options), queryClient);
    }
    
/**
 * Retrieves a list of all promotional codes from Stripe. Only admins can list promo codes.
 * @summary List all promotional codes
 */
export type listPromoCodesResponse200 = {
  data: ListPromoCodes200
  status: 200
}

export type listPromoCodesResponse401 = {
  data: void
  status: 401
}

export type listPromoCodesResponse403 = {
  data: ErrorResponse
  status: 403
}

export type listPromoCodesResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listPromoCodesResponseSuccess = (listPromoCodesResponse200) & {
  headers: Headers;
};
export type listPromoCodesResponseError = (listPromoCodesResponse401 | listPromoCodesResponse403 | listPromoCodesResponse500) & {
  headers: Headers;
};

export type listPromoCodesResponse = (listPromoCodesResponseSuccess | listPromoCodesResponseError)

export const getListPromoCodesUrl = (params?: ListPromoCodesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/customers/admin/promo-codes?${stringifiedParams}` : `/customers/admin/promo-codes`
}

export const listPromoCodes = async (params?: ListPromoCodesParams, options?: RequestInit): Promise<listPromoCodesResponse> => {
  
  return customInstance<listPromoCodesResponse>(getListPromoCodesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListPromoCodesQueryKey = (params?: ListPromoCodesParams,) => {
    return [
    `/customers/admin/promo-codes`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListPromoCodesQueryOptions = <TData = Awaited<ReturnType<typeof listPromoCodes>>, TError = void | ErrorResponse>(params?: ListPromoCodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromoCodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPromoCodesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPromoCodes>>> = ({ signal }) => listPromoCodes(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPromoCodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPromoCodesQueryResult = NonNullable<Awaited<ReturnType<typeof listPromoCodes>>>
export type ListPromoCodesQueryError = void | ErrorResponse


export function useListPromoCodes<TData = Awaited<ReturnType<typeof listPromoCodes>>, TError = void | ErrorResponse>(
 params: undefined |  ListPromoCodesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromoCodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPromoCodes>>,
          TError,
          Awaited<ReturnType<typeof listPromoCodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPromoCodes<TData = Awaited<ReturnType<typeof listPromoCodes>>, TError = void | ErrorResponse>(
 params?: ListPromoCodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromoCodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPromoCodes>>,
          TError,
          Awaited<ReturnType<typeof listPromoCodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPromoCodes<TData = Awaited<ReturnType<typeof listPromoCodes>>, TError = void | ErrorResponse>(
 params?: ListPromoCodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromoCodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all promotional codes
 */

export function useListPromoCodes<TData = Awaited<ReturnType<typeof listPromoCodes>>, TError = void | ErrorResponse>(
 params?: ListPromoCodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPromoCodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPromoCodesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Creates a new unique promotional code in Stripe for the specified coupon. Only admins can generate promo codes.
 * @summary Generate a new Stripe promotional code
 */
export type createPromoCodeResponse201 = {
  data: PromoCodeResponse
  status: 201
}

export type createPromoCodeResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createPromoCodeResponse401 = {
  data: void
  status: 401
}

export type createPromoCodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type createPromoCodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createPromoCodeResponseSuccess = (createPromoCodeResponse201) & {
  headers: Headers;
};
export type createPromoCodeResponseError = (createPromoCodeResponse400 | createPromoCodeResponse401 | createPromoCodeResponse403 | createPromoCodeResponse500) & {
  headers: Headers;
};

export type createPromoCodeResponse = (createPromoCodeResponseSuccess | createPromoCodeResponseError)

export const getCreatePromoCodeUrl = () => {


  

  return `/customers/admin/promo-codes`
}

export const createPromoCode = async (createPromoCodeRequest: CreatePromoCodeRequest, options?: RequestInit): Promise<createPromoCodeResponse> => {
  
  return customInstance<createPromoCodeResponse>(getCreatePromoCodeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPromoCodeRequest,)
  }
);}




export const getCreatePromoCodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPromoCode>>, TError,{data: CreatePromoCodeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPromoCode>>, TError,{data: CreatePromoCodeRequest}, TContext> => {

const mutationKey = ['createPromoCode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPromoCode>>, {data: CreatePromoCodeRequest}> = (props) => {
          const {data} = props ?? {};

          return  createPromoCode(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof createPromoCode>>>
    export type CreatePromoCodeMutationBody = CreatePromoCodeRequest
    export type CreatePromoCodeMutationError = ErrorResponse | void

    /**
 * @summary Generate a new Stripe promotional code
 */
export const useCreatePromoCode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPromoCode>>, TError,{data: CreatePromoCodeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPromoCode>>,
        TError,
        {data: CreatePromoCodeRequest},
        TContext
      > => {
      return useMutation(getCreatePromoCodeMutationOptions(options), queryClient);
    }
    
/**
 * Deactivates a promotional code in Stripe. Only admins can deactivate promo codes.
 * @summary Deactivate a promotional code
 */
export type deletePromoCodeResponse200 = {
  data: DeletePromoCode200
  status: 200
}

export type deletePromoCodeResponse401 = {
  data: void
  status: 401
}

export type deletePromoCodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type deletePromoCodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deletePromoCodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type deletePromoCodeResponseSuccess = (deletePromoCodeResponse200) & {
  headers: Headers;
};
export type deletePromoCodeResponseError = (deletePromoCodeResponse401 | deletePromoCodeResponse403 | deletePromoCodeResponse404 | deletePromoCodeResponse500) & {
  headers: Headers;
};

export type deletePromoCodeResponse = (deletePromoCodeResponseSuccess | deletePromoCodeResponseError)

export const getDeletePromoCodeUrl = (promoCodeId: string,) => {


  

  return `/customers/admin/promo-codes/${promoCodeId}`
}

export const deletePromoCode = async (promoCodeId: string, options?: RequestInit): Promise<deletePromoCodeResponse> => {
  
  return customInstance<deletePromoCodeResponse>(getDeletePromoCodeUrl(promoCodeId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeletePromoCodeMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePromoCode>>, TError,{promoCodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePromoCode>>, TError,{promoCodeId: string}, TContext> => {

const mutationKey = ['deletePromoCode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePromoCode>>, {promoCodeId: string}> = (props) => {
          const {promoCodeId} = props ?? {};

          return  deletePromoCode(promoCodeId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof deletePromoCode>>>
    
    export type DeletePromoCodeMutationError = void | ErrorResponse

    /**
 * @summary Deactivate a promotional code
 */
export const useDeletePromoCode = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePromoCode>>, TError,{promoCodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePromoCode>>,
        TError,
        {promoCodeId: string},
        TContext
      > => {
      return useMutation(getDeletePromoCodeMutationOptions(options), queryClient);
    }
    
/**
 * Retrieves details of a specific promotional code from Stripe. Only admins can view promo codes.
 * @summary Get a specific promotional code
 */
export type getPromoCodeResponse200 = {
  data: PromoCodeResponse
  status: 200
}

export type getPromoCodeResponse401 = {
  data: void
  status: 401
}

export type getPromoCodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type getPromoCodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getPromoCodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getPromoCodeResponseSuccess = (getPromoCodeResponse200) & {
  headers: Headers;
};
export type getPromoCodeResponseError = (getPromoCodeResponse401 | getPromoCodeResponse403 | getPromoCodeResponse404 | getPromoCodeResponse500) & {
  headers: Headers;
};

export type getPromoCodeResponse = (getPromoCodeResponseSuccess | getPromoCodeResponseError)

export const getGetPromoCodeUrl = (promoCodeId: string,) => {


  

  return `/customers/admin/promo-codes/${promoCodeId}`
}

export const getPromoCode = async (promoCodeId: string, options?: RequestInit): Promise<getPromoCodeResponse> => {
  
  return customInstance<getPromoCodeResponse>(getGetPromoCodeUrl(promoCodeId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPromoCodeQueryKey = (promoCodeId: string,) => {
    return [
    `/customers/admin/promo-codes/${promoCodeId}`
    ] as const;
    }

    
export const getGetPromoCodeQueryOptions = <TData = Awaited<ReturnType<typeof getPromoCode>>, TError = void | ErrorResponse>(promoCodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromoCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPromoCodeQueryKey(promoCodeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPromoCode>>> = ({ signal }) => getPromoCode(promoCodeId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(promoCodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPromoCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPromoCodeQueryResult = NonNullable<Awaited<ReturnType<typeof getPromoCode>>>
export type GetPromoCodeQueryError = void | ErrorResponse


export function useGetPromoCode<TData = Awaited<ReturnType<typeof getPromoCode>>, TError = void | ErrorResponse>(
 promoCodeId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromoCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPromoCode>>,
          TError,
          Awaited<ReturnType<typeof getPromoCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPromoCode<TData = Awaited<ReturnType<typeof getPromoCode>>, TError = void | ErrorResponse>(
 promoCodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromoCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPromoCode>>,
          TError,
          Awaited<ReturnType<typeof getPromoCode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPromoCode<TData = Awaited<ReturnType<typeof getPromoCode>>, TError = void | ErrorResponse>(
 promoCodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromoCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific promotional code
 */

export function useGetPromoCode<TData = Awaited<ReturnType<typeof getPromoCode>>, TError = void | ErrorResponse>(
 promoCodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPromoCode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPromoCodeQueryOptions(promoCodeId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Updates a promotional code in Stripe. Only admins can update promo codes.
 * @summary Update a promotional code
 */
export type updatePromoCodeResponse200 = {
  data: PromoCodeResponse
  status: 200
}

export type updatePromoCodeResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updatePromoCodeResponse401 = {
  data: void
  status: 401
}

export type updatePromoCodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type updatePromoCodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updatePromoCodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type updatePromoCodeResponseSuccess = (updatePromoCodeResponse200) & {
  headers: Headers;
};
export type updatePromoCodeResponseError = (updatePromoCodeResponse400 | updatePromoCodeResponse401 | updatePromoCodeResponse403 | updatePromoCodeResponse404 | updatePromoCodeResponse500) & {
  headers: Headers;
};

export type updatePromoCodeResponse = (updatePromoCodeResponseSuccess | updatePromoCodeResponseError)

export const getUpdatePromoCodeUrl = (promoCodeId: string,) => {


  

  return `/customers/admin/promo-codes/${promoCodeId}`
}

export const updatePromoCode = async (promoCodeId: string,
    updatePromoCodeRequest: UpdatePromoCodeRequest, options?: RequestInit): Promise<updatePromoCodeResponse> => {
  
  return customInstance<updatePromoCodeResponse>(getUpdatePromoCodeUrl(promoCodeId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePromoCodeRequest,)
  }
);}




export const getUpdatePromoCodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePromoCode>>, TError,{promoCodeId: string;data: UpdatePromoCodeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePromoCode>>, TError,{promoCodeId: string;data: UpdatePromoCodeRequest}, TContext> => {

const mutationKey = ['updatePromoCode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePromoCode>>, {promoCodeId: string;data: UpdatePromoCodeRequest}> = (props) => {
          const {promoCodeId,data} = props ?? {};

          return  updatePromoCode(promoCodeId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof updatePromoCode>>>
    export type UpdatePromoCodeMutationBody = UpdatePromoCodeRequest
    export type UpdatePromoCodeMutationError = ErrorResponse | void

    /**
 * @summary Update a promotional code
 */
export const useUpdatePromoCode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePromoCode>>, TError,{promoCodeId: string;data: UpdatePromoCodeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePromoCode>>,
        TError,
        {promoCodeId: string;data: UpdatePromoCodeRequest},
        TContext
      > => {
      return useMutation(getUpdatePromoCodeMutationOptions(options), queryClient);
    }
    
/**
 * @summary List all API keys for a customer
 */
export type listCustomerAPIKeysResponse200 = {
  data: ListCustomerAPIKeys200
  status: 200
}

export type listCustomerAPIKeysResponse401 = {
  data: void
  status: 401
}

export type listCustomerAPIKeysResponse404 = {
  data: void
  status: 404
}

export type listCustomerAPIKeysResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listCustomerAPIKeysResponseSuccess = (listCustomerAPIKeysResponse200) & {
  headers: Headers;
};
export type listCustomerAPIKeysResponseError = (listCustomerAPIKeysResponse401 | listCustomerAPIKeysResponse404 | listCustomerAPIKeysResponse500) & {
  headers: Headers;
};

export type listCustomerAPIKeysResponse = (listCustomerAPIKeysResponseSuccess | listCustomerAPIKeysResponseError)

export const getListCustomerAPIKeysUrl = () => {


  

  return `/customers/api-keys`
}

export const listCustomerAPIKeys = async ( options?: RequestInit): Promise<listCustomerAPIKeysResponse> => {
  
  return customInstance<listCustomerAPIKeysResponse>(getListCustomerAPIKeysUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListCustomerAPIKeysQueryKey = () => {
    return [
    `/customers/api-keys`
    ] as const;
    }

    
export const getListCustomerAPIKeysQueryOptions = <TData = Awaited<ReturnType<typeof listCustomerAPIKeys>>, TError = void | ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAPIKeys>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListCustomerAPIKeysQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listCustomerAPIKeys>>> = ({ signal }) => listCustomerAPIKeys({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listCustomerAPIKeys>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListCustomerAPIKeysQueryResult = NonNullable<Awaited<ReturnType<typeof listCustomerAPIKeys>>>
export type ListCustomerAPIKeysQueryError = void | ErrorResponse


export function useListCustomerAPIKeys<TData = Awaited<ReturnType<typeof listCustomerAPIKeys>>, TError = void | ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAPIKeys>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCustomerAPIKeys>>,
          TError,
          Awaited<ReturnType<typeof listCustomerAPIKeys>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCustomerAPIKeys<TData = Awaited<ReturnType<typeof listCustomerAPIKeys>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAPIKeys>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCustomerAPIKeys>>,
          TError,
          Awaited<ReturnType<typeof listCustomerAPIKeys>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCustomerAPIKeys<TData = Awaited<ReturnType<typeof listCustomerAPIKeys>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAPIKeys>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all API keys for a customer
 */

export function useListCustomerAPIKeys<TData = Awaited<ReturnType<typeof listCustomerAPIKeys>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAPIKeys>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListCustomerAPIKeysQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a new API key for a customer
 */
export type createCustomerAPIKeyResponse201 = {
  data: CreateCustomerAPIKey201
  status: 201
}

export type createCustomerAPIKeyResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createCustomerAPIKeyResponse401 = {
  data: void
  status: 401
}

export type createCustomerAPIKeyResponse404 = {
  data: void
  status: 404
}

export type createCustomerAPIKeyResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createCustomerAPIKeyResponseSuccess = (createCustomerAPIKeyResponse201) & {
  headers: Headers;
};
export type createCustomerAPIKeyResponseError = (createCustomerAPIKeyResponse400 | createCustomerAPIKeyResponse401 | createCustomerAPIKeyResponse404 | createCustomerAPIKeyResponse500) & {
  headers: Headers;
};

export type createCustomerAPIKeyResponse = (createCustomerAPIKeyResponseSuccess | createCustomerAPIKeyResponseError)

export const getCreateCustomerAPIKeyUrl = () => {


  

  return `/customers/api-keys`
}

export const createCustomerAPIKey = async (createAPIKeyRequest: CreateAPIKeyRequest, options?: RequestInit): Promise<createCustomerAPIKeyResponse> => {
  
  return customInstance<createCustomerAPIKeyResponse>(getCreateCustomerAPIKeyUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createAPIKeyRequest,)
  }
);}




export const getCreateCustomerAPIKeyMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomerAPIKey>>, TError,{data: CreateAPIKeyRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCustomerAPIKey>>, TError,{data: CreateAPIKeyRequest}, TContext> => {

const mutationKey = ['createCustomerAPIKey'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCustomerAPIKey>>, {data: CreateAPIKeyRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCustomerAPIKey(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCustomerAPIKeyMutationResult = NonNullable<Awaited<ReturnType<typeof createCustomerAPIKey>>>
    export type CreateCustomerAPIKeyMutationBody = CreateAPIKeyRequest
    export type CreateCustomerAPIKeyMutationError = ErrorResponse | void

    /**
 * @summary Create a new API key for a customer
 */
export const useCreateCustomerAPIKey = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomerAPIKey>>, TError,{data: CreateAPIKeyRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCustomerAPIKey>>,
        TError,
        {data: CreateAPIKeyRequest},
        TContext
      > => {
      return useMutation(getCreateCustomerAPIKeyMutationOptions(options), queryClient);
    }
    
/**
 * @summary Delete an API key for a customer
 */
export type deleteCustomerAPIKeyResponse204 = {
  data: void
  status: 204
}

export type deleteCustomerAPIKeyResponse401 = {
  data: void
  status: 401
}

export type deleteCustomerAPIKeyResponse404 = {
  data: void
  status: 404
}

export type deleteCustomerAPIKeyResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type deleteCustomerAPIKeyResponseSuccess = (deleteCustomerAPIKeyResponse204) & {
  headers: Headers;
};
export type deleteCustomerAPIKeyResponseError = (deleteCustomerAPIKeyResponse401 | deleteCustomerAPIKeyResponse404 | deleteCustomerAPIKeyResponse500) & {
  headers: Headers;
};

export type deleteCustomerAPIKeyResponse = (deleteCustomerAPIKeyResponseSuccess | deleteCustomerAPIKeyResponseError)

export const getDeleteCustomerAPIKeyUrl = (apiKeyId: string,) => {


  

  return `/customers/api-keys/${apiKeyId}`
}

export const deleteCustomerAPIKey = async (apiKeyId: string, options?: RequestInit): Promise<deleteCustomerAPIKeyResponse> => {
  
  return customInstance<deleteCustomerAPIKeyResponse>(getDeleteCustomerAPIKeyUrl(apiKeyId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteCustomerAPIKeyMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomerAPIKey>>, TError,{apiKeyId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCustomerAPIKey>>, TError,{apiKeyId: string}, TContext> => {

const mutationKey = ['deleteCustomerAPIKey'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCustomerAPIKey>>, {apiKeyId: string}> = (props) => {
          const {apiKeyId} = props ?? {};

          return  deleteCustomerAPIKey(apiKeyId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCustomerAPIKeyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCustomerAPIKey>>>
    
    export type DeleteCustomerAPIKeyMutationError = void | ErrorResponse

    /**
 * @summary Delete an API key for a customer
 */
export const useDeleteCustomerAPIKey = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomerAPIKey>>, TError,{apiKeyId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCustomerAPIKey>>,
        TError,
        {apiKeyId: string},
        TContext
      > => {
      return useMutation(getDeleteCustomerAPIKeyMutationOptions(options), queryClient);
    }
    
/**
 * Returns the customer's current remaining balance in microamount and its currency, with separate breakdowns for prepaid commits and cloud credits.
 * @summary Get customer's remaining balance
 */
export type getCustomerBalanceResponse200 = {
  data: GetCustomerBalance200
  status: 200
}

export type getCustomerBalanceResponse401 = {
  data: void
  status: 401
}

export type getCustomerBalanceResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getCustomerBalanceResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getCustomerBalanceResponseSuccess = (getCustomerBalanceResponse200) & {
  headers: Headers;
};
export type getCustomerBalanceResponseError = (getCustomerBalanceResponse401 | getCustomerBalanceResponse404 | getCustomerBalanceResponse500) & {
  headers: Headers;
};

export type getCustomerBalanceResponse = (getCustomerBalanceResponseSuccess | getCustomerBalanceResponseError)

export const getGetCustomerBalanceUrl = () => {


  

  return `/customers/balance`
}

export const getCustomerBalance = async ( options?: RequestInit): Promise<getCustomerBalanceResponse> => {
  
  return customInstance<getCustomerBalanceResponse>(getGetCustomerBalanceUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomerBalanceQueryKey = () => {
    return [
    `/customers/balance`
    ] as const;
    }

    
export const getGetCustomerBalanceQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerBalance>>, TError = void | ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerBalanceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerBalance>>> = ({ signal }) => getCustomerBalance({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalance>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerBalanceQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerBalance>>>
export type GetCustomerBalanceQueryError = void | ErrorResponse


export function useGetCustomerBalance<TData = Awaited<ReturnType<typeof getCustomerBalance>>, TError = void | ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalance>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerBalance>>,
          TError,
          Awaited<ReturnType<typeof getCustomerBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerBalance<TData = Awaited<ReturnType<typeof getCustomerBalance>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalance>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerBalance>>,
          TError,
          Awaited<ReturnType<typeof getCustomerBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerBalance<TData = Awaited<ReturnType<typeof getCustomerBalance>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get customer's remaining balance
 */

export function useGetCustomerBalance<TData = Awaited<ReturnType<typeof getCustomerBalance>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerBalanceQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Creates a session for the customer to access their billing portal where they can manage subscriptions, payment methods, and view invoices.
 * @summary Access customer billing portal
 */
export type accessBillingPortalResponse200 = {
  data: AccessBillingPortal200
  status: 200
}

export type accessBillingPortalResponse400 = {
  data: ErrorResponse
  status: 400
}

export type accessBillingPortalResponse401 = {
  data: void
  status: 401
}

export type accessBillingPortalResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type accessBillingPortalResponseSuccess = (accessBillingPortalResponse200) & {
  headers: Headers;
};
export type accessBillingPortalResponseError = (accessBillingPortalResponse400 | accessBillingPortalResponse401 | accessBillingPortalResponse500) & {
  headers: Headers;
};

export type accessBillingPortalResponse = (accessBillingPortalResponseSuccess | accessBillingPortalResponseError)

export const getAccessBillingPortalUrl = () => {


  

  return `/customers/billing`
}

export const accessBillingPortal = async (accessBillingPortalBody: AccessBillingPortalBody, options?: RequestInit): Promise<accessBillingPortalResponse> => {
  
  return customInstance<accessBillingPortalResponse>(getAccessBillingPortalUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      accessBillingPortalBody,)
  }
);}




export const getAccessBillingPortalMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accessBillingPortal>>, TError,{data: AccessBillingPortalBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof accessBillingPortal>>, TError,{data: AccessBillingPortalBody}, TContext> => {

const mutationKey = ['accessBillingPortal'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof accessBillingPortal>>, {data: AccessBillingPortalBody}> = (props) => {
          const {data} = props ?? {};

          return  accessBillingPortal(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AccessBillingPortalMutationResult = NonNullable<Awaited<ReturnType<typeof accessBillingPortal>>>
    export type AccessBillingPortalMutationBody = AccessBillingPortalBody
    export type AccessBillingPortalMutationError = ErrorResponse | void

    /**
 * @summary Access customer billing portal
 */
export const useAccessBillingPortal = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accessBillingPortal>>, TError,{data: AccessBillingPortalBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof accessBillingPortal>>,
        TError,
        {data: AccessBillingPortalBody},
        TContext
      > => {
      return useMutation(getAccessBillingPortalMutationOptions(options), queryClient);
    }
    
/**
 * Creates a cloud subscription checkout session for $20/month with automatic billing
 * @summary Create cloud subscription checkout session
 */
export type createCloudSubscriptionCheckoutResponse201 = {
  data: CreateCloudSubscriptionCheckout201
  status: 201
}

export type createCloudSubscriptionCheckoutResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createCloudSubscriptionCheckoutResponse401 = {
  data: void
  status: 401
}

export type createCloudSubscriptionCheckoutResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createCloudSubscriptionCheckoutResponseSuccess = (createCloudSubscriptionCheckoutResponse201) & {
  headers: Headers;
};
export type createCloudSubscriptionCheckoutResponseError = (createCloudSubscriptionCheckoutResponse400 | createCloudSubscriptionCheckoutResponse401 | createCloudSubscriptionCheckoutResponse500) & {
  headers: Headers;
};

export type createCloudSubscriptionCheckoutResponse = (createCloudSubscriptionCheckoutResponseSuccess | createCloudSubscriptionCheckoutResponseError)

export const getCreateCloudSubscriptionCheckoutUrl = () => {


  

  return `/customers/cloud-subscription-checkout`
}

export const createCloudSubscriptionCheckout = async (createCloudSubscriptionCheckoutBody: CreateCloudSubscriptionCheckoutBody, options?: RequestInit): Promise<createCloudSubscriptionCheckoutResponse> => {
  
  return customInstance<createCloudSubscriptionCheckoutResponse>(getCreateCloudSubscriptionCheckoutUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createCloudSubscriptionCheckoutBody,)
  }
);}




export const getCreateCloudSubscriptionCheckoutMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCloudSubscriptionCheckout>>, TError,{data: CreateCloudSubscriptionCheckoutBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCloudSubscriptionCheckout>>, TError,{data: CreateCloudSubscriptionCheckoutBody}, TContext> => {

const mutationKey = ['createCloudSubscriptionCheckout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCloudSubscriptionCheckout>>, {data: CreateCloudSubscriptionCheckoutBody}> = (props) => {
          const {data} = props ?? {};

          return  createCloudSubscriptionCheckout(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCloudSubscriptionCheckoutMutationResult = NonNullable<Awaited<ReturnType<typeof createCloudSubscriptionCheckout>>>
    export type CreateCloudSubscriptionCheckoutMutationBody = CreateCloudSubscriptionCheckoutBody
    export type CreateCloudSubscriptionCheckoutMutationError = ErrorResponse | void

    /**
 * @summary Create cloud subscription checkout session
 */
export const useCreateCloudSubscriptionCheckout = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCloudSubscriptionCheckout>>, TError,{data: CreateCloudSubscriptionCheckoutBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCloudSubscriptionCheckout>>,
        TError,
        {data: CreateCloudSubscriptionCheckoutBody},
        TContext
      > => {
      return useMutation(getCreateCloudSubscriptionCheckoutMutationOptions(options), queryClient);
    }
    
/**
 * Creates a cloud subscription checkout session for a specific subscription tier (standard, creator, or pro) with automatic billing
 * @summary Create cloud subscription checkout session for a specific tier
 */
export type createCloudSubscriptionCheckoutTierResponse201 = {
  data: CreateCloudSubscriptionCheckoutTier201
  status: 201
}

export type createCloudSubscriptionCheckoutTierResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createCloudSubscriptionCheckoutTierResponse401 = {
  data: void
  status: 401
}

export type createCloudSubscriptionCheckoutTierResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createCloudSubscriptionCheckoutTierResponseSuccess = (createCloudSubscriptionCheckoutTierResponse201) & {
  headers: Headers;
};
export type createCloudSubscriptionCheckoutTierResponseError = (createCloudSubscriptionCheckoutTierResponse400 | createCloudSubscriptionCheckoutTierResponse401 | createCloudSubscriptionCheckoutTierResponse500) & {
  headers: Headers;
};

export type createCloudSubscriptionCheckoutTierResponse = (createCloudSubscriptionCheckoutTierResponseSuccess | createCloudSubscriptionCheckoutTierResponseError)

export const getCreateCloudSubscriptionCheckoutTierUrl = (tier: 'standard' | 'creator' | 'pro' | 'standard-yearly' | 'creator-yearly' | 'pro-yearly',) => {


  

  return `/customers/cloud-subscription-checkout/${tier}`
}

export const createCloudSubscriptionCheckoutTier = async (tier: 'standard' | 'creator' | 'pro' | 'standard-yearly' | 'creator-yearly' | 'pro-yearly',
    createCloudSubscriptionCheckoutTierBody: CreateCloudSubscriptionCheckoutTierBody, options?: RequestInit): Promise<createCloudSubscriptionCheckoutTierResponse> => {
  
  return customInstance<createCloudSubscriptionCheckoutTierResponse>(getCreateCloudSubscriptionCheckoutTierUrl(tier),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createCloudSubscriptionCheckoutTierBody,)
  }
);}




export const getCreateCloudSubscriptionCheckoutTierMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCloudSubscriptionCheckoutTier>>, TError,{tier: 'standard' | 'creator' | 'pro' | 'standard-yearly' | 'creator-yearly' | 'pro-yearly';data: CreateCloudSubscriptionCheckoutTierBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCloudSubscriptionCheckoutTier>>, TError,{tier: 'standard' | 'creator' | 'pro' | 'standard-yearly' | 'creator-yearly' | 'pro-yearly';data: CreateCloudSubscriptionCheckoutTierBody}, TContext> => {

const mutationKey = ['createCloudSubscriptionCheckoutTier'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCloudSubscriptionCheckoutTier>>, {tier: 'standard' | 'creator' | 'pro' | 'standard-yearly' | 'creator-yearly' | 'pro-yearly';data: CreateCloudSubscriptionCheckoutTierBody}> = (props) => {
          const {tier,data} = props ?? {};

          return  createCloudSubscriptionCheckoutTier(tier,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCloudSubscriptionCheckoutTierMutationResult = NonNullable<Awaited<ReturnType<typeof createCloudSubscriptionCheckoutTier>>>
    export type CreateCloudSubscriptionCheckoutTierMutationBody = CreateCloudSubscriptionCheckoutTierBody
    export type CreateCloudSubscriptionCheckoutTierMutationError = ErrorResponse | void

    /**
 * @summary Create cloud subscription checkout session for a specific tier
 */
export const useCreateCloudSubscriptionCheckoutTier = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCloudSubscriptionCheckoutTier>>, TError,{tier: 'standard' | 'creator' | 'pro' | 'standard-yearly' | 'creator-yearly' | 'pro-yearly';data: CreateCloudSubscriptionCheckoutTierBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCloudSubscriptionCheckoutTier>>,
        TError,
        {tier: 'standard' | 'creator' | 'pro' | 'standard-yearly' | 'creator-yearly' | 'pro-yearly';data: CreateCloudSubscriptionCheckoutTierBody},
        TContext
      > => {
      return useMutation(getCreateCloudSubscriptionCheckoutTierMutationOptions(options), queryClient);
    }
    
/**
 * Check if the customer has an active cloud subscription
 * @summary Check cloud subscription status
 */
export type getCloudSubscriptionStatusResponse200 = {
  data: GetCloudSubscriptionStatus200
  status: 200
}

export type getCloudSubscriptionStatusResponse401 = {
  data: void
  status: 401
}

export type getCloudSubscriptionStatusResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getCloudSubscriptionStatusResponseSuccess = (getCloudSubscriptionStatusResponse200) & {
  headers: Headers;
};
export type getCloudSubscriptionStatusResponseError = (getCloudSubscriptionStatusResponse401 | getCloudSubscriptionStatusResponse500) & {
  headers: Headers;
};

export type getCloudSubscriptionStatusResponse = (getCloudSubscriptionStatusResponseSuccess | getCloudSubscriptionStatusResponseError)

export const getGetCloudSubscriptionStatusUrl = () => {


  

  return `/customers/cloud-subscription-status`
}

export const getCloudSubscriptionStatus = async ( options?: RequestInit): Promise<getCloudSubscriptionStatusResponse> => {
  
  return customInstance<getCloudSubscriptionStatusResponse>(getGetCloudSubscriptionStatusUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCloudSubscriptionStatusQueryKey = () => {
    return [
    `/customers/cloud-subscription-status`
    ] as const;
    }

    
export const getGetCloudSubscriptionStatusQueryOptions = <TData = Awaited<ReturnType<typeof getCloudSubscriptionStatus>>, TError = void | ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCloudSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCloudSubscriptionStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCloudSubscriptionStatus>>> = ({ signal }) => getCloudSubscriptionStatus({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCloudSubscriptionStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCloudSubscriptionStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getCloudSubscriptionStatus>>>
export type GetCloudSubscriptionStatusQueryError = void | ErrorResponse


export function useGetCloudSubscriptionStatus<TData = Awaited<ReturnType<typeof getCloudSubscriptionStatus>>, TError = void | ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCloudSubscriptionStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCloudSubscriptionStatus>>,
          TError,
          Awaited<ReturnType<typeof getCloudSubscriptionStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCloudSubscriptionStatus<TData = Awaited<ReturnType<typeof getCloudSubscriptionStatus>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCloudSubscriptionStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCloudSubscriptionStatus>>,
          TError,
          Awaited<ReturnType<typeof getCloudSubscriptionStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCloudSubscriptionStatus<TData = Awaited<ReturnType<typeof getCloudSubscriptionStatus>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCloudSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check cloud subscription status
 */

export function useGetCloudSubscriptionStatus<TData = Awaited<ReturnType<typeof getCloudSubscriptionStatus>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCloudSubscriptionStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCloudSubscriptionStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Initiates a Credit Purchase.
 */
export type initiateCreditPurchaseResponse201 = {
  data: InitiateCreditPurchase201
  status: 201
}

export type initiateCreditPurchaseResponse400 = {
  data: ErrorResponse
  status: 400
}

export type initiateCreditPurchaseResponse401 = {
  data: void
  status: 401
}

export type initiateCreditPurchaseResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type initiateCreditPurchaseResponseSuccess = (initiateCreditPurchaseResponse201) & {
  headers: Headers;
};
export type initiateCreditPurchaseResponseError = (initiateCreditPurchaseResponse400 | initiateCreditPurchaseResponse401 | initiateCreditPurchaseResponse500) & {
  headers: Headers;
};

export type initiateCreditPurchaseResponse = (initiateCreditPurchaseResponseSuccess | initiateCreditPurchaseResponseError)

export const getInitiateCreditPurchaseUrl = () => {


  

  return `/customers/credit`
}

export const initiateCreditPurchase = async (initiateCreditPurchaseBody: InitiateCreditPurchaseBody, options?: RequestInit): Promise<initiateCreditPurchaseResponse> => {
  
  return customInstance<initiateCreditPurchaseResponse>(getInitiateCreditPurchaseUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      initiateCreditPurchaseBody,)
  }
);}




export const getInitiateCreditPurchaseMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initiateCreditPurchase>>, TError,{data: InitiateCreditPurchaseBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof initiateCreditPurchase>>, TError,{data: InitiateCreditPurchaseBody}, TContext> => {

const mutationKey = ['initiateCreditPurchase'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initiateCreditPurchase>>, {data: InitiateCreditPurchaseBody}> = (props) => {
          const {data} = props ?? {};

          return  initiateCreditPurchase(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type InitiateCreditPurchaseMutationResult = NonNullable<Awaited<ReturnType<typeof initiateCreditPurchase>>>
    export type InitiateCreditPurchaseMutationBody = InitiateCreditPurchaseBody
    export type InitiateCreditPurchaseMutationError = ErrorResponse | void

    /**
 * @summary Initiates a Credit Purchase.
 */
export const useInitiateCreditPurchase = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initiateCreditPurchase>>, TError,{data: InitiateCreditPurchaseBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initiateCreditPurchase>>,
        TError,
        {data: InitiateCreditPurchaseBody},
        TContext
      > => {
      return useMutation(getInitiateCreditPurchaseMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get events related to customer
 */
export type getCustomerEventsResponse200 = {
  data: GetCustomerEvents200
  status: 200
}

export type getCustomerEventsResponse400 = {
  data: void
  status: 400
}

export type getCustomerEventsResponse404 = {
  data: void
  status: 404
}

export type getCustomerEventsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getCustomerEventsResponseSuccess = (getCustomerEventsResponse200) & {
  headers: Headers;
};
export type getCustomerEventsResponseError = (getCustomerEventsResponse400 | getCustomerEventsResponse404 | getCustomerEventsResponse500) & {
  headers: Headers;
};

export type getCustomerEventsResponse = (getCustomerEventsResponseSuccess | getCustomerEventsResponseError)

export const getGetCustomerEventsUrl = (params?: GetCustomerEventsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/customers/events?${stringifiedParams}` : `/customers/events`
}

export const getCustomerEvents = async (params?: GetCustomerEventsParams, options?: RequestInit): Promise<getCustomerEventsResponse> => {
  
  return customInstance<getCustomerEventsResponse>(getGetCustomerEventsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomerEventsQueryKey = (params?: GetCustomerEventsParams,) => {
    return [
    `/customers/events`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetCustomerEventsQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerEvents>>, TError = void | ErrorResponse>(params?: GetCustomerEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerEvents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerEvents>>> = ({ signal }) => getCustomerEvents(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerEventsQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerEvents>>>
export type GetCustomerEventsQueryError = void | ErrorResponse


export function useGetCustomerEvents<TData = Awaited<ReturnType<typeof getCustomerEvents>>, TError = void | ErrorResponse>(
 params: undefined |  GetCustomerEventsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerEvents>>,
          TError,
          Awaited<ReturnType<typeof getCustomerEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerEvents<TData = Awaited<ReturnType<typeof getCustomerEvents>>, TError = void | ErrorResponse>(
 params?: GetCustomerEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerEvents>>,
          TError,
          Awaited<ReturnType<typeof getCustomerEvents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerEvents<TData = Awaited<ReturnType<typeof getCustomerEvents>>, TError = void | ErrorResponse>(
 params?: GetCustomerEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerEvents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get events related to customer
 */

export function useGetCustomerEvents<TData = Awaited<ReturnType<typeof getCustomerEvents>>, TError = void | ErrorResponse>(
 params?: GetCustomerEventsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerEvents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerEventsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns details about the currently authenticated customer based on their JWT token.
 * @summary Get authenticated customer details
 */
export type getAuthenticatedCustomerResponse200 = {
  data: Customer
  status: 200
}

export type getAuthenticatedCustomerResponse401 = {
  data: void
  status: 401
}

export type getAuthenticatedCustomerResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getAuthenticatedCustomerResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getAuthenticatedCustomerResponseSuccess = (getAuthenticatedCustomerResponse200) & {
  headers: Headers;
};
export type getAuthenticatedCustomerResponseError = (getAuthenticatedCustomerResponse401 | getAuthenticatedCustomerResponse404 | getAuthenticatedCustomerResponse500) & {
  headers: Headers;
};

export type getAuthenticatedCustomerResponse = (getAuthenticatedCustomerResponseSuccess | getAuthenticatedCustomerResponseError)

export const getGetAuthenticatedCustomerUrl = () => {


  

  return `/customers/me`
}

export const getAuthenticatedCustomer = async ( options?: RequestInit): Promise<getAuthenticatedCustomerResponse> => {
  
  return customInstance<getAuthenticatedCustomerResponse>(getGetAuthenticatedCustomerUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAuthenticatedCustomerQueryKey = () => {
    return [
    `/customers/me`
    ] as const;
    }

    
export const getGetAuthenticatedCustomerQueryOptions = <TData = Awaited<ReturnType<typeof getAuthenticatedCustomer>>, TError = void | ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthenticatedCustomer>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthenticatedCustomerQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthenticatedCustomer>>> = ({ signal }) => getAuthenticatedCustomer({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthenticatedCustomer>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAuthenticatedCustomerQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthenticatedCustomer>>>
export type GetAuthenticatedCustomerQueryError = void | ErrorResponse


export function useGetAuthenticatedCustomer<TData = Awaited<ReturnType<typeof getAuthenticatedCustomer>>, TError = void | ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthenticatedCustomer>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
          TError,
          Awaited<ReturnType<typeof getAuthenticatedCustomer>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthenticatedCustomer<TData = Awaited<ReturnType<typeof getAuthenticatedCustomer>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthenticatedCustomer>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
          TError,
          Awaited<ReturnType<typeof getAuthenticatedCustomer>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAuthenticatedCustomer<TData = Awaited<ReturnType<typeof getAuthenticatedCustomer>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthenticatedCustomer>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get authenticated customer details
 */

export function useGetAuthenticatedCustomer<TData = Awaited<ReturnType<typeof getAuthenticatedCustomer>>, TError = void | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthenticatedCustomer>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAuthenticatedCustomerQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Store a resource for a customer. Resource will have a 24 hour expiry. The signed URL will be generated for the specified file path.
 * @summary Store a resource for a customer
 */
export type createCustomerStorageResourceResponse200 = {
  data: CustomerStorageResourceResponse
  status: 200
}

export type createCustomerStorageResourceResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createCustomerStorageResourceResponse401 = {
  data: void
  status: 401
}

export type createCustomerStorageResourceResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createCustomerStorageResourceResponseSuccess = (createCustomerStorageResourceResponse200) & {
  headers: Headers;
};
export type createCustomerStorageResourceResponseError = (createCustomerStorageResourceResponse400 | createCustomerStorageResourceResponse401 | createCustomerStorageResourceResponse500) & {
  headers: Headers;
};

export type createCustomerStorageResourceResponse = (createCustomerStorageResourceResponseSuccess | createCustomerStorageResourceResponseError)

export const getCreateCustomerStorageResourceUrl = () => {


  

  return `/customers/storage`
}

export const createCustomerStorageResource = async (createCustomerStorageResourceBody: CreateCustomerStorageResourceBody, options?: RequestInit): Promise<createCustomerStorageResourceResponse> => {
  
  return customInstance<createCustomerStorageResourceResponse>(getCreateCustomerStorageResourceUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createCustomerStorageResourceBody,)
  }
);}




export const getCreateCustomerStorageResourceMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomerStorageResource>>, TError,{data: CreateCustomerStorageResourceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCustomerStorageResource>>, TError,{data: CreateCustomerStorageResourceBody}, TContext> => {

const mutationKey = ['createCustomerStorageResource'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCustomerStorageResource>>, {data: CreateCustomerStorageResourceBody}> = (props) => {
          const {data} = props ?? {};

          return  createCustomerStorageResource(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCustomerStorageResourceMutationResult = NonNullable<Awaited<ReturnType<typeof createCustomerStorageResource>>>
    export type CreateCustomerStorageResourceMutationBody = CreateCustomerStorageResourceBody
    export type CreateCustomerStorageResourceMutationError = ErrorResponse | void

    /**
 * @summary Store a resource for a customer
 */
export const useCreateCustomerStorageResource = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomerStorageResource>>, TError,{data: CreateCustomerStorageResourceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCustomerStorageResource>>,
        TError,
        {data: CreateCustomerStorageResourceBody},
        TContext
      > => {
      return useMutation(getCreateCustomerStorageResourceMutationOptions(options), queryClient);
    }
    
/**
 * Returns the customer's as a dashboard URL.
 * @summary Get customer's usage
 */
export type getCustomerUsageResponse200 = {
  data: GetCustomerUsage200
  status: 200
}

export type getCustomerUsageResponse401 = {
  data: void
  status: 401
}

export type getCustomerUsageResponse404 = {
  data: void
  status: 404
}

export type getCustomerUsageResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getCustomerUsageResponseSuccess = (getCustomerUsageResponse200) & {
  headers: Headers;
};
export type getCustomerUsageResponseError = (getCustomerUsageResponse401 | getCustomerUsageResponse404 | getCustomerUsageResponse500) & {
  headers: Headers;
};

export type getCustomerUsageResponse = (getCustomerUsageResponseSuccess | getCustomerUsageResponseError)

export const getGetCustomerUsageUrl = () => {


  

  return `/customers/usage`
}

export const getCustomerUsage = async (getCustomerUsageBody: GetCustomerUsageBody, options?: RequestInit): Promise<getCustomerUsageResponse> => {
  
  return customInstance<getCustomerUsageResponse>(getGetCustomerUsageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      getCustomerUsageBody,)
  }
);}




export const getGetCustomerUsageMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getCustomerUsage>>, TError,{data: GetCustomerUsageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getCustomerUsage>>, TError,{data: GetCustomerUsageBody}, TContext> => {

const mutationKey = ['getCustomerUsage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getCustomerUsage>>, {data: GetCustomerUsageBody}> = (props) => {
          const {data} = props ?? {};

          return  getCustomerUsage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type GetCustomerUsageMutationResult = NonNullable<Awaited<ReturnType<typeof getCustomerUsage>>>
    export type GetCustomerUsageMutationBody = GetCustomerUsageBody
    export type GetCustomerUsageMutationError = void | ErrorResponse

    /**
 * @summary Get customer's usage
 */
export const useGetCustomerUsage = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getCustomerUsage>>, TError,{data: GetCustomerUsageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getCustomerUsage>>,
        TError,
        {data: GetCustomerUsageBody},
        TContext
      > => {
      return useMutation(getGetCustomerUsageMutationOptions(options), queryClient);
    }
    
/**
 * Returns details about a customer by their ID.
 * @summary Get a customer by ID
 */
export type getCustomerByIdResponse200 = {
  data: GetCustomerById200
  status: 200
}

export type getCustomerByIdResponse401 = {
  data: void
  status: 401
}

export type getCustomerByIdResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getCustomerByIdResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getCustomerByIdResponseSuccess = (getCustomerByIdResponse200) & {
  headers: Headers;
};
export type getCustomerByIdResponseError = (getCustomerByIdResponse401 | getCustomerByIdResponse404 | getCustomerByIdResponse500) & {
  headers: Headers;
};

export type getCustomerByIdResponse = (getCustomerByIdResponseSuccess | getCustomerByIdResponseError)

export const getGetCustomerByIdUrl = (customerId: string,) => {


  

  return `/customers/${customerId}`
}

export const getCustomerById = async (customerId: string, options?: RequestInit): Promise<getCustomerByIdResponse> => {
  
  return customInstance<getCustomerByIdResponse>(getGetCustomerByIdUrl(customerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomerByIdQueryKey = (customerId: string,) => {
    return [
    `/customers/${customerId}`
    ] as const;
    }

    
export const getGetCustomerByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerById>>, TError = void | ErrorResponse>(customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerByIdQueryKey(customerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerById>>> = ({ signal }) => getCustomerById(customerId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerById>>>
export type GetCustomerByIdQueryError = void | ErrorResponse


export function useGetCustomerById<TData = Awaited<ReturnType<typeof getCustomerById>>, TError = void | ErrorResponse>(
 customerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerById>>,
          TError,
          Awaited<ReturnType<typeof getCustomerById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerById<TData = Awaited<ReturnType<typeof getCustomerById>>, TError = void | ErrorResponse>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerById>>,
          TError,
          Awaited<ReturnType<typeof getCustomerById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerById<TData = Awaited<ReturnType<typeof getCustomerById>>, TError = void | ErrorResponse>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a customer by ID
 */

export function useGetCustomerById<TData = Awaited<ReturnType<typeof getCustomerById>>, TError = void | ErrorResponse>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerByIdQueryOptions(customerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns the specified customer's current remaining balance in microamount and its currency, with separate breakdowns for prepaid commits and cloud credits.
 * @summary Get customer's remaining balance by ID
 */
export type getCustomerBalanceByIdResponse200 = {
  data: GetCustomerBalanceById200
  status: 200
}

export type getCustomerBalanceByIdResponse400 = {
  data: ErrorResponse
  status: 400
}

export type getCustomerBalanceByIdResponse401 = {
  data: void
  status: 401
}

export type getCustomerBalanceByIdResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getCustomerBalanceByIdResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getCustomerBalanceByIdResponseSuccess = (getCustomerBalanceByIdResponse200) & {
  headers: Headers;
};
export type getCustomerBalanceByIdResponseError = (getCustomerBalanceByIdResponse400 | getCustomerBalanceByIdResponse401 | getCustomerBalanceByIdResponse404 | getCustomerBalanceByIdResponse500) & {
  headers: Headers;
};

export type getCustomerBalanceByIdResponse = (getCustomerBalanceByIdResponseSuccess | getCustomerBalanceByIdResponseError)

export const getGetCustomerBalanceByIdUrl = (customerId: string,) => {


  

  return `/customers/${customerId}/balance`
}

export const getCustomerBalanceById = async (customerId: string, options?: RequestInit): Promise<getCustomerBalanceByIdResponse> => {
  
  return customInstance<getCustomerBalanceByIdResponse>(getGetCustomerBalanceByIdUrl(customerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomerBalanceByIdQueryKey = (customerId: string,) => {
    return [
    `/customers/${customerId}/balance`
    ] as const;
    }

    
export const getGetCustomerBalanceByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerBalanceById>>, TError = ErrorResponse | void>(customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalanceById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerBalanceByIdQueryKey(customerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerBalanceById>>> = ({ signal }) => getCustomerBalanceById(customerId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalanceById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerBalanceByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerBalanceById>>>
export type GetCustomerBalanceByIdQueryError = ErrorResponse | void


export function useGetCustomerBalanceById<TData = Awaited<ReturnType<typeof getCustomerBalanceById>>, TError = ErrorResponse | void>(
 customerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalanceById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerBalanceById>>,
          TError,
          Awaited<ReturnType<typeof getCustomerBalanceById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerBalanceById<TData = Awaited<ReturnType<typeof getCustomerBalanceById>>, TError = ErrorResponse | void>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalanceById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerBalanceById>>,
          TError,
          Awaited<ReturnType<typeof getCustomerBalanceById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerBalanceById<TData = Awaited<ReturnType<typeof getCustomerBalanceById>>, TError = ErrorResponse | void>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalanceById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get customer's remaining balance by ID
 */

export function useGetCustomerBalanceById<TData = Awaited<ReturnType<typeof getCustomerBalanceById>>, TError = ErrorResponse | void>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerBalanceById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerBalanceByIdQueryOptions(customerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get events related to customer
 */
export type getCustomerEventsByIdResponse200 = {
  data: GetCustomerEventsById200
  status: 200
}

export type getCustomerEventsByIdResponse400 = {
  data: void
  status: 400
}

export type getCustomerEventsByIdResponse404 = {
  data: void
  status: 404
}

export type getCustomerEventsByIdResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getCustomerEventsByIdResponseSuccess = (getCustomerEventsByIdResponse200) & {
  headers: Headers;
};
export type getCustomerEventsByIdResponseError = (getCustomerEventsByIdResponse400 | getCustomerEventsByIdResponse404 | getCustomerEventsByIdResponse500) & {
  headers: Headers;
};

export type getCustomerEventsByIdResponse = (getCustomerEventsByIdResponseSuccess | getCustomerEventsByIdResponseError)

export const getGetCustomerEventsByIdUrl = (customerId: string,
    params?: GetCustomerEventsByIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/customers/${customerId}/events?${stringifiedParams}` : `/customers/${customerId}/events`
}

export const getCustomerEventsById = async (customerId: string,
    params?: GetCustomerEventsByIdParams, options?: RequestInit): Promise<getCustomerEventsByIdResponse> => {
  
  return customInstance<getCustomerEventsByIdResponse>(getGetCustomerEventsByIdUrl(customerId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomerEventsByIdQueryKey = (customerId: string,
    params?: GetCustomerEventsByIdParams,) => {
    return [
    `/customers/${customerId}/events`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetCustomerEventsByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerEventsById>>, TError = void | ErrorResponse>(customerId: string,
    params?: GetCustomerEventsByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerEventsById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerEventsByIdQueryKey(customerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerEventsById>>> = ({ signal }) => getCustomerEventsById(customerId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerEventsById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerEventsByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerEventsById>>>
export type GetCustomerEventsByIdQueryError = void | ErrorResponse


export function useGetCustomerEventsById<TData = Awaited<ReturnType<typeof getCustomerEventsById>>, TError = void | ErrorResponse>(
 customerId: string,
    params: undefined |  GetCustomerEventsByIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerEventsById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerEventsById>>,
          TError,
          Awaited<ReturnType<typeof getCustomerEventsById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerEventsById<TData = Awaited<ReturnType<typeof getCustomerEventsById>>, TError = void | ErrorResponse>(
 customerId: string,
    params?: GetCustomerEventsByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerEventsById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerEventsById>>,
          TError,
          Awaited<ReturnType<typeof getCustomerEventsById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerEventsById<TData = Awaited<ReturnType<typeof getCustomerEventsById>>, TError = void | ErrorResponse>(
 customerId: string,
    params?: GetCustomerEventsByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerEventsById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get events related to customer
 */

export function useGetCustomerEventsById<TData = Awaited<ReturnType<typeof getCustomerEventsById>>, TError = void | ErrorResponse>(
 customerId: string,
    params?: GetCustomerEventsByIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerEventsById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerEventsByIdQueryOptions(customerId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Manually track usage for a customer in Metronome. This endpoint is for admin use to record usage events.
 * @summary Track usage for a customer (Admin only)
 */
export type trackCustomerUsageResponse200 = {
  data: TrackCustomerUsage200
  status: 200
}

export type trackCustomerUsageResponse400 = {
  data: ErrorResponse
  status: 400
}

export type trackCustomerUsageResponse401 = {
  data: void
  status: 401
}

export type trackCustomerUsageResponse404 = {
  data: ErrorResponse
  status: 404
}

export type trackCustomerUsageResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type trackCustomerUsageResponseSuccess = (trackCustomerUsageResponse200) & {
  headers: Headers;
};
export type trackCustomerUsageResponseError = (trackCustomerUsageResponse400 | trackCustomerUsageResponse401 | trackCustomerUsageResponse404 | trackCustomerUsageResponse500) & {
  headers: Headers;
};

export type trackCustomerUsageResponse = (trackCustomerUsageResponseSuccess | trackCustomerUsageResponseError)

export const getTrackCustomerUsageUrl = (customerId: string,) => {


  

  return `/customers/${customerId}/usage`
}

export const trackCustomerUsage = async (customerId: string,
    trackCustomerUsageBody: TrackCustomerUsageBody, options?: RequestInit): Promise<trackCustomerUsageResponse> => {
  
  return customInstance<trackCustomerUsageResponse>(getTrackCustomerUsageUrl(customerId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      trackCustomerUsageBody,)
  }
);}




export const getTrackCustomerUsageMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trackCustomerUsage>>, TError,{customerId: string;data: TrackCustomerUsageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof trackCustomerUsage>>, TError,{customerId: string;data: TrackCustomerUsageBody}, TContext> => {

const mutationKey = ['trackCustomerUsage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trackCustomerUsage>>, {customerId: string;data: TrackCustomerUsageBody}> = (props) => {
          const {customerId,data} = props ?? {};

          return  trackCustomerUsage(customerId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TrackCustomerUsageMutationResult = NonNullable<Awaited<ReturnType<typeof trackCustomerUsage>>>
    export type TrackCustomerUsageMutationBody = TrackCustomerUsageBody
    export type TrackCustomerUsageMutationError = ErrorResponse | void

    /**
 * @summary Track usage for a customer (Admin only)
 */
export const useTrackCustomerUsage = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trackCustomerUsage>>, TError,{customerId: string;data: TrackCustomerUsageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof trackCustomerUsage>>,
        TError,
        {customerId: string;data: TrackCustomerUsageBody},
        TContext
      > => {
      return useMutation(getTrackCustomerUsageMutationOptions(options), queryClient);
    }
    
/**
 * Returns the server's feature capabilities
 * @summary Get server feature flags
 */
export type getFeaturesResponse200 = {
  data: FeaturesResponse
  status: 200
}
    
export type getFeaturesResponseSuccess = (getFeaturesResponse200) & {
  headers: Headers;
};
;

export type getFeaturesResponse = (getFeaturesResponseSuccess)

export const getGetFeaturesUrl = () => {


  

  return `/features`
}

export const getFeatures = async ( options?: RequestInit): Promise<getFeaturesResponse> => {
  
  return customInstance<getFeaturesResponse>(getGetFeaturesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetFeaturesQueryKey = () => {
    return [
    `/features`
    ] as const;
    }

    
export const getGetFeaturesQueryOptions = <TData = Awaited<ReturnType<typeof getFeatures>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeatures>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFeaturesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeatures>>> = ({ signal }) => getFeatures({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFeatures>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFeaturesQueryResult = NonNullable<Awaited<ReturnType<typeof getFeatures>>>
export type GetFeaturesQueryError = unknown


export function useGetFeatures<TData = Awaited<ReturnType<typeof getFeatures>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeatures>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeatures>>,
          TError,
          Awaited<ReturnType<typeof getFeatures>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeatures<TData = Awaited<ReturnType<typeof getFeatures>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeatures>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeatures>>,
          TError,
          Awaited<ReturnType<typeof getFeatures>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeatures<TData = Awaited<ReturnType<typeof getFeatures>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeatures>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get server feature flags
 */

export function useGetFeatures<TData = Awaited<ReturnType<typeof getFeatures>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeatures>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFeaturesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns all runs, jobs, job results, and storage files associated with a given commit.
 * @summary Retrieve CI data for a given commit
 */
export type getGitcommitResponse200 = {
  data: GetGitcommit200
  status: 200
}

export type getGitcommitResponse404 = {
  data: void
  status: 404
}

export type getGitcommitResponse500 = {
  data: void
  status: 500
}
    
export type getGitcommitResponseSuccess = (getGitcommitResponse200) & {
  headers: Headers;
};
export type getGitcommitResponseError = (getGitcommitResponse404 | getGitcommitResponse500) & {
  headers: Headers;
};

export type getGitcommitResponse = (getGitcommitResponseSuccess | getGitcommitResponseError)

export const getGetGitcommitUrl = (params?: GetGitcommitParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/gitcommit?${stringifiedParams}` : `/gitcommit`
}

export const getGitcommit = async (params?: GetGitcommitParams, options?: RequestInit): Promise<getGitcommitResponse> => {
  
  return customInstance<getGitcommitResponse>(getGetGitcommitUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetGitcommitQueryKey = (params?: GetGitcommitParams,) => {
    return [
    `/gitcommit`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetGitcommitQueryOptions = <TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGitcommitQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGitcommit>>> = ({ signal }) => getGitcommit(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGitcommitQueryResult = NonNullable<Awaited<ReturnType<typeof getGitcommit>>>
export type GetGitcommitQueryError = void


export function useGetGitcommit<TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(
 params: undefined |  GetGitcommitParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGitcommit>>,
          TError,
          Awaited<ReturnType<typeof getGitcommit>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGitcommit<TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(
 params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGitcommit>>,
          TError,
          Awaited<ReturnType<typeof getGitcommit>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGitcommit<TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(
 params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve CI data for a given commit
 */

export function useGetGitcommit<TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(
 params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGitcommitQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns a summary of git commits, including status, start time, and end time.
 * @summary Retrieve a summary of git commits
 */
export type getGitcommitsummaryResponse200 = {
  data: GetGitcommitsummary200
  status: 200
}

export type getGitcommitsummaryResponse500 = {
  data: GetGitcommitsummary500
  status: 500
}
    
export type getGitcommitsummaryResponseSuccess = (getGitcommitsummaryResponse200) & {
  headers: Headers;
};
export type getGitcommitsummaryResponseError = (getGitcommitsummaryResponse500) & {
  headers: Headers;
};

export type getGitcommitsummaryResponse = (getGitcommitsummaryResponseSuccess | getGitcommitsummaryResponseError)

export const getGetGitcommitsummaryUrl = (params?: GetGitcommitsummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/gitcommitsummary?${stringifiedParams}` : `/gitcommitsummary`
}

export const getGitcommitsummary = async (params?: GetGitcommitsummaryParams, options?: RequestInit): Promise<getGitcommitsummaryResponse> => {
  
  return customInstance<getGitcommitsummaryResponse>(getGetGitcommitsummaryUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetGitcommitsummaryQueryKey = (params?: GetGitcommitsummaryParams,) => {
    return [
    `/gitcommitsummary`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetGitcommitsummaryQueryOptions = <TData = Awaited<ReturnType<typeof getGitcommitsummary>>, TError = GetGitcommitsummary500>(params?: GetGitcommitsummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGitcommitsummaryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGitcommitsummary>>> = ({ signal }) => getGitcommitsummary(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGitcommitsummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getGitcommitsummary>>>
export type GetGitcommitsummaryQueryError = GetGitcommitsummary500


export function useGetGitcommitsummary<TData = Awaited<ReturnType<typeof getGitcommitsummary>>, TError = GetGitcommitsummary500>(
 params: undefined |  GetGitcommitsummaryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGitcommitsummary>>,
          TError,
          Awaited<ReturnType<typeof getGitcommitsummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGitcommitsummary<TData = Awaited<ReturnType<typeof getGitcommitsummary>>, TError = GetGitcommitsummary500>(
 params?: GetGitcommitsummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGitcommitsummary>>,
          TError,
          Awaited<ReturnType<typeof getGitcommitsummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGitcommitsummary<TData = Awaited<ReturnType<typeof getGitcommitsummary>>, TError = GetGitcommitsummary500>(
 params?: GetGitcommitsummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a summary of git commits
 */

export function useGetGitcommitsummary<TData = Awaited<ReturnType<typeof getGitcommitsummary>>, TError = GetGitcommitsummary500>(
 params?: GetGitcommitsummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGitcommitsummaryQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Returns a paginated list of nodes across all publishers.
 * @summary Retrieves a list of nodes
 */
export type listAllNodesResponse200 = {
  data: ListAllNodes200
  status: 200
}

export type listAllNodesResponse400 = {
  data: void
  status: 400
}

export type listAllNodesResponse404 = {
  data: void
  status: 404
}

export type listAllNodesResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listAllNodesResponseSuccess = (listAllNodesResponse200) & {
  headers: Headers;
};
export type listAllNodesResponseError = (listAllNodesResponse400 | listAllNodesResponse404 | listAllNodesResponse500) & {
  headers: Headers;
};

export type listAllNodesResponse = (listAllNodesResponseSuccess | listAllNodesResponseError)

export const getListAllNodesUrl = (params?: ListAllNodesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/nodes?${stringifiedParams}` : `/nodes`
}

export const listAllNodes = async (params?: ListAllNodesParams, options?: RequestInit): Promise<listAllNodesResponse> => {
  
  return customInstance<listAllNodesResponse>(getListAllNodesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListAllNodesQueryKey = (params?: ListAllNodesParams,) => {
    return [
    `/nodes`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListAllNodesQueryOptions = <TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAllNodesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllNodes>>> = ({ signal }) => listAllNodes(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAllNodesQueryResult = NonNullable<Awaited<ReturnType<typeof listAllNodes>>>
export type ListAllNodesQueryError = void | ErrorResponse


export function useListAllNodes<TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(
 params: undefined |  ListAllNodesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllNodes>>,
          TError,
          Awaited<ReturnType<typeof listAllNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAllNodes<TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(
 params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllNodes>>,
          TError,
          Awaited<ReturnType<typeof listAllNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAllNodes<TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(
 params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a list of nodes
 */

export function useListAllNodes<TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(
 params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListAllNodesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Reindex all nodes for searching.
 */
export type reindexNodesResponse200 = {
  data: void
  status: 200
}

export type reindexNodesResponse400 = {
  data: ErrorResponse
  status: 400
}

export type reindexNodesResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type reindexNodesResponseSuccess = (reindexNodesResponse200) & {
  headers: Headers;
};
export type reindexNodesResponseError = (reindexNodesResponse400 | reindexNodesResponse500) & {
  headers: Headers;
};

export type reindexNodesResponse = (reindexNodesResponseSuccess | reindexNodesResponseError)

export const getReindexNodesUrl = (params?: ReindexNodesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/nodes/reindex?${stringifiedParams}` : `/nodes/reindex`
}

export const reindexNodes = async (params?: ReindexNodesParams, options?: RequestInit): Promise<reindexNodesResponse> => {
  
  return customInstance<reindexNodesResponse>(getReindexNodesUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getReindexNodesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reindexNodes>>, TError,{params?: ReindexNodesParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof reindexNodes>>, TError,{params?: ReindexNodesParams}, TContext> => {

const mutationKey = ['reindexNodes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reindexNodes>>, {params?: ReindexNodesParams}> = (props) => {
          const {params} = props ?? {};

          return  reindexNodes(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ReindexNodesMutationResult = NonNullable<Awaited<ReturnType<typeof reindexNodes>>>
    
    export type ReindexNodesMutationError = ErrorResponse

    /**
 * @summary Reindex all nodes for searching.
 */
export const useReindexNodes = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reindexNodes>>, TError,{params?: ReindexNodesParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof reindexNodes>>,
        TError,
        {params?: ReindexNodesParams},
        TContext
      > => {
      return useMutation(getReindexNodesMutationOptions(options), queryClient);
    }
    
/**
 * Returns a paginated list of nodes across all publishers.
 * @summary Retrieves a list of nodes
 */
export type searchNodesResponse200 = {
  data: SearchNodes200
  status: 200
}

export type searchNodesResponse400 = {
  data: void
  status: 400
}

export type searchNodesResponse404 = {
  data: void
  status: 404
}

export type searchNodesResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type searchNodesResponseSuccess = (searchNodesResponse200) & {
  headers: Headers;
};
export type searchNodesResponseError = (searchNodesResponse400 | searchNodesResponse404 | searchNodesResponse500) & {
  headers: Headers;
};

export type searchNodesResponse = (searchNodesResponseSuccess | searchNodesResponseError)

export const getSearchNodesUrl = (params?: SearchNodesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/nodes/search?${stringifiedParams}` : `/nodes/search`
}

export const searchNodes = async (params?: SearchNodesParams, options?: RequestInit): Promise<searchNodesResponse> => {
  
  return customInstance<searchNodesResponse>(getSearchNodesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getSearchNodesQueryKey = (params?: SearchNodesParams,) => {
    return [
    `/nodes/search`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getSearchNodesQueryOptions = <TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(params?: SearchNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchNodesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchNodes>>> = ({ signal }) => searchNodes(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchNodesQueryResult = NonNullable<Awaited<ReturnType<typeof searchNodes>>>
export type SearchNodesQueryError = void | ErrorResponse


export function useSearchNodes<TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(
 params: undefined |  SearchNodesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchNodes>>,
          TError,
          Awaited<ReturnType<typeof searchNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchNodes<TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(
 params?: SearchNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchNodes>>,
          TError,
          Awaited<ReturnType<typeof searchNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchNodes<TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(
 params?: SearchNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a list of nodes
 */

export function useSearchNodes<TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(
 params?: SearchNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchNodesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Update GitHub stars for nodes
 */
export type updateGithubStarsResponse200 = {
  data: void
  status: 200
}

export type updateGithubStarsResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateGithubStarsResponse401 = {
  data: void
  status: 401
}

export type updateGithubStarsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type updateGithubStarsResponseSuccess = (updateGithubStarsResponse200) & {
  headers: Headers;
};
export type updateGithubStarsResponseError = (updateGithubStarsResponse400 | updateGithubStarsResponse401 | updateGithubStarsResponse500) & {
  headers: Headers;
};

export type updateGithubStarsResponse = (updateGithubStarsResponseSuccess | updateGithubStarsResponseError)

export const getUpdateGithubStarsUrl = (params?: UpdateGithubStarsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/nodes/update-github-stars?${stringifiedParams}` : `/nodes/update-github-stars`
}

export const updateGithubStars = async (params?: UpdateGithubStarsParams, options?: RequestInit): Promise<updateGithubStarsResponse> => {
  
  return customInstance<updateGithubStarsResponse>(getUpdateGithubStarsUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getUpdateGithubStarsMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGithubStars>>, TError,{params?: UpdateGithubStarsParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateGithubStars>>, TError,{params?: UpdateGithubStarsParams}, TContext> => {

const mutationKey = ['updateGithubStars'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateGithubStars>>, {params?: UpdateGithubStarsParams}> = (props) => {
          const {params} = props ?? {};

          return  updateGithubStars(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateGithubStarsMutationResult = NonNullable<Awaited<ReturnType<typeof updateGithubStars>>>
    
    export type UpdateGithubStarsMutationError = ErrorResponse | void

    /**
 * @summary Update GitHub stars for nodes
 */
export const useUpdateGithubStars = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGithubStars>>, TError,{params?: UpdateGithubStarsParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateGithubStars>>,
        TError,
        {params?: UpdateGithubStarsParams},
        TContext
      > => {
      return useMutation(getUpdateGithubStarsMutationOptions(options), queryClient);
    }
    
/**
 * Returns the details of a specific node.
 * @summary Retrieve a specific node by ID
 */
export type getNodeResponse200 = {
  data: Node
  status: 200
}

export type getNodeResponse302 = {
  data: void
  status: 302
}

export type getNodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type getNodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getNodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getNodeResponseSuccess = (getNodeResponse200) & {
  headers: Headers;
};
export type getNodeResponseError = (getNodeResponse302 | getNodeResponse403 | getNodeResponse404 | getNodeResponse500) & {
  headers: Headers;
};

export type getNodeResponse = (getNodeResponseSuccess | getNodeResponseError)

export const getGetNodeUrl = (nodeId: string,
    params?: GetNodeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/nodes/${nodeId}?${stringifiedParams}` : `/nodes/${nodeId}`
}

export const getNode = async (nodeId: string,
    params?: GetNodeParams, options?: RequestInit): Promise<getNodeResponse> => {
  
  return customInstance<getNodeResponse>(getGetNodeUrl(nodeId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetNodeQueryKey = (nodeId: string,
    params?: GetNodeParams,) => {
    return [
    `/nodes/${nodeId}`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetNodeQueryOptions = <TData = Awaited<ReturnType<typeof getNode>>, TError = void | ErrorResponse>(nodeId: string,
    params?: GetNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeQueryKey(nodeId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNode>>> = ({ signal }) => getNode(nodeId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNodeQueryResult = NonNullable<Awaited<ReturnType<typeof getNode>>>
export type GetNodeQueryError = void | ErrorResponse


export function useGetNode<TData = Awaited<ReturnType<typeof getNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    params: undefined |  GetNodeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNode>>,
          TError,
          Awaited<ReturnType<typeof getNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNode<TData = Awaited<ReturnType<typeof getNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    params?: GetNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNode>>,
          TError,
          Awaited<ReturnType<typeof getNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNode<TData = Awaited<ReturnType<typeof getNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    params?: GetNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a specific node by ID
 */

export function useGetNode<TData = Awaited<ReturnType<typeof getNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    params?: GetNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNodeQueryOptions(nodeId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Retrieves the node data for installation, either the latest or a specific version.
 * @summary Returns a node version to be installed.
 */
export type installNodeResponse200 = {
  data: NodeVersion
  status: 200
}

export type installNodeResponse400 = {
  data: ErrorResponse
  status: 400
}

export type installNodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type installNodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type installNodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type installNodeResponseSuccess = (installNodeResponse200) & {
  headers: Headers;
};
export type installNodeResponseError = (installNodeResponse400 | installNodeResponse403 | installNodeResponse404 | installNodeResponse500) & {
  headers: Headers;
};

export type installNodeResponse = (installNodeResponseSuccess | installNodeResponseError)

export const getInstallNodeUrl = (nodeId: string,
    params?: InstallNodeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/nodes/${nodeId}/install?${stringifiedParams}` : `/nodes/${nodeId}/install`
}

export const installNode = async (nodeId: string,
    params?: InstallNodeParams, options?: RequestInit): Promise<installNodeResponse> => {
  
  return customInstance<installNodeResponse>(getInstallNodeUrl(nodeId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getInstallNodeQueryKey = (nodeId: string,
    params?: InstallNodeParams,) => {
    return [
    `/nodes/${nodeId}/install`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getInstallNodeQueryOptions = <TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(nodeId: string,
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInstallNodeQueryKey(nodeId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof installNode>>> = ({ signal }) => installNode(nodeId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InstallNodeQueryResult = NonNullable<Awaited<ReturnType<typeof installNode>>>
export type InstallNodeQueryError = ErrorResponse


export function useInstallNode<TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(
 nodeId: string,
    params: undefined |  InstallNodeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof installNode>>,
          TError,
          Awaited<ReturnType<typeof installNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInstallNode<TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(
 nodeId: string,
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof installNode>>,
          TError,
          Awaited<ReturnType<typeof installNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInstallNode<TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(
 nodeId: string,
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Returns a node version to be installed.
 */

export function useInstallNode<TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(
 nodeId: string,
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInstallNodeQueryOptions(nodeId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Add review to a specific version of a node
 */
export type postNodeReviewResponse200 = {
  data: Node
  status: 200
}

export type postNodeReviewResponse400 = {
  data: void
  status: 400
}

export type postNodeReviewResponse404 = {
  data: Error
  status: 404
}

export type postNodeReviewResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type postNodeReviewResponseSuccess = (postNodeReviewResponse200) & {
  headers: Headers;
};
export type postNodeReviewResponseError = (postNodeReviewResponse400 | postNodeReviewResponse404 | postNodeReviewResponse500) & {
  headers: Headers;
};

export type postNodeReviewResponse = (postNodeReviewResponseSuccess | postNodeReviewResponseError)

export const getPostNodeReviewUrl = (nodeId: string,
    params: PostNodeReviewParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/nodes/${nodeId}/reviews?${stringifiedParams}` : `/nodes/${nodeId}/reviews`
}

export const postNodeReview = async (nodeId: string,
    params: PostNodeReviewParams, options?: RequestInit): Promise<postNodeReviewResponse> => {
  
  return customInstance<postNodeReviewResponse>(getPostNodeReviewUrl(nodeId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getPostNodeReviewMutationOptions = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postNodeReview>>, TError,{nodeId: string;params: PostNodeReviewParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postNodeReview>>, TError,{nodeId: string;params: PostNodeReviewParams}, TContext> => {

const mutationKey = ['postNodeReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postNodeReview>>, {nodeId: string;params: PostNodeReviewParams}> = (props) => {
          const {nodeId,params} = props ?? {};

          return  postNodeReview(nodeId,params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostNodeReviewMutationResult = NonNullable<Awaited<ReturnType<typeof postNodeReview>>>
    
    export type PostNodeReviewMutationError = void | Error | ErrorResponse

    /**
 * @summary Add review to a specific version of a node
 */
export const usePostNodeReview = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postNodeReview>>, TError,{nodeId: string;params: PostNodeReviewParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postNodeReview>>,
        TError,
        {nodeId: string;params: PostNodeReviewParams},
        TContext
      > => {
      return useMutation(getPostNodeReviewMutationOptions(options), queryClient);
    }
    
/**
 * @summary Create Node Translations
 */
export type createNodeTranslationsResponse201 = {
  data: void
  status: 201
}

export type createNodeTranslationsResponse400 = {
  data: void
  status: 400
}

export type createNodeTranslationsResponse404 = {
  data: Error
  status: 404
}

export type createNodeTranslationsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createNodeTranslationsResponseSuccess = (createNodeTranslationsResponse201) & {
  headers: Headers;
};
export type createNodeTranslationsResponseError = (createNodeTranslationsResponse400 | createNodeTranslationsResponse404 | createNodeTranslationsResponse500) & {
  headers: Headers;
};

export type createNodeTranslationsResponse = (createNodeTranslationsResponseSuccess | createNodeTranslationsResponseError)

export const getCreateNodeTranslationsUrl = (nodeId: string,) => {


  

  return `/nodes/${nodeId}/translations`
}

export const createNodeTranslations = async (nodeId: string,
    createNodeTranslationsBody: CreateNodeTranslationsBody, options?: RequestInit): Promise<createNodeTranslationsResponse> => {
  
  return customInstance<createNodeTranslationsResponse>(getCreateNodeTranslationsUrl(nodeId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createNodeTranslationsBody,)
  }
);}




export const getCreateNodeTranslationsMutationOptions = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNodeTranslations>>, TError,{nodeId: string;data: CreateNodeTranslationsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createNodeTranslations>>, TError,{nodeId: string;data: CreateNodeTranslationsBody}, TContext> => {

const mutationKey = ['createNodeTranslations'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNodeTranslations>>, {nodeId: string;data: CreateNodeTranslationsBody}> = (props) => {
          const {nodeId,data} = props ?? {};

          return  createNodeTranslations(nodeId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNodeTranslationsMutationResult = NonNullable<Awaited<ReturnType<typeof createNodeTranslations>>>
    export type CreateNodeTranslationsMutationBody = CreateNodeTranslationsBody
    export type CreateNodeTranslationsMutationError = void | Error | ErrorResponse

    /**
 * @summary Create Node Translations
 */
export const useCreateNodeTranslations = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNodeTranslations>>, TError,{nodeId: string;data: CreateNodeTranslationsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createNodeTranslations>>,
        TError,
        {nodeId: string;data: CreateNodeTranslationsBody},
        TContext
      > => {
      return useMutation(getCreateNodeTranslationsMutationOptions(options), queryClient);
    }
    
/**
 * @summary List all versions of a node
 */
export type listNodeVersionsResponse200 = {
  data: NodeVersion[]
  status: 200
}

export type listNodeVersionsResponse403 = {
  data: ErrorResponse
  status: 403
}

export type listNodeVersionsResponse404 = {
  data: Error
  status: 404
}

export type listNodeVersionsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listNodeVersionsResponseSuccess = (listNodeVersionsResponse200) & {
  headers: Headers;
};
export type listNodeVersionsResponseError = (listNodeVersionsResponse403 | listNodeVersionsResponse404 | listNodeVersionsResponse500) & {
  headers: Headers;
};

export type listNodeVersionsResponse = (listNodeVersionsResponseSuccess | listNodeVersionsResponseError)

export const getListNodeVersionsUrl = (nodeId: string,
    params?: ListNodeVersionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/nodes/${nodeId}/versions?${stringifiedParams}` : `/nodes/${nodeId}/versions`
}

export const listNodeVersions = async (nodeId: string,
    params?: ListNodeVersionsParams, options?: RequestInit): Promise<listNodeVersionsResponse> => {
  
  return customInstance<listNodeVersionsResponse>(getListNodeVersionsUrl(nodeId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListNodeVersionsQueryKey = (nodeId: string,
    params?: ListNodeVersionsParams,) => {
    return [
    `/nodes/${nodeId}/versions`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListNodeVersionsQueryOptions = <TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(nodeId: string,
    params?: ListNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListNodeVersionsQueryKey(nodeId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodeVersions>>> = ({ signal }) => listNodeVersions(nodeId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListNodeVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof listNodeVersions>>>
export type ListNodeVersionsQueryError = ErrorResponse | Error


export function useListNodeVersions<TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(
 nodeId: string,
    params: undefined |  ListNodeVersionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodeVersions>>,
          TError,
          Awaited<ReturnType<typeof listNodeVersions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListNodeVersions<TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(
 nodeId: string,
    params?: ListNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodeVersions>>,
          TError,
          Awaited<ReturnType<typeof listNodeVersions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListNodeVersions<TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(
 nodeId: string,
    params?: ListNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all versions of a node
 */

export function useListNodeVersions<TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(
 nodeId: string,
    params?: ListNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListNodeVersionsQueryOptions(nodeId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Retrieve a specific version of a node
 */
export type getNodeVersionResponse200 = {
  data: NodeVersion
  status: 200
}

export type getNodeVersionResponse404 = {
  data: Error
  status: 404
}

export type getNodeVersionResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getNodeVersionResponseSuccess = (getNodeVersionResponse200) & {
  headers: Headers;
};
export type getNodeVersionResponseError = (getNodeVersionResponse404 | getNodeVersionResponse500) & {
  headers: Headers;
};

export type getNodeVersionResponse = (getNodeVersionResponseSuccess | getNodeVersionResponseError)

export const getGetNodeVersionUrl = (nodeId: string,
    versionId: string,) => {


  

  return `/nodes/${nodeId}/versions/${versionId}`
}

export const getNodeVersion = async (nodeId: string,
    versionId: string, options?: RequestInit): Promise<getNodeVersionResponse> => {
  
  return customInstance<getNodeVersionResponse>(getGetNodeVersionUrl(nodeId,versionId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetNodeVersionQueryKey = (nodeId: string,
    versionId: string,) => {
    return [
    `/nodes/${nodeId}/versions/${versionId}`
    ] as const;
    }

    
export const getGetNodeVersionQueryOptions = <TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(nodeId: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeVersionQueryKey(nodeId,versionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeVersion>>> = ({ signal }) => getNodeVersion(nodeId,versionId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId && versionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNodeVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getNodeVersion>>>
export type GetNodeVersionQueryError = Error | ErrorResponse


export function useGetNodeVersion<TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(
 nodeId: string,
    versionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNodeVersion>>,
          TError,
          Awaited<ReturnType<typeof getNodeVersion>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNodeVersion<TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(
 nodeId: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNodeVersion>>,
          TError,
          Awaited<ReturnType<typeof getNodeVersion>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNodeVersion<TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(
 nodeId: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a specific version of a node
 */

export function useGetNodeVersion<TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(
 nodeId: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNodeVersionQueryOptions(nodeId,versionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary list comfy-nodes for node version
 */
export type listComfyNodesResponse200 = {
  data: ListComfyNodes200
  status: 200
}

export type listComfyNodesResponse401 = {
  data: void
  status: 401
}

export type listComfyNodesResponse403 = {
  data: ErrorResponse
  status: 403
}

export type listComfyNodesResponse404 = {
  data: ErrorResponse
  status: 404
}

export type listComfyNodesResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listComfyNodesResponseSuccess = (listComfyNodesResponse200) & {
  headers: Headers;
};
export type listComfyNodesResponseError = (listComfyNodesResponse401 | listComfyNodesResponse403 | listComfyNodesResponse404 | listComfyNodesResponse500) & {
  headers: Headers;
};

export type listComfyNodesResponse = (listComfyNodesResponseSuccess | listComfyNodesResponseError)

export const getListComfyNodesUrl = (nodeId: string,
    version: string,
    params?: ListComfyNodesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/nodes/${nodeId}/versions/${version}/comfy-nodes?${stringifiedParams}` : `/nodes/${nodeId}/versions/${version}/comfy-nodes`
}

export const listComfyNodes = async (nodeId: string,
    version: string,
    params?: ListComfyNodesParams, options?: RequestInit): Promise<listComfyNodesResponse> => {
  
  return customInstance<listComfyNodesResponse>(getListComfyNodesUrl(nodeId,version,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListComfyNodesQueryKey = (nodeId: string,
    version: string,
    params?: ListComfyNodesParams,) => {
    return [
    `/nodes/${nodeId}/versions/${version}/comfy-nodes`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListComfyNodesQueryOptions = <TData = Awaited<ReturnType<typeof listComfyNodes>>, TError = void | ErrorResponse>(nodeId: string,
    version: string,
    params?: ListComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListComfyNodesQueryKey(nodeId,version,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listComfyNodes>>> = ({ signal }) => listComfyNodes(nodeId,version,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId && version), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListComfyNodesQueryResult = NonNullable<Awaited<ReturnType<typeof listComfyNodes>>>
export type ListComfyNodesQueryError = void | ErrorResponse


export function useListComfyNodes<TData = Awaited<ReturnType<typeof listComfyNodes>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    params: undefined |  ListComfyNodesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listComfyNodes>>,
          TError,
          Awaited<ReturnType<typeof listComfyNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListComfyNodes<TData = Awaited<ReturnType<typeof listComfyNodes>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    params?: ListComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listComfyNodes>>,
          TError,
          Awaited<ReturnType<typeof listComfyNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListComfyNodes<TData = Awaited<ReturnType<typeof listComfyNodes>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    params?: ListComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary list comfy-nodes for node version
 */

export function useListComfyNodes<TData = Awaited<ReturnType<typeof listComfyNodes>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    params?: ListComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListComfyNodesQueryOptions(nodeId,version,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary create comfy-nodes for certain node
 */
export type createComfyNodesResponse204 = {
  data: void
  status: 204
}

export type createComfyNodesResponse401 = {
  data: void
  status: 401
}

export type createComfyNodesResponse403 = {
  data: ErrorResponse
  status: 403
}

export type createComfyNodesResponse404 = {
  data: ErrorResponse
  status: 404
}

export type createComfyNodesResponse409 = {
  data: ErrorResponse
  status: 409
}

export type createComfyNodesResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createComfyNodesResponseSuccess = (createComfyNodesResponse204) & {
  headers: Headers;
};
export type createComfyNodesResponseError = (createComfyNodesResponse401 | createComfyNodesResponse403 | createComfyNodesResponse404 | createComfyNodesResponse409 | createComfyNodesResponse500) & {
  headers: Headers;
};

export type createComfyNodesResponse = (createComfyNodesResponseSuccess | createComfyNodesResponseError)

export const getCreateComfyNodesUrl = (nodeId: string,
    version: string,) => {


  

  return `/nodes/${nodeId}/versions/${version}/comfy-nodes`
}

export const createComfyNodes = async (nodeId: string,
    version: string,
    createComfyNodesBody: CreateComfyNodesBody, options?: RequestInit): Promise<createComfyNodesResponse> => {
  
  return customInstance<createComfyNodesResponse>(getCreateComfyNodesUrl(nodeId,version),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createComfyNodesBody,)
  }
);}




export const getCreateComfyNodesMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComfyNodes>>, TError,{nodeId: string;version: string;data: CreateComfyNodesBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createComfyNodes>>, TError,{nodeId: string;version: string;data: CreateComfyNodesBody}, TContext> => {

const mutationKey = ['createComfyNodes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createComfyNodes>>, {nodeId: string;version: string;data: CreateComfyNodesBody}> = (props) => {
          const {nodeId,version,data} = props ?? {};

          return  createComfyNodes(nodeId,version,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateComfyNodesMutationResult = NonNullable<Awaited<ReturnType<typeof createComfyNodes>>>
    export type CreateComfyNodesMutationBody = CreateComfyNodesBody
    export type CreateComfyNodesMutationError = void | ErrorResponse

    /**
 * @summary create comfy-nodes for certain node
 */
export const useCreateComfyNodes = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComfyNodes>>, TError,{nodeId: string;version: string;data: CreateComfyNodesBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createComfyNodes>>,
        TError,
        {nodeId: string;version: string;data: CreateComfyNodesBody},
        TContext
      > => {
      return useMutation(getCreateComfyNodesMutationOptions(options), queryClient);
    }
    
/**
 * @summary get specify comfy-node based on its id
 */
export type getComfyNodeResponse200 = {
  data: ComfyNode
  status: 200
}

export type getComfyNodeResponse401 = {
  data: void
  status: 401
}

export type getComfyNodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type getComfyNodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getComfyNodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getComfyNodeResponseSuccess = (getComfyNodeResponse200) & {
  headers: Headers;
};
export type getComfyNodeResponseError = (getComfyNodeResponse401 | getComfyNodeResponse403 | getComfyNodeResponse404 | getComfyNodeResponse500) & {
  headers: Headers;
};

export type getComfyNodeResponse = (getComfyNodeResponseSuccess | getComfyNodeResponseError)

export const getGetComfyNodeUrl = (nodeId: string,
    version: string,
    comfyNodeName: string,) => {


  

  return `/nodes/${nodeId}/versions/${version}/comfy-nodes/${comfyNodeName}`
}

export const getComfyNode = async (nodeId: string,
    version: string,
    comfyNodeName: string, options?: RequestInit): Promise<getComfyNodeResponse> => {
  
  return customInstance<getComfyNodeResponse>(getGetComfyNodeUrl(nodeId,version,comfyNodeName),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetComfyNodeQueryKey = (nodeId: string,
    version: string,
    comfyNodeName: string,) => {
    return [
    `/nodes/${nodeId}/versions/${version}/comfy-nodes/${comfyNodeName}`
    ] as const;
    }

    
export const getGetComfyNodeQueryOptions = <TData = Awaited<ReturnType<typeof getComfyNode>>, TError = void | ErrorResponse>(nodeId: string,
    version: string,
    comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetComfyNodeQueryKey(nodeId,version,comfyNodeName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getComfyNode>>> = ({ signal }) => getComfyNode(nodeId,version,comfyNodeName, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId && version && comfyNodeName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetComfyNodeQueryResult = NonNullable<Awaited<ReturnType<typeof getComfyNode>>>
export type GetComfyNodeQueryError = void | ErrorResponse


export function useGetComfyNode<TData = Awaited<ReturnType<typeof getComfyNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    comfyNodeName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComfyNode>>,
          TError,
          Awaited<ReturnType<typeof getComfyNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetComfyNode<TData = Awaited<ReturnType<typeof getComfyNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComfyNode>>,
          TError,
          Awaited<ReturnType<typeof getComfyNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetComfyNode<TData = Awaited<ReturnType<typeof getComfyNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary get specify comfy-node based on its id
 */

export function useGetComfyNode<TData = Awaited<ReturnType<typeof getComfyNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetComfyNodeQueryOptions(nodeId,version,comfyNodeName,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Update a specific comfy-node
 */
export type updateComfyNodeResponse200 = {
  data: ComfyNode
  status: 200
}

export type updateComfyNodeResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateComfyNodeResponse401 = {
  data: void
  status: 401
}

export type updateComfyNodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type updateComfyNodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateComfyNodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type updateComfyNodeResponseSuccess = (updateComfyNodeResponse200) & {
  headers: Headers;
};
export type updateComfyNodeResponseError = (updateComfyNodeResponse400 | updateComfyNodeResponse401 | updateComfyNodeResponse403 | updateComfyNodeResponse404 | updateComfyNodeResponse500) & {
  headers: Headers;
};

export type updateComfyNodeResponse = (updateComfyNodeResponseSuccess | updateComfyNodeResponseError)

export const getUpdateComfyNodeUrl = (nodeId: string,
    version: string,
    comfyNodeName: string,) => {


  

  return `/nodes/${nodeId}/versions/${version}/comfy-nodes/${comfyNodeName}`
}

export const updateComfyNode = async (nodeId: string,
    version: string,
    comfyNodeName: string,
    comfyNodeUpdateRequest: ComfyNodeUpdateRequest, options?: RequestInit): Promise<updateComfyNodeResponse> => {
  
  return customInstance<updateComfyNodeResponse>(getUpdateComfyNodeUrl(nodeId,version,comfyNodeName),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      comfyNodeUpdateRequest,)
  }
);}




export const getUpdateComfyNodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateComfyNode>>, TError,{nodeId: string;version: string;comfyNodeName: string;data: ComfyNodeUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateComfyNode>>, TError,{nodeId: string;version: string;comfyNodeName: string;data: ComfyNodeUpdateRequest}, TContext> => {

const mutationKey = ['updateComfyNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateComfyNode>>, {nodeId: string;version: string;comfyNodeName: string;data: ComfyNodeUpdateRequest}> = (props) => {
          const {nodeId,version,comfyNodeName,data} = props ?? {};

          return  updateComfyNode(nodeId,version,comfyNodeName,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateComfyNodeMutationResult = NonNullable<Awaited<ReturnType<typeof updateComfyNode>>>
    export type UpdateComfyNodeMutationBody = ComfyNodeUpdateRequest
    export type UpdateComfyNodeMutationError = ErrorResponse | void

    /**
 * @summary Update a specific comfy-node
 */
export const useUpdateComfyNode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateComfyNode>>, TError,{nodeId: string;version: string;comfyNodeName: string;data: ComfyNodeUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateComfyNode>>,
        TError,
        {nodeId: string;version: string;comfyNodeName: string;data: ComfyNodeUpdateRequest},
        TContext
      > => {
      return useMutation(getUpdateComfyNodeMutationOptions(options), queryClient);
    }
    
/**
 * Forwards image generation requests to BFL's Flux 2 Max API and returns the results. Supports image-to-image generation with up to 8 input images.
 * @summary Proxy request to BFL Flux 2 Max for image generation
 */
export type bflFlux2MaxGenerateResponse200 = {
  data: BFLFluxProGenerateResponse
  status: 200
}

export type bflFlux2MaxGenerateResponse400 = {
  data: ErrorResponse
  status: 400
}

export type bflFlux2MaxGenerateResponse401 = {
  data: void
  status: 401
}

export type bflFlux2MaxGenerateResponse402 = {
  data: void
  status: 402
}

export type bflFlux2MaxGenerateResponse429 = {
  data: ErrorResponse
  status: 429
}

export type bflFlux2MaxGenerateResponse500 = {
  data: ErrorResponse
  status: 500
}

export type bflFlux2MaxGenerateResponse502 = {
  data: ErrorResponse
  status: 502
}

export type bflFlux2MaxGenerateResponse504 = {
  data: ErrorResponse
  status: 504
}
    
export type bflFlux2MaxGenerateResponseSuccess = (bflFlux2MaxGenerateResponse200) & {
  headers: Headers;
};
export type bflFlux2MaxGenerateResponseError = (bflFlux2MaxGenerateResponse400 | bflFlux2MaxGenerateResponse401 | bflFlux2MaxGenerateResponse402 | bflFlux2MaxGenerateResponse429 | bflFlux2MaxGenerateResponse500 | bflFlux2MaxGenerateResponse502 | bflFlux2MaxGenerateResponse504) & {
  headers: Headers;
};

export type bflFlux2MaxGenerateResponse = (bflFlux2MaxGenerateResponseSuccess | bflFlux2MaxGenerateResponseError)

export const getBflFlux2MaxGenerateUrl = () => {


  

  return `/proxy/bfl/flux-2-max/generate`
}

export const bflFlux2MaxGenerate = async (bFLFlux2ProGenerateRequest: BFLFlux2ProGenerateRequest, options?: RequestInit): Promise<bflFlux2MaxGenerateResponse> => {
  
  return customInstance<bflFlux2MaxGenerateResponse>(getBflFlux2MaxGenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bFLFlux2ProGenerateRequest,)
  }
);}




export const getBflFlux2MaxGenerateMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFlux2MaxGenerate>>, TError,{data: BFLFlux2ProGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof bflFlux2MaxGenerate>>, TError,{data: BFLFlux2ProGenerateRequest}, TContext> => {

const mutationKey = ['bflFlux2MaxGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bflFlux2MaxGenerate>>, {data: BFLFlux2ProGenerateRequest}> = (props) => {
          const {data} = props ?? {};

          return  bflFlux2MaxGenerate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BflFlux2MaxGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof bflFlux2MaxGenerate>>>
    export type BflFlux2MaxGenerateMutationBody = BFLFlux2ProGenerateRequest
    export type BflFlux2MaxGenerateMutationError = ErrorResponse | void

    /**
 * @summary Proxy request to BFL Flux 2 Max for image generation
 */
export const useBflFlux2MaxGenerate = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFlux2MaxGenerate>>, TError,{data: BFLFlux2ProGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bflFlux2MaxGenerate>>,
        TError,
        {data: BFLFlux2ProGenerateRequest},
        TContext
      > => {
      return useMutation(getBflFlux2MaxGenerateMutationOptions(options), queryClient);
    }
    
/**
 * Forwards image generation requests to BFL's Flux 2 Pro API and returns the results. Supports image-to-image generation with up to 5 input images.
 * @summary Proxy request to BFL Flux 2 Pro for image generation
 */
export type bflFlux2ProGenerateResponse200 = {
  data: BFLFluxProGenerateResponse
  status: 200
}

export type bflFlux2ProGenerateResponse400 = {
  data: ErrorResponse
  status: 400
}

export type bflFlux2ProGenerateResponse401 = {
  data: void
  status: 401
}

export type bflFlux2ProGenerateResponse402 = {
  data: void
  status: 402
}

export type bflFlux2ProGenerateResponse429 = {
  data: ErrorResponse
  status: 429
}

export type bflFlux2ProGenerateResponse500 = {
  data: ErrorResponse
  status: 500
}

export type bflFlux2ProGenerateResponse502 = {
  data: ErrorResponse
  status: 502
}

export type bflFlux2ProGenerateResponse504 = {
  data: ErrorResponse
  status: 504
}
    
export type bflFlux2ProGenerateResponseSuccess = (bflFlux2ProGenerateResponse200) & {
  headers: Headers;
};
export type bflFlux2ProGenerateResponseError = (bflFlux2ProGenerateResponse400 | bflFlux2ProGenerateResponse401 | bflFlux2ProGenerateResponse402 | bflFlux2ProGenerateResponse429 | bflFlux2ProGenerateResponse500 | bflFlux2ProGenerateResponse502 | bflFlux2ProGenerateResponse504) & {
  headers: Headers;
};

export type bflFlux2ProGenerateResponse = (bflFlux2ProGenerateResponseSuccess | bflFlux2ProGenerateResponseError)

export const getBflFlux2ProGenerateUrl = () => {


  

  return `/proxy/bfl/flux-2-pro/generate`
}

export const bflFlux2ProGenerate = async (bFLFlux2ProGenerateRequest: BFLFlux2ProGenerateRequest, options?: RequestInit): Promise<bflFlux2ProGenerateResponse> => {
  
  return customInstance<bflFlux2ProGenerateResponse>(getBflFlux2ProGenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bFLFlux2ProGenerateRequest,)
  }
);}




export const getBflFlux2ProGenerateMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFlux2ProGenerate>>, TError,{data: BFLFlux2ProGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof bflFlux2ProGenerate>>, TError,{data: BFLFlux2ProGenerateRequest}, TContext> => {

const mutationKey = ['bflFlux2ProGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bflFlux2ProGenerate>>, {data: BFLFlux2ProGenerateRequest}> = (props) => {
          const {data} = props ?? {};

          return  bflFlux2ProGenerate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BflFlux2ProGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof bflFlux2ProGenerate>>>
    export type BflFlux2ProGenerateMutationBody = BFLFlux2ProGenerateRequest
    export type BflFlux2ProGenerateMutationError = ErrorResponse | void

    /**
 * @summary Proxy request to BFL Flux 2 Pro for image generation
 */
export const useBflFlux2ProGenerate = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFlux2ProGenerate>>, TError,{data: BFLFlux2ProGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bflFlux2ProGenerate>>,
        TError,
        {data: BFLFlux2ProGenerateRequest},
        TContext
      > => {
      return useMutation(getBflFlux2ProGenerateMutationOptions(options), queryClient);
    }
    
/**
 * Forwards image editing requests to BFL's Flux Kontext Max API and returns the results.
 * @summary Proxy request to BFL Flux Kontext Max for image editing
 */
export type bflFluxKontextMaxGenerateResponse200 = {
  data: BFLFluxKontextMaxGenerateResponse
  status: 200
}

export type bflFluxKontextMaxGenerateResponse400 = {
  data: ErrorResponse
  status: 400
}

export type bflFluxKontextMaxGenerateResponse401 = {
  data: void
  status: 401
}

export type bflFluxKontextMaxGenerateResponse402 = {
  data: void
  status: 402
}

export type bflFluxKontextMaxGenerateResponse429 = {
  data: ErrorResponse
  status: 429
}

export type bflFluxKontextMaxGenerateResponse500 = {
  data: ErrorResponse
  status: 500
}

export type bflFluxKontextMaxGenerateResponse502 = {
  data: ErrorResponse
  status: 502
}

export type bflFluxKontextMaxGenerateResponse504 = {
  data: ErrorResponse
  status: 504
}
    
export type bflFluxKontextMaxGenerateResponseSuccess = (bflFluxKontextMaxGenerateResponse200) & {
  headers: Headers;
};
export type bflFluxKontextMaxGenerateResponseError = (bflFluxKontextMaxGenerateResponse400 | bflFluxKontextMaxGenerateResponse401 | bflFluxKontextMaxGenerateResponse402 | bflFluxKontextMaxGenerateResponse429 | bflFluxKontextMaxGenerateResponse500 | bflFluxKontextMaxGenerateResponse502 | bflFluxKontextMaxGenerateResponse504) & {
  headers: Headers;
};

export type bflFluxKontextMaxGenerateResponse = (bflFluxKontextMaxGenerateResponseSuccess | bflFluxKontextMaxGenerateResponseError)

export const getBflFluxKontextMaxGenerateUrl = () => {


  

  return `/proxy/bfl/flux-kontext-max/generate`
}

export const bflFluxKontextMaxGenerate = async (bFLFluxKontextMaxGenerateRequest: BFLFluxKontextMaxGenerateRequest, options?: RequestInit): Promise<bflFluxKontextMaxGenerateResponse> => {
  
  return customInstance<bflFluxKontextMaxGenerateResponse>(getBflFluxKontextMaxGenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bFLFluxKontextMaxGenerateRequest,)
  }
);}




export const getBflFluxKontextMaxGenerateMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>, TError,{data: BFLFluxKontextMaxGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>, TError,{data: BFLFluxKontextMaxGenerateRequest}, TContext> => {

const mutationKey = ['bflFluxKontextMaxGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>, {data: BFLFluxKontextMaxGenerateRequest}> = (props) => {
          const {data} = props ?? {};

          return  bflFluxKontextMaxGenerate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BflFluxKontextMaxGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>>
    export type BflFluxKontextMaxGenerateMutationBody = BFLFluxKontextMaxGenerateRequest
    export type BflFluxKontextMaxGenerateMutationError = ErrorResponse | void

    /**
 * @summary Proxy request to BFL Flux Kontext Max for image editing
 */
export const useBflFluxKontextMaxGenerate = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>, TError,{data: BFLFluxKontextMaxGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>,
        TError,
        {data: BFLFluxKontextMaxGenerateRequest},
        TContext
      > => {
      return useMutation(getBflFluxKontextMaxGenerateMutationOptions(options), queryClient);
    }
    
/**
 * Forwards image editing requests to BFL's Flux Kontext Pro API and returns the results.
 * @summary Proxy request to BFL Flux Kontext Pro for image editing
 */
export type bflFluxKontextProGenerateResponse200 = {
  data: BFLFluxKontextProGenerateResponse
  status: 200
}

export type bflFluxKontextProGenerateResponse400 = {
  data: ErrorResponse
  status: 400
}

export type bflFluxKontextProGenerateResponse401 = {
  data: void
  status: 401
}

export type bflFluxKontextProGenerateResponse402 = {
  data: void
  status: 402
}

export type bflFluxKontextProGenerateResponse429 = {
  data: ErrorResponse
  status: 429
}

export type bflFluxKontextProGenerateResponse500 = {
  data: ErrorResponse
  status: 500
}

export type bflFluxKontextProGenerateResponse502 = {
  data: ErrorResponse
  status: 502
}

export type bflFluxKontextProGenerateResponse504 = {
  data: ErrorResponse
  status: 504
}
    
export type bflFluxKontextProGenerateResponseSuccess = (bflFluxKontextProGenerateResponse200) & {
  headers: Headers;
};
export type bflFluxKontextProGenerateResponseError = (bflFluxKontextProGenerateResponse400 | bflFluxKontextProGenerateResponse401 | bflFluxKontextProGenerateResponse402 | bflFluxKontextProGenerateResponse429 | bflFluxKontextProGenerateResponse500 | bflFluxKontextProGenerateResponse502 | bflFluxKontextProGenerateResponse504) & {
  headers: Headers;
};

export type bflFluxKontextProGenerateResponse = (bflFluxKontextProGenerateResponseSuccess | bflFluxKontextProGenerateResponseError)

export const getBflFluxKontextProGenerateUrl = () => {


  

  return `/proxy/bfl/flux-kontext-pro/generate`
}

export const bflFluxKontextProGenerate = async (bFLFluxKontextProGenerateRequest: BFLFluxKontextProGenerateRequest, options?: RequestInit): Promise<bflFluxKontextProGenerateResponse> => {
  
  return customInstance<bflFluxKontextProGenerateResponse>(getBflFluxKontextProGenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bFLFluxKontextProGenerateRequest,)
  }
);}




export const getBflFluxKontextProGenerateMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFluxKontextProGenerate>>, TError,{data: BFLFluxKontextProGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof bflFluxKontextProGenerate>>, TError,{data: BFLFluxKontextProGenerateRequest}, TContext> => {

const mutationKey = ['bflFluxKontextProGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bflFluxKontextProGenerate>>, {data: BFLFluxKontextProGenerateRequest}> = (props) => {
          const {data} = props ?? {};

          return  bflFluxKontextProGenerate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BflFluxKontextProGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof bflFluxKontextProGenerate>>>
    export type BflFluxKontextProGenerateMutationBody = BFLFluxKontextProGenerateRequest
    export type BflFluxKontextProGenerateMutationError = ErrorResponse | void

    /**
 * @summary Proxy request to BFL Flux Kontext Pro for image editing
 */
export const useBflFluxKontextProGenerate = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFluxKontextProGenerate>>, TError,{data: BFLFluxKontextProGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bflFluxKontextProGenerate>>,
        TError,
        {data: BFLFluxKontextProGenerateRequest},
        TContext
      > => {
      return useMutation(getBflFluxKontextProGenerateMutationOptions(options), queryClient);
    }
    
/**
 * Submits an image generation task with FLUX.1 Canny [pro].
 * @summary Generate an image with FLUX.1 Canny [pro] using a control image.
 */
export type bFLProCannyV1FluxPro10CannyPostResponse200 = {
  data: BFLAsyncResponse | BFLAsyncWebhookResponse
  status: 200
}

export type bFLProCannyV1FluxPro10CannyPostResponse422 = {
  data: BFLHTTPValidationError
  status: 422
}
    
export type bFLProCannyV1FluxPro10CannyPostResponseSuccess = (bFLProCannyV1FluxPro10CannyPostResponse200) & {
  headers: Headers;
};
export type bFLProCannyV1FluxPro10CannyPostResponseError = (bFLProCannyV1FluxPro10CannyPostResponse422) & {
  headers: Headers;
};

export type bFLProCannyV1FluxPro10CannyPostResponse = (bFLProCannyV1FluxPro10CannyPostResponseSuccess | bFLProCannyV1FluxPro10CannyPostResponseError)

export const getBFLProCannyV1FluxPro10CannyPostUrl = () => {


  

  return `/proxy/bfl/flux-pro-1.0-canny/generate`
}

export const bFLProCannyV1FluxPro10CannyPost = async (bFLCannyInputs: BFLCannyInputs, options?: RequestInit): Promise<bFLProCannyV1FluxPro10CannyPostResponse> => {
  
  return customInstance<bFLProCannyV1FluxPro10CannyPostResponse>(getBFLProCannyV1FluxPro10CannyPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bFLCannyInputs,)
  }
);}




export const getBFLProCannyV1FluxPro10CannyPostMutationOptions = <TError = BFLHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>, TError,{data: BFLCannyInputs}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>, TError,{data: BFLCannyInputs}, TContext> => {

const mutationKey = ['bFLProCannyV1FluxPro10CannyPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>, {data: BFLCannyInputs}> = (props) => {
          const {data} = props ?? {};

          return  bFLProCannyV1FluxPro10CannyPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BFLProCannyV1FluxPro10CannyPostMutationResult = NonNullable<Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>>
    export type BFLProCannyV1FluxPro10CannyPostMutationBody = BFLCannyInputs
    export type BFLProCannyV1FluxPro10CannyPostMutationError = BFLHTTPValidationError

    /**
 * @summary Generate an image with FLUX.1 Canny [pro] using a control image.
 */
export const useBFLProCannyV1FluxPro10CannyPost = <TError = BFLHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>, TError,{data: BFLCannyInputs}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>,
        TError,
        {data: BFLCannyInputs},
        TContext
      > => {
      return useMutation(getBFLProCannyV1FluxPro10CannyPostMutationOptions(options), queryClient);
    }
    
/**
 * Submits an image generation task with FLUX.1 Depth [pro].
 * @summary Generate an image with FLUX.1 Depth [pro] using a control image.
 */
export type bFLProDepthV1FluxPro10DepthPostResponse200 = {
  data: BFLAsyncResponse | BFLAsyncWebhookResponse
  status: 200
}

export type bFLProDepthV1FluxPro10DepthPostResponse422 = {
  data: BFLHTTPValidationError
  status: 422
}
    
export type bFLProDepthV1FluxPro10DepthPostResponseSuccess = (bFLProDepthV1FluxPro10DepthPostResponse200) & {
  headers: Headers;
};
export type bFLProDepthV1FluxPro10DepthPostResponseError = (bFLProDepthV1FluxPro10DepthPostResponse422) & {
  headers: Headers;
};

export type bFLProDepthV1FluxPro10DepthPostResponse = (bFLProDepthV1FluxPro10DepthPostResponseSuccess | bFLProDepthV1FluxPro10DepthPostResponseError)

export const getBFLProDepthV1FluxPro10DepthPostUrl = () => {


  

  return `/proxy/bfl/flux-pro-1.0-depth/generate`
}

export const bFLProDepthV1FluxPro10DepthPost = async (bFLDepthInputs: BFLDepthInputs, options?: RequestInit): Promise<bFLProDepthV1FluxPro10DepthPostResponse> => {
  
  return customInstance<bFLProDepthV1FluxPro10DepthPostResponse>(getBFLProDepthV1FluxPro10DepthPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bFLDepthInputs,)
  }
);}




export const getBFLProDepthV1FluxPro10DepthPostMutationOptions = <TError = BFLHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>, TError,{data: BFLDepthInputs}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>, TError,{data: BFLDepthInputs}, TContext> => {

const mutationKey = ['bFLProDepthV1FluxPro10DepthPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>, {data: BFLDepthInputs}> = (props) => {
          const {data} = props ?? {};

          return  bFLProDepthV1FluxPro10DepthPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BFLProDepthV1FluxPro10DepthPostMutationResult = NonNullable<Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>>
    export type BFLProDepthV1FluxPro10DepthPostMutationBody = BFLDepthInputs
    export type BFLProDepthV1FluxPro10DepthPostMutationError = BFLHTTPValidationError

    /**
 * @summary Generate an image with FLUX.1 Depth [pro] using a control image.
 */
export const useBFLProDepthV1FluxPro10DepthPost = <TError = BFLHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>, TError,{data: BFLDepthInputs}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>,
        TError,
        {data: BFLDepthInputs},
        TContext
      > => {
      return useMutation(getBFLProDepthV1FluxPro10DepthPostMutationOptions(options), queryClient);
    }
    
/**
 * Submits an image expansion task that adds the specified number of pixels to any combination of sides (top, bottom, left, right) while maintaining context.
 * @summary Expand an image by adding pixels on any side.
 */
export type bFLExpandV1FluxPro10ExpandPostResponse200 = {
  data: BFLAsyncResponse | BFLAsyncWebhookResponse
  status: 200
}

export type bFLExpandV1FluxPro10ExpandPostResponse422 = {
  data: BFLHTTPValidationError
  status: 422
}
    
export type bFLExpandV1FluxPro10ExpandPostResponseSuccess = (bFLExpandV1FluxPro10ExpandPostResponse200) & {
  headers: Headers;
};
export type bFLExpandV1FluxPro10ExpandPostResponseError = (bFLExpandV1FluxPro10ExpandPostResponse422) & {
  headers: Headers;
};

export type bFLExpandV1FluxPro10ExpandPostResponse = (bFLExpandV1FluxPro10ExpandPostResponseSuccess | bFLExpandV1FluxPro10ExpandPostResponseError)

export const getBFLExpandV1FluxPro10ExpandPostUrl = () => {


  

  return `/proxy/bfl/flux-pro-1.0-expand/generate`
}

export const bFLExpandV1FluxPro10ExpandPost = async (bFLFluxProExpandInputs: BFLFluxProExpandInputs, options?: RequestInit): Promise<bFLExpandV1FluxPro10ExpandPostResponse> => {
  
  return customInstance<bFLExpandV1FluxPro10ExpandPostResponse>(getBFLExpandV1FluxPro10ExpandPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bFLFluxProExpandInputs,)
  }
);}




export const getBFLExpandV1FluxPro10ExpandPostMutationOptions = <TError = BFLHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>, TError,{data: BFLFluxProExpandInputs}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>, TError,{data: BFLFluxProExpandInputs}, TContext> => {

const mutationKey = ['bFLExpandV1FluxPro10ExpandPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>, {data: BFLFluxProExpandInputs}> = (props) => {
          const {data} = props ?? {};

          return  bFLExpandV1FluxPro10ExpandPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BFLExpandV1FluxPro10ExpandPostMutationResult = NonNullable<Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>>
    export type BFLExpandV1FluxPro10ExpandPostMutationBody = BFLFluxProExpandInputs
    export type BFLExpandV1FluxPro10ExpandPostMutationError = BFLHTTPValidationError

    /**
 * @summary Expand an image by adding pixels on any side.
 */
export const useBFLExpandV1FluxPro10ExpandPost = <TError = BFLHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>, TError,{data: BFLFluxProExpandInputs}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>,
        TError,
        {data: BFLFluxProExpandInputs},
        TContext
      > => {
      return useMutation(getBFLExpandV1FluxPro10ExpandPostMutationOptions(options), queryClient);
    }
    
/**
 * Submits an image generation task with the FLUX.1 Fill [pro] model using an input image and mask. Mask can be applied to alpha channel or submitted as a separate image.
 * @summary Generate an image with FLUX.1 Fill [pro] using an input image and mask.
 */
export type bFLFillV1FluxPro10FillPostResponse200 = {
  data: BFLAsyncResponse | BFLAsyncWebhookResponse
  status: 200
}

export type bFLFillV1FluxPro10FillPostResponse422 = {
  data: BFLHTTPValidationError
  status: 422
}
    
export type bFLFillV1FluxPro10FillPostResponseSuccess = (bFLFillV1FluxPro10FillPostResponse200) & {
  headers: Headers;
};
export type bFLFillV1FluxPro10FillPostResponseError = (bFLFillV1FluxPro10FillPostResponse422) & {
  headers: Headers;
};

export type bFLFillV1FluxPro10FillPostResponse = (bFLFillV1FluxPro10FillPostResponseSuccess | bFLFillV1FluxPro10FillPostResponseError)

export const getBFLFillV1FluxPro10FillPostUrl = () => {


  

  return `/proxy/bfl/flux-pro-1.0-fill/generate`
}

export const bFLFillV1FluxPro10FillPost = async (bFLFluxProFillInputs: BFLFluxProFillInputs, options?: RequestInit): Promise<bFLFillV1FluxPro10FillPostResponse> => {
  
  return customInstance<bFLFillV1FluxPro10FillPostResponse>(getBFLFillV1FluxPro10FillPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bFLFluxProFillInputs,)
  }
);}




export const getBFLFillV1FluxPro10FillPostMutationOptions = <TError = BFLHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>, TError,{data: BFLFluxProFillInputs}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>, TError,{data: BFLFluxProFillInputs}, TContext> => {

const mutationKey = ['bFLFillV1FluxPro10FillPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>, {data: BFLFluxProFillInputs}> = (props) => {
          const {data} = props ?? {};

          return  bFLFillV1FluxPro10FillPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BFLFillV1FluxPro10FillPostMutationResult = NonNullable<Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>>
    export type BFLFillV1FluxPro10FillPostMutationBody = BFLFluxProFillInputs
    export type BFLFillV1FluxPro10FillPostMutationError = BFLHTTPValidationError

    /**
 * @summary Generate an image with FLUX.1 Fill [pro] using an input image and mask.
 */
export const useBFLFillV1FluxPro10FillPost = <TError = BFLHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>, TError,{data: BFLFluxProFillInputs}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>,
        TError,
        {data: BFLFluxProFillInputs},
        TContext
      > => {
      return useMutation(getBFLFillV1FluxPro10FillPostMutationOptions(options), queryClient);
    }
    
/**
 * Forwards image generation requests to BFL's Flux Pro 1.1 Ultra API and returns the results.
 * @summary Proxy request to BFL Flux Pro 1.1 Ultra for image generation
 */
export type bflFluxProGenerateResponse200 = {
  data: BFLFluxProGenerateResponse
  status: 200
}

export type bflFluxProGenerateResponse400 = {
  data: ErrorResponse
  status: 400
}

export type bflFluxProGenerateResponse401 = {
  data: void
  status: 401
}

export type bflFluxProGenerateResponse402 = {
  data: void
  status: 402
}

export type bflFluxProGenerateResponse429 = {
  data: ErrorResponse
  status: 429
}

export type bflFluxProGenerateResponse500 = {
  data: ErrorResponse
  status: 500
}

export type bflFluxProGenerateResponse502 = {
  data: ErrorResponse
  status: 502
}

export type bflFluxProGenerateResponse504 = {
  data: ErrorResponse
  status: 504
}
    
export type bflFluxProGenerateResponseSuccess = (bflFluxProGenerateResponse200) & {
  headers: Headers;
};
export type bflFluxProGenerateResponseError = (bflFluxProGenerateResponse400 | bflFluxProGenerateResponse401 | bflFluxProGenerateResponse402 | bflFluxProGenerateResponse429 | bflFluxProGenerateResponse500 | bflFluxProGenerateResponse502 | bflFluxProGenerateResponse504) & {
  headers: Headers;
};

export type bflFluxProGenerateResponse = (bflFluxProGenerateResponseSuccess | bflFluxProGenerateResponseError)

export const getBflFluxProGenerateUrl = () => {


  

  return `/proxy/bfl/flux-pro-1.1-ultra/generate`
}

export const bflFluxProGenerate = async (bFLFluxProGenerateRequest: BFLFluxProGenerateRequest, options?: RequestInit): Promise<bflFluxProGenerateResponse> => {
  
  return customInstance<bflFluxProGenerateResponse>(getBflFluxProGenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bFLFluxProGenerateRequest,)
  }
);}




export const getBflFluxProGenerateMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFluxProGenerate>>, TError,{data: BFLFluxProGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof bflFluxProGenerate>>, TError,{data: BFLFluxProGenerateRequest}, TContext> => {

const mutationKey = ['bflFluxProGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bflFluxProGenerate>>, {data: BFLFluxProGenerateRequest}> = (props) => {
          const {data} = props ?? {};

          return  bflFluxProGenerate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BflFluxProGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof bflFluxProGenerate>>>
    export type BflFluxProGenerateMutationBody = BFLFluxProGenerateRequest
    export type BflFluxProGenerateMutationError = ErrorResponse | void

    /**
 * @summary Proxy request to BFL Flux Pro 1.1 Ultra for image generation
 */
export const useBflFluxProGenerate = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFluxProGenerate>>, TError,{data: BFLFluxProGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bflFluxProGenerate>>,
        TError,
        {data: BFLFluxProGenerateRequest},
        TContext
      > => {
      return useMutation(getBflFluxProGenerateMutationOptions(options), queryClient);
    }
    
/**
 * Forwards image generation requests to BFL's Flux Pro 1.1 API and returns the results.
 * @summary Proxy request to BFL Flux Pro 1.1 for image generation
 */
export type bflFluxPro11GenerateResponse200 = {
  data: BFLFluxPro11GenerateResponse
  status: 200
}

export type bflFluxPro11GenerateResponse400 = {
  data: ErrorResponse
  status: 400
}

export type bflFluxPro11GenerateResponse401 = {
  data: void
  status: 401
}

export type bflFluxPro11GenerateResponse402 = {
  data: void
  status: 402
}

export type bflFluxPro11GenerateResponse429 = {
  data: ErrorResponse
  status: 429
}

export type bflFluxPro11GenerateResponse500 = {
  data: ErrorResponse
  status: 500
}

export type bflFluxPro11GenerateResponse502 = {
  data: ErrorResponse
  status: 502
}

export type bflFluxPro11GenerateResponse504 = {
  data: ErrorResponse
  status: 504
}
    
export type bflFluxPro11GenerateResponseSuccess = (bflFluxPro11GenerateResponse200) & {
  headers: Headers;
};
export type bflFluxPro11GenerateResponseError = (bflFluxPro11GenerateResponse400 | bflFluxPro11GenerateResponse401 | bflFluxPro11GenerateResponse402 | bflFluxPro11GenerateResponse429 | bflFluxPro11GenerateResponse500 | bflFluxPro11GenerateResponse502 | bflFluxPro11GenerateResponse504) & {
  headers: Headers;
};

export type bflFluxPro11GenerateResponse = (bflFluxPro11GenerateResponseSuccess | bflFluxPro11GenerateResponseError)

export const getBflFluxPro11GenerateUrl = () => {


  

  return `/proxy/bfl/flux-pro-1.1/generate`
}

export const bflFluxPro11Generate = async (bFLFluxPro11GenerateRequest: BFLFluxPro11GenerateRequest, options?: RequestInit): Promise<bflFluxPro11GenerateResponse> => {
  
  return customInstance<bflFluxPro11GenerateResponse>(getBflFluxPro11GenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bFLFluxPro11GenerateRequest,)
  }
);}




export const getBflFluxPro11GenerateMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFluxPro11Generate>>, TError,{data: BFLFluxPro11GenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof bflFluxPro11Generate>>, TError,{data: BFLFluxPro11GenerateRequest}, TContext> => {

const mutationKey = ['bflFluxPro11Generate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bflFluxPro11Generate>>, {data: BFLFluxPro11GenerateRequest}> = (props) => {
          const {data} = props ?? {};

          return  bflFluxPro11Generate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BflFluxPro11GenerateMutationResult = NonNullable<Awaited<ReturnType<typeof bflFluxPro11Generate>>>
    export type BflFluxPro11GenerateMutationBody = BFLFluxPro11GenerateRequest
    export type BflFluxPro11GenerateMutationError = ErrorResponse | void

    /**
 * @summary Proxy request to BFL Flux Pro 1.1 for image generation
 */
export const useBflFluxPro11Generate = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bflFluxPro11Generate>>, TError,{data: BFLFluxPro11GenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bflFluxPro11Generate>>,
        TError,
        {data: BFLFluxPro11GenerateRequest},
        TContext
      > => {
      return useMutation(getBflFluxPro11GenerateMutationOptions(options), queryClient);
    }
    
/**
 * Edit an existing image using Bria's FIBO Edit API. You can provide:
1. A source image and a text-based instruction (prompt)
2. A source image and a structured_instruction
3. A source image, a mask, and a text-based instruction
4. A source image, a mask, and a structured_instruction

This endpoint always uses async mode (sync: false) and returns a status_url to poll for results.

 * @summary Edit an image using Bria FIBO
 */
export type briaFiboEditResponse202 = {
  data: BriaAsyncResponse
  status: 202
}

export type briaFiboEditResponse400 = {
  data: ErrorResponse
  status: 400
}

export type briaFiboEditResponse401 = {
  data: void
  status: 401
}

export type briaFiboEditResponse402 = {
  data: ErrorResponse
  status: 402
}

export type briaFiboEditResponse422 = {
  data: BriaErrorResponse
  status: 422
}

export type briaFiboEditResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type briaFiboEditResponseSuccess = (briaFiboEditResponse202) & {
  headers: Headers;
};
export type briaFiboEditResponseError = (briaFiboEditResponse400 | briaFiboEditResponse401 | briaFiboEditResponse402 | briaFiboEditResponse422 | briaFiboEditResponse500) & {
  headers: Headers;
};

export type briaFiboEditResponse = (briaFiboEditResponseSuccess | briaFiboEditResponseError)

export const getBriaFiboEditUrl = () => {


  

  return `/proxy/bria/v2/image/edit`
}

export const briaFiboEdit = async (briaFiboEditRequest: BriaFiboEditRequest, options?: RequestInit): Promise<briaFiboEditResponse> => {
  
  return customInstance<briaFiboEditResponse>(getBriaFiboEditUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      briaFiboEditRequest,)
  }
);}




export const getBriaFiboEditMutationOptions = <TError = ErrorResponse | void | BriaErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof briaFiboEdit>>, TError,{data: BriaFiboEditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof briaFiboEdit>>, TError,{data: BriaFiboEditRequest}, TContext> => {

const mutationKey = ['briaFiboEdit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof briaFiboEdit>>, {data: BriaFiboEditRequest}> = (props) => {
          const {data} = props ?? {};

          return  briaFiboEdit(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BriaFiboEditMutationResult = NonNullable<Awaited<ReturnType<typeof briaFiboEdit>>>
    export type BriaFiboEditMutationBody = BriaFiboEditRequest
    export type BriaFiboEditMutationError = ErrorResponse | void | BriaErrorResponse

    /**
 * @summary Edit an image using Bria FIBO
 */
export const useBriaFiboEdit = <TError = ErrorResponse | void | BriaErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof briaFiboEdit>>, TError,{data: BriaFiboEditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof briaFiboEdit>>,
        TError,
        {data: BriaFiboEditRequest},
        TContext
      > => {
      return useMutation(getBriaFiboEditMutationOptions(options), queryClient);
    }
    
/**
 * Remove the background of an image using Bria's RMBG 2.0 model.

Returns HTTP 202 with request_id and status_url when async (default).
Can return 200 with result directly when sync is true.

Accepted image formats: JPEG, JPG, PNG, WEBP.

 * @summary Remove background from an image using Bria
 */
export type briaImageRemoveBackgroundResponse202 = {
  data: BriaAsyncResponse
  status: 202
}

export type briaImageRemoveBackgroundResponse400 = {
  data: BriaErrorResponse
  status: 400
}

export type briaImageRemoveBackgroundResponse401 = {
  data: void
  status: 401
}

export type briaImageRemoveBackgroundResponse402 = {
  data: ErrorResponse
  status: 402
}

export type briaImageRemoveBackgroundResponse422 = {
  data: BriaErrorResponse
  status: 422
}

export type briaImageRemoveBackgroundResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type briaImageRemoveBackgroundResponseSuccess = (briaImageRemoveBackgroundResponse202) & {
  headers: Headers;
};
export type briaImageRemoveBackgroundResponseError = (briaImageRemoveBackgroundResponse400 | briaImageRemoveBackgroundResponse401 | briaImageRemoveBackgroundResponse402 | briaImageRemoveBackgroundResponse422 | briaImageRemoveBackgroundResponse500) & {
  headers: Headers;
};

export type briaImageRemoveBackgroundResponse = (briaImageRemoveBackgroundResponseSuccess | briaImageRemoveBackgroundResponseError)

export const getBriaImageRemoveBackgroundUrl = () => {


  

  return `/proxy/bria/v2/image/edit/remove_background`
}

export const briaImageRemoveBackground = async (briaImageRemoveBackgroundRequest: BriaImageRemoveBackgroundRequest, options?: RequestInit): Promise<briaImageRemoveBackgroundResponse> => {
  
  return customInstance<briaImageRemoveBackgroundResponse>(getBriaImageRemoveBackgroundUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      briaImageRemoveBackgroundRequest,)
  }
);}




export const getBriaImageRemoveBackgroundMutationOptions = <TError = BriaErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof briaImageRemoveBackground>>, TError,{data: BriaImageRemoveBackgroundRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof briaImageRemoveBackground>>, TError,{data: BriaImageRemoveBackgroundRequest}, TContext> => {

const mutationKey = ['briaImageRemoveBackground'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof briaImageRemoveBackground>>, {data: BriaImageRemoveBackgroundRequest}> = (props) => {
          const {data} = props ?? {};

          return  briaImageRemoveBackground(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BriaImageRemoveBackgroundMutationResult = NonNullable<Awaited<ReturnType<typeof briaImageRemoveBackground>>>
    export type BriaImageRemoveBackgroundMutationBody = BriaImageRemoveBackgroundRequest
    export type BriaImageRemoveBackgroundMutationError = BriaErrorResponse | void | ErrorResponse

    /**
 * @summary Remove background from an image using Bria
 */
export const useBriaImageRemoveBackground = <TError = BriaErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof briaImageRemoveBackground>>, TError,{data: BriaImageRemoveBackgroundRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof briaImageRemoveBackground>>,
        TError,
        {data: BriaImageRemoveBackgroundRequest},
        TContext
      > => {
      return useMutation(getBriaImageRemoveBackgroundMutationOptions(options), queryClient);
    }
    
/**
 * Retrieves the current status of an asynchronous Bria request.

Poll this endpoint until the status is COMPLETED or ERROR.

Status values:
- `IN_PROGRESS` ‚Äì Request is being processed. Continue polling.
- `COMPLETED` ‚Äì Success. Response includes `result.image_url` for images, `result.video_url` for videos, or `result.structured_prompt` for structured prompt generation. Additional optional fields (seed, prompt, refined_prompt) may be included.
- `ERROR` ‚Äì Processing failed. Check error object for details.
- `UNKNOWN` ‚Äì Unexpected internal error.

 * @summary Get Bria request status
 */
export type briaGetStatusResponse200 = {
  data: BriaStatusResponse
  status: 200
}

export type briaGetStatusResponse401 = {
  data: void
  status: 401
}

export type briaGetStatusResponse402 = {
  data: ErrorResponse
  status: 402
}

export type briaGetStatusResponse404 = {
  data: BriaStatusNotFoundResponse
  status: 404
}

export type briaGetStatusResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type briaGetStatusResponseSuccess = (briaGetStatusResponse200) & {
  headers: Headers;
};
export type briaGetStatusResponseError = (briaGetStatusResponse401 | briaGetStatusResponse402 | briaGetStatusResponse404 | briaGetStatusResponse500) & {
  headers: Headers;
};

export type briaGetStatusResponse = (briaGetStatusResponseSuccess | briaGetStatusResponseError)

export const getBriaGetStatusUrl = (requestId: string,) => {


  

  return `/proxy/bria/v2/status/${requestId}`
}

export const briaGetStatus = async (requestId: string, options?: RequestInit): Promise<briaGetStatusResponse> => {
  
  return customInstance<briaGetStatusResponse>(getBriaGetStatusUrl(requestId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getBriaGetStatusQueryKey = (requestId: string,) => {
    return [
    `/proxy/bria/v2/status/${requestId}`
    ] as const;
    }

    
export const getBriaGetStatusQueryOptions = <TData = Awaited<ReturnType<typeof briaGetStatus>>, TError = void | ErrorResponse | BriaStatusNotFoundResponse>(requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof briaGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBriaGetStatusQueryKey(requestId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof briaGetStatus>>> = ({ signal }) => briaGetStatus(requestId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(requestId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof briaGetStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BriaGetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof briaGetStatus>>>
export type BriaGetStatusQueryError = void | ErrorResponse | BriaStatusNotFoundResponse


export function useBriaGetStatus<TData = Awaited<ReturnType<typeof briaGetStatus>>, TError = void | ErrorResponse | BriaStatusNotFoundResponse>(
 requestId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof briaGetStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof briaGetStatus>>,
          TError,
          Awaited<ReturnType<typeof briaGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBriaGetStatus<TData = Awaited<ReturnType<typeof briaGetStatus>>, TError = void | ErrorResponse | BriaStatusNotFoundResponse>(
 requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof briaGetStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof briaGetStatus>>,
          TError,
          Awaited<ReturnType<typeof briaGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBriaGetStatus<TData = Awaited<ReturnType<typeof briaGetStatus>>, TError = void | ErrorResponse | BriaStatusNotFoundResponse>(
 requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof briaGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Bria request status
 */

export function useBriaGetStatus<TData = Awaited<ReturnType<typeof briaGetStatus>>, TError = void | ErrorResponse | BriaStatusNotFoundResponse>(
 requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof briaGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBriaGetStatusQueryOptions(requestId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Translates a user's text-based edit instruction and source image/mask into a detailed, 
machine-readable structured edit instruction in JSON format.

This endpoint uses Gemini 2.5 Flash VLM to understand the edit context and returns only 
the JSON string without generating an image.

The resulting structured_instruction can be used as input for the /proxy/bria/v2/image/edit endpoint.

This endpoint always uses async mode (sync: false) and returns a status_url to poll for results.

 * @summary Generate a structured instruction from text
 */
export type briaStructuredInstructionGenerateResponse202 = {
  data: BriaAsyncResponse
  status: 202
}

export type briaStructuredInstructionGenerateResponse400 = {
  data: ErrorResponse
  status: 400
}

export type briaStructuredInstructionGenerateResponse401 = {
  data: void
  status: 401
}

export type briaStructuredInstructionGenerateResponse402 = {
  data: ErrorResponse
  status: 402
}

export type briaStructuredInstructionGenerateResponse422 = {
  data: BriaErrorResponse
  status: 422
}

export type briaStructuredInstructionGenerateResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type briaStructuredInstructionGenerateResponseSuccess = (briaStructuredInstructionGenerateResponse202) & {
  headers: Headers;
};
export type briaStructuredInstructionGenerateResponseError = (briaStructuredInstructionGenerateResponse400 | briaStructuredInstructionGenerateResponse401 | briaStructuredInstructionGenerateResponse402 | briaStructuredInstructionGenerateResponse422 | briaStructuredInstructionGenerateResponse500) & {
  headers: Headers;
};

export type briaStructuredInstructionGenerateResponse = (briaStructuredInstructionGenerateResponseSuccess | briaStructuredInstructionGenerateResponseError)

export const getBriaStructuredInstructionGenerateUrl = () => {


  

  return `/proxy/bria/v2/structured_instruction/generate`
}

export const briaStructuredInstructionGenerate = async (briaStructuredInstructionRequest: BriaStructuredInstructionRequest, options?: RequestInit): Promise<briaStructuredInstructionGenerateResponse> => {
  
  return customInstance<briaStructuredInstructionGenerateResponse>(getBriaStructuredInstructionGenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      briaStructuredInstructionRequest,)
  }
);}




export const getBriaStructuredInstructionGenerateMutationOptions = <TError = ErrorResponse | void | BriaErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof briaStructuredInstructionGenerate>>, TError,{data: BriaStructuredInstructionRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof briaStructuredInstructionGenerate>>, TError,{data: BriaStructuredInstructionRequest}, TContext> => {

const mutationKey = ['briaStructuredInstructionGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof briaStructuredInstructionGenerate>>, {data: BriaStructuredInstructionRequest}> = (props) => {
          const {data} = props ?? {};

          return  briaStructuredInstructionGenerate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BriaStructuredInstructionGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof briaStructuredInstructionGenerate>>>
    export type BriaStructuredInstructionGenerateMutationBody = BriaStructuredInstructionRequest
    export type BriaStructuredInstructionGenerateMutationError = ErrorResponse | void | BriaErrorResponse

    /**
 * @summary Generate a structured instruction from text
 */
export const useBriaStructuredInstructionGenerate = <TError = ErrorResponse | void | BriaErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof briaStructuredInstructionGenerate>>, TError,{data: BriaStructuredInstructionRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof briaStructuredInstructionGenerate>>,
        TError,
        {data: BriaStructuredInstructionRequest},
        TContext
      > => {
      return useMutation(getBriaStructuredInstructionGenerateMutationOptions(options), queryClient);
    }
    
/**
 * Initiates an asynchronous background removal job for a video using Bria's API.

Returns HTTP 202 with request_id and status_url. Poll the status endpoint for results.

Supported input containers: .mp4, .mov, .webm, .avi, .gif
Supported input codecs: H.264, H.265 (HEVC), VP9, AV1, PhotoJPEG
Max input duration: 60 seconds. Input resolution up to 16000x16000.

 * @summary Remove background from a video using Bria
 */
export type briaVideoRemoveBackgroundResponse202 = {
  data: BriaAsyncResponse
  status: 202
}

export type briaVideoRemoveBackgroundResponse400 = {
  data: BriaErrorResponse
  status: 400
}

export type briaVideoRemoveBackgroundResponse401 = {
  data: void
  status: 401
}

export type briaVideoRemoveBackgroundResponse402 = {
  data: ErrorResponse
  status: 402
}

export type briaVideoRemoveBackgroundResponse422 = {
  data: BriaErrorResponse
  status: 422
}

export type briaVideoRemoveBackgroundResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type briaVideoRemoveBackgroundResponseSuccess = (briaVideoRemoveBackgroundResponse202) & {
  headers: Headers;
};
export type briaVideoRemoveBackgroundResponseError = (briaVideoRemoveBackgroundResponse400 | briaVideoRemoveBackgroundResponse401 | briaVideoRemoveBackgroundResponse402 | briaVideoRemoveBackgroundResponse422 | briaVideoRemoveBackgroundResponse500) & {
  headers: Headers;
};

export type briaVideoRemoveBackgroundResponse = (briaVideoRemoveBackgroundResponseSuccess | briaVideoRemoveBackgroundResponseError)

export const getBriaVideoRemoveBackgroundUrl = () => {


  

  return `/proxy/bria/v2/video/edit/remove_background`
}

export const briaVideoRemoveBackground = async (briaVideoRemoveBackgroundRequest: BriaVideoRemoveBackgroundRequest, options?: RequestInit): Promise<briaVideoRemoveBackgroundResponse> => {
  
  return customInstance<briaVideoRemoveBackgroundResponse>(getBriaVideoRemoveBackgroundUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      briaVideoRemoveBackgroundRequest,)
  }
);}




export const getBriaVideoRemoveBackgroundMutationOptions = <TError = BriaErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof briaVideoRemoveBackground>>, TError,{data: BriaVideoRemoveBackgroundRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof briaVideoRemoveBackground>>, TError,{data: BriaVideoRemoveBackgroundRequest}, TContext> => {

const mutationKey = ['briaVideoRemoveBackground'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof briaVideoRemoveBackground>>, {data: BriaVideoRemoveBackgroundRequest}> = (props) => {
          const {data} = props ?? {};

          return  briaVideoRemoveBackground(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BriaVideoRemoveBackgroundMutationResult = NonNullable<Awaited<ReturnType<typeof briaVideoRemoveBackground>>>
    export type BriaVideoRemoveBackgroundMutationBody = BriaVideoRemoveBackgroundRequest
    export type BriaVideoRemoveBackgroundMutationError = BriaErrorResponse | void | ErrorResponse

    /**
 * @summary Remove background from a video using Bria
 */
export const useBriaVideoRemoveBackground = <TError = BriaErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof briaVideoRemoveBackground>>, TError,{data: BriaVideoRemoveBackgroundRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof briaVideoRemoveBackground>>,
        TError,
        {data: BriaVideoRemoveBackgroundRequest},
        TContext
      > => {
      return useMutation(getBriaVideoRemoveBackgroundMutationOptions(options), queryClient);
    }
    
export type byteplusVideoGenerationResponse200 = {
  data: BytePlusVideoGenerationResponse
  status: 200
}

export type byteplusVideoGenerationResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type byteplusVideoGenerationResponseSuccess = (byteplusVideoGenerationResponse200) & {
  headers: Headers;
};
export type byteplusVideoGenerationResponseError = (byteplusVideoGenerationResponseDefault) & {
  headers: Headers;
};

export type byteplusVideoGenerationResponse = (byteplusVideoGenerationResponseSuccess | byteplusVideoGenerationResponseError)

export const getByteplusVideoGenerationUrl = () => {


  

  return `/proxy/byteplus/api/v3/contents/generations/tasks`
}

export const byteplusVideoGeneration = async (bytePlusVideoGenerationRequest: BytePlusVideoGenerationRequest, options?: RequestInit): Promise<byteplusVideoGenerationResponse> => {
  
  return customInstance<byteplusVideoGenerationResponse>(getByteplusVideoGenerationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bytePlusVideoGenerationRequest,)
  }
);}




export const getByteplusVideoGenerationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof byteplusVideoGeneration>>, TError,{data: BytePlusVideoGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof byteplusVideoGeneration>>, TError,{data: BytePlusVideoGenerationRequest}, TContext> => {

const mutationKey = ['byteplusVideoGeneration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof byteplusVideoGeneration>>, {data: BytePlusVideoGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  byteplusVideoGeneration(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ByteplusVideoGenerationMutationResult = NonNullable<Awaited<ReturnType<typeof byteplusVideoGeneration>>>
    export type ByteplusVideoGenerationMutationBody = BytePlusVideoGenerationRequest
    export type ByteplusVideoGenerationMutationError = ErrorResponse

    export const useByteplusVideoGeneration = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof byteplusVideoGeneration>>, TError,{data: BytePlusVideoGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof byteplusVideoGeneration>>,
        TError,
        {data: BytePlusVideoGenerationRequest},
        TContext
      > => {
      return useMutation(getByteplusVideoGenerationMutationOptions(options), queryClient);
    }
    
export type byteplusVideoGenerationQueryResponse200 = {
  data: BytePlusVideoGenerationQueryResponse
  status: 200
}

export type byteplusVideoGenerationQueryResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type byteplusVideoGenerationQueryResponseSuccess = (byteplusVideoGenerationQueryResponse200) & {
  headers: Headers;
};
export type byteplusVideoGenerationQueryResponseError = (byteplusVideoGenerationQueryResponseDefault) & {
  headers: Headers;
};

export type byteplusVideoGenerationQueryResponse = (byteplusVideoGenerationQueryResponseSuccess | byteplusVideoGenerationQueryResponseError)

export const getByteplusVideoGenerationQueryUrl = (taskId: string,) => {


  

  return `/proxy/byteplus/api/v3/contents/generations/tasks/${taskId}`
}

export const byteplusVideoGenerationQuery = async (taskId: string, options?: RequestInit): Promise<byteplusVideoGenerationQueryResponse> => {
  
  return customInstance<byteplusVideoGenerationQueryResponse>(getByteplusVideoGenerationQueryUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getByteplusVideoGenerationQueryQueryKey = (taskId: string,) => {
    return [
    `/proxy/byteplus/api/v3/contents/generations/tasks/${taskId}`
    ] as const;
    }

    
export const getByteplusVideoGenerationQueryQueryOptions = <TData = Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>, TError = ErrorResponse>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getByteplusVideoGenerationQueryQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>> = ({ signal }) => byteplusVideoGenerationQuery(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ByteplusVideoGenerationQueryQueryResult = NonNullable<Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>>
export type ByteplusVideoGenerationQueryQueryError = ErrorResponse


export function useByteplusVideoGenerationQuery<TData = Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>, TError = ErrorResponse>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
          TError,
          Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useByteplusVideoGenerationQuery<TData = Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
          TError,
          Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useByteplusVideoGenerationQuery<TData = Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useByteplusVideoGenerationQuery<TData = Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getByteplusVideoGenerationQueryQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type byteplusImageGenerationResponse200 = {
  data: BytePlusImageGenerationResponse
  status: 200
}

export type byteplusImageGenerationResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type byteplusImageGenerationResponseSuccess = (byteplusImageGenerationResponse200) & {
  headers: Headers;
};
export type byteplusImageGenerationResponseError = (byteplusImageGenerationResponseDefault) & {
  headers: Headers;
};

export type byteplusImageGenerationResponse = (byteplusImageGenerationResponseSuccess | byteplusImageGenerationResponseError)

export const getByteplusImageGenerationUrl = () => {


  

  return `/proxy/byteplus/api/v3/images/generations`
}

export const byteplusImageGeneration = async (bytePlusImageGenerationRequest: BytePlusImageGenerationRequest, options?: RequestInit): Promise<byteplusImageGenerationResponse> => {
  
  return customInstance<byteplusImageGenerationResponse>(getByteplusImageGenerationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bytePlusImageGenerationRequest,)
  }
);}




export const getByteplusImageGenerationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof byteplusImageGeneration>>, TError,{data: BytePlusImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof byteplusImageGeneration>>, TError,{data: BytePlusImageGenerationRequest}, TContext> => {

const mutationKey = ['byteplusImageGeneration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof byteplusImageGeneration>>, {data: BytePlusImageGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  byteplusImageGeneration(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ByteplusImageGenerationMutationResult = NonNullable<Awaited<ReturnType<typeof byteplusImageGeneration>>>
    export type ByteplusImageGenerationMutationBody = BytePlusImageGenerationRequest
    export type ByteplusImageGenerationMutationError = ErrorResponse

    export const useByteplusImageGeneration = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof byteplusImageGeneration>>, TError,{data: BytePlusImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof byteplusImageGeneration>>,
        TError,
        {data: BytePlusImageGenerationRequest},
        TContext
      > => {
      return useMutation(getByteplusImageGenerationMutationOptions(options), queryClient);
    }
    
/**
 * Dummy proxy endpoint that returns a simple string
 * @summary Dummy proxy
 */
export type dummyProxyResponse200 = {
  data: void
  status: 200
}
    
export type dummyProxyResponseSuccess = (dummyProxyResponse200) & {
  headers: Headers;
};
;

export type dummyProxyResponse = (dummyProxyResponseSuccess)

export const getDummyProxyUrl = () => {


  

  return `/proxy/dummy`
}

export const dummyProxy = async (dummyProxyBody: DummyProxyBody, options?: RequestInit): Promise<dummyProxyResponse> => {
  
  return customInstance<dummyProxyResponse>(getDummyProxyUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      dummyProxyBody,)
  }
);}




export const getDummyProxyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof dummyProxy>>, TError,{data: DummyProxyBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof dummyProxy>>, TError,{data: DummyProxyBody}, TContext> => {

const mutationKey = ['dummyProxy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof dummyProxy>>, {data: DummyProxyBody}> = (props) => {
          const {data} = props ?? {};

          return  dummyProxy(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DummyProxyMutationResult = NonNullable<Awaited<ReturnType<typeof dummyProxy>>>
    export type DummyProxyMutationBody = DummyProxyBody
    export type DummyProxyMutationError = unknown

    /**
 * @summary Dummy proxy
 */
export const useDummyProxy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof dummyProxy>>, TError,{data: DummyProxyBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof dummyProxy>>,
        TError,
        {data: DummyProxyBody},
        TContext
      > => {
      return useMutation(getDummyProxyMutationOptions(options), queryClient);
    }
    
/**
 * Relight an image using AI. This endpoint accepts a variety of parameters to customize the generated images.

 * @summary Relight an image
 */
export type freepikMagnificRelightResponse200 = {
  data: FreepikTaskResponse
  status: 200
}

export type freepikMagnificRelightResponse400 = {
  data: FreepikErrorResponse
  status: 400
}

export type freepikMagnificRelightResponse500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikMagnificRelightResponseSuccess = (freepikMagnificRelightResponse200) & {
  headers: Headers;
};
export type freepikMagnificRelightResponseError = (freepikMagnificRelightResponse400 | freepikMagnificRelightResponse500) & {
  headers: Headers;
};

export type freepikMagnificRelightResponse = (freepikMagnificRelightResponseSuccess | freepikMagnificRelightResponseError)

export const getFreepikMagnificRelightUrl = () => {


  

  return `/proxy/freepik/v1/ai/image-relight`
}

export const freepikMagnificRelight = async (freepikMagnificRelightRequest: FreepikMagnificRelightRequest, options?: RequestInit): Promise<freepikMagnificRelightResponse> => {
  
  return customInstance<freepikMagnificRelightResponse>(getFreepikMagnificRelightUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      freepikMagnificRelightRequest,)
  }
);}




export const getFreepikMagnificRelightMutationOptions = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificRelight>>, TError,{data: FreepikMagnificRelightRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificRelight>>, TError,{data: FreepikMagnificRelightRequest}, TContext> => {

const mutationKey = ['freepikMagnificRelight'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof freepikMagnificRelight>>, {data: FreepikMagnificRelightRequest}> = (props) => {
          const {data} = props ?? {};

          return  freepikMagnificRelight(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type FreepikMagnificRelightMutationResult = NonNullable<Awaited<ReturnType<typeof freepikMagnificRelight>>>
    export type FreepikMagnificRelightMutationBody = FreepikMagnificRelightRequest
    export type FreepikMagnificRelightMutationError = FreepikErrorResponse

    /**
 * @summary Relight an image
 */
export const useFreepikMagnificRelight = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificRelight>>, TError,{data: FreepikMagnificRelightRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof freepikMagnificRelight>>,
        TError,
        {data: FreepikMagnificRelightRequest},
        TContext
      > => {
      return useMutation(getFreepikMagnificRelightMutationOptions(options), queryClient);
    }
    
/**
 * Get the status of the relight task
 * @summary Get the status of the relight task
 */
export type freepikMagnificRelightGetStatusResponse200 = {
  data: FreepikTaskResponse
  status: 200
}

export type freepikMagnificRelightGetStatusResponse404 = {
  data: void
  status: 404
}

export type freepikMagnificRelightGetStatusResponse500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikMagnificRelightGetStatusResponseSuccess = (freepikMagnificRelightGetStatusResponse200) & {
  headers: Headers;
};
export type freepikMagnificRelightGetStatusResponseError = (freepikMagnificRelightGetStatusResponse404 | freepikMagnificRelightGetStatusResponse500) & {
  headers: Headers;
};

export type freepikMagnificRelightGetStatusResponse = (freepikMagnificRelightGetStatusResponseSuccess | freepikMagnificRelightGetStatusResponseError)

export const getFreepikMagnificRelightGetStatusUrl = (taskId: string,) => {


  

  return `/proxy/freepik/v1/ai/image-relight/${taskId}`
}

export const freepikMagnificRelightGetStatus = async (taskId: string, options?: RequestInit): Promise<freepikMagnificRelightGetStatusResponse> => {
  
  return customInstance<freepikMagnificRelightGetStatusResponse>(getFreepikMagnificRelightGetStatusUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getFreepikMagnificRelightGetStatusQueryKey = (taskId: string,) => {
    return [
    `/proxy/freepik/v1/ai/image-relight/${taskId}`
    ] as const;
    }

    
export const getFreepikMagnificRelightGetStatusQueryOptions = <TData = Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>, TError = void | FreepikErrorResponse>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFreepikMagnificRelightGetStatusQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>> = ({ signal }) => freepikMagnificRelightGetStatus(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FreepikMagnificRelightGetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>>
export type FreepikMagnificRelightGetStatusQueryError = void | FreepikErrorResponse


export function useFreepikMagnificRelightGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>,
          TError,
          Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFreepikMagnificRelightGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>,
          TError,
          Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFreepikMagnificRelightGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the status of the relight task
 */

export function useFreepikMagnificRelightGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificRelightGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFreepikMagnificRelightGetStatusQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Style transfer an image using AI.
 * @summary Style transfer an image
 */
export type freepikMagnificStyleTransferResponse200 = {
  data: FreepikTaskData
  status: 200
}

export type freepikMagnificStyleTransferResponse400 = {
  data: FreepikErrorResponse
  status: 400
}

export type freepikMagnificStyleTransferResponse500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikMagnificStyleTransferResponseSuccess = (freepikMagnificStyleTransferResponse200) & {
  headers: Headers;
};
export type freepikMagnificStyleTransferResponseError = (freepikMagnificStyleTransferResponse400 | freepikMagnificStyleTransferResponse500) & {
  headers: Headers;
};

export type freepikMagnificStyleTransferResponse = (freepikMagnificStyleTransferResponseSuccess | freepikMagnificStyleTransferResponseError)

export const getFreepikMagnificStyleTransferUrl = () => {


  

  return `/proxy/freepik/v1/ai/image-style-transfer`
}

export const freepikMagnificStyleTransfer = async (freepikMagnificStyleTransferRequest: FreepikMagnificStyleTransferRequest, options?: RequestInit): Promise<freepikMagnificStyleTransferResponse> => {
  
  return customInstance<freepikMagnificStyleTransferResponse>(getFreepikMagnificStyleTransferUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      freepikMagnificStyleTransferRequest,)
  }
);}




export const getFreepikMagnificStyleTransferMutationOptions = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificStyleTransfer>>, TError,{data: FreepikMagnificStyleTransferRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificStyleTransfer>>, TError,{data: FreepikMagnificStyleTransferRequest}, TContext> => {

const mutationKey = ['freepikMagnificStyleTransfer'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof freepikMagnificStyleTransfer>>, {data: FreepikMagnificStyleTransferRequest}> = (props) => {
          const {data} = props ?? {};

          return  freepikMagnificStyleTransfer(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type FreepikMagnificStyleTransferMutationResult = NonNullable<Awaited<ReturnType<typeof freepikMagnificStyleTransfer>>>
    export type FreepikMagnificStyleTransferMutationBody = FreepikMagnificStyleTransferRequest
    export type FreepikMagnificStyleTransferMutationError = FreepikErrorResponse

    /**
 * @summary Style transfer an image
 */
export const useFreepikMagnificStyleTransfer = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificStyleTransfer>>, TError,{data: FreepikMagnificStyleTransferRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof freepikMagnificStyleTransfer>>,
        TError,
        {data: FreepikMagnificStyleTransferRequest},
        TContext
      > => {
      return useMutation(getFreepikMagnificStyleTransferMutationOptions(options), queryClient);
    }
    
/**
 * Get the status of the style transfer task
 * @summary Get the status of the style transfer task
 */
export type freepikMagnificStyleTransferGetStatusResponse200 = {
  data: FreepikTaskResponse
  status: 200
}

export type freepikMagnificStyleTransferGetStatusResponse404 = {
  data: void
  status: 404
}

export type freepikMagnificStyleTransferGetStatusResponse500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikMagnificStyleTransferGetStatusResponseSuccess = (freepikMagnificStyleTransferGetStatusResponse200) & {
  headers: Headers;
};
export type freepikMagnificStyleTransferGetStatusResponseError = (freepikMagnificStyleTransferGetStatusResponse404 | freepikMagnificStyleTransferGetStatusResponse500) & {
  headers: Headers;
};

export type freepikMagnificStyleTransferGetStatusResponse = (freepikMagnificStyleTransferGetStatusResponseSuccess | freepikMagnificStyleTransferGetStatusResponseError)

export const getFreepikMagnificStyleTransferGetStatusUrl = (taskId: string,) => {


  

  return `/proxy/freepik/v1/ai/image-style-transfer/${taskId}`
}

export const freepikMagnificStyleTransferGetStatus = async (taskId: string, options?: RequestInit): Promise<freepikMagnificStyleTransferGetStatusResponse> => {
  
  return customInstance<freepikMagnificStyleTransferGetStatusResponse>(getFreepikMagnificStyleTransferGetStatusUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getFreepikMagnificStyleTransferGetStatusQueryKey = (taskId: string,) => {
    return [
    `/proxy/freepik/v1/ai/image-style-transfer/${taskId}`
    ] as const;
    }

    
export const getFreepikMagnificStyleTransferGetStatusQueryOptions = <TData = Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>, TError = void | FreepikErrorResponse>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFreepikMagnificStyleTransferGetStatusQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>> = ({ signal }) => freepikMagnificStyleTransferGetStatus(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FreepikMagnificStyleTransferGetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>>
export type FreepikMagnificStyleTransferGetStatusQueryError = void | FreepikErrorResponse


export function useFreepikMagnificStyleTransferGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>,
          TError,
          Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFreepikMagnificStyleTransferGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>,
          TError,
          Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFreepikMagnificStyleTransferGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the status of the style transfer task
 */

export function useFreepikMagnificStyleTransferGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificStyleTransferGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFreepikMagnificStyleTransferGetStatusQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * This asynchronous endpoint enables image upscaling using advanced AI algorithms.
Upon submission, it returns a unique task_id which can be used to track the progress.
For real-time production use, include the optional webhook_url parameter to receive
an automated notification once the task has been completed.

 * @summary Upscale an image with Magnific
 */
export type freepikMagnificUpscalerCreativeResponse200 = {
  data: FreepikTaskResponse
  status: 200
}

export type freepikMagnificUpscalerCreativeResponse400 = {
  data: FreepikErrorResponse
  status: 400
}

export type freepikMagnificUpscalerCreativeResponse500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikMagnificUpscalerCreativeResponseSuccess = (freepikMagnificUpscalerCreativeResponse200) & {
  headers: Headers;
};
export type freepikMagnificUpscalerCreativeResponseError = (freepikMagnificUpscalerCreativeResponse400 | freepikMagnificUpscalerCreativeResponse500) & {
  headers: Headers;
};

export type freepikMagnificUpscalerCreativeResponse = (freepikMagnificUpscalerCreativeResponseSuccess | freepikMagnificUpscalerCreativeResponseError)

export const getFreepikMagnificUpscalerCreativeUrl = () => {


  

  return `/proxy/freepik/v1/ai/image-upscaler`
}

export const freepikMagnificUpscalerCreative = async (freepikMagnificUpscalerCreativeRequest: FreepikMagnificUpscalerCreativeRequest, options?: RequestInit): Promise<freepikMagnificUpscalerCreativeResponse> => {
  
  return customInstance<freepikMagnificUpscalerCreativeResponse>(getFreepikMagnificUpscalerCreativeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      freepikMagnificUpscalerCreativeRequest,)
  }
);}




export const getFreepikMagnificUpscalerCreativeMutationOptions = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerCreative>>, TError,{data: FreepikMagnificUpscalerCreativeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerCreative>>, TError,{data: FreepikMagnificUpscalerCreativeRequest}, TContext> => {

const mutationKey = ['freepikMagnificUpscalerCreative'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof freepikMagnificUpscalerCreative>>, {data: FreepikMagnificUpscalerCreativeRequest}> = (props) => {
          const {data} = props ?? {};

          return  freepikMagnificUpscalerCreative(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type FreepikMagnificUpscalerCreativeMutationResult = NonNullable<Awaited<ReturnType<typeof freepikMagnificUpscalerCreative>>>
    export type FreepikMagnificUpscalerCreativeMutationBody = FreepikMagnificUpscalerCreativeRequest
    export type FreepikMagnificUpscalerCreativeMutationError = FreepikErrorResponse

    /**
 * @summary Upscale an image with Magnific
 */
export const useFreepikMagnificUpscalerCreative = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerCreative>>, TError,{data: FreepikMagnificUpscalerCreativeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof freepikMagnificUpscalerCreative>>,
        TError,
        {data: FreepikMagnificUpscalerCreativeRequest},
        TContext
      > => {
      return useMutation(getFreepikMagnificUpscalerCreativeMutationOptions(options), queryClient);
    }
    
/**
 * Upscales an image while adding new visual elements or details (V2).
This endpoint may modify the original image content based on the prompt and inferred context.
Upon submission, it returns a unique task_id which can be used to track the progress.

 * @summary Upscale an image with Precision V2
 */
export type freepikMagnificUpscalerPrecisionV2Response200 = {
  data: FreepikTaskResponse
  status: 200
}

export type freepikMagnificUpscalerPrecisionV2Response400 = {
  data: FreepikErrorResponse
  status: 400
}

export type freepikMagnificUpscalerPrecisionV2Response500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikMagnificUpscalerPrecisionV2ResponseSuccess = (freepikMagnificUpscalerPrecisionV2Response200) & {
  headers: Headers;
};
export type freepikMagnificUpscalerPrecisionV2ResponseError = (freepikMagnificUpscalerPrecisionV2Response400 | freepikMagnificUpscalerPrecisionV2Response500) & {
  headers: Headers;
};

export type freepikMagnificUpscalerPrecisionV2Response = (freepikMagnificUpscalerPrecisionV2ResponseSuccess | freepikMagnificUpscalerPrecisionV2ResponseError)

export const getFreepikMagnificUpscalerPrecisionV2Url = () => {


  

  return `/proxy/freepik/v1/ai/image-upscaler-precision-v2`
}

export const freepikMagnificUpscalerPrecisionV2 = async (freepikMagnificUpscalerPrecisionV2Request: FreepikMagnificUpscalerPrecisionV2Request, options?: RequestInit): Promise<freepikMagnificUpscalerPrecisionV2Response> => {
  
  return customInstance<freepikMagnificUpscalerPrecisionV2Response>(getFreepikMagnificUpscalerPrecisionV2Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      freepikMagnificUpscalerPrecisionV2Request,)
  }
);}




export const getFreepikMagnificUpscalerPrecisionV2MutationOptions = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2>>, TError,{data: FreepikMagnificUpscalerPrecisionV2Request}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2>>, TError,{data: FreepikMagnificUpscalerPrecisionV2Request}, TContext> => {

const mutationKey = ['freepikMagnificUpscalerPrecisionV2'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2>>, {data: FreepikMagnificUpscalerPrecisionV2Request}> = (props) => {
          const {data} = props ?? {};

          return  freepikMagnificUpscalerPrecisionV2(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type FreepikMagnificUpscalerPrecisionV2MutationResult = NonNullable<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2>>>
    export type FreepikMagnificUpscalerPrecisionV2MutationBody = FreepikMagnificUpscalerPrecisionV2Request
    export type FreepikMagnificUpscalerPrecisionV2MutationError = FreepikErrorResponse

    /**
 * @summary Upscale an image with Precision V2
 */
export const useFreepikMagnificUpscalerPrecisionV2 = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2>>, TError,{data: FreepikMagnificUpscalerPrecisionV2Request}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2>>,
        TError,
        {data: FreepikMagnificUpscalerPrecisionV2Request},
        TContext
      > => {
      return useMutation(getFreepikMagnificUpscalerPrecisionV2MutationOptions(options), queryClient);
    }
    
/**
 * Returns the current status and output URL of a specific precision upscaler V2 task.
 * @summary Get the status of the Precision V2 upscaling task
 */
export type freepikMagnificUpscalerPrecisionV2GetStatusResponse200 = {
  data: FreepikTaskResponse
  status: 200
}

export type freepikMagnificUpscalerPrecisionV2GetStatusResponse404 = {
  data: void
  status: 404
}

export type freepikMagnificUpscalerPrecisionV2GetStatusResponse500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikMagnificUpscalerPrecisionV2GetStatusResponseSuccess = (freepikMagnificUpscalerPrecisionV2GetStatusResponse200) & {
  headers: Headers;
};
export type freepikMagnificUpscalerPrecisionV2GetStatusResponseError = (freepikMagnificUpscalerPrecisionV2GetStatusResponse404 | freepikMagnificUpscalerPrecisionV2GetStatusResponse500) & {
  headers: Headers;
};

export type freepikMagnificUpscalerPrecisionV2GetStatusResponse = (freepikMagnificUpscalerPrecisionV2GetStatusResponseSuccess | freepikMagnificUpscalerPrecisionV2GetStatusResponseError)

export const getFreepikMagnificUpscalerPrecisionV2GetStatusUrl = (taskId: string,) => {


  

  return `/proxy/freepik/v1/ai/image-upscaler-precision-v2/${taskId}`
}

export const freepikMagnificUpscalerPrecisionV2GetStatus = async (taskId: string, options?: RequestInit): Promise<freepikMagnificUpscalerPrecisionV2GetStatusResponse> => {
  
  return customInstance<freepikMagnificUpscalerPrecisionV2GetStatusResponse>(getFreepikMagnificUpscalerPrecisionV2GetStatusUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getFreepikMagnificUpscalerPrecisionV2GetStatusQueryKey = (taskId: string,) => {
    return [
    `/proxy/freepik/v1/ai/image-upscaler-precision-v2/${taskId}`
    ] as const;
    }

    
export const getFreepikMagnificUpscalerPrecisionV2GetStatusQueryOptions = <TData = Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>, TError = void | FreepikErrorResponse>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFreepikMagnificUpscalerPrecisionV2GetStatusQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>> = ({ signal }) => freepikMagnificUpscalerPrecisionV2GetStatus(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FreepikMagnificUpscalerPrecisionV2GetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>>
export type FreepikMagnificUpscalerPrecisionV2GetStatusQueryError = void | FreepikErrorResponse


export function useFreepikMagnificUpscalerPrecisionV2GetStatus<TData = Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>,
          TError,
          Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFreepikMagnificUpscalerPrecisionV2GetStatus<TData = Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>,
          TError,
          Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFreepikMagnificUpscalerPrecisionV2GetStatus<TData = Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the status of the Precision V2 upscaling task
 */

export function useFreepikMagnificUpscalerPrecisionV2GetStatus<TData = Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerPrecisionV2GetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFreepikMagnificUpscalerPrecisionV2GetStatusQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Get the status of the upscaling task
 * @summary Get the status of the upscaling task
 */
export type freepikMagnificUpscalerCreativeGetStatusResponse200 = {
  data: FreepikTaskResponse
  status: 200
}

export type freepikMagnificUpscalerCreativeGetStatusResponse404 = {
  data: void
  status: 404
}

export type freepikMagnificUpscalerCreativeGetStatusResponse500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikMagnificUpscalerCreativeGetStatusResponseSuccess = (freepikMagnificUpscalerCreativeGetStatusResponse200) & {
  headers: Headers;
};
export type freepikMagnificUpscalerCreativeGetStatusResponseError = (freepikMagnificUpscalerCreativeGetStatusResponse404 | freepikMagnificUpscalerCreativeGetStatusResponse500) & {
  headers: Headers;
};

export type freepikMagnificUpscalerCreativeGetStatusResponse = (freepikMagnificUpscalerCreativeGetStatusResponseSuccess | freepikMagnificUpscalerCreativeGetStatusResponseError)

export const getFreepikMagnificUpscalerCreativeGetStatusUrl = (taskId: string,) => {


  

  return `/proxy/freepik/v1/ai/image-upscaler/${taskId}`
}

export const freepikMagnificUpscalerCreativeGetStatus = async (taskId: string, options?: RequestInit): Promise<freepikMagnificUpscalerCreativeGetStatusResponse> => {
  
  return customInstance<freepikMagnificUpscalerCreativeGetStatusResponse>(getFreepikMagnificUpscalerCreativeGetStatusUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getFreepikMagnificUpscalerCreativeGetStatusQueryKey = (taskId: string,) => {
    return [
    `/proxy/freepik/v1/ai/image-upscaler/${taskId}`
    ] as const;
    }

    
export const getFreepikMagnificUpscalerCreativeGetStatusQueryOptions = <TData = Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>, TError = void | FreepikErrorResponse>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFreepikMagnificUpscalerCreativeGetStatusQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>> = ({ signal }) => freepikMagnificUpscalerCreativeGetStatus(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FreepikMagnificUpscalerCreativeGetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>>
export type FreepikMagnificUpscalerCreativeGetStatusQueryError = void | FreepikErrorResponse


export function useFreepikMagnificUpscalerCreativeGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>,
          TError,
          Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFreepikMagnificUpscalerCreativeGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>,
          TError,
          Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFreepikMagnificUpscalerCreativeGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the status of the upscaling task
 */

export function useFreepikMagnificUpscalerCreativeGetStatus<TData = Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikMagnificUpscalerCreativeGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFreepikMagnificUpscalerCreativeGetStatusQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Enhance skin in images using AI with the Creative mode. This mode provides more artistic and stylized enhancements.
 * @summary Skin enhancer using AI (Creative)
 */
export type freepikSkinEnhancerCreativeResponse200 = {
  data: FreepikTaskResponse
  status: 200
}

export type freepikSkinEnhancerCreativeResponse400 = {
  data: FreepikErrorResponse
  status: 400
}

export type freepikSkinEnhancerCreativeResponse500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikSkinEnhancerCreativeResponseSuccess = (freepikSkinEnhancerCreativeResponse200) & {
  headers: Headers;
};
export type freepikSkinEnhancerCreativeResponseError = (freepikSkinEnhancerCreativeResponse400 | freepikSkinEnhancerCreativeResponse500) & {
  headers: Headers;
};

export type freepikSkinEnhancerCreativeResponse = (freepikSkinEnhancerCreativeResponseSuccess | freepikSkinEnhancerCreativeResponseError)

export const getFreepikSkinEnhancerCreativeUrl = () => {


  

  return `/proxy/freepik/v1/ai/skin-enhancer/creative`
}

export const freepikSkinEnhancerCreative = async (freepikSkinEnhancerCreativeRequest: FreepikSkinEnhancerCreativeRequest, options?: RequestInit): Promise<freepikSkinEnhancerCreativeResponse> => {
  
  return customInstance<freepikSkinEnhancerCreativeResponse>(getFreepikSkinEnhancerCreativeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      freepikSkinEnhancerCreativeRequest,)
  }
);}




export const getFreepikSkinEnhancerCreativeMutationOptions = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikSkinEnhancerCreative>>, TError,{data: FreepikSkinEnhancerCreativeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof freepikSkinEnhancerCreative>>, TError,{data: FreepikSkinEnhancerCreativeRequest}, TContext> => {

const mutationKey = ['freepikSkinEnhancerCreative'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof freepikSkinEnhancerCreative>>, {data: FreepikSkinEnhancerCreativeRequest}> = (props) => {
          const {data} = props ?? {};

          return  freepikSkinEnhancerCreative(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type FreepikSkinEnhancerCreativeMutationResult = NonNullable<Awaited<ReturnType<typeof freepikSkinEnhancerCreative>>>
    export type FreepikSkinEnhancerCreativeMutationBody = FreepikSkinEnhancerCreativeRequest
    export type FreepikSkinEnhancerCreativeMutationError = FreepikErrorResponse

    /**
 * @summary Skin enhancer using AI (Creative)
 */
export const useFreepikSkinEnhancerCreative = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikSkinEnhancerCreative>>, TError,{data: FreepikSkinEnhancerCreativeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof freepikSkinEnhancerCreative>>,
        TError,
        {data: FreepikSkinEnhancerCreativeRequest},
        TContext
      > => {
      return useMutation(getFreepikSkinEnhancerCreativeMutationOptions(options), queryClient);
    }
    
/**
 * Enhance skin in images using AI with the Faithful mode. This mode preserves the original appearance while improving skin quality.
 * @summary Skin enhancer using AI (Faithful)
 */
export type freepikSkinEnhancerFaithfulResponse200 = {
  data: FreepikTaskResponse
  status: 200
}

export type freepikSkinEnhancerFaithfulResponse400 = {
  data: FreepikErrorResponse
  status: 400
}

export type freepikSkinEnhancerFaithfulResponse500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikSkinEnhancerFaithfulResponseSuccess = (freepikSkinEnhancerFaithfulResponse200) & {
  headers: Headers;
};
export type freepikSkinEnhancerFaithfulResponseError = (freepikSkinEnhancerFaithfulResponse400 | freepikSkinEnhancerFaithfulResponse500) & {
  headers: Headers;
};

export type freepikSkinEnhancerFaithfulResponse = (freepikSkinEnhancerFaithfulResponseSuccess | freepikSkinEnhancerFaithfulResponseError)

export const getFreepikSkinEnhancerFaithfulUrl = () => {


  

  return `/proxy/freepik/v1/ai/skin-enhancer/faithful`
}

export const freepikSkinEnhancerFaithful = async (freepikSkinEnhancerFaithfulRequest: FreepikSkinEnhancerFaithfulRequest, options?: RequestInit): Promise<freepikSkinEnhancerFaithfulResponse> => {
  
  return customInstance<freepikSkinEnhancerFaithfulResponse>(getFreepikSkinEnhancerFaithfulUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      freepikSkinEnhancerFaithfulRequest,)
  }
);}




export const getFreepikSkinEnhancerFaithfulMutationOptions = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikSkinEnhancerFaithful>>, TError,{data: FreepikSkinEnhancerFaithfulRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof freepikSkinEnhancerFaithful>>, TError,{data: FreepikSkinEnhancerFaithfulRequest}, TContext> => {

const mutationKey = ['freepikSkinEnhancerFaithful'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof freepikSkinEnhancerFaithful>>, {data: FreepikSkinEnhancerFaithfulRequest}> = (props) => {
          const {data} = props ?? {};

          return  freepikSkinEnhancerFaithful(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type FreepikSkinEnhancerFaithfulMutationResult = NonNullable<Awaited<ReturnType<typeof freepikSkinEnhancerFaithful>>>
    export type FreepikSkinEnhancerFaithfulMutationBody = FreepikSkinEnhancerFaithfulRequest
    export type FreepikSkinEnhancerFaithfulMutationError = FreepikErrorResponse

    /**
 * @summary Skin enhancer using AI (Faithful)
 */
export const useFreepikSkinEnhancerFaithful = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikSkinEnhancerFaithful>>, TError,{data: FreepikSkinEnhancerFaithfulRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof freepikSkinEnhancerFaithful>>,
        TError,
        {data: FreepikSkinEnhancerFaithfulRequest},
        TContext
      > => {
      return useMutation(getFreepikSkinEnhancerFaithfulMutationOptions(options), queryClient);
    }
    
/**
 * Enhance skin in images using AI with the Flexible mode. This mode allows you to choose the optimization target for the enhancement.
 * @summary Skin enhancer using AI (Flexible)
 */
export type freepikSkinEnhancerFlexibleResponse200 = {
  data: FreepikTaskResponse
  status: 200
}

export type freepikSkinEnhancerFlexibleResponse400 = {
  data: FreepikErrorResponse
  status: 400
}

export type freepikSkinEnhancerFlexibleResponse500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikSkinEnhancerFlexibleResponseSuccess = (freepikSkinEnhancerFlexibleResponse200) & {
  headers: Headers;
};
export type freepikSkinEnhancerFlexibleResponseError = (freepikSkinEnhancerFlexibleResponse400 | freepikSkinEnhancerFlexibleResponse500) & {
  headers: Headers;
};

export type freepikSkinEnhancerFlexibleResponse = (freepikSkinEnhancerFlexibleResponseSuccess | freepikSkinEnhancerFlexibleResponseError)

export const getFreepikSkinEnhancerFlexibleUrl = () => {


  

  return `/proxy/freepik/v1/ai/skin-enhancer/flexible`
}

export const freepikSkinEnhancerFlexible = async (freepikSkinEnhancerFlexibleRequest: FreepikSkinEnhancerFlexibleRequest, options?: RequestInit): Promise<freepikSkinEnhancerFlexibleResponse> => {
  
  return customInstance<freepikSkinEnhancerFlexibleResponse>(getFreepikSkinEnhancerFlexibleUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      freepikSkinEnhancerFlexibleRequest,)
  }
);}




export const getFreepikSkinEnhancerFlexibleMutationOptions = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikSkinEnhancerFlexible>>, TError,{data: FreepikSkinEnhancerFlexibleRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof freepikSkinEnhancerFlexible>>, TError,{data: FreepikSkinEnhancerFlexibleRequest}, TContext> => {

const mutationKey = ['freepikSkinEnhancerFlexible'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof freepikSkinEnhancerFlexible>>, {data: FreepikSkinEnhancerFlexibleRequest}> = (props) => {
          const {data} = props ?? {};

          return  freepikSkinEnhancerFlexible(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type FreepikSkinEnhancerFlexibleMutationResult = NonNullable<Awaited<ReturnType<typeof freepikSkinEnhancerFlexible>>>
    export type FreepikSkinEnhancerFlexibleMutationBody = FreepikSkinEnhancerFlexibleRequest
    export type FreepikSkinEnhancerFlexibleMutationError = FreepikErrorResponse

    /**
 * @summary Skin enhancer using AI (Flexible)
 */
export const useFreepikSkinEnhancerFlexible = <TError = FreepikErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof freepikSkinEnhancerFlexible>>, TError,{data: FreepikSkinEnhancerFlexibleRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof freepikSkinEnhancerFlexible>>,
        TError,
        {data: FreepikSkinEnhancerFlexibleRequest},
        TContext
      > => {
      return useMutation(getFreepikSkinEnhancerFlexibleMutationOptions(options), queryClient);
    }
    
/**
 * Get the status of a skin enhancer task (works for both Creative and Faithful modes)
 * @summary Get the status of one skin enhancer task
 */
export type freepikSkinEnhancerGetStatusResponse200 = {
  data: FreepikTaskResponse
  status: 200
}

export type freepikSkinEnhancerGetStatusResponse404 = {
  data: void
  status: 404
}

export type freepikSkinEnhancerGetStatusResponse500 = {
  data: FreepikErrorResponse
  status: 500
}
    
export type freepikSkinEnhancerGetStatusResponseSuccess = (freepikSkinEnhancerGetStatusResponse200) & {
  headers: Headers;
};
export type freepikSkinEnhancerGetStatusResponseError = (freepikSkinEnhancerGetStatusResponse404 | freepikSkinEnhancerGetStatusResponse500) & {
  headers: Headers;
};

export type freepikSkinEnhancerGetStatusResponse = (freepikSkinEnhancerGetStatusResponseSuccess | freepikSkinEnhancerGetStatusResponseError)

export const getFreepikSkinEnhancerGetStatusUrl = (taskId: string,) => {


  

  return `/proxy/freepik/v1/ai/skin-enhancer/${taskId}`
}

export const freepikSkinEnhancerGetStatus = async (taskId: string, options?: RequestInit): Promise<freepikSkinEnhancerGetStatusResponse> => {
  
  return customInstance<freepikSkinEnhancerGetStatusResponse>(getFreepikSkinEnhancerGetStatusUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getFreepikSkinEnhancerGetStatusQueryKey = (taskId: string,) => {
    return [
    `/proxy/freepik/v1/ai/skin-enhancer/${taskId}`
    ] as const;
    }

    
export const getFreepikSkinEnhancerGetStatusQueryOptions = <TData = Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>, TError = void | FreepikErrorResponse>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFreepikSkinEnhancerGetStatusQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>> = ({ signal }) => freepikSkinEnhancerGetStatus(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FreepikSkinEnhancerGetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>>
export type FreepikSkinEnhancerGetStatusQueryError = void | FreepikErrorResponse


export function useFreepikSkinEnhancerGetStatus<TData = Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>,
          TError,
          Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFreepikSkinEnhancerGetStatus<TData = Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>,
          TError,
          Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFreepikSkinEnhancerGetStatus<TData = Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the status of one skin enhancer task
 */

export function useFreepikSkinEnhancerGetStatus<TData = Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>, TError = void | FreepikErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof freepikSkinEnhancerGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFreepikSkinEnhancerGetStatusQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Submit an image processing task using HitPaw Photo Enhancement API.
Supports multiple enhancement models for image super-resolution processing.

The returned job_id can be used with the task-status endpoint to check processing results.

**Available Models:**
- Enhancement & Denoise Models (face_2x/4x, face_v2_2x/4x, general_2x/4x, high_fidelity_2x/4x, sharpen_denoise, detail_denoise):
  - Max input: 67 MP, Max output: 600 MP
  - Supported formats: bmp, jpeg, jpg, png, jfif, tga, tiff, webp, heif
- Generative Models (generative_portrait, generative):
  - No input limit, Max output: 8K (33 MP)
  - Supported formats: bmp, jpeg, jpg, png, jfif, tga, tiff, webp, heif

 * @summary Submit HitPaw Photo Enhancement Task
 */
export type hitpawPhotoEnhancerResponse200 = {
  data: HitPawJobResponse
  status: 200
}

export type hitpawPhotoEnhancerResponse400 = {
  data: HitPawErrorResponse
  status: 400
}

export type hitpawPhotoEnhancerResponse401 = {
  data: void
  status: 401
}

export type hitpawPhotoEnhancerResponse402 = {
  data: ErrorResponse
  status: 402
}

export type hitpawPhotoEnhancerResponse500 = {
  data: HitPawErrorResponse
  status: 500
}
    
export type hitpawPhotoEnhancerResponseSuccess = (hitpawPhotoEnhancerResponse200) & {
  headers: Headers;
};
export type hitpawPhotoEnhancerResponseError = (hitpawPhotoEnhancerResponse400 | hitpawPhotoEnhancerResponse401 | hitpawPhotoEnhancerResponse402 | hitpawPhotoEnhancerResponse500) & {
  headers: Headers;
};

export type hitpawPhotoEnhancerResponse = (hitpawPhotoEnhancerResponseSuccess | hitpawPhotoEnhancerResponseError)

export const getHitpawPhotoEnhancerUrl = () => {


  

  return `/proxy/hitpaw/api/photo-enhancer`
}

export const hitpawPhotoEnhancer = async (hitPawPhotoEnhancerRequest: HitPawPhotoEnhancerRequest, options?: RequestInit): Promise<hitpawPhotoEnhancerResponse> => {
  
  return customInstance<hitpawPhotoEnhancerResponse>(getHitpawPhotoEnhancerUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      hitPawPhotoEnhancerRequest,)
  }
);}




export const getHitpawPhotoEnhancerMutationOptions = <TError = HitPawErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hitpawPhotoEnhancer>>, TError,{data: HitPawPhotoEnhancerRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof hitpawPhotoEnhancer>>, TError,{data: HitPawPhotoEnhancerRequest}, TContext> => {

const mutationKey = ['hitpawPhotoEnhancer'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof hitpawPhotoEnhancer>>, {data: HitPawPhotoEnhancerRequest}> = (props) => {
          const {data} = props ?? {};

          return  hitpawPhotoEnhancer(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type HitpawPhotoEnhancerMutationResult = NonNullable<Awaited<ReturnType<typeof hitpawPhotoEnhancer>>>
    export type HitpawPhotoEnhancerMutationBody = HitPawPhotoEnhancerRequest
    export type HitpawPhotoEnhancerMutationError = HitPawErrorResponse | void | ErrorResponse

    /**
 * @summary Submit HitPaw Photo Enhancement Task
 */
export const useHitpawPhotoEnhancer = <TError = HitPawErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hitpawPhotoEnhancer>>, TError,{data: HitPawPhotoEnhancerRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof hitpawPhotoEnhancer>>,
        TError,
        {data: HitPawPhotoEnhancerRequest},
        TContext
      > => {
      return useMutation(getHitpawPhotoEnhancerMutationOptions(options), queryClient);
    }
    
/**
 * Query the status and result of a previously submitted photo or video enhancement task.
Poll this endpoint until the task status indicates completion (COMPLETED).

**Status Codes:**
- CONVERTING: Job is currently being processed
- COMPLETED: Job has completed successfully, result is available
- ERROR: Job failed due to an error

 * @summary Query HitPaw Task Status
 */
export type hitpawTaskStatusResponse200 = {
  data: HitPawTaskStatusResponse
  status: 200
}

export type hitpawTaskStatusResponse400 = {
  data: HitPawErrorResponse
  status: 400
}

export type hitpawTaskStatusResponse401 = {
  data: void
  status: 401
}

export type hitpawTaskStatusResponse500 = {
  data: HitPawErrorResponse
  status: 500
}
    
export type hitpawTaskStatusResponseSuccess = (hitpawTaskStatusResponse200) & {
  headers: Headers;
};
export type hitpawTaskStatusResponseError = (hitpawTaskStatusResponse400 | hitpawTaskStatusResponse401 | hitpawTaskStatusResponse500) & {
  headers: Headers;
};

export type hitpawTaskStatusResponse = (hitpawTaskStatusResponseSuccess | hitpawTaskStatusResponseError)

export const getHitpawTaskStatusUrl = () => {


  

  return `/proxy/hitpaw/api/task-status`
}

export const hitpawTaskStatus = async (hitPawTaskStatusRequest: HitPawTaskStatusRequest, options?: RequestInit): Promise<hitpawTaskStatusResponse> => {
  
  return customInstance<hitpawTaskStatusResponse>(getHitpawTaskStatusUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      hitPawTaskStatusRequest,)
  }
);}




export const getHitpawTaskStatusMutationOptions = <TError = HitPawErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hitpawTaskStatus>>, TError,{data: HitPawTaskStatusRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof hitpawTaskStatus>>, TError,{data: HitPawTaskStatusRequest}, TContext> => {

const mutationKey = ['hitpawTaskStatus'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof hitpawTaskStatus>>, {data: HitPawTaskStatusRequest}> = (props) => {
          const {data} = props ?? {};

          return  hitpawTaskStatus(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type HitpawTaskStatusMutationResult = NonNullable<Awaited<ReturnType<typeof hitpawTaskStatus>>>
    export type HitpawTaskStatusMutationBody = HitPawTaskStatusRequest
    export type HitpawTaskStatusMutationError = HitPawErrorResponse | void

    /**
 * @summary Query HitPaw Task Status
 */
export const useHitpawTaskStatus = <TError = HitPawErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hitpawTaskStatus>>, TError,{data: HitPawTaskStatusRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof hitpawTaskStatus>>,
        TError,
        {data: HitPawTaskStatusRequest},
        TContext
      > => {
      return useMutation(getHitpawTaskStatusMutationOptions(options), queryClient);
    }
    
/**
 * Submit a video processing task using HitPaw Video Enhancement API.
Uses AI technology to upscale low-resolution videos to high resolution,
eliminate artifacts and noise, and improve clarity and details.

The returned job_id can be used with the task-status endpoint to check processing results.

**Video Constraints:**
- Duration: 0.5 seconds to 1 hour
- Maximum output resolution: 36 MP (Total Pixels)
- Supported input formats: dv, mlv, m2ts, m2t, m2v, nut, ser, 3g2, 3gp, asf, divx, f4v, h261, h263, m4v, mkv, mov, mp4, mpeg, mpeg4, mpg, mxf, ogv, rm, rmvb, webm, wmv, dmsm, dvdmedia, dvr-ms, mts, trp, ts, vob, vro, gif, xvid
- Supported output formats: mp4, mov, mkv, m4v, avi, gif

 * @summary Submit HitPaw Video Enhancement Task
 */
export type hitpawVideoEnhancerResponse200 = {
  data: HitPawJobResponse
  status: 200
}

export type hitpawVideoEnhancerResponse400 = {
  data: HitPawErrorResponse
  status: 400
}

export type hitpawVideoEnhancerResponse401 = {
  data: void
  status: 401
}

export type hitpawVideoEnhancerResponse402 = {
  data: HitPawErrorResponse
  status: 402
}

export type hitpawVideoEnhancerResponse500 = {
  data: HitPawErrorResponse
  status: 500
}
    
export type hitpawVideoEnhancerResponseSuccess = (hitpawVideoEnhancerResponse200) & {
  headers: Headers;
};
export type hitpawVideoEnhancerResponseError = (hitpawVideoEnhancerResponse400 | hitpawVideoEnhancerResponse401 | hitpawVideoEnhancerResponse402 | hitpawVideoEnhancerResponse500) & {
  headers: Headers;
};

export type hitpawVideoEnhancerResponse = (hitpawVideoEnhancerResponseSuccess | hitpawVideoEnhancerResponseError)

export const getHitpawVideoEnhancerUrl = () => {


  

  return `/proxy/hitpaw/api/video-enhancer`
}

export const hitpawVideoEnhancer = async (hitPawVideoEnhancerRequest: HitPawVideoEnhancerRequest, options?: RequestInit): Promise<hitpawVideoEnhancerResponse> => {
  
  return customInstance<hitpawVideoEnhancerResponse>(getHitpawVideoEnhancerUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      hitPawVideoEnhancerRequest,)
  }
);}




export const getHitpawVideoEnhancerMutationOptions = <TError = HitPawErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hitpawVideoEnhancer>>, TError,{data: HitPawVideoEnhancerRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof hitpawVideoEnhancer>>, TError,{data: HitPawVideoEnhancerRequest}, TContext> => {

const mutationKey = ['hitpawVideoEnhancer'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof hitpawVideoEnhancer>>, {data: HitPawVideoEnhancerRequest}> = (props) => {
          const {data} = props ?? {};

          return  hitpawVideoEnhancer(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type HitpawVideoEnhancerMutationResult = NonNullable<Awaited<ReturnType<typeof hitpawVideoEnhancer>>>
    export type HitpawVideoEnhancerMutationBody = HitPawVideoEnhancerRequest
    export type HitpawVideoEnhancerMutationError = HitPawErrorResponse | void

    /**
 * @summary Submit HitPaw Video Enhancement Task
 */
export const useHitpawVideoEnhancer = <TError = HitPawErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof hitpawVideoEnhancer>>, TError,{data: HitPawVideoEnhancerRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof hitpawVideoEnhancer>>,
        TError,
        {data: HitPawVideoEnhancerRequest},
        TContext
      > => {
      return useMutation(getHitpawVideoEnhancerMutationOptions(options), queryClient);
    }
    
/**
 * Forwards image generation requests to Ideogram's API and returns the results.
 * @summary Proxy request to Ideogram for image generation
 */
export type ideogramGenerateResponse200 = {
  data: IdeogramGenerateResponse
  status: 200
}

export type ideogramGenerateResponse400 = {
  data: ErrorResponse
  status: 400
}

export type ideogramGenerateResponse401 = {
  data: void
  status: 401
}

export type ideogramGenerateResponse402 = {
  data: void
  status: 402
}

export type ideogramGenerateResponse429 = {
  data: ErrorResponse
  status: 429
}

export type ideogramGenerateResponse500 = {
  data: ErrorResponse
  status: 500
}

export type ideogramGenerateResponse502 = {
  data: ErrorResponse
  status: 502
}

export type ideogramGenerateResponse504 = {
  data: ErrorResponse
  status: 504
}
    
export type ideogramGenerateResponseSuccess = (ideogramGenerateResponse200) & {
  headers: Headers;
};
export type ideogramGenerateResponseError = (ideogramGenerateResponse400 | ideogramGenerateResponse401 | ideogramGenerateResponse402 | ideogramGenerateResponse429 | ideogramGenerateResponse500 | ideogramGenerateResponse502 | ideogramGenerateResponse504) & {
  headers: Headers;
};

export type ideogramGenerateResponse = (ideogramGenerateResponseSuccess | ideogramGenerateResponseError)

export const getIdeogramGenerateUrl = () => {


  

  return `/proxy/ideogram/generate`
}

export const ideogramGenerate = async (ideogramGenerateRequest: IdeogramGenerateRequest, options?: RequestInit): Promise<ideogramGenerateResponse> => {
  
  return customInstance<ideogramGenerateResponse>(getIdeogramGenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ideogramGenerateRequest,)
  }
);}




export const getIdeogramGenerateMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramGenerate>>, TError,{data: IdeogramGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ideogramGenerate>>, TError,{data: IdeogramGenerateRequest}, TContext> => {

const mutationKey = ['ideogramGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ideogramGenerate>>, {data: IdeogramGenerateRequest}> = (props) => {
          const {data} = props ?? {};

          return  ideogramGenerate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type IdeogramGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof ideogramGenerate>>>
    export type IdeogramGenerateMutationBody = IdeogramGenerateRequest
    export type IdeogramGenerateMutationError = ErrorResponse | void

    /**
 * @summary Proxy request to Ideogram for image generation
 */
export const useIdeogramGenerate = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramGenerate>>, TError,{data: IdeogramGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ideogramGenerate>>,
        TError,
        {data: IdeogramGenerateRequest},
        TContext
      > => {
      return useMutation(getIdeogramGenerateMutationOptions(options), queryClient);
    }
    
/**
 * Forwards image editing requests to Ideogram's API and returns the results.
 * @summary Proxy request to Ideogram for image editing
 */
export type ideogramV3EditResponse200 = {
  data: IdeogramGenerateResponse
  status: 200
}

export type ideogramV3EditResponse400 = {
  data: ErrorResponse
  status: 400
}

export type ideogramV3EditResponse401 = {
  data: void
  status: 401
}

export type ideogramV3EditResponse422 = {
  data: ErrorResponse
  status: 422
}

export type ideogramV3EditResponse429 = {
  data: void
  status: 429
}

export type ideogramV3EditResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type ideogramV3EditResponseSuccess = (ideogramV3EditResponse200) & {
  headers: Headers;
};
export type ideogramV3EditResponseError = (ideogramV3EditResponse400 | ideogramV3EditResponse401 | ideogramV3EditResponse422 | ideogramV3EditResponse429 | ideogramV3EditResponse500) & {
  headers: Headers;
};

export type ideogramV3EditResponse = (ideogramV3EditResponseSuccess | ideogramV3EditResponseError)

export const getIdeogramV3EditUrl = () => {


  

  return `/proxy/ideogram/ideogram-v3/edit`
}

export const ideogramV3Edit = async (ideogramV3EditRequest: IdeogramV3EditRequest, options?: RequestInit): Promise<ideogramV3EditResponse> => {
    const formData = new FormData();
if(ideogramV3EditRequest.character_reference_images !== undefined) {
 ideogramV3EditRequest.character_reference_images.forEach(value => formData.append(`character_reference_images`, value));
 }
if(ideogramV3EditRequest.character_reference_images_mask !== undefined) {
 ideogramV3EditRequest.character_reference_images_mask.forEach(value => formData.append(`character_reference_images_mask`, value));
 }
if(ideogramV3EditRequest.color_palette !== undefined) {
 formData.append(`color_palette`, JSON.stringify(ideogramV3EditRequest.color_palette));
 }
if(ideogramV3EditRequest.image !== undefined) {
 formData.append(`image`, ideogramV3EditRequest.image);
 }
if(ideogramV3EditRequest.magic_prompt !== undefined) {
 formData.append(`magic_prompt`, ideogramV3EditRequest.magic_prompt);
 }
if(ideogramV3EditRequest.mask !== undefined) {
 formData.append(`mask`, ideogramV3EditRequest.mask);
 }
if(ideogramV3EditRequest.num_images !== undefined) {
 formData.append(`num_images`, ideogramV3EditRequest.num_images.toString())
 }
formData.append(`prompt`, ideogramV3EditRequest.prompt);
formData.append(`rendering_speed`, ideogramV3EditRequest.rendering_speed);
if(ideogramV3EditRequest.seed !== undefined) {
 formData.append(`seed`, ideogramV3EditRequest.seed.toString())
 }
if(ideogramV3EditRequest.style_codes !== undefined) {
 ideogramV3EditRequest.style_codes.forEach(value => formData.append(`style_codes`, value));
 }
if(ideogramV3EditRequest.style_reference_images !== undefined) {
 ideogramV3EditRequest.style_reference_images.forEach(value => formData.append(`style_reference_images`, value));
 }
if(ideogramV3EditRequest.style_type !== undefined) {
 formData.append(`style_type`, ideogramV3EditRequest.style_type);
 }

  return customInstance<ideogramV3EditResponse>(getIdeogramV3EditUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getIdeogramV3EditMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Edit>>, TError,{data: IdeogramV3EditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Edit>>, TError,{data: IdeogramV3EditRequest}, TContext> => {

const mutationKey = ['ideogramV3Edit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ideogramV3Edit>>, {data: IdeogramV3EditRequest}> = (props) => {
          const {data} = props ?? {};

          return  ideogramV3Edit(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type IdeogramV3EditMutationResult = NonNullable<Awaited<ReturnType<typeof ideogramV3Edit>>>
    export type IdeogramV3EditMutationBody = IdeogramV3EditRequest
    export type IdeogramV3EditMutationError = ErrorResponse | void

    /**
 * @summary Proxy request to Ideogram for image editing
 */
export const useIdeogramV3Edit = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Edit>>, TError,{data: IdeogramV3EditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ideogramV3Edit>>,
        TError,
        {data: IdeogramV3EditRequest},
        TContext
      > => {
      return useMutation(getIdeogramV3EditMutationOptions(options), queryClient);
    }
    
/**
 * Forwards image generation requests to Ideogram's API and returns the results.
 * @summary Proxy request to Ideogram for image generation
 */
export type ideogramV3GenerateResponse200 = {
  data: IdeogramGenerateResponse
  status: 200
}

export type ideogramV3GenerateResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type ideogramV3GenerateResponseSuccess = (ideogramV3GenerateResponse200) & {
  headers: Headers;
};
export type ideogramV3GenerateResponseError = (ideogramV3GenerateResponse500) & {
  headers: Headers;
};

export type ideogramV3GenerateResponse = (ideogramV3GenerateResponseSuccess | ideogramV3GenerateResponseError)

export const getIdeogramV3GenerateUrl = () => {


  

  return `/proxy/ideogram/ideogram-v3/generate`
}

export const ideogramV3Generate = async (ideogramV3Request: IdeogramV3Request, options?: RequestInit): Promise<ideogramV3GenerateResponse> => {
  
  return customInstance<ideogramV3GenerateResponse>(getIdeogramV3GenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      ideogramV3Request,)
  }
);}




export const getIdeogramV3GenerateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Generate>>, TError,{data: IdeogramV3Request}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Generate>>, TError,{data: IdeogramV3Request}, TContext> => {

const mutationKey = ['ideogramV3Generate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ideogramV3Generate>>, {data: IdeogramV3Request}> = (props) => {
          const {data} = props ?? {};

          return  ideogramV3Generate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type IdeogramV3GenerateMutationResult = NonNullable<Awaited<ReturnType<typeof ideogramV3Generate>>>
    export type IdeogramV3GenerateMutationBody = IdeogramV3Request
    export type IdeogramV3GenerateMutationError = ErrorResponse

    /**
 * @summary Proxy request to Ideogram for image generation
 */
export const useIdeogramV3Generate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Generate>>, TError,{data: IdeogramV3Request}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ideogramV3Generate>>,
        TError,
        {data: IdeogramV3Request},
        TContext
      > => {
      return useMutation(getIdeogramV3GenerateMutationOptions(options), queryClient);
    }
    
/**
 * @summary Reframe an image to a chosen resolution
 */
export type ideogramV3ReframeResponse200 = {
  data: IdeogramV3IdeogramResponse
  status: 200
}

export type ideogramV3ReframeResponse400 = {
  data: void
  status: 400
}

export type ideogramV3ReframeResponse401 = {
  data: void
  status: 401
}

export type ideogramV3ReframeResponse422 = {
  data: void
  status: 422
}

export type ideogramV3ReframeResponse429 = {
  data: void
  status: 429
}
    
export type ideogramV3ReframeResponseSuccess = (ideogramV3ReframeResponse200) & {
  headers: Headers;
};
export type ideogramV3ReframeResponseError = (ideogramV3ReframeResponse400 | ideogramV3ReframeResponse401 | ideogramV3ReframeResponse422 | ideogramV3ReframeResponse429) & {
  headers: Headers;
};

export type ideogramV3ReframeResponse = (ideogramV3ReframeResponseSuccess | ideogramV3ReframeResponseError)

export const getIdeogramV3ReframeUrl = () => {


  

  return `/proxy/ideogram/ideogram-v3/reframe`
}

export const ideogramV3Reframe = async (ideogramV3ReframeRequest: IdeogramV3ReframeRequest, options?: RequestInit): Promise<ideogramV3ReframeResponse> => {
    const formData = new FormData();
if(ideogramV3ReframeRequest.color_palette !== undefined) {
 formData.append(`color_palette`, JSON.stringify(ideogramV3ReframeRequest.color_palette));
 }
if(ideogramV3ReframeRequest.image !== undefined) {
 formData.append(`image`, ideogramV3ReframeRequest.image);
 }
if(ideogramV3ReframeRequest.num_images !== undefined) {
 formData.append(`num_images`, ideogramV3ReframeRequest.num_images.toString())
 }
if(ideogramV3ReframeRequest.rendering_speed !== undefined) {
 formData.append(`rendering_speed`, ideogramV3ReframeRequest.rendering_speed);
 }
formData.append(`resolution`, ideogramV3ReframeRequest.resolution);
if(ideogramV3ReframeRequest.seed !== undefined) {
 formData.append(`seed`, ideogramV3ReframeRequest.seed.toString())
 }
if(ideogramV3ReframeRequest.style_codes !== undefined) {
 ideogramV3ReframeRequest.style_codes.forEach(value => formData.append(`style_codes`, value));
 }
if(ideogramV3ReframeRequest.style_reference_images !== undefined) {
 ideogramV3ReframeRequest.style_reference_images.forEach(value => formData.append(`style_reference_images`, value));
 }

  return customInstance<ideogramV3ReframeResponse>(getIdeogramV3ReframeUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getIdeogramV3ReframeMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Reframe>>, TError,{data: IdeogramV3ReframeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Reframe>>, TError,{data: IdeogramV3ReframeRequest}, TContext> => {

const mutationKey = ['ideogramV3Reframe'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ideogramV3Reframe>>, {data: IdeogramV3ReframeRequest}> = (props) => {
          const {data} = props ?? {};

          return  ideogramV3Reframe(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type IdeogramV3ReframeMutationResult = NonNullable<Awaited<ReturnType<typeof ideogramV3Reframe>>>
    export type IdeogramV3ReframeMutationBody = IdeogramV3ReframeRequest
    export type IdeogramV3ReframeMutationError = void

    /**
 * @summary Reframe an image to a chosen resolution
 */
export const useIdeogramV3Reframe = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Reframe>>, TError,{data: IdeogramV3ReframeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ideogramV3Reframe>>,
        TError,
        {data: IdeogramV3ReframeRequest},
        TContext
      > => {
      return useMutation(getIdeogramV3ReframeMutationOptions(options), queryClient);
    }
    
/**
 * @summary Remix an image using a prompt
 */
export type ideogramV3RemixResponse200 = {
  data: IdeogramV3IdeogramResponse
  status: 200
}

export type ideogramV3RemixResponse400 = {
  data: void
  status: 400
}

export type ideogramV3RemixResponse403 = {
  data: void
  status: 403
}

export type ideogramV3RemixResponse422 = {
  data: void
  status: 422
}

export type ideogramV3RemixResponse429 = {
  data: void
  status: 429
}
    
export type ideogramV3RemixResponseSuccess = (ideogramV3RemixResponse200) & {
  headers: Headers;
};
export type ideogramV3RemixResponseError = (ideogramV3RemixResponse400 | ideogramV3RemixResponse403 | ideogramV3RemixResponse422 | ideogramV3RemixResponse429) & {
  headers: Headers;
};

export type ideogramV3RemixResponse = (ideogramV3RemixResponseSuccess | ideogramV3RemixResponseError)

export const getIdeogramV3RemixUrl = () => {


  

  return `/proxy/ideogram/ideogram-v3/remix`
}

export const ideogramV3Remix = async (ideogramV3RemixRequest: IdeogramV3RemixRequest, options?: RequestInit): Promise<ideogramV3RemixResponse> => {
    const formData = new FormData();
if(ideogramV3RemixRequest.aspect_ratio !== undefined) {
 formData.append(`aspect_ratio`, ideogramV3RemixRequest.aspect_ratio);
 }
if(ideogramV3RemixRequest.character_reference_images !== undefined) {
 ideogramV3RemixRequest.character_reference_images.forEach(value => formData.append(`character_reference_images`, value));
 }
if(ideogramV3RemixRequest.character_reference_images_mask !== undefined) {
 ideogramV3RemixRequest.character_reference_images_mask.forEach(value => formData.append(`character_reference_images_mask`, value));
 }
if(ideogramV3RemixRequest.color_palette !== undefined) {
 formData.append(`color_palette`, JSON.stringify(ideogramV3RemixRequest.color_palette));
 }
if(ideogramV3RemixRequest.image !== undefined) {
 formData.append(`image`, ideogramV3RemixRequest.image);
 }
if(ideogramV3RemixRequest.image_weight !== undefined) {
 formData.append(`image_weight`, ideogramV3RemixRequest.image_weight.toString())
 }
if(ideogramV3RemixRequest.magic_prompt !== undefined) {
 formData.append(`magic_prompt`, ideogramV3RemixRequest.magic_prompt);
 }
if(ideogramV3RemixRequest.negative_prompt !== undefined) {
 formData.append(`negative_prompt`, ideogramV3RemixRequest.negative_prompt);
 }
if(ideogramV3RemixRequest.num_images !== undefined) {
 formData.append(`num_images`, ideogramV3RemixRequest.num_images.toString())
 }
formData.append(`prompt`, ideogramV3RemixRequest.prompt);
if(ideogramV3RemixRequest.rendering_speed !== undefined) {
 formData.append(`rendering_speed`, ideogramV3RemixRequest.rendering_speed);
 }
if(ideogramV3RemixRequest.resolution !== undefined) {
 formData.append(`resolution`, ideogramV3RemixRequest.resolution);
 }
if(ideogramV3RemixRequest.seed !== undefined) {
 formData.append(`seed`, ideogramV3RemixRequest.seed.toString())
 }
if(ideogramV3RemixRequest.style_codes !== undefined) {
 ideogramV3RemixRequest.style_codes.forEach(value => formData.append(`style_codes`, value));
 }
if(ideogramV3RemixRequest.style_reference_images !== undefined) {
 ideogramV3RemixRequest.style_reference_images.forEach(value => formData.append(`style_reference_images`, value));
 }
if(ideogramV3RemixRequest.style_type !== undefined) {
 formData.append(`style_type`, ideogramV3RemixRequest.style_type);
 }

  return customInstance<ideogramV3RemixResponse>(getIdeogramV3RemixUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getIdeogramV3RemixMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Remix>>, TError,{data: IdeogramV3RemixRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Remix>>, TError,{data: IdeogramV3RemixRequest}, TContext> => {

const mutationKey = ['ideogramV3Remix'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ideogramV3Remix>>, {data: IdeogramV3RemixRequest}> = (props) => {
          const {data} = props ?? {};

          return  ideogramV3Remix(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type IdeogramV3RemixMutationResult = NonNullable<Awaited<ReturnType<typeof ideogramV3Remix>>>
    export type IdeogramV3RemixMutationBody = IdeogramV3RemixRequest
    export type IdeogramV3RemixMutationError = void

    /**
 * @summary Remix an image using a prompt
 */
export const useIdeogramV3Remix = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramV3Remix>>, TError,{data: IdeogramV3RemixRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ideogramV3Remix>>,
        TError,
        {data: IdeogramV3RemixRequest},
        TContext
      > => {
      return useMutation(getIdeogramV3RemixMutationOptions(options), queryClient);
    }
    
/**
 * @summary Replace background of an image using a prompt
 */
export type ideogramV3ReplaceBackgroundResponse200 = {
  data: IdeogramV3IdeogramResponse
  status: 200
}

export type ideogramV3ReplaceBackgroundResponse400 = {
  data: void
  status: 400
}

export type ideogramV3ReplaceBackgroundResponse401 = {
  data: void
  status: 401
}

export type ideogramV3ReplaceBackgroundResponse422 = {
  data: void
  status: 422
}

export type ideogramV3ReplaceBackgroundResponse429 = {
  data: void
  status: 429
}
    
export type ideogramV3ReplaceBackgroundResponseSuccess = (ideogramV3ReplaceBackgroundResponse200) & {
  headers: Headers;
};
export type ideogramV3ReplaceBackgroundResponseError = (ideogramV3ReplaceBackgroundResponse400 | ideogramV3ReplaceBackgroundResponse401 | ideogramV3ReplaceBackgroundResponse422 | ideogramV3ReplaceBackgroundResponse429) & {
  headers: Headers;
};

export type ideogramV3ReplaceBackgroundResponse = (ideogramV3ReplaceBackgroundResponseSuccess | ideogramV3ReplaceBackgroundResponseError)

export const getIdeogramV3ReplaceBackgroundUrl = () => {


  

  return `/proxy/ideogram/ideogram-v3/replace-background`
}

export const ideogramV3ReplaceBackground = async (ideogramV3ReplaceBackgroundRequest: IdeogramV3ReplaceBackgroundRequest, options?: RequestInit): Promise<ideogramV3ReplaceBackgroundResponse> => {
    const formData = new FormData();
if(ideogramV3ReplaceBackgroundRequest.color_palette !== undefined) {
 formData.append(`color_palette`, JSON.stringify(ideogramV3ReplaceBackgroundRequest.color_palette));
 }
if(ideogramV3ReplaceBackgroundRequest.image !== undefined) {
 formData.append(`image`, ideogramV3ReplaceBackgroundRequest.image);
 }
if(ideogramV3ReplaceBackgroundRequest.magic_prompt !== undefined) {
 formData.append(`magic_prompt`, ideogramV3ReplaceBackgroundRequest.magic_prompt);
 }
if(ideogramV3ReplaceBackgroundRequest.num_images !== undefined) {
 formData.append(`num_images`, ideogramV3ReplaceBackgroundRequest.num_images.toString())
 }
formData.append(`prompt`, ideogramV3ReplaceBackgroundRequest.prompt);
if(ideogramV3ReplaceBackgroundRequest.rendering_speed !== undefined) {
 formData.append(`rendering_speed`, ideogramV3ReplaceBackgroundRequest.rendering_speed);
 }
if(ideogramV3ReplaceBackgroundRequest.seed !== undefined) {
 formData.append(`seed`, ideogramV3ReplaceBackgroundRequest.seed.toString())
 }
if(ideogramV3ReplaceBackgroundRequest.style_codes !== undefined) {
 ideogramV3ReplaceBackgroundRequest.style_codes.forEach(value => formData.append(`style_codes`, value));
 }
if(ideogramV3ReplaceBackgroundRequest.style_reference_images !== undefined) {
 ideogramV3ReplaceBackgroundRequest.style_reference_images.forEach(value => formData.append(`style_reference_images`, value));
 }

  return customInstance<ideogramV3ReplaceBackgroundResponse>(getIdeogramV3ReplaceBackgroundUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getIdeogramV3ReplaceBackgroundMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>, TError,{data: IdeogramV3ReplaceBackgroundRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>, TError,{data: IdeogramV3ReplaceBackgroundRequest}, TContext> => {

const mutationKey = ['ideogramV3ReplaceBackground'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>, {data: IdeogramV3ReplaceBackgroundRequest}> = (props) => {
          const {data} = props ?? {};

          return  ideogramV3ReplaceBackground(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type IdeogramV3ReplaceBackgroundMutationResult = NonNullable<Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>>
    export type IdeogramV3ReplaceBackgroundMutationBody = IdeogramV3ReplaceBackgroundRequest
    export type IdeogramV3ReplaceBackgroundMutationError = void

    /**
 * @summary Replace background of an image using a prompt
 */
export const useIdeogramV3ReplaceBackground = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>, TError,{data: IdeogramV3ReplaceBackgroundRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>,
        TError,
        {data: IdeogramV3ReplaceBackgroundRequest},
        TContext
      > => {
      return useMutation(getIdeogramV3ReplaceBackgroundMutationOptions(options), queryClient);
    }
    
/**
 * @summary KlingAI Query Resource Package Information
 */
export type klingQueryResourcePackagesResponse200 = {
  data: KlingResourcePackageResponse
  status: 200
}

export type klingQueryResourcePackagesResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingQueryResourcePackagesResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingQueryResourcePackagesResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingQueryResourcePackagesResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingQueryResourcePackagesResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingQueryResourcePackagesResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingQueryResourcePackagesResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingQueryResourcePackagesResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingQueryResourcePackagesResponseSuccess = (klingQueryResourcePackagesResponse200) & {
  headers: Headers;
};
export type klingQueryResourcePackagesResponseError = (klingQueryResourcePackagesResponse400 | klingQueryResourcePackagesResponse401 | klingQueryResourcePackagesResponse403 | klingQueryResourcePackagesResponse404 | klingQueryResourcePackagesResponse429 | klingQueryResourcePackagesResponse500 | klingQueryResourcePackagesResponse503 | klingQueryResourcePackagesResponse504) & {
  headers: Headers;
};

export type klingQueryResourcePackagesResponse = (klingQueryResourcePackagesResponseSuccess | klingQueryResourcePackagesResponseError)

export const getKlingQueryResourcePackagesUrl = (params: KlingQueryResourcePackagesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/kling/v1/account/costs?${stringifiedParams}` : `/proxy/kling/v1/account/costs`
}

export const klingQueryResourcePackages = async (params: KlingQueryResourcePackagesParams, options?: RequestInit): Promise<klingQueryResourcePackagesResponse> => {
  
  return customInstance<klingQueryResourcePackagesResponse>(getKlingQueryResourcePackagesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingQueryResourcePackagesQueryKey = (params?: KlingQueryResourcePackagesParams,) => {
    return [
    `/proxy/kling/v1/account/costs`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getKlingQueryResourcePackagesQueryOptions = <TData = Awaited<ReturnType<typeof klingQueryResourcePackages>>, TError = KlingErrorResponse>(params: KlingQueryResourcePackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingQueryResourcePackages>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingQueryResourcePackagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingQueryResourcePackages>>> = ({ signal }) => klingQueryResourcePackages(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingQueryResourcePackages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingQueryResourcePackagesQueryResult = NonNullable<Awaited<ReturnType<typeof klingQueryResourcePackages>>>
export type KlingQueryResourcePackagesQueryError = KlingErrorResponse


export function useKlingQueryResourcePackages<TData = Awaited<ReturnType<typeof klingQueryResourcePackages>>, TError = KlingErrorResponse>(
 params: KlingQueryResourcePackagesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingQueryResourcePackages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingQueryResourcePackages>>,
          TError,
          Awaited<ReturnType<typeof klingQueryResourcePackages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingQueryResourcePackages<TData = Awaited<ReturnType<typeof klingQueryResourcePackages>>, TError = KlingErrorResponse>(
 params: KlingQueryResourcePackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingQueryResourcePackages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingQueryResourcePackages>>,
          TError,
          Awaited<ReturnType<typeof klingQueryResourcePackages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingQueryResourcePackages<TData = Awaited<ReturnType<typeof klingQueryResourcePackages>>, TError = KlingErrorResponse>(
 params: KlingQueryResourcePackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingQueryResourcePackages>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Resource Package Information
 */

export function useKlingQueryResourcePackages<TData = Awaited<ReturnType<typeof klingQueryResourcePackages>>, TError = KlingErrorResponse>(
 params: KlingQueryResourcePackagesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingQueryResourcePackages>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingQueryResourcePackagesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Query Image Generation Task List
 */
export type klingImageGenerationsQueryTaskListResponse200 = {
  data: KlingImageGenerationsResponse
  status: 200
}

export type klingImageGenerationsQueryTaskListResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingImageGenerationsQueryTaskListResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingImageGenerationsQueryTaskListResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingImageGenerationsQueryTaskListResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingImageGenerationsQueryTaskListResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingImageGenerationsQueryTaskListResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingImageGenerationsQueryTaskListResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingImageGenerationsQueryTaskListResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingImageGenerationsQueryTaskListResponseSuccess = (klingImageGenerationsQueryTaskListResponse200) & {
  headers: Headers;
};
export type klingImageGenerationsQueryTaskListResponseError = (klingImageGenerationsQueryTaskListResponse400 | klingImageGenerationsQueryTaskListResponse401 | klingImageGenerationsQueryTaskListResponse403 | klingImageGenerationsQueryTaskListResponse404 | klingImageGenerationsQueryTaskListResponse429 | klingImageGenerationsQueryTaskListResponse500 | klingImageGenerationsQueryTaskListResponse503 | klingImageGenerationsQueryTaskListResponse504) & {
  headers: Headers;
};

export type klingImageGenerationsQueryTaskListResponse = (klingImageGenerationsQueryTaskListResponseSuccess | klingImageGenerationsQueryTaskListResponseError)

export const getKlingImageGenerationsQueryTaskListUrl = (params?: KlingImageGenerationsQueryTaskListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/kling/v1/images/generations?${stringifiedParams}` : `/proxy/kling/v1/images/generations`
}

export const klingImageGenerationsQueryTaskList = async (params?: KlingImageGenerationsQueryTaskListParams, options?: RequestInit): Promise<klingImageGenerationsQueryTaskListResponse> => {
  
  return customInstance<klingImageGenerationsQueryTaskListResponse>(getKlingImageGenerationsQueryTaskListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingImageGenerationsQueryTaskListQueryKey = (params?: KlingImageGenerationsQueryTaskListParams,) => {
    return [
    `/proxy/kling/v1/images/generations`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getKlingImageGenerationsQueryTaskListQueryOptions = <TData = Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>, TError = KlingErrorResponse>(params?: KlingImageGenerationsQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingImageGenerationsQueryTaskListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>> = ({ signal }) => klingImageGenerationsQueryTaskList(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingImageGenerationsQueryTaskListQueryResult = NonNullable<Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>>
export type KlingImageGenerationsQueryTaskListQueryError = KlingErrorResponse


export function useKlingImageGenerationsQueryTaskList<TData = Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>, TError = KlingErrorResponse>(
 params: undefined |  KlingImageGenerationsQueryTaskListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingImageGenerationsQueryTaskList<TData = Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingImageGenerationsQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingImageGenerationsQueryTaskList<TData = Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingImageGenerationsQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Image Generation Task List
 */

export function useKlingImageGenerationsQueryTaskList<TData = Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingImageGenerationsQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingImageGenerationsQueryTaskListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Create Image Generation Task
 */
export type klingCreateImageGenerationResponse200 = {
  data: KlingImageGenerationsResponse
  status: 200
}

export type klingCreateImageGenerationResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingCreateImageGenerationResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingCreateImageGenerationResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingCreateImageGenerationResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingCreateImageGenerationResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingCreateImageGenerationResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingCreateImageGenerationResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingCreateImageGenerationResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingCreateImageGenerationResponseSuccess = (klingCreateImageGenerationResponse200) & {
  headers: Headers;
};
export type klingCreateImageGenerationResponseError = (klingCreateImageGenerationResponse400 | klingCreateImageGenerationResponse401 | klingCreateImageGenerationResponse403 | klingCreateImageGenerationResponse404 | klingCreateImageGenerationResponse429 | klingCreateImageGenerationResponse500 | klingCreateImageGenerationResponse503 | klingCreateImageGenerationResponse504) & {
  headers: Headers;
};

export type klingCreateImageGenerationResponse = (klingCreateImageGenerationResponseSuccess | klingCreateImageGenerationResponseError)

export const getKlingCreateImageGenerationUrl = () => {


  

  return `/proxy/kling/v1/images/generations`
}

export const klingCreateImageGeneration = async (klingImageGenerationsRequest: KlingImageGenerationsRequest, options?: RequestInit): Promise<klingCreateImageGenerationResponse> => {
  
  return customInstance<klingCreateImageGenerationResponse>(getKlingCreateImageGenerationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      klingImageGenerationsRequest,)
  }
);}




export const getKlingCreateImageGenerationMutationOptions = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateImageGeneration>>, TError,{data: KlingImageGenerationsRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof klingCreateImageGeneration>>, TError,{data: KlingImageGenerationsRequest}, TContext> => {

const mutationKey = ['klingCreateImageGeneration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof klingCreateImageGeneration>>, {data: KlingImageGenerationsRequest}> = (props) => {
          const {data} = props ?? {};

          return  klingCreateImageGeneration(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type KlingCreateImageGenerationMutationResult = NonNullable<Awaited<ReturnType<typeof klingCreateImageGeneration>>>
    export type KlingCreateImageGenerationMutationBody = KlingImageGenerationsRequest
    export type KlingCreateImageGenerationMutationError = KlingErrorResponse

    /**
 * @summary KlingAI Create Image Generation Task
 */
export const useKlingCreateImageGeneration = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateImageGeneration>>, TError,{data: KlingImageGenerationsRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof klingCreateImageGeneration>>,
        TError,
        {data: KlingImageGenerationsRequest},
        TContext
      > => {
      return useMutation(getKlingCreateImageGenerationMutationOptions(options), queryClient);
    }
    
/**
 * @summary KlingAI Query Single Image Generation Task
 */
export type klingImageGenerationsQuerySingleTaskResponse200 = {
  data: KlingImageGenerationsResponse
  status: 200
}

export type klingImageGenerationsQuerySingleTaskResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingImageGenerationsQuerySingleTaskResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingImageGenerationsQuerySingleTaskResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingImageGenerationsQuerySingleTaskResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingImageGenerationsQuerySingleTaskResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingImageGenerationsQuerySingleTaskResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingImageGenerationsQuerySingleTaskResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingImageGenerationsQuerySingleTaskResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingImageGenerationsQuerySingleTaskResponseSuccess = (klingImageGenerationsQuerySingleTaskResponse200) & {
  headers: Headers;
};
export type klingImageGenerationsQuerySingleTaskResponseError = (klingImageGenerationsQuerySingleTaskResponse400 | klingImageGenerationsQuerySingleTaskResponse401 | klingImageGenerationsQuerySingleTaskResponse403 | klingImageGenerationsQuerySingleTaskResponse404 | klingImageGenerationsQuerySingleTaskResponse429 | klingImageGenerationsQuerySingleTaskResponse500 | klingImageGenerationsQuerySingleTaskResponse503 | klingImageGenerationsQuerySingleTaskResponse504) & {
  headers: Headers;
};

export type klingImageGenerationsQuerySingleTaskResponse = (klingImageGenerationsQuerySingleTaskResponseSuccess | klingImageGenerationsQuerySingleTaskResponseError)

export const getKlingImageGenerationsQuerySingleTaskUrl = (id: string,) => {


  

  return `/proxy/kling/v1/images/generations/${id}`
}

export const klingImageGenerationsQuerySingleTask = async (id: string, options?: RequestInit): Promise<klingImageGenerationsQuerySingleTaskResponse> => {
  
  return customInstance<klingImageGenerationsQuerySingleTaskResponse>(getKlingImageGenerationsQuerySingleTaskUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingImageGenerationsQuerySingleTaskQueryKey = (id: string,) => {
    return [
    `/proxy/kling/v1/images/generations/${id}`
    ] as const;
    }

    
export const getKlingImageGenerationsQuerySingleTaskQueryOptions = <TData = Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>, TError = KlingErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingImageGenerationsQuerySingleTaskQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>> = ({ signal }) => klingImageGenerationsQuerySingleTask(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingImageGenerationsQuerySingleTaskQueryResult = NonNullable<Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>>
export type KlingImageGenerationsQuerySingleTaskQueryError = KlingErrorResponse


export function useKlingImageGenerationsQuerySingleTask<TData = Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingImageGenerationsQuerySingleTask<TData = Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingImageGenerationsQuerySingleTask<TData = Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Single Image Generation Task
 */

export function useKlingImageGenerationsQuerySingleTask<TData = Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingImageGenerationsQuerySingleTaskQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Query Virtual Try-On Task List
 */
export type klingVirtualTryOnQueryTaskListResponse200 = {
  data: KlingVirtualTryOnResponse
  status: 200
}

export type klingVirtualTryOnQueryTaskListResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingVirtualTryOnQueryTaskListResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingVirtualTryOnQueryTaskListResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingVirtualTryOnQueryTaskListResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingVirtualTryOnQueryTaskListResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingVirtualTryOnQueryTaskListResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingVirtualTryOnQueryTaskListResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingVirtualTryOnQueryTaskListResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingVirtualTryOnQueryTaskListResponseSuccess = (klingVirtualTryOnQueryTaskListResponse200) & {
  headers: Headers;
};
export type klingVirtualTryOnQueryTaskListResponseError = (klingVirtualTryOnQueryTaskListResponse400 | klingVirtualTryOnQueryTaskListResponse401 | klingVirtualTryOnQueryTaskListResponse403 | klingVirtualTryOnQueryTaskListResponse404 | klingVirtualTryOnQueryTaskListResponse429 | klingVirtualTryOnQueryTaskListResponse500 | klingVirtualTryOnQueryTaskListResponse503 | klingVirtualTryOnQueryTaskListResponse504) & {
  headers: Headers;
};

export type klingVirtualTryOnQueryTaskListResponse = (klingVirtualTryOnQueryTaskListResponseSuccess | klingVirtualTryOnQueryTaskListResponseError)

export const getKlingVirtualTryOnQueryTaskListUrl = (params?: KlingVirtualTryOnQueryTaskListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/kling/v1/images/kolors-virtual-try-on?${stringifiedParams}` : `/proxy/kling/v1/images/kolors-virtual-try-on`
}

export const klingVirtualTryOnQueryTaskList = async (params?: KlingVirtualTryOnQueryTaskListParams, options?: RequestInit): Promise<klingVirtualTryOnQueryTaskListResponse> => {
  
  return customInstance<klingVirtualTryOnQueryTaskListResponse>(getKlingVirtualTryOnQueryTaskListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingVirtualTryOnQueryTaskListQueryKey = (params?: KlingVirtualTryOnQueryTaskListParams,) => {
    return [
    `/proxy/kling/v1/images/kolors-virtual-try-on`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getKlingVirtualTryOnQueryTaskListQueryOptions = <TData = Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>, TError = KlingErrorResponse>(params?: KlingVirtualTryOnQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingVirtualTryOnQueryTaskListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>> = ({ signal }) => klingVirtualTryOnQueryTaskList(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingVirtualTryOnQueryTaskListQueryResult = NonNullable<Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>>
export type KlingVirtualTryOnQueryTaskListQueryError = KlingErrorResponse


export function useKlingVirtualTryOnQueryTaskList<TData = Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>, TError = KlingErrorResponse>(
 params: undefined |  KlingVirtualTryOnQueryTaskListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVirtualTryOnQueryTaskList<TData = Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingVirtualTryOnQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVirtualTryOnQueryTaskList<TData = Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingVirtualTryOnQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Virtual Try-On Task List
 */

export function useKlingVirtualTryOnQueryTaskList<TData = Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingVirtualTryOnQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingVirtualTryOnQueryTaskListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Create Virtual Try-On Task
 */
export type klingCreateVirtualTryOnResponse200 = {
  data: KlingVirtualTryOnResponse
  status: 200
}

export type klingCreateVirtualTryOnResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingCreateVirtualTryOnResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingCreateVirtualTryOnResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingCreateVirtualTryOnResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingCreateVirtualTryOnResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingCreateVirtualTryOnResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingCreateVirtualTryOnResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingCreateVirtualTryOnResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingCreateVirtualTryOnResponseSuccess = (klingCreateVirtualTryOnResponse200) & {
  headers: Headers;
};
export type klingCreateVirtualTryOnResponseError = (klingCreateVirtualTryOnResponse400 | klingCreateVirtualTryOnResponse401 | klingCreateVirtualTryOnResponse403 | klingCreateVirtualTryOnResponse404 | klingCreateVirtualTryOnResponse429 | klingCreateVirtualTryOnResponse500 | klingCreateVirtualTryOnResponse503 | klingCreateVirtualTryOnResponse504) & {
  headers: Headers;
};

export type klingCreateVirtualTryOnResponse = (klingCreateVirtualTryOnResponseSuccess | klingCreateVirtualTryOnResponseError)

export const getKlingCreateVirtualTryOnUrl = () => {


  

  return `/proxy/kling/v1/images/kolors-virtual-try-on`
}

export const klingCreateVirtualTryOn = async (klingVirtualTryOnRequest: KlingVirtualTryOnRequest, options?: RequestInit): Promise<klingCreateVirtualTryOnResponse> => {
  
  return customInstance<klingCreateVirtualTryOnResponse>(getKlingCreateVirtualTryOnUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      klingVirtualTryOnRequest,)
  }
);}




export const getKlingCreateVirtualTryOnMutationOptions = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateVirtualTryOn>>, TError,{data: KlingVirtualTryOnRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof klingCreateVirtualTryOn>>, TError,{data: KlingVirtualTryOnRequest}, TContext> => {

const mutationKey = ['klingCreateVirtualTryOn'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof klingCreateVirtualTryOn>>, {data: KlingVirtualTryOnRequest}> = (props) => {
          const {data} = props ?? {};

          return  klingCreateVirtualTryOn(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type KlingCreateVirtualTryOnMutationResult = NonNullable<Awaited<ReturnType<typeof klingCreateVirtualTryOn>>>
    export type KlingCreateVirtualTryOnMutationBody = KlingVirtualTryOnRequest
    export type KlingCreateVirtualTryOnMutationError = KlingErrorResponse

    /**
 * @summary KlingAI Create Virtual Try-On Task
 */
export const useKlingCreateVirtualTryOn = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateVirtualTryOn>>, TError,{data: KlingVirtualTryOnRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof klingCreateVirtualTryOn>>,
        TError,
        {data: KlingVirtualTryOnRequest},
        TContext
      > => {
      return useMutation(getKlingCreateVirtualTryOnMutationOptions(options), queryClient);
    }
    
/**
 * @summary KlingAI Query Single Virtual Try-On Task
 */
export type klingVirtualTryOnQuerySingleTaskResponse200 = {
  data: KlingVirtualTryOnResponse
  status: 200
}

export type klingVirtualTryOnQuerySingleTaskResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingVirtualTryOnQuerySingleTaskResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingVirtualTryOnQuerySingleTaskResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingVirtualTryOnQuerySingleTaskResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingVirtualTryOnQuerySingleTaskResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingVirtualTryOnQuerySingleTaskResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingVirtualTryOnQuerySingleTaskResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingVirtualTryOnQuerySingleTaskResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingVirtualTryOnQuerySingleTaskResponseSuccess = (klingVirtualTryOnQuerySingleTaskResponse200) & {
  headers: Headers;
};
export type klingVirtualTryOnQuerySingleTaskResponseError = (klingVirtualTryOnQuerySingleTaskResponse400 | klingVirtualTryOnQuerySingleTaskResponse401 | klingVirtualTryOnQuerySingleTaskResponse403 | klingVirtualTryOnQuerySingleTaskResponse404 | klingVirtualTryOnQuerySingleTaskResponse429 | klingVirtualTryOnQuerySingleTaskResponse500 | klingVirtualTryOnQuerySingleTaskResponse503 | klingVirtualTryOnQuerySingleTaskResponse504) & {
  headers: Headers;
};

export type klingVirtualTryOnQuerySingleTaskResponse = (klingVirtualTryOnQuerySingleTaskResponseSuccess | klingVirtualTryOnQuerySingleTaskResponseError)

export const getKlingVirtualTryOnQuerySingleTaskUrl = (id: string,) => {


  

  return `/proxy/kling/v1/images/kolors-virtual-try-on/${id}`
}

export const klingVirtualTryOnQuerySingleTask = async (id: string, options?: RequestInit): Promise<klingVirtualTryOnQuerySingleTaskResponse> => {
  
  return customInstance<klingVirtualTryOnQuerySingleTaskResponse>(getKlingVirtualTryOnQuerySingleTaskUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingVirtualTryOnQuerySingleTaskQueryKey = (id: string,) => {
    return [
    `/proxy/kling/v1/images/kolors-virtual-try-on/${id}`
    ] as const;
    }

    
export const getKlingVirtualTryOnQuerySingleTaskQueryOptions = <TData = Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>, TError = KlingErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingVirtualTryOnQuerySingleTaskQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>> = ({ signal }) => klingVirtualTryOnQuerySingleTask(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingVirtualTryOnQuerySingleTaskQueryResult = NonNullable<Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>>
export type KlingVirtualTryOnQuerySingleTaskQueryError = KlingErrorResponse


export function useKlingVirtualTryOnQuerySingleTask<TData = Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVirtualTryOnQuerySingleTask<TData = Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVirtualTryOnQuerySingleTask<TData = Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Single Virtual Try-On Task
 */

export function useKlingVirtualTryOnQuerySingleTask<TData = Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingVirtualTryOnQuerySingleTaskQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Create Omni-Image Task
 */
export type klingCreateOmniImageResponse200 = {
  data: KlingOmniImageResponse
  status: 200
}

export type klingCreateOmniImageResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingCreateOmniImageResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingCreateOmniImageResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingCreateOmniImageResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingCreateOmniImageResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingCreateOmniImageResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingCreateOmniImageResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingCreateOmniImageResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingCreateOmniImageResponseSuccess = (klingCreateOmniImageResponse200) & {
  headers: Headers;
};
export type klingCreateOmniImageResponseError = (klingCreateOmniImageResponse400 | klingCreateOmniImageResponse401 | klingCreateOmniImageResponse403 | klingCreateOmniImageResponse404 | klingCreateOmniImageResponse429 | klingCreateOmniImageResponse500 | klingCreateOmniImageResponse503 | klingCreateOmniImageResponse504) & {
  headers: Headers;
};

export type klingCreateOmniImageResponse = (klingCreateOmniImageResponseSuccess | klingCreateOmniImageResponseError)

export const getKlingCreateOmniImageUrl = () => {


  

  return `/proxy/kling/v1/images/omni-image`
}

export const klingCreateOmniImage = async (klingOmniImageRequest: KlingOmniImageRequest, options?: RequestInit): Promise<klingCreateOmniImageResponse> => {
  
  return customInstance<klingCreateOmniImageResponse>(getKlingCreateOmniImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      klingOmniImageRequest,)
  }
);}




export const getKlingCreateOmniImageMutationOptions = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateOmniImage>>, TError,{data: KlingOmniImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof klingCreateOmniImage>>, TError,{data: KlingOmniImageRequest}, TContext> => {

const mutationKey = ['klingCreateOmniImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof klingCreateOmniImage>>, {data: KlingOmniImageRequest}> = (props) => {
          const {data} = props ?? {};

          return  klingCreateOmniImage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type KlingCreateOmniImageMutationResult = NonNullable<Awaited<ReturnType<typeof klingCreateOmniImage>>>
    export type KlingCreateOmniImageMutationBody = KlingOmniImageRequest
    export type KlingCreateOmniImageMutationError = KlingErrorResponse

    /**
 * @summary KlingAI Create Omni-Image Task
 */
export const useKlingCreateOmniImage = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateOmniImage>>, TError,{data: KlingOmniImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof klingCreateOmniImage>>,
        TError,
        {data: KlingOmniImageRequest},
        TContext
      > => {
      return useMutation(getKlingCreateOmniImageMutationOptions(options), queryClient);
    }
    
/**
 * @summary KlingAI Query Single Omni-Image Task
 */
export type klingOmniImageQuerySingleTaskResponse200 = {
  data: KlingOmniImageResponse
  status: 200
}

export type klingOmniImageQuerySingleTaskResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingOmniImageQuerySingleTaskResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingOmniImageQuerySingleTaskResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingOmniImageQuerySingleTaskResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingOmniImageQuerySingleTaskResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingOmniImageQuerySingleTaskResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingOmniImageQuerySingleTaskResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingOmniImageQuerySingleTaskResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingOmniImageQuerySingleTaskResponseSuccess = (klingOmniImageQuerySingleTaskResponse200) & {
  headers: Headers;
};
export type klingOmniImageQuerySingleTaskResponseError = (klingOmniImageQuerySingleTaskResponse400 | klingOmniImageQuerySingleTaskResponse401 | klingOmniImageQuerySingleTaskResponse403 | klingOmniImageQuerySingleTaskResponse404 | klingOmniImageQuerySingleTaskResponse429 | klingOmniImageQuerySingleTaskResponse500 | klingOmniImageQuerySingleTaskResponse503 | klingOmniImageQuerySingleTaskResponse504) & {
  headers: Headers;
};

export type klingOmniImageQuerySingleTaskResponse = (klingOmniImageQuerySingleTaskResponseSuccess | klingOmniImageQuerySingleTaskResponseError)

export const getKlingOmniImageQuerySingleTaskUrl = (id: string,) => {


  

  return `/proxy/kling/v1/images/omni-image/${id}`
}

export const klingOmniImageQuerySingleTask = async (id: string, options?: RequestInit): Promise<klingOmniImageQuerySingleTaskResponse> => {
  
  return customInstance<klingOmniImageQuerySingleTaskResponse>(getKlingOmniImageQuerySingleTaskUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingOmniImageQuerySingleTaskQueryKey = (id: string,) => {
    return [
    `/proxy/kling/v1/images/omni-image/${id}`
    ] as const;
    }

    
export const getKlingOmniImageQuerySingleTaskQueryOptions = <TData = Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>, TError = KlingErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingOmniImageQuerySingleTaskQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>> = ({ signal }) => klingOmniImageQuerySingleTask(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingOmniImageQuerySingleTaskQueryResult = NonNullable<Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>>
export type KlingOmniImageQuerySingleTaskQueryError = KlingErrorResponse


export function useKlingOmniImageQuerySingleTask<TData = Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingOmniImageQuerySingleTask<TData = Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingOmniImageQuerySingleTask<TData = Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Single Omni-Image Task
 */

export function useKlingOmniImageQuerySingleTask<TData = Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingOmniImageQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingOmniImageQuerySingleTaskQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Query Video Effects Task List
 */
export type klingVideoEffectsQueryTaskListResponse200 = {
  data: KlingVideoEffectsResponse
  status: 200
}

export type klingVideoEffectsQueryTaskListResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingVideoEffectsQueryTaskListResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingVideoEffectsQueryTaskListResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingVideoEffectsQueryTaskListResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingVideoEffectsQueryTaskListResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingVideoEffectsQueryTaskListResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingVideoEffectsQueryTaskListResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingVideoEffectsQueryTaskListResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingVideoEffectsQueryTaskListResponseSuccess = (klingVideoEffectsQueryTaskListResponse200) & {
  headers: Headers;
};
export type klingVideoEffectsQueryTaskListResponseError = (klingVideoEffectsQueryTaskListResponse400 | klingVideoEffectsQueryTaskListResponse401 | klingVideoEffectsQueryTaskListResponse403 | klingVideoEffectsQueryTaskListResponse404 | klingVideoEffectsQueryTaskListResponse429 | klingVideoEffectsQueryTaskListResponse500 | klingVideoEffectsQueryTaskListResponse503 | klingVideoEffectsQueryTaskListResponse504) & {
  headers: Headers;
};

export type klingVideoEffectsQueryTaskListResponse = (klingVideoEffectsQueryTaskListResponseSuccess | klingVideoEffectsQueryTaskListResponseError)

export const getKlingVideoEffectsQueryTaskListUrl = (params?: KlingVideoEffectsQueryTaskListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/kling/v1/videos/effects?${stringifiedParams}` : `/proxy/kling/v1/videos/effects`
}

export const klingVideoEffectsQueryTaskList = async (params?: KlingVideoEffectsQueryTaskListParams, options?: RequestInit): Promise<klingVideoEffectsQueryTaskListResponse> => {
  
  return customInstance<klingVideoEffectsQueryTaskListResponse>(getKlingVideoEffectsQueryTaskListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingVideoEffectsQueryTaskListQueryKey = (params?: KlingVideoEffectsQueryTaskListParams,) => {
    return [
    `/proxy/kling/v1/videos/effects`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getKlingVideoEffectsQueryTaskListQueryOptions = <TData = Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>, TError = KlingErrorResponse>(params?: KlingVideoEffectsQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingVideoEffectsQueryTaskListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>> = ({ signal }) => klingVideoEffectsQueryTaskList(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingVideoEffectsQueryTaskListQueryResult = NonNullable<Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>>
export type KlingVideoEffectsQueryTaskListQueryError = KlingErrorResponse


export function useKlingVideoEffectsQueryTaskList<TData = Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>, TError = KlingErrorResponse>(
 params: undefined |  KlingVideoEffectsQueryTaskListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVideoEffectsQueryTaskList<TData = Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingVideoEffectsQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVideoEffectsQueryTaskList<TData = Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingVideoEffectsQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Video Effects Task List
 */

export function useKlingVideoEffectsQueryTaskList<TData = Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingVideoEffectsQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingVideoEffectsQueryTaskListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Create Video Effects Task
 */
export type klingCreateVideoEffectsResponse200 = {
  data: KlingVideoEffectsResponse
  status: 200
}

export type klingCreateVideoEffectsResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingCreateVideoEffectsResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingCreateVideoEffectsResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingCreateVideoEffectsResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingCreateVideoEffectsResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingCreateVideoEffectsResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingCreateVideoEffectsResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingCreateVideoEffectsResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingCreateVideoEffectsResponseSuccess = (klingCreateVideoEffectsResponse200) & {
  headers: Headers;
};
export type klingCreateVideoEffectsResponseError = (klingCreateVideoEffectsResponse400 | klingCreateVideoEffectsResponse401 | klingCreateVideoEffectsResponse403 | klingCreateVideoEffectsResponse404 | klingCreateVideoEffectsResponse429 | klingCreateVideoEffectsResponse500 | klingCreateVideoEffectsResponse503 | klingCreateVideoEffectsResponse504) & {
  headers: Headers;
};

export type klingCreateVideoEffectsResponse = (klingCreateVideoEffectsResponseSuccess | klingCreateVideoEffectsResponseError)

export const getKlingCreateVideoEffectsUrl = () => {


  

  return `/proxy/kling/v1/videos/effects`
}

export const klingCreateVideoEffects = async (klingVideoEffectsRequest: KlingVideoEffectsRequest, options?: RequestInit): Promise<klingCreateVideoEffectsResponse> => {
  
  return customInstance<klingCreateVideoEffectsResponse>(getKlingCreateVideoEffectsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      klingVideoEffectsRequest,)
  }
);}




export const getKlingCreateVideoEffectsMutationOptions = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateVideoEffects>>, TError,{data: KlingVideoEffectsRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof klingCreateVideoEffects>>, TError,{data: KlingVideoEffectsRequest}, TContext> => {

const mutationKey = ['klingCreateVideoEffects'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof klingCreateVideoEffects>>, {data: KlingVideoEffectsRequest}> = (props) => {
          const {data} = props ?? {};

          return  klingCreateVideoEffects(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type KlingCreateVideoEffectsMutationResult = NonNullable<Awaited<ReturnType<typeof klingCreateVideoEffects>>>
    export type KlingCreateVideoEffectsMutationBody = KlingVideoEffectsRequest
    export type KlingCreateVideoEffectsMutationError = KlingErrorResponse

    /**
 * @summary KlingAI Create Video Effects Task
 */
export const useKlingCreateVideoEffects = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateVideoEffects>>, TError,{data: KlingVideoEffectsRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof klingCreateVideoEffects>>,
        TError,
        {data: KlingVideoEffectsRequest},
        TContext
      > => {
      return useMutation(getKlingCreateVideoEffectsMutationOptions(options), queryClient);
    }
    
/**
 * @summary KlingAI Query Single Video Effects Task
 */
export type klingVideoEffectsQuerySingleTaskResponse200 = {
  data: KlingVideoEffectsResponse
  status: 200
}

export type klingVideoEffectsQuerySingleTaskResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingVideoEffectsQuerySingleTaskResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingVideoEffectsQuerySingleTaskResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingVideoEffectsQuerySingleTaskResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingVideoEffectsQuerySingleTaskResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingVideoEffectsQuerySingleTaskResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingVideoEffectsQuerySingleTaskResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingVideoEffectsQuerySingleTaskResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingVideoEffectsQuerySingleTaskResponseSuccess = (klingVideoEffectsQuerySingleTaskResponse200) & {
  headers: Headers;
};
export type klingVideoEffectsQuerySingleTaskResponseError = (klingVideoEffectsQuerySingleTaskResponse400 | klingVideoEffectsQuerySingleTaskResponse401 | klingVideoEffectsQuerySingleTaskResponse403 | klingVideoEffectsQuerySingleTaskResponse404 | klingVideoEffectsQuerySingleTaskResponse429 | klingVideoEffectsQuerySingleTaskResponse500 | klingVideoEffectsQuerySingleTaskResponse503 | klingVideoEffectsQuerySingleTaskResponse504) & {
  headers: Headers;
};

export type klingVideoEffectsQuerySingleTaskResponse = (klingVideoEffectsQuerySingleTaskResponseSuccess | klingVideoEffectsQuerySingleTaskResponseError)

export const getKlingVideoEffectsQuerySingleTaskUrl = (id: string,) => {


  

  return `/proxy/kling/v1/videos/effects/${id}`
}

export const klingVideoEffectsQuerySingleTask = async (id: string, options?: RequestInit): Promise<klingVideoEffectsQuerySingleTaskResponse> => {
  
  return customInstance<klingVideoEffectsQuerySingleTaskResponse>(getKlingVideoEffectsQuerySingleTaskUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingVideoEffectsQuerySingleTaskQueryKey = (id: string,) => {
    return [
    `/proxy/kling/v1/videos/effects/${id}`
    ] as const;
    }

    
export const getKlingVideoEffectsQuerySingleTaskQueryOptions = <TData = Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>, TError = KlingErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingVideoEffectsQuerySingleTaskQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>> = ({ signal }) => klingVideoEffectsQuerySingleTask(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingVideoEffectsQuerySingleTaskQueryResult = NonNullable<Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>>
export type KlingVideoEffectsQuerySingleTaskQueryError = KlingErrorResponse


export function useKlingVideoEffectsQuerySingleTask<TData = Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVideoEffectsQuerySingleTask<TData = Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVideoEffectsQuerySingleTask<TData = Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Single Video Effects Task
 */

export function useKlingVideoEffectsQuerySingleTask<TData = Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingVideoEffectsQuerySingleTaskQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Query Image2Video Task List
 */
export type klingImage2VideoQueryTaskListResponse200 = {
  data: KlingImage2VideoResponse
  status: 200
}

export type klingImage2VideoQueryTaskListResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingImage2VideoQueryTaskListResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingImage2VideoQueryTaskListResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingImage2VideoQueryTaskListResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingImage2VideoQueryTaskListResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingImage2VideoQueryTaskListResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingImage2VideoQueryTaskListResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingImage2VideoQueryTaskListResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingImage2VideoQueryTaskListResponseSuccess = (klingImage2VideoQueryTaskListResponse200) & {
  headers: Headers;
};
export type klingImage2VideoQueryTaskListResponseError = (klingImage2VideoQueryTaskListResponse400 | klingImage2VideoQueryTaskListResponse401 | klingImage2VideoQueryTaskListResponse403 | klingImage2VideoQueryTaskListResponse404 | klingImage2VideoQueryTaskListResponse429 | klingImage2VideoQueryTaskListResponse500 | klingImage2VideoQueryTaskListResponse503 | klingImage2VideoQueryTaskListResponse504) & {
  headers: Headers;
};

export type klingImage2VideoQueryTaskListResponse = (klingImage2VideoQueryTaskListResponseSuccess | klingImage2VideoQueryTaskListResponseError)

export const getKlingImage2VideoQueryTaskListUrl = (params?: KlingImage2VideoQueryTaskListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/kling/v1/videos/image2video?${stringifiedParams}` : `/proxy/kling/v1/videos/image2video`
}

export const klingImage2VideoQueryTaskList = async (params?: KlingImage2VideoQueryTaskListParams, options?: RequestInit): Promise<klingImage2VideoQueryTaskListResponse> => {
  
  return customInstance<klingImage2VideoQueryTaskListResponse>(getKlingImage2VideoQueryTaskListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingImage2VideoQueryTaskListQueryKey = (params?: KlingImage2VideoQueryTaskListParams,) => {
    return [
    `/proxy/kling/v1/videos/image2video`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getKlingImage2VideoQueryTaskListQueryOptions = <TData = Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>, TError = KlingErrorResponse>(params?: KlingImage2VideoQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingImage2VideoQueryTaskListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>> = ({ signal }) => klingImage2VideoQueryTaskList(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingImage2VideoQueryTaskListQueryResult = NonNullable<Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>>
export type KlingImage2VideoQueryTaskListQueryError = KlingErrorResponse


export function useKlingImage2VideoQueryTaskList<TData = Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>, TError = KlingErrorResponse>(
 params: undefined |  KlingImage2VideoQueryTaskListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingImage2VideoQueryTaskList<TData = Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingImage2VideoQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingImage2VideoQueryTaskList<TData = Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingImage2VideoQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Image2Video Task List
 */

export function useKlingImage2VideoQueryTaskList<TData = Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingImage2VideoQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingImage2VideoQueryTaskListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Create Video from Image
 */
export type klingCreateVideoFromImageResponse200 = {
  data: KlingImage2VideoResponse
  status: 200
}

export type klingCreateVideoFromImageResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingCreateVideoFromImageResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingCreateVideoFromImageResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingCreateVideoFromImageResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingCreateVideoFromImageResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingCreateVideoFromImageResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingCreateVideoFromImageResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingCreateVideoFromImageResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingCreateVideoFromImageResponseSuccess = (klingCreateVideoFromImageResponse200) & {
  headers: Headers;
};
export type klingCreateVideoFromImageResponseError = (klingCreateVideoFromImageResponse400 | klingCreateVideoFromImageResponse401 | klingCreateVideoFromImageResponse403 | klingCreateVideoFromImageResponse404 | klingCreateVideoFromImageResponse429 | klingCreateVideoFromImageResponse500 | klingCreateVideoFromImageResponse503 | klingCreateVideoFromImageResponse504) & {
  headers: Headers;
};

export type klingCreateVideoFromImageResponse = (klingCreateVideoFromImageResponseSuccess | klingCreateVideoFromImageResponseError)

export const getKlingCreateVideoFromImageUrl = () => {


  

  return `/proxy/kling/v1/videos/image2video`
}

export const klingCreateVideoFromImage = async (klingImage2VideoRequest: KlingImage2VideoRequest, options?: RequestInit): Promise<klingCreateVideoFromImageResponse> => {
  
  return customInstance<klingCreateVideoFromImageResponse>(getKlingCreateVideoFromImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      klingImage2VideoRequest,)
  }
);}




export const getKlingCreateVideoFromImageMutationOptions = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateVideoFromImage>>, TError,{data: KlingImage2VideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof klingCreateVideoFromImage>>, TError,{data: KlingImage2VideoRequest}, TContext> => {

const mutationKey = ['klingCreateVideoFromImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof klingCreateVideoFromImage>>, {data: KlingImage2VideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  klingCreateVideoFromImage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type KlingCreateVideoFromImageMutationResult = NonNullable<Awaited<ReturnType<typeof klingCreateVideoFromImage>>>
    export type KlingCreateVideoFromImageMutationBody = KlingImage2VideoRequest
    export type KlingCreateVideoFromImageMutationError = KlingErrorResponse

    /**
 * @summary KlingAI Create Video from Image
 */
export const useKlingCreateVideoFromImage = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateVideoFromImage>>, TError,{data: KlingImage2VideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof klingCreateVideoFromImage>>,
        TError,
        {data: KlingImage2VideoRequest},
        TContext
      > => {
      return useMutation(getKlingCreateVideoFromImageMutationOptions(options), queryClient);
    }
    
/**
 * @summary KlingAI Query Single Image2Video Task
 */
export type klingImage2VideoQuerySingleTaskResponse200 = {
  data: KlingImage2VideoResponse
  status: 200
}

export type klingImage2VideoQuerySingleTaskResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingImage2VideoQuerySingleTaskResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingImage2VideoQuerySingleTaskResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingImage2VideoQuerySingleTaskResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingImage2VideoQuerySingleTaskResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingImage2VideoQuerySingleTaskResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingImage2VideoQuerySingleTaskResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingImage2VideoQuerySingleTaskResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingImage2VideoQuerySingleTaskResponseSuccess = (klingImage2VideoQuerySingleTaskResponse200) & {
  headers: Headers;
};
export type klingImage2VideoQuerySingleTaskResponseError = (klingImage2VideoQuerySingleTaskResponse400 | klingImage2VideoQuerySingleTaskResponse401 | klingImage2VideoQuerySingleTaskResponse403 | klingImage2VideoQuerySingleTaskResponse404 | klingImage2VideoQuerySingleTaskResponse429 | klingImage2VideoQuerySingleTaskResponse500 | klingImage2VideoQuerySingleTaskResponse503 | klingImage2VideoQuerySingleTaskResponse504) & {
  headers: Headers;
};

export type klingImage2VideoQuerySingleTaskResponse = (klingImage2VideoQuerySingleTaskResponseSuccess | klingImage2VideoQuerySingleTaskResponseError)

export const getKlingImage2VideoQuerySingleTaskUrl = (id: string,) => {


  

  return `/proxy/kling/v1/videos/image2video/${id}`
}

export const klingImage2VideoQuerySingleTask = async (id: string, options?: RequestInit): Promise<klingImage2VideoQuerySingleTaskResponse> => {
  
  return customInstance<klingImage2VideoQuerySingleTaskResponse>(getKlingImage2VideoQuerySingleTaskUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingImage2VideoQuerySingleTaskQueryKey = (id: string,) => {
    return [
    `/proxy/kling/v1/videos/image2video/${id}`
    ] as const;
    }

    
export const getKlingImage2VideoQuerySingleTaskQueryOptions = <TData = Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>, TError = KlingErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingImage2VideoQuerySingleTaskQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>> = ({ signal }) => klingImage2VideoQuerySingleTask(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingImage2VideoQuerySingleTaskQueryResult = NonNullable<Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>>
export type KlingImage2VideoQuerySingleTaskQueryError = KlingErrorResponse


export function useKlingImage2VideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingImage2VideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingImage2VideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Single Image2Video Task
 */

export function useKlingImage2VideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingImage2VideoQuerySingleTaskQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Query Lip-Sync Task List
 */
export type klingLipSyncQueryTaskListResponse200 = {
  data: KlingLipSyncResponse
  status: 200
}

export type klingLipSyncQueryTaskListResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingLipSyncQueryTaskListResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingLipSyncQueryTaskListResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingLipSyncQueryTaskListResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingLipSyncQueryTaskListResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingLipSyncQueryTaskListResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingLipSyncQueryTaskListResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingLipSyncQueryTaskListResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingLipSyncQueryTaskListResponseSuccess = (klingLipSyncQueryTaskListResponse200) & {
  headers: Headers;
};
export type klingLipSyncQueryTaskListResponseError = (klingLipSyncQueryTaskListResponse400 | klingLipSyncQueryTaskListResponse401 | klingLipSyncQueryTaskListResponse403 | klingLipSyncQueryTaskListResponse404 | klingLipSyncQueryTaskListResponse429 | klingLipSyncQueryTaskListResponse500 | klingLipSyncQueryTaskListResponse503 | klingLipSyncQueryTaskListResponse504) & {
  headers: Headers;
};

export type klingLipSyncQueryTaskListResponse = (klingLipSyncQueryTaskListResponseSuccess | klingLipSyncQueryTaskListResponseError)

export const getKlingLipSyncQueryTaskListUrl = (params?: KlingLipSyncQueryTaskListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/kling/v1/videos/lip-sync?${stringifiedParams}` : `/proxy/kling/v1/videos/lip-sync`
}

export const klingLipSyncQueryTaskList = async (params?: KlingLipSyncQueryTaskListParams, options?: RequestInit): Promise<klingLipSyncQueryTaskListResponse> => {
  
  return customInstance<klingLipSyncQueryTaskListResponse>(getKlingLipSyncQueryTaskListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingLipSyncQueryTaskListQueryKey = (params?: KlingLipSyncQueryTaskListParams,) => {
    return [
    `/proxy/kling/v1/videos/lip-sync`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getKlingLipSyncQueryTaskListQueryOptions = <TData = Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>, TError = KlingErrorResponse>(params?: KlingLipSyncQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingLipSyncQueryTaskListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>> = ({ signal }) => klingLipSyncQueryTaskList(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingLipSyncQueryTaskListQueryResult = NonNullable<Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>>
export type KlingLipSyncQueryTaskListQueryError = KlingErrorResponse


export function useKlingLipSyncQueryTaskList<TData = Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>, TError = KlingErrorResponse>(
 params: undefined |  KlingLipSyncQueryTaskListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingLipSyncQueryTaskList<TData = Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingLipSyncQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingLipSyncQueryTaskList<TData = Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingLipSyncQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Lip-Sync Task List
 */

export function useKlingLipSyncQueryTaskList<TData = Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingLipSyncQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingLipSyncQueryTaskListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Create Lip-Sync Video
 */
export type klingCreateLipSyncVideoResponse200 = {
  data: KlingLipSyncResponse
  status: 200
}

export type klingCreateLipSyncVideoResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingCreateLipSyncVideoResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingCreateLipSyncVideoResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingCreateLipSyncVideoResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingCreateLipSyncVideoResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingCreateLipSyncVideoResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingCreateLipSyncVideoResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingCreateLipSyncVideoResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingCreateLipSyncVideoResponseSuccess = (klingCreateLipSyncVideoResponse200) & {
  headers: Headers;
};
export type klingCreateLipSyncVideoResponseError = (klingCreateLipSyncVideoResponse400 | klingCreateLipSyncVideoResponse401 | klingCreateLipSyncVideoResponse403 | klingCreateLipSyncVideoResponse404 | klingCreateLipSyncVideoResponse429 | klingCreateLipSyncVideoResponse500 | klingCreateLipSyncVideoResponse503 | klingCreateLipSyncVideoResponse504) & {
  headers: Headers;
};

export type klingCreateLipSyncVideoResponse = (klingCreateLipSyncVideoResponseSuccess | klingCreateLipSyncVideoResponseError)

export const getKlingCreateLipSyncVideoUrl = () => {


  

  return `/proxy/kling/v1/videos/lip-sync`
}

export const klingCreateLipSyncVideo = async (klingLipSyncRequest: KlingLipSyncRequest, options?: RequestInit): Promise<klingCreateLipSyncVideoResponse> => {
  
  return customInstance<klingCreateLipSyncVideoResponse>(getKlingCreateLipSyncVideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      klingLipSyncRequest,)
  }
);}




export const getKlingCreateLipSyncVideoMutationOptions = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateLipSyncVideo>>, TError,{data: KlingLipSyncRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof klingCreateLipSyncVideo>>, TError,{data: KlingLipSyncRequest}, TContext> => {

const mutationKey = ['klingCreateLipSyncVideo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof klingCreateLipSyncVideo>>, {data: KlingLipSyncRequest}> = (props) => {
          const {data} = props ?? {};

          return  klingCreateLipSyncVideo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type KlingCreateLipSyncVideoMutationResult = NonNullable<Awaited<ReturnType<typeof klingCreateLipSyncVideo>>>
    export type KlingCreateLipSyncVideoMutationBody = KlingLipSyncRequest
    export type KlingCreateLipSyncVideoMutationError = KlingErrorResponse

    /**
 * @summary KlingAI Create Lip-Sync Video
 */
export const useKlingCreateLipSyncVideo = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateLipSyncVideo>>, TError,{data: KlingLipSyncRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof klingCreateLipSyncVideo>>,
        TError,
        {data: KlingLipSyncRequest},
        TContext
      > => {
      return useMutation(getKlingCreateLipSyncVideoMutationOptions(options), queryClient);
    }
    
/**
 * @summary KlingAI Query Single Lip-Sync Task
 */
export type klingLipSyncQuerySingleTaskResponse200 = {
  data: KlingLipSyncResponse
  status: 200
}

export type klingLipSyncQuerySingleTaskResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingLipSyncQuerySingleTaskResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingLipSyncQuerySingleTaskResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingLipSyncQuerySingleTaskResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingLipSyncQuerySingleTaskResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingLipSyncQuerySingleTaskResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingLipSyncQuerySingleTaskResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingLipSyncQuerySingleTaskResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingLipSyncQuerySingleTaskResponseSuccess = (klingLipSyncQuerySingleTaskResponse200) & {
  headers: Headers;
};
export type klingLipSyncQuerySingleTaskResponseError = (klingLipSyncQuerySingleTaskResponse400 | klingLipSyncQuerySingleTaskResponse401 | klingLipSyncQuerySingleTaskResponse403 | klingLipSyncQuerySingleTaskResponse404 | klingLipSyncQuerySingleTaskResponse429 | klingLipSyncQuerySingleTaskResponse500 | klingLipSyncQuerySingleTaskResponse503 | klingLipSyncQuerySingleTaskResponse504) & {
  headers: Headers;
};

export type klingLipSyncQuerySingleTaskResponse = (klingLipSyncQuerySingleTaskResponseSuccess | klingLipSyncQuerySingleTaskResponseError)

export const getKlingLipSyncQuerySingleTaskUrl = (id: string,) => {


  

  return `/proxy/kling/v1/videos/lip-sync/${id}`
}

export const klingLipSyncQuerySingleTask = async (id: string, options?: RequestInit): Promise<klingLipSyncQuerySingleTaskResponse> => {
  
  return customInstance<klingLipSyncQuerySingleTaskResponse>(getKlingLipSyncQuerySingleTaskUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingLipSyncQuerySingleTaskQueryKey = (id: string,) => {
    return [
    `/proxy/kling/v1/videos/lip-sync/${id}`
    ] as const;
    }

    
export const getKlingLipSyncQuerySingleTaskQueryOptions = <TData = Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>, TError = KlingErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingLipSyncQuerySingleTaskQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>> = ({ signal }) => klingLipSyncQuerySingleTask(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingLipSyncQuerySingleTaskQueryResult = NonNullable<Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>>
export type KlingLipSyncQuerySingleTaskQueryError = KlingErrorResponse


export function useKlingLipSyncQuerySingleTask<TData = Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingLipSyncQuerySingleTask<TData = Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingLipSyncQuerySingleTask<TData = Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Single Lip-Sync Task
 */

export function useKlingLipSyncQuerySingleTask<TData = Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingLipSyncQuerySingleTaskQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Create Motion Control Task
 */
export type klingCreateMotionControlResponse200 = {
  data: KlingMotionControlResponse
  status: 200
}

export type klingCreateMotionControlResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingCreateMotionControlResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingCreateMotionControlResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingCreateMotionControlResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingCreateMotionControlResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingCreateMotionControlResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingCreateMotionControlResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingCreateMotionControlResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingCreateMotionControlResponseSuccess = (klingCreateMotionControlResponse200) & {
  headers: Headers;
};
export type klingCreateMotionControlResponseError = (klingCreateMotionControlResponse400 | klingCreateMotionControlResponse401 | klingCreateMotionControlResponse403 | klingCreateMotionControlResponse404 | klingCreateMotionControlResponse429 | klingCreateMotionControlResponse500 | klingCreateMotionControlResponse503 | klingCreateMotionControlResponse504) & {
  headers: Headers;
};

export type klingCreateMotionControlResponse = (klingCreateMotionControlResponseSuccess | klingCreateMotionControlResponseError)

export const getKlingCreateMotionControlUrl = () => {


  

  return `/proxy/kling/v1/videos/motion-control`
}

export const klingCreateMotionControl = async (klingMotionControlRequest: KlingMotionControlRequest, options?: RequestInit): Promise<klingCreateMotionControlResponse> => {
  
  return customInstance<klingCreateMotionControlResponse>(getKlingCreateMotionControlUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      klingMotionControlRequest,)
  }
);}




export const getKlingCreateMotionControlMutationOptions = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateMotionControl>>, TError,{data: KlingMotionControlRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof klingCreateMotionControl>>, TError,{data: KlingMotionControlRequest}, TContext> => {

const mutationKey = ['klingCreateMotionControl'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof klingCreateMotionControl>>, {data: KlingMotionControlRequest}> = (props) => {
          const {data} = props ?? {};

          return  klingCreateMotionControl(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type KlingCreateMotionControlMutationResult = NonNullable<Awaited<ReturnType<typeof klingCreateMotionControl>>>
    export type KlingCreateMotionControlMutationBody = KlingMotionControlRequest
    export type KlingCreateMotionControlMutationError = KlingErrorResponse

    /**
 * @summary KlingAI Create Motion Control Task
 */
export const useKlingCreateMotionControl = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateMotionControl>>, TError,{data: KlingMotionControlRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof klingCreateMotionControl>>,
        TError,
        {data: KlingMotionControlRequest},
        TContext
      > => {
      return useMutation(getKlingCreateMotionControlMutationOptions(options), queryClient);
    }
    
/**
 * @summary KlingAI Query Single Motion Control Task
 */
export type klingMotionControlQuerySingleTaskResponse200 = {
  data: KlingMotionControlResponse
  status: 200
}

export type klingMotionControlQuerySingleTaskResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingMotionControlQuerySingleTaskResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingMotionControlQuerySingleTaskResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingMotionControlQuerySingleTaskResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingMotionControlQuerySingleTaskResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingMotionControlQuerySingleTaskResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingMotionControlQuerySingleTaskResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingMotionControlQuerySingleTaskResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingMotionControlQuerySingleTaskResponseSuccess = (klingMotionControlQuerySingleTaskResponse200) & {
  headers: Headers;
};
export type klingMotionControlQuerySingleTaskResponseError = (klingMotionControlQuerySingleTaskResponse400 | klingMotionControlQuerySingleTaskResponse401 | klingMotionControlQuerySingleTaskResponse403 | klingMotionControlQuerySingleTaskResponse404 | klingMotionControlQuerySingleTaskResponse429 | klingMotionControlQuerySingleTaskResponse500 | klingMotionControlQuerySingleTaskResponse503 | klingMotionControlQuerySingleTaskResponse504) & {
  headers: Headers;
};

export type klingMotionControlQuerySingleTaskResponse = (klingMotionControlQuerySingleTaskResponseSuccess | klingMotionControlQuerySingleTaskResponseError)

export const getKlingMotionControlQuerySingleTaskUrl = (id: string,) => {


  

  return `/proxy/kling/v1/videos/motion-control/${id}`
}

export const klingMotionControlQuerySingleTask = async (id: string, options?: RequestInit): Promise<klingMotionControlQuerySingleTaskResponse> => {
  
  return customInstance<klingMotionControlQuerySingleTaskResponse>(getKlingMotionControlQuerySingleTaskUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingMotionControlQuerySingleTaskQueryKey = (id: string,) => {
    return [
    `/proxy/kling/v1/videos/motion-control/${id}`
    ] as const;
    }

    
export const getKlingMotionControlQuerySingleTaskQueryOptions = <TData = Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>, TError = KlingErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingMotionControlQuerySingleTaskQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>> = ({ signal }) => klingMotionControlQuerySingleTask(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingMotionControlQuerySingleTaskQueryResult = NonNullable<Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>>
export type KlingMotionControlQuerySingleTaskQueryError = KlingErrorResponse


export function useKlingMotionControlQuerySingleTask<TData = Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingMotionControlQuerySingleTask<TData = Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingMotionControlQuerySingleTask<TData = Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Single Motion Control Task
 */

export function useKlingMotionControlQuerySingleTask<TData = Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingMotionControlQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingMotionControlQuerySingleTaskQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Create Omni-Video Task
 */
export type klingCreateOmniVideoResponse200 = {
  data: KlingOmniVideoResponse
  status: 200
}

export type klingCreateOmniVideoResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingCreateOmniVideoResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingCreateOmniVideoResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingCreateOmniVideoResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingCreateOmniVideoResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingCreateOmniVideoResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingCreateOmniVideoResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingCreateOmniVideoResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingCreateOmniVideoResponseSuccess = (klingCreateOmniVideoResponse200) & {
  headers: Headers;
};
export type klingCreateOmniVideoResponseError = (klingCreateOmniVideoResponse400 | klingCreateOmniVideoResponse401 | klingCreateOmniVideoResponse403 | klingCreateOmniVideoResponse404 | klingCreateOmniVideoResponse429 | klingCreateOmniVideoResponse500 | klingCreateOmniVideoResponse503 | klingCreateOmniVideoResponse504) & {
  headers: Headers;
};

export type klingCreateOmniVideoResponse = (klingCreateOmniVideoResponseSuccess | klingCreateOmniVideoResponseError)

export const getKlingCreateOmniVideoUrl = () => {


  

  return `/proxy/kling/v1/videos/omni-video`
}

export const klingCreateOmniVideo = async (klingOmniVideoRequest: KlingOmniVideoRequest, options?: RequestInit): Promise<klingCreateOmniVideoResponse> => {
  
  return customInstance<klingCreateOmniVideoResponse>(getKlingCreateOmniVideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      klingOmniVideoRequest,)
  }
);}




export const getKlingCreateOmniVideoMutationOptions = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateOmniVideo>>, TError,{data: KlingOmniVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof klingCreateOmniVideo>>, TError,{data: KlingOmniVideoRequest}, TContext> => {

const mutationKey = ['klingCreateOmniVideo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof klingCreateOmniVideo>>, {data: KlingOmniVideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  klingCreateOmniVideo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type KlingCreateOmniVideoMutationResult = NonNullable<Awaited<ReturnType<typeof klingCreateOmniVideo>>>
    export type KlingCreateOmniVideoMutationBody = KlingOmniVideoRequest
    export type KlingCreateOmniVideoMutationError = KlingErrorResponse

    /**
 * @summary KlingAI Create Omni-Video Task
 */
export const useKlingCreateOmniVideo = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateOmniVideo>>, TError,{data: KlingOmniVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof klingCreateOmniVideo>>,
        TError,
        {data: KlingOmniVideoRequest},
        TContext
      > => {
      return useMutation(getKlingCreateOmniVideoMutationOptions(options), queryClient);
    }
    
/**
 * @summary KlingAI Query Single Omni-Video Task
 */
export type klingOmniVideoQuerySingleTaskResponse200 = {
  data: KlingOmniVideoResponse
  status: 200
}

export type klingOmniVideoQuerySingleTaskResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingOmniVideoQuerySingleTaskResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingOmniVideoQuerySingleTaskResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingOmniVideoQuerySingleTaskResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingOmniVideoQuerySingleTaskResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingOmniVideoQuerySingleTaskResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingOmniVideoQuerySingleTaskResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingOmniVideoQuerySingleTaskResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingOmniVideoQuerySingleTaskResponseSuccess = (klingOmniVideoQuerySingleTaskResponse200) & {
  headers: Headers;
};
export type klingOmniVideoQuerySingleTaskResponseError = (klingOmniVideoQuerySingleTaskResponse400 | klingOmniVideoQuerySingleTaskResponse401 | klingOmniVideoQuerySingleTaskResponse403 | klingOmniVideoQuerySingleTaskResponse404 | klingOmniVideoQuerySingleTaskResponse429 | klingOmniVideoQuerySingleTaskResponse500 | klingOmniVideoQuerySingleTaskResponse503 | klingOmniVideoQuerySingleTaskResponse504) & {
  headers: Headers;
};

export type klingOmniVideoQuerySingleTaskResponse = (klingOmniVideoQuerySingleTaskResponseSuccess | klingOmniVideoQuerySingleTaskResponseError)

export const getKlingOmniVideoQuerySingleTaskUrl = (id: string,) => {


  

  return `/proxy/kling/v1/videos/omni-video/${id}`
}

export const klingOmniVideoQuerySingleTask = async (id: string, options?: RequestInit): Promise<klingOmniVideoQuerySingleTaskResponse> => {
  
  return customInstance<klingOmniVideoQuerySingleTaskResponse>(getKlingOmniVideoQuerySingleTaskUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingOmniVideoQuerySingleTaskQueryKey = (id: string,) => {
    return [
    `/proxy/kling/v1/videos/omni-video/${id}`
    ] as const;
    }

    
export const getKlingOmniVideoQuerySingleTaskQueryOptions = <TData = Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>, TError = KlingErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingOmniVideoQuerySingleTaskQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>> = ({ signal }) => klingOmniVideoQuerySingleTask(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingOmniVideoQuerySingleTaskQueryResult = NonNullable<Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>>
export type KlingOmniVideoQuerySingleTaskQueryError = KlingErrorResponse


export function useKlingOmniVideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingOmniVideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingOmniVideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Single Omni-Video Task
 */

export function useKlingOmniVideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingOmniVideoQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingOmniVideoQuerySingleTaskQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Query Task List
 */
export type klingText2VideoQueryTaskListResponse200 = {
  data: KlingText2VideoResponse
  status: 200
}

export type klingText2VideoQueryTaskListResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingText2VideoQueryTaskListResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingText2VideoQueryTaskListResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingText2VideoQueryTaskListResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingText2VideoQueryTaskListResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingText2VideoQueryTaskListResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingText2VideoQueryTaskListResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingText2VideoQueryTaskListResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingText2VideoQueryTaskListResponseSuccess = (klingText2VideoQueryTaskListResponse200) & {
  headers: Headers;
};
export type klingText2VideoQueryTaskListResponseError = (klingText2VideoQueryTaskListResponse400 | klingText2VideoQueryTaskListResponse401 | klingText2VideoQueryTaskListResponse403 | klingText2VideoQueryTaskListResponse404 | klingText2VideoQueryTaskListResponse429 | klingText2VideoQueryTaskListResponse500 | klingText2VideoQueryTaskListResponse503 | klingText2VideoQueryTaskListResponse504) & {
  headers: Headers;
};

export type klingText2VideoQueryTaskListResponse = (klingText2VideoQueryTaskListResponseSuccess | klingText2VideoQueryTaskListResponseError)

export const getKlingText2VideoQueryTaskListUrl = (params?: KlingText2VideoQueryTaskListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/kling/v1/videos/text2video?${stringifiedParams}` : `/proxy/kling/v1/videos/text2video`
}

export const klingText2VideoQueryTaskList = async (params?: KlingText2VideoQueryTaskListParams, options?: RequestInit): Promise<klingText2VideoQueryTaskListResponse> => {
  
  return customInstance<klingText2VideoQueryTaskListResponse>(getKlingText2VideoQueryTaskListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingText2VideoQueryTaskListQueryKey = (params?: KlingText2VideoQueryTaskListParams,) => {
    return [
    `/proxy/kling/v1/videos/text2video`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getKlingText2VideoQueryTaskListQueryOptions = <TData = Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>, TError = KlingErrorResponse>(params?: KlingText2VideoQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingText2VideoQueryTaskListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>> = ({ signal }) => klingText2VideoQueryTaskList(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingText2VideoQueryTaskListQueryResult = NonNullable<Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>>
export type KlingText2VideoQueryTaskListQueryError = KlingErrorResponse


export function useKlingText2VideoQueryTaskList<TData = Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>, TError = KlingErrorResponse>(
 params: undefined |  KlingText2VideoQueryTaskListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingText2VideoQueryTaskList<TData = Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingText2VideoQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingText2VideoQueryTaskList<TData = Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingText2VideoQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Task List
 */

export function useKlingText2VideoQueryTaskList<TData = Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingText2VideoQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingText2VideoQueryTaskListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Create Video from Text
 */
export type klingCreateVideoFromTextResponse200 = {
  data: KlingText2VideoResponse
  status: 200
}

export type klingCreateVideoFromTextResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingCreateVideoFromTextResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingCreateVideoFromTextResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingCreateVideoFromTextResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingCreateVideoFromTextResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingCreateVideoFromTextResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingCreateVideoFromTextResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingCreateVideoFromTextResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingCreateVideoFromTextResponseSuccess = (klingCreateVideoFromTextResponse200) & {
  headers: Headers;
};
export type klingCreateVideoFromTextResponseError = (klingCreateVideoFromTextResponse400 | klingCreateVideoFromTextResponse401 | klingCreateVideoFromTextResponse403 | klingCreateVideoFromTextResponse404 | klingCreateVideoFromTextResponse429 | klingCreateVideoFromTextResponse500 | klingCreateVideoFromTextResponse503 | klingCreateVideoFromTextResponse504) & {
  headers: Headers;
};

export type klingCreateVideoFromTextResponse = (klingCreateVideoFromTextResponseSuccess | klingCreateVideoFromTextResponseError)

export const getKlingCreateVideoFromTextUrl = () => {


  

  return `/proxy/kling/v1/videos/text2video`
}

export const klingCreateVideoFromText = async (klingText2VideoRequest: KlingText2VideoRequest, options?: RequestInit): Promise<klingCreateVideoFromTextResponse> => {
  
  return customInstance<klingCreateVideoFromTextResponse>(getKlingCreateVideoFromTextUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      klingText2VideoRequest,)
  }
);}




export const getKlingCreateVideoFromTextMutationOptions = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateVideoFromText>>, TError,{data: KlingText2VideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof klingCreateVideoFromText>>, TError,{data: KlingText2VideoRequest}, TContext> => {

const mutationKey = ['klingCreateVideoFromText'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof klingCreateVideoFromText>>, {data: KlingText2VideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  klingCreateVideoFromText(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type KlingCreateVideoFromTextMutationResult = NonNullable<Awaited<ReturnType<typeof klingCreateVideoFromText>>>
    export type KlingCreateVideoFromTextMutationBody = KlingText2VideoRequest
    export type KlingCreateVideoFromTextMutationError = KlingErrorResponse

    /**
 * @summary KlingAI Create Video from Text
 */
export const useKlingCreateVideoFromText = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingCreateVideoFromText>>, TError,{data: KlingText2VideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof klingCreateVideoFromText>>,
        TError,
        {data: KlingText2VideoRequest},
        TContext
      > => {
      return useMutation(getKlingCreateVideoFromTextMutationOptions(options), queryClient);
    }
    
/**
 * @summary KlingAI Query Single Task
 */
export type klingText2VideoQuerySingleTaskResponse200 = {
  data: KlingText2VideoResponse
  status: 200
}

export type klingText2VideoQuerySingleTaskResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingText2VideoQuerySingleTaskResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingText2VideoQuerySingleTaskResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingText2VideoQuerySingleTaskResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingText2VideoQuerySingleTaskResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingText2VideoQuerySingleTaskResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingText2VideoQuerySingleTaskResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingText2VideoQuerySingleTaskResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingText2VideoQuerySingleTaskResponseSuccess = (klingText2VideoQuerySingleTaskResponse200) & {
  headers: Headers;
};
export type klingText2VideoQuerySingleTaskResponseError = (klingText2VideoQuerySingleTaskResponse400 | klingText2VideoQuerySingleTaskResponse401 | klingText2VideoQuerySingleTaskResponse403 | klingText2VideoQuerySingleTaskResponse404 | klingText2VideoQuerySingleTaskResponse429 | klingText2VideoQuerySingleTaskResponse500 | klingText2VideoQuerySingleTaskResponse503 | klingText2VideoQuerySingleTaskResponse504) & {
  headers: Headers;
};

export type klingText2VideoQuerySingleTaskResponse = (klingText2VideoQuerySingleTaskResponseSuccess | klingText2VideoQuerySingleTaskResponseError)

export const getKlingText2VideoQuerySingleTaskUrl = (id: string,) => {


  

  return `/proxy/kling/v1/videos/text2video/${id}`
}

export const klingText2VideoQuerySingleTask = async (id: string, options?: RequestInit): Promise<klingText2VideoQuerySingleTaskResponse> => {
  
  return customInstance<klingText2VideoQuerySingleTaskResponse>(getKlingText2VideoQuerySingleTaskUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingText2VideoQuerySingleTaskQueryKey = (id: string,) => {
    return [
    `/proxy/kling/v1/videos/text2video/${id}`
    ] as const;
    }

    
export const getKlingText2VideoQuerySingleTaskQueryOptions = <TData = Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>, TError = KlingErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingText2VideoQuerySingleTaskQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>> = ({ signal }) => klingText2VideoQuerySingleTask(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingText2VideoQuerySingleTaskQueryResult = NonNullable<Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>>
export type KlingText2VideoQuerySingleTaskQueryError = KlingErrorResponse


export function useKlingText2VideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingText2VideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingText2VideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Single Task
 */

export function useKlingText2VideoQuerySingleTask<TData = Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingText2VideoQuerySingleTaskQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Query Video-Extend Task List
 */
export type klingVideoExtendQueryTaskListResponse200 = {
  data: KlingVideoExtendResponse
  status: 200
}

export type klingVideoExtendQueryTaskListResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingVideoExtendQueryTaskListResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingVideoExtendQueryTaskListResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingVideoExtendQueryTaskListResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingVideoExtendQueryTaskListResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingVideoExtendQueryTaskListResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingVideoExtendQueryTaskListResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingVideoExtendQueryTaskListResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingVideoExtendQueryTaskListResponseSuccess = (klingVideoExtendQueryTaskListResponse200) & {
  headers: Headers;
};
export type klingVideoExtendQueryTaskListResponseError = (klingVideoExtendQueryTaskListResponse400 | klingVideoExtendQueryTaskListResponse401 | klingVideoExtendQueryTaskListResponse403 | klingVideoExtendQueryTaskListResponse404 | klingVideoExtendQueryTaskListResponse429 | klingVideoExtendQueryTaskListResponse500 | klingVideoExtendQueryTaskListResponse503 | klingVideoExtendQueryTaskListResponse504) & {
  headers: Headers;
};

export type klingVideoExtendQueryTaskListResponse = (klingVideoExtendQueryTaskListResponseSuccess | klingVideoExtendQueryTaskListResponseError)

export const getKlingVideoExtendQueryTaskListUrl = (params?: KlingVideoExtendQueryTaskListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/kling/v1/videos/video-extend?${stringifiedParams}` : `/proxy/kling/v1/videos/video-extend`
}

export const klingVideoExtendQueryTaskList = async (params?: KlingVideoExtendQueryTaskListParams, options?: RequestInit): Promise<klingVideoExtendQueryTaskListResponse> => {
  
  return customInstance<klingVideoExtendQueryTaskListResponse>(getKlingVideoExtendQueryTaskListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingVideoExtendQueryTaskListQueryKey = (params?: KlingVideoExtendQueryTaskListParams,) => {
    return [
    `/proxy/kling/v1/videos/video-extend`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getKlingVideoExtendQueryTaskListQueryOptions = <TData = Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>, TError = KlingErrorResponse>(params?: KlingVideoExtendQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingVideoExtendQueryTaskListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>> = ({ signal }) => klingVideoExtendQueryTaskList(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingVideoExtendQueryTaskListQueryResult = NonNullable<Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>>
export type KlingVideoExtendQueryTaskListQueryError = KlingErrorResponse


export function useKlingVideoExtendQueryTaskList<TData = Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>, TError = KlingErrorResponse>(
 params: undefined |  KlingVideoExtendQueryTaskListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVideoExtendQueryTaskList<TData = Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingVideoExtendQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
          TError,
          Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVideoExtendQueryTaskList<TData = Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingVideoExtendQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Video-Extend Task List
 */

export function useKlingVideoExtendQueryTaskList<TData = Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>, TError = KlingErrorResponse>(
 params?: KlingVideoExtendQueryTaskListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingVideoExtendQueryTaskListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary KlingAI Extend Video Duration
 */
export type klingExtendVideoResponse200 = {
  data: KlingVideoExtendResponse
  status: 200
}

export type klingExtendVideoResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingExtendVideoResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingExtendVideoResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingExtendVideoResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingExtendVideoResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingExtendVideoResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingExtendVideoResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingExtendVideoResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingExtendVideoResponseSuccess = (klingExtendVideoResponse200) & {
  headers: Headers;
};
export type klingExtendVideoResponseError = (klingExtendVideoResponse400 | klingExtendVideoResponse401 | klingExtendVideoResponse403 | klingExtendVideoResponse404 | klingExtendVideoResponse429 | klingExtendVideoResponse500 | klingExtendVideoResponse503 | klingExtendVideoResponse504) & {
  headers: Headers;
};

export type klingExtendVideoResponse = (klingExtendVideoResponseSuccess | klingExtendVideoResponseError)

export const getKlingExtendVideoUrl = () => {


  

  return `/proxy/kling/v1/videos/video-extend`
}

export const klingExtendVideo = async (klingVideoExtendRequest: KlingVideoExtendRequest, options?: RequestInit): Promise<klingExtendVideoResponse> => {
  
  return customInstance<klingExtendVideoResponse>(getKlingExtendVideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      klingVideoExtendRequest,)
  }
);}




export const getKlingExtendVideoMutationOptions = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingExtendVideo>>, TError,{data: KlingVideoExtendRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof klingExtendVideo>>, TError,{data: KlingVideoExtendRequest}, TContext> => {

const mutationKey = ['klingExtendVideo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof klingExtendVideo>>, {data: KlingVideoExtendRequest}> = (props) => {
          const {data} = props ?? {};

          return  klingExtendVideo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type KlingExtendVideoMutationResult = NonNullable<Awaited<ReturnType<typeof klingExtendVideo>>>
    export type KlingExtendVideoMutationBody = KlingVideoExtendRequest
    export type KlingExtendVideoMutationError = KlingErrorResponse

    /**
 * @summary KlingAI Extend Video Duration
 */
export const useKlingExtendVideo = <TError = KlingErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof klingExtendVideo>>, TError,{data: KlingVideoExtendRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof klingExtendVideo>>,
        TError,
        {data: KlingVideoExtendRequest},
        TContext
      > => {
      return useMutation(getKlingExtendVideoMutationOptions(options), queryClient);
    }
    
/**
 * @summary KlingAI Query Single Video-Extend Task
 */
export type klingVideoExtendQuerySingleTaskResponse200 = {
  data: KlingVideoExtendResponse
  status: 200
}

export type klingVideoExtendQuerySingleTaskResponse400 = {
  data: KlingErrorResponse
  status: 400
}

export type klingVideoExtendQuerySingleTaskResponse401 = {
  data: KlingErrorResponse
  status: 401
}

export type klingVideoExtendQuerySingleTaskResponse403 = {
  data: KlingErrorResponse
  status: 403
}

export type klingVideoExtendQuerySingleTaskResponse404 = {
  data: KlingErrorResponse
  status: 404
}

export type klingVideoExtendQuerySingleTaskResponse429 = {
  data: KlingErrorResponse
  status: 429
}

export type klingVideoExtendQuerySingleTaskResponse500 = {
  data: KlingErrorResponse
  status: 500
}

export type klingVideoExtendQuerySingleTaskResponse503 = {
  data: KlingErrorResponse
  status: 503
}

export type klingVideoExtendQuerySingleTaskResponse504 = {
  data: KlingErrorResponse
  status: 504
}
    
export type klingVideoExtendQuerySingleTaskResponseSuccess = (klingVideoExtendQuerySingleTaskResponse200) & {
  headers: Headers;
};
export type klingVideoExtendQuerySingleTaskResponseError = (klingVideoExtendQuerySingleTaskResponse400 | klingVideoExtendQuerySingleTaskResponse401 | klingVideoExtendQuerySingleTaskResponse403 | klingVideoExtendQuerySingleTaskResponse404 | klingVideoExtendQuerySingleTaskResponse429 | klingVideoExtendQuerySingleTaskResponse500 | klingVideoExtendQuerySingleTaskResponse503 | klingVideoExtendQuerySingleTaskResponse504) & {
  headers: Headers;
};

export type klingVideoExtendQuerySingleTaskResponse = (klingVideoExtendQuerySingleTaskResponseSuccess | klingVideoExtendQuerySingleTaskResponseError)

export const getKlingVideoExtendQuerySingleTaskUrl = (id: string,) => {


  

  return `/proxy/kling/v1/videos/video-extend/${id}`
}

export const klingVideoExtendQuerySingleTask = async (id: string, options?: RequestInit): Promise<klingVideoExtendQuerySingleTaskResponse> => {
  
  return customInstance<klingVideoExtendQuerySingleTaskResponse>(getKlingVideoExtendQuerySingleTaskUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getKlingVideoExtendQuerySingleTaskQueryKey = (id: string,) => {
    return [
    `/proxy/kling/v1/videos/video-extend/${id}`
    ] as const;
    }

    
export const getKlingVideoExtendQuerySingleTaskQueryOptions = <TData = Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>, TError = KlingErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getKlingVideoExtendQuerySingleTaskQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>> = ({ signal }) => klingVideoExtendQuerySingleTask(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type KlingVideoExtendQuerySingleTaskQueryResult = NonNullable<Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>>
export type KlingVideoExtendQuerySingleTaskQueryError = KlingErrorResponse


export function useKlingVideoExtendQuerySingleTask<TData = Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVideoExtendQuerySingleTask<TData = Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
          TError,
          Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useKlingVideoExtendQuerySingleTask<TData = Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary KlingAI Query Single Video-Extend Task
 */

export function useKlingVideoExtendQuerySingleTask<TData = Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>, TError = KlingErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getKlingVideoExtendQuerySingleTaskQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Transform a static image into a dynamic video using LTX Video AI models
 * @summary LTX Video Generate Video from Image
 */
export type ltxCreateVideoFromImageResponse200 = {
  data: Blob
  status: 200
}

export type ltxCreateVideoFromImageResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type ltxCreateVideoFromImageResponseSuccess = (ltxCreateVideoFromImageResponse200) & {
  headers: Headers;
};
export type ltxCreateVideoFromImageResponseError = (ltxCreateVideoFromImageResponseDefault) & {
  headers: Headers;
};

export type ltxCreateVideoFromImageResponse = (ltxCreateVideoFromImageResponseSuccess | ltxCreateVideoFromImageResponseError)

export const getLtxCreateVideoFromImageUrl = () => {


  

  return `/proxy/ltx/v1/image-to-video`
}

export const ltxCreateVideoFromImage = async (lTXImage2VideoRequest: LTXImage2VideoRequest, options?: RequestInit): Promise<ltxCreateVideoFromImageResponse> => {
  
  return customInstance<ltxCreateVideoFromImageResponse>(getLtxCreateVideoFromImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      lTXImage2VideoRequest,)
  }
);}




export const getLtxCreateVideoFromImageMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ltxCreateVideoFromImage>>, TError,{data: LTXImage2VideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ltxCreateVideoFromImage>>, TError,{data: LTXImage2VideoRequest}, TContext> => {

const mutationKey = ['ltxCreateVideoFromImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ltxCreateVideoFromImage>>, {data: LTXImage2VideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  ltxCreateVideoFromImage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LtxCreateVideoFromImageMutationResult = NonNullable<Awaited<ReturnType<typeof ltxCreateVideoFromImage>>>
    export type LtxCreateVideoFromImageMutationBody = LTXImage2VideoRequest
    export type LtxCreateVideoFromImageMutationError = ErrorResponse

    /**
 * @summary LTX Video Generate Video from Image
 */
export const useLtxCreateVideoFromImage = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ltxCreateVideoFromImage>>, TError,{data: LTXImage2VideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ltxCreateVideoFromImage>>,
        TError,
        {data: LTXImage2VideoRequest},
        TContext
      > => {
      return useMutation(getLtxCreateVideoFromImageMutationOptions(options), queryClient);
    }
    
/**
 * Generate a video from a text prompt using LTX Video AI models
 * @summary LTX Video Generate Video from Text
 */
export type ltxCreateVideoFromTextResponse200 = {
  data: Blob
  status: 200
}

export type ltxCreateVideoFromTextResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type ltxCreateVideoFromTextResponseSuccess = (ltxCreateVideoFromTextResponse200) & {
  headers: Headers;
};
export type ltxCreateVideoFromTextResponseError = (ltxCreateVideoFromTextResponseDefault) & {
  headers: Headers;
};

export type ltxCreateVideoFromTextResponse = (ltxCreateVideoFromTextResponseSuccess | ltxCreateVideoFromTextResponseError)

export const getLtxCreateVideoFromTextUrl = () => {


  

  return `/proxy/ltx/v1/text-to-video`
}

export const ltxCreateVideoFromText = async (lTXText2VideoRequest: LTXText2VideoRequest, options?: RequestInit): Promise<ltxCreateVideoFromTextResponse> => {
  
  return customInstance<ltxCreateVideoFromTextResponse>(getLtxCreateVideoFromTextUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      lTXText2VideoRequest,)
  }
);}




export const getLtxCreateVideoFromTextMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ltxCreateVideoFromText>>, TError,{data: LTXText2VideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ltxCreateVideoFromText>>, TError,{data: LTXText2VideoRequest}, TContext> => {

const mutationKey = ['ltxCreateVideoFromText'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ltxCreateVideoFromText>>, {data: LTXText2VideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  ltxCreateVideoFromText(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LtxCreateVideoFromTextMutationResult = NonNullable<Awaited<ReturnType<typeof ltxCreateVideoFromText>>>
    export type LtxCreateVideoFromTextMutationBody = LTXText2VideoRequest
    export type LtxCreateVideoFromTextMutationError = ErrorResponse

    /**
 * @summary LTX Video Generate Video from Text
 */
export const useLtxCreateVideoFromText = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ltxCreateVideoFromText>>, TError,{data: LTXText2VideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ltxCreateVideoFromText>>,
        TError,
        {data: LTXText2VideoRequest},
        TContext
      > => {
      return useMutation(getLtxCreateVideoFromTextMutationOptions(options), queryClient);
    }
    
/**
 * Initiate a new generation with the provided prompt
 * @summary Create a generation
 */
export type lumaCreateGenerationResponse201 = {
  data: LumaGeneration
  status: 201
}

export type lumaCreateGenerationResponseDefault = {
  data: LumaError
  status: Exclude<HTTPStatusCodes, 201>
}
    
export type lumaCreateGenerationResponseSuccess = (lumaCreateGenerationResponse201) & {
  headers: Headers;
};
export type lumaCreateGenerationResponseError = (lumaCreateGenerationResponseDefault) & {
  headers: Headers;
};

export type lumaCreateGenerationResponse = (lumaCreateGenerationResponseSuccess | lumaCreateGenerationResponseError)

export const getLumaCreateGenerationUrl = () => {


  

  return `/proxy/luma/generations`
}

export const lumaCreateGeneration = async (lumaGenerationRequest: LumaGenerationRequest, options?: RequestInit): Promise<lumaCreateGenerationResponse> => {
  
  return customInstance<lumaCreateGenerationResponse>(getLumaCreateGenerationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      lumaGenerationRequest,)
  }
);}




export const getLumaCreateGenerationMutationOptions = <TError = LumaError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lumaCreateGeneration>>, TError,{data: LumaGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof lumaCreateGeneration>>, TError,{data: LumaGenerationRequest}, TContext> => {

const mutationKey = ['lumaCreateGeneration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lumaCreateGeneration>>, {data: LumaGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  lumaCreateGeneration(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LumaCreateGenerationMutationResult = NonNullable<Awaited<ReturnType<typeof lumaCreateGeneration>>>
    export type LumaCreateGenerationMutationBody = LumaGenerationRequest
    export type LumaCreateGenerationMutationError = LumaError

    /**
 * @summary Create a generation
 */
export const useLumaCreateGeneration = <TError = LumaError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lumaCreateGeneration>>, TError,{data: LumaGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lumaCreateGeneration>>,
        TError,
        {data: LumaGenerationRequest},
        TContext
      > => {
      return useMutation(getLumaCreateGenerationMutationOptions(options), queryClient);
    }
    
/**
 * Generate an image with the provided prompt
 * @summary Generate an image
 */
export type lumaGenerateImageResponse201 = {
  data: LumaGeneration
  status: 201
}

export type lumaGenerateImageResponseDefault = {
  data: LumaError
  status: Exclude<HTTPStatusCodes, 201>
}
    
export type lumaGenerateImageResponseSuccess = (lumaGenerateImageResponse201) & {
  headers: Headers;
};
export type lumaGenerateImageResponseError = (lumaGenerateImageResponseDefault) & {
  headers: Headers;
};

export type lumaGenerateImageResponse = (lumaGenerateImageResponseSuccess | lumaGenerateImageResponseError)

export const getLumaGenerateImageUrl = () => {


  

  return `/proxy/luma/generations/image`
}

export const lumaGenerateImage = async (lumaImageGenerationRequest: LumaImageGenerationRequest, options?: RequestInit): Promise<lumaGenerateImageResponse> => {
  
  return customInstance<lumaGenerateImageResponse>(getLumaGenerateImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      lumaImageGenerationRequest,)
  }
);}




export const getLumaGenerateImageMutationOptions = <TError = LumaError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lumaGenerateImage>>, TError,{data: LumaImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof lumaGenerateImage>>, TError,{data: LumaImageGenerationRequest}, TContext> => {

const mutationKey = ['lumaGenerateImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lumaGenerateImage>>, {data: LumaImageGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  lumaGenerateImage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LumaGenerateImageMutationResult = NonNullable<Awaited<ReturnType<typeof lumaGenerateImage>>>
    export type LumaGenerateImageMutationBody = LumaImageGenerationRequest
    export type LumaGenerateImageMutationError = LumaError

    /**
 * @summary Generate an image
 */
export const useLumaGenerateImage = <TError = LumaError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lumaGenerateImage>>, TError,{data: LumaImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lumaGenerateImage>>,
        TError,
        {data: LumaImageGenerationRequest},
        TContext
      > => {
      return useMutation(getLumaGenerateImageMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve details of a specific generation by its ID
 * @summary Get a generation
 */
export type lumaGetGenerationResponse200 = {
  data: LumaGeneration
  status: 200
}

export type lumaGetGenerationResponseDefault = {
  data: LumaError
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type lumaGetGenerationResponseSuccess = (lumaGetGenerationResponse200) & {
  headers: Headers;
};
export type lumaGetGenerationResponseError = (lumaGetGenerationResponseDefault) & {
  headers: Headers;
};

export type lumaGetGenerationResponse = (lumaGetGenerationResponseSuccess | lumaGetGenerationResponseError)

export const getLumaGetGenerationUrl = (id: string,) => {


  

  return `/proxy/luma/generations/${id}`
}

export const lumaGetGeneration = async (id: string, options?: RequestInit): Promise<lumaGetGenerationResponse> => {
  
  return customInstance<lumaGetGenerationResponse>(getLumaGetGenerationUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getLumaGetGenerationQueryKey = (id: string,) => {
    return [
    `/proxy/luma/generations/${id}`
    ] as const;
    }

    
export const getLumaGetGenerationQueryOptions = <TData = Awaited<ReturnType<typeof lumaGetGeneration>>, TError = LumaError>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lumaGetGeneration>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLumaGetGenerationQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lumaGetGeneration>>> = ({ signal }) => lumaGetGeneration(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lumaGetGeneration>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LumaGetGenerationQueryResult = NonNullable<Awaited<ReturnType<typeof lumaGetGeneration>>>
export type LumaGetGenerationQueryError = LumaError


export function useLumaGetGeneration<TData = Awaited<ReturnType<typeof lumaGetGeneration>>, TError = LumaError>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof lumaGetGeneration>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lumaGetGeneration>>,
          TError,
          Awaited<ReturnType<typeof lumaGetGeneration>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLumaGetGeneration<TData = Awaited<ReturnType<typeof lumaGetGeneration>>, TError = LumaError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lumaGetGeneration>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lumaGetGeneration>>,
          TError,
          Awaited<ReturnType<typeof lumaGetGeneration>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLumaGetGeneration<TData = Awaited<ReturnType<typeof lumaGetGeneration>>, TError = LumaError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lumaGetGeneration>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a generation
 */

export function useLumaGetGeneration<TData = Awaited<ReturnType<typeof lumaGetGeneration>>, TError = LumaError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lumaGetGeneration>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLumaGetGenerationQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Create a new task to apply a specific animation action to a previously rigged character. Includes post-processing options.

 * @summary Create an Animation Task
 */
export type meshyAnimationCreateResponse200 = {
  data: MeshyAnimationCreateResponse
  status: 200
}

export type meshyAnimationCreateResponse400 = {
  data: Error
  status: 400
}

export type meshyAnimationCreateResponse401 = {
  data: Error
  status: 401
}

export type meshyAnimationCreateResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400 | 401>
}
    
export type meshyAnimationCreateResponseSuccess = (meshyAnimationCreateResponse200) & {
  headers: Headers;
};
export type meshyAnimationCreateResponseError = (meshyAnimationCreateResponse400 | meshyAnimationCreateResponse401 | meshyAnimationCreateResponseDefault) & {
  headers: Headers;
};

export type meshyAnimationCreateResponse = (meshyAnimationCreateResponseSuccess | meshyAnimationCreateResponseError)

export const getMeshyAnimationCreateUrl = () => {


  

  return `/proxy/meshy/openapi/v1/animations`
}

export const meshyAnimationCreate = async (meshyAnimationRequest: MeshyAnimationRequest, options?: RequestInit): Promise<meshyAnimationCreateResponse> => {
  
  return customInstance<meshyAnimationCreateResponse>(getMeshyAnimationCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      meshyAnimationRequest,)
  }
);}




export const getMeshyAnimationCreateMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyAnimationCreate>>, TError,{data: MeshyAnimationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof meshyAnimationCreate>>, TError,{data: MeshyAnimationRequest}, TContext> => {

const mutationKey = ['meshyAnimationCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof meshyAnimationCreate>>, {data: MeshyAnimationRequest}> = (props) => {
          const {data} = props ?? {};

          return  meshyAnimationCreate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MeshyAnimationCreateMutationResult = NonNullable<Awaited<ReturnType<typeof meshyAnimationCreate>>>
    export type MeshyAnimationCreateMutationBody = MeshyAnimationRequest
    export type MeshyAnimationCreateMutationError = Error

    /**
 * @summary Create an Animation Task
 */
export const useMeshyAnimationCreate = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyAnimationCreate>>, TError,{data: MeshyAnimationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof meshyAnimationCreate>>,
        TError,
        {data: MeshyAnimationRequest},
        TContext
      > => {
      return useMutation(getMeshyAnimationCreateMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve the status and result of an Animation task.
 * @summary Get Animation Task Status
 */
export type meshyAnimationGetTaskResponse200 = {
  data: MeshyAnimationTask
  status: 200
}

export type meshyAnimationGetTaskResponse404 = {
  data: Error
  status: 404
}

export type meshyAnimationGetTaskResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 404>
}
    
export type meshyAnimationGetTaskResponseSuccess = (meshyAnimationGetTaskResponse200) & {
  headers: Headers;
};
export type meshyAnimationGetTaskResponseError = (meshyAnimationGetTaskResponse404 | meshyAnimationGetTaskResponseDefault) & {
  headers: Headers;
};

export type meshyAnimationGetTaskResponse = (meshyAnimationGetTaskResponseSuccess | meshyAnimationGetTaskResponseError)

export const getMeshyAnimationGetTaskUrl = (taskId: string,) => {


  

  return `/proxy/meshy/openapi/v1/animations/${taskId}`
}

export const meshyAnimationGetTask = async (taskId: string, options?: RequestInit): Promise<meshyAnimationGetTaskResponse> => {
  
  return customInstance<meshyAnimationGetTaskResponse>(getMeshyAnimationGetTaskUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getMeshyAnimationGetTaskQueryKey = (taskId: string,) => {
    return [
    `/proxy/meshy/openapi/v1/animations/${taskId}`
    ] as const;
    }

    
export const getMeshyAnimationGetTaskQueryOptions = <TData = Awaited<ReturnType<typeof meshyAnimationGetTask>>, TError = Error>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyAnimationGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMeshyAnimationGetTaskQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof meshyAnimationGetTask>>> = ({ signal }) => meshyAnimationGetTask(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof meshyAnimationGetTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeshyAnimationGetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof meshyAnimationGetTask>>>
export type MeshyAnimationGetTaskQueryError = Error


export function useMeshyAnimationGetTask<TData = Awaited<ReturnType<typeof meshyAnimationGetTask>>, TError = Error>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyAnimationGetTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyAnimationGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyAnimationGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyAnimationGetTask<TData = Awaited<ReturnType<typeof meshyAnimationGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyAnimationGetTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyAnimationGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyAnimationGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyAnimationGetTask<TData = Awaited<ReturnType<typeof meshyAnimationGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyAnimationGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Animation Task Status
 */

export function useMeshyAnimationGetTask<TData = Awaited<ReturnType<typeof meshyAnimationGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyAnimationGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMeshyAnimationGetTaskQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Create a new Image to 3D task. This task generates a 3D model from an image input.

 * @summary Create an Image to 3D Task
 */
export type meshyImageTo3DCreateResponse200 = {
  data: MeshyImageTo3DCreateResponse
  status: 200
}

export type meshyImageTo3DCreateResponse400 = {
  data: Error
  status: 400
}

export type meshyImageTo3DCreateResponse401 = {
  data: Error
  status: 401
}

export type meshyImageTo3DCreateResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400 | 401>
}
    
export type meshyImageTo3DCreateResponseSuccess = (meshyImageTo3DCreateResponse200) & {
  headers: Headers;
};
export type meshyImageTo3DCreateResponseError = (meshyImageTo3DCreateResponse400 | meshyImageTo3DCreateResponse401 | meshyImageTo3DCreateResponseDefault) & {
  headers: Headers;
};

export type meshyImageTo3DCreateResponse = (meshyImageTo3DCreateResponseSuccess | meshyImageTo3DCreateResponseError)

export const getMeshyImageTo3DCreateUrl = () => {


  

  return `/proxy/meshy/openapi/v1/image-to-3d`
}

export const meshyImageTo3DCreate = async (meshyImageTo3DRequest: MeshyImageTo3DRequest, options?: RequestInit): Promise<meshyImageTo3DCreateResponse> => {
  
  return customInstance<meshyImageTo3DCreateResponse>(getMeshyImageTo3DCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      meshyImageTo3DRequest,)
  }
);}




export const getMeshyImageTo3DCreateMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyImageTo3DCreate>>, TError,{data: MeshyImageTo3DRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof meshyImageTo3DCreate>>, TError,{data: MeshyImageTo3DRequest}, TContext> => {

const mutationKey = ['meshyImageTo3DCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof meshyImageTo3DCreate>>, {data: MeshyImageTo3DRequest}> = (props) => {
          const {data} = props ?? {};

          return  meshyImageTo3DCreate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MeshyImageTo3DCreateMutationResult = NonNullable<Awaited<ReturnType<typeof meshyImageTo3DCreate>>>
    export type MeshyImageTo3DCreateMutationBody = MeshyImageTo3DRequest
    export type MeshyImageTo3DCreateMutationError = Error

    /**
 * @summary Create an Image to 3D Task
 */
export const useMeshyImageTo3DCreate = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyImageTo3DCreate>>, TError,{data: MeshyImageTo3DRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof meshyImageTo3DCreate>>,
        TError,
        {data: MeshyImageTo3DRequest},
        TContext
      > => {
      return useMutation(getMeshyImageTo3DCreateMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve the status and result of an Image to 3D task.
 * @summary Get Image to 3D Task Status
 */
export type meshyImageTo3DGetTaskResponse200 = {
  data: MeshyImageTo3DTask
  status: 200
}

export type meshyImageTo3DGetTaskResponse404 = {
  data: Error
  status: 404
}

export type meshyImageTo3DGetTaskResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 404>
}
    
export type meshyImageTo3DGetTaskResponseSuccess = (meshyImageTo3DGetTaskResponse200) & {
  headers: Headers;
};
export type meshyImageTo3DGetTaskResponseError = (meshyImageTo3DGetTaskResponse404 | meshyImageTo3DGetTaskResponseDefault) & {
  headers: Headers;
};

export type meshyImageTo3DGetTaskResponse = (meshyImageTo3DGetTaskResponseSuccess | meshyImageTo3DGetTaskResponseError)

export const getMeshyImageTo3DGetTaskUrl = (taskId: string,) => {


  

  return `/proxy/meshy/openapi/v1/image-to-3d/${taskId}`
}

export const meshyImageTo3DGetTask = async (taskId: string, options?: RequestInit): Promise<meshyImageTo3DGetTaskResponse> => {
  
  return customInstance<meshyImageTo3DGetTaskResponse>(getMeshyImageTo3DGetTaskUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getMeshyImageTo3DGetTaskQueryKey = (taskId: string,) => {
    return [
    `/proxy/meshy/openapi/v1/image-to-3d/${taskId}`
    ] as const;
    }

    
export const getMeshyImageTo3DGetTaskQueryOptions = <TData = Awaited<ReturnType<typeof meshyImageTo3DGetTask>>, TError = Error>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyImageTo3DGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMeshyImageTo3DGetTaskQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof meshyImageTo3DGetTask>>> = ({ signal }) => meshyImageTo3DGetTask(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof meshyImageTo3DGetTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeshyImageTo3DGetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof meshyImageTo3DGetTask>>>
export type MeshyImageTo3DGetTaskQueryError = Error


export function useMeshyImageTo3DGetTask<TData = Awaited<ReturnType<typeof meshyImageTo3DGetTask>>, TError = Error>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyImageTo3DGetTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyImageTo3DGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyImageTo3DGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyImageTo3DGetTask<TData = Awaited<ReturnType<typeof meshyImageTo3DGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyImageTo3DGetTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyImageTo3DGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyImageTo3DGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyImageTo3DGetTask<TData = Awaited<ReturnType<typeof meshyImageTo3DGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyImageTo3DGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Image to 3D Task Status
 */

export function useMeshyImageTo3DGetTask<TData = Awaited<ReturnType<typeof meshyImageTo3DGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyImageTo3DGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMeshyImageTo3DGetTaskQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Create a new Multi-Image to 3D task. This task generates a 3D model from 1 to 4 images of the same object from different angles.
Mesh generation uses Meshy-5 model, while texture generation supports Meshy-6-preview model.

 * @summary Create a Multi-Image to 3D Task
 */
export type meshyMultiImageTo3DCreateResponse200 = {
  data: MeshyMultiImageTo3DCreateResponse
  status: 200
}

export type meshyMultiImageTo3DCreateResponse400 = {
  data: Error
  status: 400
}

export type meshyMultiImageTo3DCreateResponse401 = {
  data: Error
  status: 401
}

export type meshyMultiImageTo3DCreateResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400 | 401>
}
    
export type meshyMultiImageTo3DCreateResponseSuccess = (meshyMultiImageTo3DCreateResponse200) & {
  headers: Headers;
};
export type meshyMultiImageTo3DCreateResponseError = (meshyMultiImageTo3DCreateResponse400 | meshyMultiImageTo3DCreateResponse401 | meshyMultiImageTo3DCreateResponseDefault) & {
  headers: Headers;
};

export type meshyMultiImageTo3DCreateResponse = (meshyMultiImageTo3DCreateResponseSuccess | meshyMultiImageTo3DCreateResponseError)

export const getMeshyMultiImageTo3DCreateUrl = () => {


  

  return `/proxy/meshy/openapi/v1/multi-image-to-3d`
}

export const meshyMultiImageTo3DCreate = async (meshyMultiImageTo3DRequest: MeshyMultiImageTo3DRequest, options?: RequestInit): Promise<meshyMultiImageTo3DCreateResponse> => {
  
  return customInstance<meshyMultiImageTo3DCreateResponse>(getMeshyMultiImageTo3DCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      meshyMultiImageTo3DRequest,)
  }
);}




export const getMeshyMultiImageTo3DCreateMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyMultiImageTo3DCreate>>, TError,{data: MeshyMultiImageTo3DRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof meshyMultiImageTo3DCreate>>, TError,{data: MeshyMultiImageTo3DRequest}, TContext> => {

const mutationKey = ['meshyMultiImageTo3DCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof meshyMultiImageTo3DCreate>>, {data: MeshyMultiImageTo3DRequest}> = (props) => {
          const {data} = props ?? {};

          return  meshyMultiImageTo3DCreate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MeshyMultiImageTo3DCreateMutationResult = NonNullable<Awaited<ReturnType<typeof meshyMultiImageTo3DCreate>>>
    export type MeshyMultiImageTo3DCreateMutationBody = MeshyMultiImageTo3DRequest
    export type MeshyMultiImageTo3DCreateMutationError = Error

    /**
 * @summary Create a Multi-Image to 3D Task
 */
export const useMeshyMultiImageTo3DCreate = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyMultiImageTo3DCreate>>, TError,{data: MeshyMultiImageTo3DRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof meshyMultiImageTo3DCreate>>,
        TError,
        {data: MeshyMultiImageTo3DRequest},
        TContext
      > => {
      return useMutation(getMeshyMultiImageTo3DCreateMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve the status and result of a Multi-Image to 3D task.
 * @summary Get Multi-Image to 3D Task Status
 */
export type meshyMultiImageTo3DGetTaskResponse200 = {
  data: MeshyMultiImageTo3DTask
  status: 200
}

export type meshyMultiImageTo3DGetTaskResponse404 = {
  data: Error
  status: 404
}

export type meshyMultiImageTo3DGetTaskResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 404>
}
    
export type meshyMultiImageTo3DGetTaskResponseSuccess = (meshyMultiImageTo3DGetTaskResponse200) & {
  headers: Headers;
};
export type meshyMultiImageTo3DGetTaskResponseError = (meshyMultiImageTo3DGetTaskResponse404 | meshyMultiImageTo3DGetTaskResponseDefault) & {
  headers: Headers;
};

export type meshyMultiImageTo3DGetTaskResponse = (meshyMultiImageTo3DGetTaskResponseSuccess | meshyMultiImageTo3DGetTaskResponseError)

export const getMeshyMultiImageTo3DGetTaskUrl = (taskId: string,) => {


  

  return `/proxy/meshy/openapi/v1/multi-image-to-3d/${taskId}`
}

export const meshyMultiImageTo3DGetTask = async (taskId: string, options?: RequestInit): Promise<meshyMultiImageTo3DGetTaskResponse> => {
  
  return customInstance<meshyMultiImageTo3DGetTaskResponse>(getMeshyMultiImageTo3DGetTaskUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getMeshyMultiImageTo3DGetTaskQueryKey = (taskId: string,) => {
    return [
    `/proxy/meshy/openapi/v1/multi-image-to-3d/${taskId}`
    ] as const;
    }

    
export const getMeshyMultiImageTo3DGetTaskQueryOptions = <TData = Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>, TError = Error>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMeshyMultiImageTo3DGetTaskQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>> = ({ signal }) => meshyMultiImageTo3DGetTask(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeshyMultiImageTo3DGetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>>
export type MeshyMultiImageTo3DGetTaskQueryError = Error


export function useMeshyMultiImageTo3DGetTask<TData = Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>, TError = Error>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyMultiImageTo3DGetTask<TData = Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyMultiImageTo3DGetTask<TData = Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Multi-Image to 3D Task Status
 */

export function useMeshyMultiImageTo3DGetTask<TData = Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyMultiImageTo3DGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMeshyMultiImageTo3DGetTaskQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Create a new remesh task to remesh and export an existing 3D model into various formats.

 * @summary Create a Remesh Task
 */
export type meshyRemeshCreateResponse200 = {
  data: MeshyRemeshCreateResponse
  status: 200
}

export type meshyRemeshCreateResponse400 = {
  data: Error
  status: 400
}

export type meshyRemeshCreateResponse401 = {
  data: Error
  status: 401
}

export type meshyRemeshCreateResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400 | 401>
}
    
export type meshyRemeshCreateResponseSuccess = (meshyRemeshCreateResponse200) & {
  headers: Headers;
};
export type meshyRemeshCreateResponseError = (meshyRemeshCreateResponse400 | meshyRemeshCreateResponse401 | meshyRemeshCreateResponseDefault) & {
  headers: Headers;
};

export type meshyRemeshCreateResponse = (meshyRemeshCreateResponseSuccess | meshyRemeshCreateResponseError)

export const getMeshyRemeshCreateUrl = () => {


  

  return `/proxy/meshy/openapi/v1/remesh`
}

export const meshyRemeshCreate = async (meshyRemeshRequest: MeshyRemeshRequest, options?: RequestInit): Promise<meshyRemeshCreateResponse> => {
  
  return customInstance<meshyRemeshCreateResponse>(getMeshyRemeshCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      meshyRemeshRequest,)
  }
);}




export const getMeshyRemeshCreateMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyRemeshCreate>>, TError,{data: MeshyRemeshRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof meshyRemeshCreate>>, TError,{data: MeshyRemeshRequest}, TContext> => {

const mutationKey = ['meshyRemeshCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof meshyRemeshCreate>>, {data: MeshyRemeshRequest}> = (props) => {
          const {data} = props ?? {};

          return  meshyRemeshCreate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MeshyRemeshCreateMutationResult = NonNullable<Awaited<ReturnType<typeof meshyRemeshCreate>>>
    export type MeshyRemeshCreateMutationBody = MeshyRemeshRequest
    export type MeshyRemeshCreateMutationError = Error

    /**
 * @summary Create a Remesh Task
 */
export const useMeshyRemeshCreate = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyRemeshCreate>>, TError,{data: MeshyRemeshRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof meshyRemeshCreate>>,
        TError,
        {data: MeshyRemeshRequest},
        TContext
      > => {
      return useMutation(getMeshyRemeshCreateMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve the status and result of a Remesh task.
 * @summary Get Remesh Task Status
 */
export type meshyRemeshGetTaskResponse200 = {
  data: MeshyRemeshTask
  status: 200
}

export type meshyRemeshGetTaskResponse404 = {
  data: Error
  status: 404
}

export type meshyRemeshGetTaskResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 404>
}
    
export type meshyRemeshGetTaskResponseSuccess = (meshyRemeshGetTaskResponse200) & {
  headers: Headers;
};
export type meshyRemeshGetTaskResponseError = (meshyRemeshGetTaskResponse404 | meshyRemeshGetTaskResponseDefault) & {
  headers: Headers;
};

export type meshyRemeshGetTaskResponse = (meshyRemeshGetTaskResponseSuccess | meshyRemeshGetTaskResponseError)

export const getMeshyRemeshGetTaskUrl = (taskId: string,) => {


  

  return `/proxy/meshy/openapi/v1/remesh/${taskId}`
}

export const meshyRemeshGetTask = async (taskId: string, options?: RequestInit): Promise<meshyRemeshGetTaskResponse> => {
  
  return customInstance<meshyRemeshGetTaskResponse>(getMeshyRemeshGetTaskUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getMeshyRemeshGetTaskQueryKey = (taskId: string,) => {
    return [
    `/proxy/meshy/openapi/v1/remesh/${taskId}`
    ] as const;
    }

    
export const getMeshyRemeshGetTaskQueryOptions = <TData = Awaited<ReturnType<typeof meshyRemeshGetTask>>, TError = Error>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRemeshGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMeshyRemeshGetTaskQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof meshyRemeshGetTask>>> = ({ signal }) => meshyRemeshGetTask(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof meshyRemeshGetTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeshyRemeshGetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof meshyRemeshGetTask>>>
export type MeshyRemeshGetTaskQueryError = Error


export function useMeshyRemeshGetTask<TData = Awaited<ReturnType<typeof meshyRemeshGetTask>>, TError = Error>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRemeshGetTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyRemeshGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyRemeshGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyRemeshGetTask<TData = Awaited<ReturnType<typeof meshyRemeshGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRemeshGetTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyRemeshGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyRemeshGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyRemeshGetTask<TData = Awaited<ReturnType<typeof meshyRemeshGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRemeshGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Remesh Task Status
 */

export function useMeshyRemeshGetTask<TData = Awaited<ReturnType<typeof meshyRemeshGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRemeshGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMeshyRemeshGetTaskQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Create a new Retexture task to generate 3D texture from text or image inputs.

 * @summary Create a Retexture Task
 */
export type meshyRetextureCreateResponse200 = {
  data: MeshyRetextureCreateResponse
  status: 200
}

export type meshyRetextureCreateResponse400 = {
  data: Error
  status: 400
}

export type meshyRetextureCreateResponse401 = {
  data: Error
  status: 401
}

export type meshyRetextureCreateResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400 | 401>
}
    
export type meshyRetextureCreateResponseSuccess = (meshyRetextureCreateResponse200) & {
  headers: Headers;
};
export type meshyRetextureCreateResponseError = (meshyRetextureCreateResponse400 | meshyRetextureCreateResponse401 | meshyRetextureCreateResponseDefault) & {
  headers: Headers;
};

export type meshyRetextureCreateResponse = (meshyRetextureCreateResponseSuccess | meshyRetextureCreateResponseError)

export const getMeshyRetextureCreateUrl = () => {


  

  return `/proxy/meshy/openapi/v1/retexture`
}

export const meshyRetextureCreate = async (meshyRetextureRequest: MeshyRetextureRequest, options?: RequestInit): Promise<meshyRetextureCreateResponse> => {
  
  return customInstance<meshyRetextureCreateResponse>(getMeshyRetextureCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      meshyRetextureRequest,)
  }
);}




export const getMeshyRetextureCreateMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyRetextureCreate>>, TError,{data: MeshyRetextureRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof meshyRetextureCreate>>, TError,{data: MeshyRetextureRequest}, TContext> => {

const mutationKey = ['meshyRetextureCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof meshyRetextureCreate>>, {data: MeshyRetextureRequest}> = (props) => {
          const {data} = props ?? {};

          return  meshyRetextureCreate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MeshyRetextureCreateMutationResult = NonNullable<Awaited<ReturnType<typeof meshyRetextureCreate>>>
    export type MeshyRetextureCreateMutationBody = MeshyRetextureRequest
    export type MeshyRetextureCreateMutationError = Error

    /**
 * @summary Create a Retexture Task
 */
export const useMeshyRetextureCreate = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyRetextureCreate>>, TError,{data: MeshyRetextureRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof meshyRetextureCreate>>,
        TError,
        {data: MeshyRetextureRequest},
        TContext
      > => {
      return useMutation(getMeshyRetextureCreateMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve the status and result of a Retexture task.
 * @summary Get Retexture Task Status
 */
export type meshyRetextureGetTaskResponse200 = {
  data: MeshyRetextureTask
  status: 200
}

export type meshyRetextureGetTaskResponse404 = {
  data: Error
  status: 404
}

export type meshyRetextureGetTaskResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 404>
}
    
export type meshyRetextureGetTaskResponseSuccess = (meshyRetextureGetTaskResponse200) & {
  headers: Headers;
};
export type meshyRetextureGetTaskResponseError = (meshyRetextureGetTaskResponse404 | meshyRetextureGetTaskResponseDefault) & {
  headers: Headers;
};

export type meshyRetextureGetTaskResponse = (meshyRetextureGetTaskResponseSuccess | meshyRetextureGetTaskResponseError)

export const getMeshyRetextureGetTaskUrl = (taskId: string,) => {


  

  return `/proxy/meshy/openapi/v1/retexture/${taskId}`
}

export const meshyRetextureGetTask = async (taskId: string, options?: RequestInit): Promise<meshyRetextureGetTaskResponse> => {
  
  return customInstance<meshyRetextureGetTaskResponse>(getMeshyRetextureGetTaskUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getMeshyRetextureGetTaskQueryKey = (taskId: string,) => {
    return [
    `/proxy/meshy/openapi/v1/retexture/${taskId}`
    ] as const;
    }

    
export const getMeshyRetextureGetTaskQueryOptions = <TData = Awaited<ReturnType<typeof meshyRetextureGetTask>>, TError = Error>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRetextureGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMeshyRetextureGetTaskQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof meshyRetextureGetTask>>> = ({ signal }) => meshyRetextureGetTask(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof meshyRetextureGetTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeshyRetextureGetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof meshyRetextureGetTask>>>
export type MeshyRetextureGetTaskQueryError = Error


export function useMeshyRetextureGetTask<TData = Awaited<ReturnType<typeof meshyRetextureGetTask>>, TError = Error>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRetextureGetTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyRetextureGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyRetextureGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyRetextureGetTask<TData = Awaited<ReturnType<typeof meshyRetextureGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRetextureGetTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyRetextureGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyRetextureGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyRetextureGetTask<TData = Awaited<ReturnType<typeof meshyRetextureGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRetextureGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Retexture Task Status
 */

export function useMeshyRetextureGetTask<TData = Awaited<ReturnType<typeof meshyRetextureGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRetextureGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMeshyRetextureGetTaskQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Create a new rigging task for a given 3D model. Upon successful completion, provides a rigged character in standard formats and optionally basic walking/running animations.

 * @summary Create a Rigging Task
 */
export type meshyRiggingCreateResponse200 = {
  data: MeshyRiggingCreateResponse
  status: 200
}

export type meshyRiggingCreateResponse400 = {
  data: Error
  status: 400
}

export type meshyRiggingCreateResponse401 = {
  data: Error
  status: 401
}

export type meshyRiggingCreateResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400 | 401>
}
    
export type meshyRiggingCreateResponseSuccess = (meshyRiggingCreateResponse200) & {
  headers: Headers;
};
export type meshyRiggingCreateResponseError = (meshyRiggingCreateResponse400 | meshyRiggingCreateResponse401 | meshyRiggingCreateResponseDefault) & {
  headers: Headers;
};

export type meshyRiggingCreateResponse = (meshyRiggingCreateResponseSuccess | meshyRiggingCreateResponseError)

export const getMeshyRiggingCreateUrl = () => {


  

  return `/proxy/meshy/openapi/v1/rigging`
}

export const meshyRiggingCreate = async (meshyRiggingRequest: MeshyRiggingRequest, options?: RequestInit): Promise<meshyRiggingCreateResponse> => {
  
  return customInstance<meshyRiggingCreateResponse>(getMeshyRiggingCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      meshyRiggingRequest,)
  }
);}




export const getMeshyRiggingCreateMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyRiggingCreate>>, TError,{data: MeshyRiggingRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof meshyRiggingCreate>>, TError,{data: MeshyRiggingRequest}, TContext> => {

const mutationKey = ['meshyRiggingCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof meshyRiggingCreate>>, {data: MeshyRiggingRequest}> = (props) => {
          const {data} = props ?? {};

          return  meshyRiggingCreate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MeshyRiggingCreateMutationResult = NonNullable<Awaited<ReturnType<typeof meshyRiggingCreate>>>
    export type MeshyRiggingCreateMutationBody = MeshyRiggingRequest
    export type MeshyRiggingCreateMutationError = Error

    /**
 * @summary Create a Rigging Task
 */
export const useMeshyRiggingCreate = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyRiggingCreate>>, TError,{data: MeshyRiggingRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof meshyRiggingCreate>>,
        TError,
        {data: MeshyRiggingRequest},
        TContext
      > => {
      return useMutation(getMeshyRiggingCreateMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve the status and result of a Rigging task.
 * @summary Get Rigging Task Status
 */
export type meshyRiggingGetTaskResponse200 = {
  data: MeshyRiggingTask
  status: 200
}

export type meshyRiggingGetTaskResponse404 = {
  data: Error
  status: 404
}

export type meshyRiggingGetTaskResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 404>
}
    
export type meshyRiggingGetTaskResponseSuccess = (meshyRiggingGetTaskResponse200) & {
  headers: Headers;
};
export type meshyRiggingGetTaskResponseError = (meshyRiggingGetTaskResponse404 | meshyRiggingGetTaskResponseDefault) & {
  headers: Headers;
};

export type meshyRiggingGetTaskResponse = (meshyRiggingGetTaskResponseSuccess | meshyRiggingGetTaskResponseError)

export const getMeshyRiggingGetTaskUrl = (taskId: string,) => {


  

  return `/proxy/meshy/openapi/v1/rigging/${taskId}`
}

export const meshyRiggingGetTask = async (taskId: string, options?: RequestInit): Promise<meshyRiggingGetTaskResponse> => {
  
  return customInstance<meshyRiggingGetTaskResponse>(getMeshyRiggingGetTaskUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getMeshyRiggingGetTaskQueryKey = (taskId: string,) => {
    return [
    `/proxy/meshy/openapi/v1/rigging/${taskId}`
    ] as const;
    }

    
export const getMeshyRiggingGetTaskQueryOptions = <TData = Awaited<ReturnType<typeof meshyRiggingGetTask>>, TError = Error>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRiggingGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMeshyRiggingGetTaskQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof meshyRiggingGetTask>>> = ({ signal }) => meshyRiggingGetTask(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof meshyRiggingGetTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeshyRiggingGetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof meshyRiggingGetTask>>>
export type MeshyRiggingGetTaskQueryError = Error


export function useMeshyRiggingGetTask<TData = Awaited<ReturnType<typeof meshyRiggingGetTask>>, TError = Error>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRiggingGetTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyRiggingGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyRiggingGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyRiggingGetTask<TData = Awaited<ReturnType<typeof meshyRiggingGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRiggingGetTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyRiggingGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyRiggingGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyRiggingGetTask<TData = Awaited<ReturnType<typeof meshyRiggingGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRiggingGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Rigging Task Status
 */

export function useMeshyRiggingGetTask<TData = Awaited<ReturnType<typeof meshyRiggingGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyRiggingGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMeshyRiggingGetTaskQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Create a new Text to 3D Preview task. This task costs 20 credits for Meshy-6 models and 5 credits for other models.

 * @summary Create a Text to 3D Preview Task
 */
export type meshyTextTo3DCreateResponse200 = {
  data: MeshyTextTo3DCreateResponse
  status: 200
}

export type meshyTextTo3DCreateResponse400 = {
  data: Error
  status: 400
}

export type meshyTextTo3DCreateResponse401 = {
  data: Error
  status: 401
}

export type meshyTextTo3DCreateResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400 | 401>
}
    
export type meshyTextTo3DCreateResponseSuccess = (meshyTextTo3DCreateResponse200) & {
  headers: Headers;
};
export type meshyTextTo3DCreateResponseError = (meshyTextTo3DCreateResponse400 | meshyTextTo3DCreateResponse401 | meshyTextTo3DCreateResponseDefault) & {
  headers: Headers;
};

export type meshyTextTo3DCreateResponse = (meshyTextTo3DCreateResponseSuccess | meshyTextTo3DCreateResponseError)

export const getMeshyTextTo3DCreateUrl = () => {


  

  return `/proxy/meshy/openapi/v2/text-to-3d`
}

export const meshyTextTo3DCreate = async (meshyTextTo3DRequest: MeshyTextTo3DRequest, options?: RequestInit): Promise<meshyTextTo3DCreateResponse> => {
  
  return customInstance<meshyTextTo3DCreateResponse>(getMeshyTextTo3DCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      meshyTextTo3DRequest,)
  }
);}




export const getMeshyTextTo3DCreateMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyTextTo3DCreate>>, TError,{data: MeshyTextTo3DRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof meshyTextTo3DCreate>>, TError,{data: MeshyTextTo3DRequest}, TContext> => {

const mutationKey = ['meshyTextTo3DCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof meshyTextTo3DCreate>>, {data: MeshyTextTo3DRequest}> = (props) => {
          const {data} = props ?? {};

          return  meshyTextTo3DCreate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MeshyTextTo3DCreateMutationResult = NonNullable<Awaited<ReturnType<typeof meshyTextTo3DCreate>>>
    export type MeshyTextTo3DCreateMutationBody = MeshyTextTo3DRequest
    export type MeshyTextTo3DCreateMutationError = Error

    /**
 * @summary Create a Text to 3D Preview Task
 */
export const useMeshyTextTo3DCreate = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof meshyTextTo3DCreate>>, TError,{data: MeshyTextTo3DRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof meshyTextTo3DCreate>>,
        TError,
        {data: MeshyTextTo3DRequest},
        TContext
      > => {
      return useMutation(getMeshyTextTo3DCreateMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve the status and result of a Text to 3D task.
 * @summary Get Text to 3D Task Status
 */
export type meshyTextTo3DGetTaskResponse200 = {
  data: MeshyTextTo3DTask
  status: 200
}

export type meshyTextTo3DGetTaskResponse404 = {
  data: Error
  status: 404
}

export type meshyTextTo3DGetTaskResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 404>
}
    
export type meshyTextTo3DGetTaskResponseSuccess = (meshyTextTo3DGetTaskResponse200) & {
  headers: Headers;
};
export type meshyTextTo3DGetTaskResponseError = (meshyTextTo3DGetTaskResponse404 | meshyTextTo3DGetTaskResponseDefault) & {
  headers: Headers;
};

export type meshyTextTo3DGetTaskResponse = (meshyTextTo3DGetTaskResponseSuccess | meshyTextTo3DGetTaskResponseError)

export const getMeshyTextTo3DGetTaskUrl = (taskId: string,) => {


  

  return `/proxy/meshy/openapi/v2/text-to-3d/${taskId}`
}

export const meshyTextTo3DGetTask = async (taskId: string, options?: RequestInit): Promise<meshyTextTo3DGetTaskResponse> => {
  
  return customInstance<meshyTextTo3DGetTaskResponse>(getMeshyTextTo3DGetTaskUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getMeshyTextTo3DGetTaskQueryKey = (taskId: string,) => {
    return [
    `/proxy/meshy/openapi/v2/text-to-3d/${taskId}`
    ] as const;
    }

    
export const getMeshyTextTo3DGetTaskQueryOptions = <TData = Awaited<ReturnType<typeof meshyTextTo3DGetTask>>, TError = Error>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyTextTo3DGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMeshyTextTo3DGetTaskQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof meshyTextTo3DGetTask>>> = ({ signal }) => meshyTextTo3DGetTask(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof meshyTextTo3DGetTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MeshyTextTo3DGetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof meshyTextTo3DGetTask>>>
export type MeshyTextTo3DGetTaskQueryError = Error


export function useMeshyTextTo3DGetTask<TData = Awaited<ReturnType<typeof meshyTextTo3DGetTask>>, TError = Error>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyTextTo3DGetTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyTextTo3DGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyTextTo3DGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyTextTo3DGetTask<TData = Awaited<ReturnType<typeof meshyTextTo3DGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyTextTo3DGetTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meshyTextTo3DGetTask>>,
          TError,
          Awaited<ReturnType<typeof meshyTextTo3DGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMeshyTextTo3DGetTask<TData = Awaited<ReturnType<typeof meshyTextTo3DGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyTextTo3DGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Text to 3D Task Status
 */

export function useMeshyTextTo3DGetTask<TData = Awaited<ReturnType<typeof meshyTextTo3DGetTask>>, TError = Error>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof meshyTextTo3DGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMeshyTextTo3DGetTaskQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Proxies a request to Minimax to get the download URL for a file
 * @summary Retrieve download URL for a Minimax file
 */
export type retrieveMinimaxFileResponse200 = {
  data: MinimaxFileRetrieveResponse
  status: 200
}

export type retrieveMinimaxFileResponse400 = {
  data: ErrorResponse
  status: 400
}

export type retrieveMinimaxFileResponse401 = {
  data: void
  status: 401
}

export type retrieveMinimaxFileResponse402 = {
  data: void
  status: 402
}

export type retrieveMinimaxFileResponse429 = {
  data: ErrorResponse
  status: 429
}

export type retrieveMinimaxFileResponse500 = {
  data: ErrorResponse
  status: 500
}

export type retrieveMinimaxFileResponse502 = {
  data: ErrorResponse
  status: 502
}

export type retrieveMinimaxFileResponse504 = {
  data: ErrorResponse
  status: 504
}
    
export type retrieveMinimaxFileResponseSuccess = (retrieveMinimaxFileResponse200) & {
  headers: Headers;
};
export type retrieveMinimaxFileResponseError = (retrieveMinimaxFileResponse400 | retrieveMinimaxFileResponse401 | retrieveMinimaxFileResponse402 | retrieveMinimaxFileResponse429 | retrieveMinimaxFileResponse500 | retrieveMinimaxFileResponse502 | retrieveMinimaxFileResponse504) & {
  headers: Headers;
};

export type retrieveMinimaxFileResponse = (retrieveMinimaxFileResponseSuccess | retrieveMinimaxFileResponseError)

export const getRetrieveMinimaxFileUrl = (params: RetrieveMinimaxFileParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/minimax/files/retrieve?${stringifiedParams}` : `/proxy/minimax/files/retrieve`
}

export const retrieveMinimaxFile = async (params: RetrieveMinimaxFileParams, options?: RequestInit): Promise<retrieveMinimaxFileResponse> => {
  
  return customInstance<retrieveMinimaxFileResponse>(getRetrieveMinimaxFileUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getRetrieveMinimaxFileMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof retrieveMinimaxFile>>, TError,{params: RetrieveMinimaxFileParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof retrieveMinimaxFile>>, TError,{params: RetrieveMinimaxFileParams}, TContext> => {

const mutationKey = ['retrieveMinimaxFile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof retrieveMinimaxFile>>, {params: RetrieveMinimaxFileParams}> = (props) => {
          const {params} = props ?? {};

          return  retrieveMinimaxFile(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RetrieveMinimaxFileMutationResult = NonNullable<Awaited<ReturnType<typeof retrieveMinimaxFile>>>
    
    export type RetrieveMinimaxFileMutationError = ErrorResponse | void

    /**
 * @summary Retrieve download URL for a Minimax file
 */
export const useRetrieveMinimaxFile = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof retrieveMinimaxFile>>, TError,{params: RetrieveMinimaxFileParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof retrieveMinimaxFile>>,
        TError,
        {params: RetrieveMinimaxFileParams},
        TContext
      > => {
      return useMutation(getRetrieveMinimaxFileMutationOptions(options), queryClient);
    }
    
/**
 * Proxies a request to Minimax to check the status of a video generation task
 * @summary Query status of a Minimax video generation task
 */
export type getMinimaxVideoGenerationResponse200 = {
  data: MinimaxTaskResultResponse
  status: 200
}

export type getMinimaxVideoGenerationResponse400 = {
  data: ErrorResponse
  status: 400
}

export type getMinimaxVideoGenerationResponse401 = {
  data: void
  status: 401
}

export type getMinimaxVideoGenerationResponse402 = {
  data: void
  status: 402
}

export type getMinimaxVideoGenerationResponse429 = {
  data: ErrorResponse
  status: 429
}

export type getMinimaxVideoGenerationResponse500 = {
  data: ErrorResponse
  status: 500
}

export type getMinimaxVideoGenerationResponse502 = {
  data: ErrorResponse
  status: 502
}

export type getMinimaxVideoGenerationResponse504 = {
  data: ErrorResponse
  status: 504
}
    
export type getMinimaxVideoGenerationResponseSuccess = (getMinimaxVideoGenerationResponse200) & {
  headers: Headers;
};
export type getMinimaxVideoGenerationResponseError = (getMinimaxVideoGenerationResponse400 | getMinimaxVideoGenerationResponse401 | getMinimaxVideoGenerationResponse402 | getMinimaxVideoGenerationResponse429 | getMinimaxVideoGenerationResponse500 | getMinimaxVideoGenerationResponse502 | getMinimaxVideoGenerationResponse504) & {
  headers: Headers;
};

export type getMinimaxVideoGenerationResponse = (getMinimaxVideoGenerationResponseSuccess | getMinimaxVideoGenerationResponseError)

export const getGetMinimaxVideoGenerationUrl = (params: GetMinimaxVideoGenerationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/minimax/query/video_generation?${stringifiedParams}` : `/proxy/minimax/query/video_generation`
}

export const getMinimaxVideoGeneration = async (params: GetMinimaxVideoGenerationParams, options?: RequestInit): Promise<getMinimaxVideoGenerationResponse> => {
  
  return customInstance<getMinimaxVideoGenerationResponse>(getGetMinimaxVideoGenerationUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetMinimaxVideoGenerationQueryKey = (params?: GetMinimaxVideoGenerationParams,) => {
    return [
    `/proxy/minimax/query/video_generation`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetMinimaxVideoGenerationQueryOptions = <TData = Awaited<ReturnType<typeof getMinimaxVideoGeneration>>, TError = ErrorResponse | void>(params: GetMinimaxVideoGenerationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMinimaxVideoGeneration>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMinimaxVideoGenerationQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMinimaxVideoGeneration>>> = ({ signal }) => getMinimaxVideoGeneration(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMinimaxVideoGeneration>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMinimaxVideoGenerationQueryResult = NonNullable<Awaited<ReturnType<typeof getMinimaxVideoGeneration>>>
export type GetMinimaxVideoGenerationQueryError = ErrorResponse | void


export function useGetMinimaxVideoGeneration<TData = Awaited<ReturnType<typeof getMinimaxVideoGeneration>>, TError = ErrorResponse | void>(
 params: GetMinimaxVideoGenerationParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMinimaxVideoGeneration>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
          TError,
          Awaited<ReturnType<typeof getMinimaxVideoGeneration>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMinimaxVideoGeneration<TData = Awaited<ReturnType<typeof getMinimaxVideoGeneration>>, TError = ErrorResponse | void>(
 params: GetMinimaxVideoGenerationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMinimaxVideoGeneration>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
          TError,
          Awaited<ReturnType<typeof getMinimaxVideoGeneration>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMinimaxVideoGeneration<TData = Awaited<ReturnType<typeof getMinimaxVideoGeneration>>, TError = ErrorResponse | void>(
 params: GetMinimaxVideoGenerationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMinimaxVideoGeneration>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Query status of a Minimax video generation task
 */

export function useGetMinimaxVideoGeneration<TData = Awaited<ReturnType<typeof getMinimaxVideoGeneration>>, TError = ErrorResponse | void>(
 params: GetMinimaxVideoGenerationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMinimaxVideoGeneration>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMinimaxVideoGenerationQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Forwards video generation requests to Minimax's API and returns the task ID for asynchronous processing.
 * @summary Proxy request to Minimax for video generation
 */
export type minimaxVideoGenerationResponse200 = {
  data: MinimaxVideoGenerationResponse
  status: 200
}

export type minimaxVideoGenerationResponse400 = {
  data: ErrorResponse
  status: 400
}

export type minimaxVideoGenerationResponse401 = {
  data: void
  status: 401
}

export type minimaxVideoGenerationResponse402 = {
  data: void
  status: 402
}

export type minimaxVideoGenerationResponse429 = {
  data: ErrorResponse
  status: 429
}

export type minimaxVideoGenerationResponse500 = {
  data: ErrorResponse
  status: 500
}

export type minimaxVideoGenerationResponse502 = {
  data: ErrorResponse
  status: 502
}

export type minimaxVideoGenerationResponse504 = {
  data: ErrorResponse
  status: 504
}
    
export type minimaxVideoGenerationResponseSuccess = (minimaxVideoGenerationResponse200) & {
  headers: Headers;
};
export type minimaxVideoGenerationResponseError = (minimaxVideoGenerationResponse400 | minimaxVideoGenerationResponse401 | minimaxVideoGenerationResponse402 | minimaxVideoGenerationResponse429 | minimaxVideoGenerationResponse500 | minimaxVideoGenerationResponse502 | minimaxVideoGenerationResponse504) & {
  headers: Headers;
};

export type minimaxVideoGenerationResponse = (minimaxVideoGenerationResponseSuccess | minimaxVideoGenerationResponseError)

export const getMinimaxVideoGenerationUrl = () => {


  

  return `/proxy/minimax/video_generation`
}

export const minimaxVideoGeneration = async (minimaxVideoGenerationRequest: MinimaxVideoGenerationRequest, options?: RequestInit): Promise<minimaxVideoGenerationResponse> => {
  
  return customInstance<minimaxVideoGenerationResponse>(getMinimaxVideoGenerationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      minimaxVideoGenerationRequest,)
  }
);}




export const getMinimaxVideoGenerationMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof minimaxVideoGeneration>>, TError,{data: MinimaxVideoGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof minimaxVideoGeneration>>, TError,{data: MinimaxVideoGenerationRequest}, TContext> => {

const mutationKey = ['minimaxVideoGeneration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof minimaxVideoGeneration>>, {data: MinimaxVideoGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  minimaxVideoGeneration(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MinimaxVideoGenerationMutationResult = NonNullable<Awaited<ReturnType<typeof minimaxVideoGeneration>>>
    export type MinimaxVideoGenerationMutationBody = MinimaxVideoGenerationRequest
    export type MinimaxVideoGenerationMutationError = ErrorResponse | void

    /**
 * @summary Proxy request to Minimax for video generation
 */
export const useMinimaxVideoGeneration = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof minimaxVideoGeneration>>, TError,{data: MinimaxVideoGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof minimaxVideoGeneration>>,
        TError,
        {data: MinimaxVideoGenerationRequest},
        TContext
      > => {
      return useMutation(getMinimaxVideoGenerationMutationOptions(options), queryClient);
    }
    
/**
 * @summary Create Image to Video Prompt
 */
export type moonvalleyImageToVideoResponse201 = {
  data: MoonvalleyPromptResponse
  status: 201
}
    
export type moonvalleyImageToVideoResponseSuccess = (moonvalleyImageToVideoResponse201) & {
  headers: Headers;
};
;

export type moonvalleyImageToVideoResponse = (moonvalleyImageToVideoResponseSuccess)

export const getMoonvalleyImageToVideoUrl = () => {


  

  return `/proxy/moonvalley/prompts/image-to-video`
}

export const moonvalleyImageToVideo = async (moonvalleyImageToVideoRequest: MoonvalleyImageToVideoRequest, options?: RequestInit): Promise<moonvalleyImageToVideoResponse> => {
  
  return customInstance<moonvalleyImageToVideoResponse>(getMoonvalleyImageToVideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      moonvalleyImageToVideoRequest,)
  }
);}




export const getMoonvalleyImageToVideoMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyImageToVideo>>, TError,{data: MoonvalleyImageToVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof moonvalleyImageToVideo>>, TError,{data: MoonvalleyImageToVideoRequest}, TContext> => {

const mutationKey = ['moonvalleyImageToVideo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moonvalleyImageToVideo>>, {data: MoonvalleyImageToVideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  moonvalleyImageToVideo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MoonvalleyImageToVideoMutationResult = NonNullable<Awaited<ReturnType<typeof moonvalleyImageToVideo>>>
    export type MoonvalleyImageToVideoMutationBody = MoonvalleyImageToVideoRequest
    export type MoonvalleyImageToVideoMutationError = unknown

    /**
 * @summary Create Image to Video Prompt
 */
export const useMoonvalleyImageToVideo = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyImageToVideo>>, TError,{data: MoonvalleyImageToVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof moonvalleyImageToVideo>>,
        TError,
        {data: MoonvalleyImageToVideoRequest},
        TContext
      > => {
      return useMutation(getMoonvalleyImageToVideoMutationOptions(options), queryClient);
    }
    
/**
 * @summary Create Text to Image Prompt
 */
export type moonvalleyTextToImageResponse201 = {
  data: MoonvalleyPromptResponse
  status: 201
}
    
export type moonvalleyTextToImageResponseSuccess = (moonvalleyTextToImageResponse201) & {
  headers: Headers;
};
;

export type moonvalleyTextToImageResponse = (moonvalleyTextToImageResponseSuccess)

export const getMoonvalleyTextToImageUrl = () => {


  

  return `/proxy/moonvalley/prompts/text-to-image`
}

export const moonvalleyTextToImage = async (moonvalleyTextToImageRequest: MoonvalleyTextToImageRequest, options?: RequestInit): Promise<moonvalleyTextToImageResponse> => {
  
  return customInstance<moonvalleyTextToImageResponse>(getMoonvalleyTextToImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      moonvalleyTextToImageRequest,)
  }
);}




export const getMoonvalleyTextToImageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyTextToImage>>, TError,{data: MoonvalleyTextToImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof moonvalleyTextToImage>>, TError,{data: MoonvalleyTextToImageRequest}, TContext> => {

const mutationKey = ['moonvalleyTextToImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moonvalleyTextToImage>>, {data: MoonvalleyTextToImageRequest}> = (props) => {
          const {data} = props ?? {};

          return  moonvalleyTextToImage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MoonvalleyTextToImageMutationResult = NonNullable<Awaited<ReturnType<typeof moonvalleyTextToImage>>>
    export type MoonvalleyTextToImageMutationBody = MoonvalleyTextToImageRequest
    export type MoonvalleyTextToImageMutationError = unknown

    /**
 * @summary Create Text to Image Prompt
 */
export const useMoonvalleyTextToImage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyTextToImage>>, TError,{data: MoonvalleyTextToImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof moonvalleyTextToImage>>,
        TError,
        {data: MoonvalleyTextToImageRequest},
        TContext
      > => {
      return useMutation(getMoonvalleyTextToImageMutationOptions(options), queryClient);
    }
    
/**
 * @summary Create Text to Video Prompt
 */
export type moonvalleyTextToVideoResponse201 = {
  data: MoonvalleyPromptResponse
  status: 201
}
    
export type moonvalleyTextToVideoResponseSuccess = (moonvalleyTextToVideoResponse201) & {
  headers: Headers;
};
;

export type moonvalleyTextToVideoResponse = (moonvalleyTextToVideoResponseSuccess)

export const getMoonvalleyTextToVideoUrl = () => {


  

  return `/proxy/moonvalley/prompts/text-to-video`
}

export const moonvalleyTextToVideo = async (moonvalleyTextToVideoRequest: MoonvalleyTextToVideoRequest, options?: RequestInit): Promise<moonvalleyTextToVideoResponse> => {
  
  return customInstance<moonvalleyTextToVideoResponse>(getMoonvalleyTextToVideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      moonvalleyTextToVideoRequest,)
  }
);}




export const getMoonvalleyTextToVideoMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyTextToVideo>>, TError,{data: MoonvalleyTextToVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof moonvalleyTextToVideo>>, TError,{data: MoonvalleyTextToVideoRequest}, TContext> => {

const mutationKey = ['moonvalleyTextToVideo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moonvalleyTextToVideo>>, {data: MoonvalleyTextToVideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  moonvalleyTextToVideo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MoonvalleyTextToVideoMutationResult = NonNullable<Awaited<ReturnType<typeof moonvalleyTextToVideo>>>
    export type MoonvalleyTextToVideoMutationBody = MoonvalleyTextToVideoRequest
    export type MoonvalleyTextToVideoMutationError = unknown

    /**
 * @summary Create Text to Video Prompt
 */
export const useMoonvalleyTextToVideo = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyTextToVideo>>, TError,{data: MoonvalleyTextToVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof moonvalleyTextToVideo>>,
        TError,
        {data: MoonvalleyTextToVideoRequest},
        TContext
      > => {
      return useMutation(getMoonvalleyTextToVideoMutationOptions(options), queryClient);
    }
    
/**
 * @summary Create Video to Video Prompt
 */
export type moonvalleyVideoToVideoResponse201 = {
  data: MoonvalleyPromptResponse
  status: 201
}
    
export type moonvalleyVideoToVideoResponseSuccess = (moonvalleyVideoToVideoResponse201) & {
  headers: Headers;
};
;

export type moonvalleyVideoToVideoResponse = (moonvalleyVideoToVideoResponseSuccess)

export const getMoonvalleyVideoToVideoUrl = () => {


  

  return `/proxy/moonvalley/prompts/video-to-video`
}

export const moonvalleyVideoToVideo = async (moonvalleyVideoToVideoRequest: MoonvalleyVideoToVideoRequest, options?: RequestInit): Promise<moonvalleyVideoToVideoResponse> => {
  
  return customInstance<moonvalleyVideoToVideoResponse>(getMoonvalleyVideoToVideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      moonvalleyVideoToVideoRequest,)
  }
);}




export const getMoonvalleyVideoToVideoMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyVideoToVideo>>, TError,{data: MoonvalleyVideoToVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof moonvalleyVideoToVideo>>, TError,{data: MoonvalleyVideoToVideoRequest}, TContext> => {

const mutationKey = ['moonvalleyVideoToVideo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moonvalleyVideoToVideo>>, {data: MoonvalleyVideoToVideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  moonvalleyVideoToVideo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MoonvalleyVideoToVideoMutationResult = NonNullable<Awaited<ReturnType<typeof moonvalleyVideoToVideo>>>
    export type MoonvalleyVideoToVideoMutationBody = MoonvalleyVideoToVideoRequest
    export type MoonvalleyVideoToVideoMutationError = unknown

    /**
 * @summary Create Video to Video Prompt
 */
export const useMoonvalleyVideoToVideo = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyVideoToVideo>>, TError,{data: MoonvalleyVideoToVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof moonvalleyVideoToVideo>>,
        TError,
        {data: MoonvalleyVideoToVideoRequest},
        TContext
      > => {
      return useMutation(getMoonvalleyVideoToVideoMutationOptions(options), queryClient);
    }
    
/**
 * @summary Resize a video
 */
export type moonvalleyVideoToVideoResizeResponse201 = {
  data: MoonvalleyPromptResponse
  status: 201
}
    
export type moonvalleyVideoToVideoResizeResponseSuccess = (moonvalleyVideoToVideoResizeResponse201) & {
  headers: Headers;
};
;

export type moonvalleyVideoToVideoResizeResponse = (moonvalleyVideoToVideoResizeResponseSuccess)

export const getMoonvalleyVideoToVideoResizeUrl = () => {


  

  return `/proxy/moonvalley/prompts/video-to-video/resize`
}

export const moonvalleyVideoToVideoResize = async (moonvalleyResizeVideoRequest: MoonvalleyResizeVideoRequest, options?: RequestInit): Promise<moonvalleyVideoToVideoResizeResponse> => {
  
  return customInstance<moonvalleyVideoToVideoResizeResponse>(getMoonvalleyVideoToVideoResizeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      moonvalleyResizeVideoRequest,)
  }
);}




export const getMoonvalleyVideoToVideoResizeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>, TError,{data: MoonvalleyResizeVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>, TError,{data: MoonvalleyResizeVideoRequest}, TContext> => {

const mutationKey = ['moonvalleyVideoToVideoResize'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>, {data: MoonvalleyResizeVideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  moonvalleyVideoToVideoResize(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MoonvalleyVideoToVideoResizeMutationResult = NonNullable<Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>>
    export type MoonvalleyVideoToVideoResizeMutationBody = MoonvalleyResizeVideoRequest
    export type MoonvalleyVideoToVideoResizeMutationError = unknown

    /**
 * @summary Resize a video
 */
export const useMoonvalleyVideoToVideoResize = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>, TError,{data: MoonvalleyResizeVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>,
        TError,
        {data: MoonvalleyResizeVideoRequest},
        TContext
      > => {
      return useMutation(getMoonvalleyVideoToVideoResizeMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get Prompt Details
 */
export type moonvalleyGetPromptResponse200 = {
  data: MoonvalleyPromptResponse
  status: 200
}
    
export type moonvalleyGetPromptResponseSuccess = (moonvalleyGetPromptResponse200) & {
  headers: Headers;
};
;

export type moonvalleyGetPromptResponse = (moonvalleyGetPromptResponseSuccess)

export const getMoonvalleyGetPromptUrl = (promptId: string,) => {


  

  return `/proxy/moonvalley/prompts/${promptId}`
}

export const moonvalleyGetPrompt = async (promptId: string, options?: RequestInit): Promise<moonvalleyGetPromptResponse> => {
  
  return customInstance<moonvalleyGetPromptResponse>(getMoonvalleyGetPromptUrl(promptId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getMoonvalleyGetPromptQueryKey = (promptId: string,) => {
    return [
    `/proxy/moonvalley/prompts/${promptId}`
    ] as const;
    }

    
export const getMoonvalleyGetPromptQueryOptions = <TData = Awaited<ReturnType<typeof moonvalleyGetPrompt>>, TError = unknown>(promptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moonvalleyGetPrompt>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMoonvalleyGetPromptQueryKey(promptId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof moonvalleyGetPrompt>>> = ({ signal }) => moonvalleyGetPrompt(promptId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(promptId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof moonvalleyGetPrompt>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MoonvalleyGetPromptQueryResult = NonNullable<Awaited<ReturnType<typeof moonvalleyGetPrompt>>>
export type MoonvalleyGetPromptQueryError = unknown


export function useMoonvalleyGetPrompt<TData = Awaited<ReturnType<typeof moonvalleyGetPrompt>>, TError = unknown>(
 promptId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof moonvalleyGetPrompt>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
          TError,
          Awaited<ReturnType<typeof moonvalleyGetPrompt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMoonvalleyGetPrompt<TData = Awaited<ReturnType<typeof moonvalleyGetPrompt>>, TError = unknown>(
 promptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moonvalleyGetPrompt>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
          TError,
          Awaited<ReturnType<typeof moonvalleyGetPrompt>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMoonvalleyGetPrompt<TData = Awaited<ReturnType<typeof moonvalleyGetPrompt>>, TError = unknown>(
 promptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moonvalleyGetPrompt>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Prompt Details
 */

export function useMoonvalleyGetPrompt<TData = Awaited<ReturnType<typeof moonvalleyGetPrompt>>, TError = unknown>(
 promptId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof moonvalleyGetPrompt>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMoonvalleyGetPromptQueryOptions(promptId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Upload Files
 */
export type moonvalleyUploadResponse200 = {
  data: MoonvalleyUploadFileResponse
  status: 200
}
    
export type moonvalleyUploadResponseSuccess = (moonvalleyUploadResponse200) & {
  headers: Headers;
};
;

export type moonvalleyUploadResponse = (moonvalleyUploadResponseSuccess)

export const getMoonvalleyUploadUrl = () => {


  

  return `/proxy/moonvalley/uploads`
}

export const moonvalleyUpload = async (moonvalleyUploadFileRequest: MoonvalleyUploadFileRequest, options?: RequestInit): Promise<moonvalleyUploadResponse> => {
    const formData = new FormData();
if(moonvalleyUploadFileRequest.file !== undefined) {
 formData.append(`file`, moonvalleyUploadFileRequest.file);
 }

  return customInstance<moonvalleyUploadResponse>(getMoonvalleyUploadUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getMoonvalleyUploadMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyUpload>>, TError,{data: MoonvalleyUploadFileRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof moonvalleyUpload>>, TError,{data: MoonvalleyUploadFileRequest}, TContext> => {

const mutationKey = ['moonvalleyUpload'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moonvalleyUpload>>, {data: MoonvalleyUploadFileRequest}> = (props) => {
          const {data} = props ?? {};

          return  moonvalleyUpload(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MoonvalleyUploadMutationResult = NonNullable<Awaited<ReturnType<typeof moonvalleyUpload>>>
    export type MoonvalleyUploadMutationBody = MoonvalleyUploadFileRequest
    export type MoonvalleyUploadMutationError = unknown

    /**
 * @summary Upload Files
 */
export const useMoonvalleyUpload = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moonvalleyUpload>>, TError,{data: MoonvalleyUploadFileRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof moonvalleyUpload>>,
        TError,
        {data: MoonvalleyUploadFileRequest},
        TContext
      > => {
      return useMutation(getMoonvalleyUploadMutationOptions(options), queryClient);
    }
    
/**
 * @summary Edit an image using OpenAI's DALL-E model
 */
export type openAIEditImageResponse200 = {
  data: OpenAIImageGenerationResponse
  status: 200
}

export type openAIEditImageResponse400 = {
  data: ErrorResponse
  status: 400
}

export type openAIEditImageResponse401 = {
  data: void
  status: 401
}

export type openAIEditImageResponse402 = {
  data: void
  status: 402
}

export type openAIEditImageResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type openAIEditImageResponseSuccess = (openAIEditImageResponse200) & {
  headers: Headers;
};
export type openAIEditImageResponseError = (openAIEditImageResponse400 | openAIEditImageResponse401 | openAIEditImageResponse402 | openAIEditImageResponse500) & {
  headers: Headers;
};

export type openAIEditImageResponse = (openAIEditImageResponseSuccess | openAIEditImageResponseError)

export const getOpenAIEditImageUrl = () => {


  

  return `/proxy/openai/images/edits`
}

export const openAIEditImage = async (openAIImageEditRequest: OpenAIImageEditRequest, options?: RequestInit): Promise<openAIEditImageResponse> => {
    const formData = new FormData();
if(openAIImageEditRequest.background !== undefined) {
 formData.append(`background`, openAIImageEditRequest.background);
 }
formData.append(`model`, openAIImageEditRequest.model);
if(openAIImageEditRequest.moderation !== undefined) {
 formData.append(`moderation`, openAIImageEditRequest.moderation);
 }
if(openAIImageEditRequest.n !== undefined) {
 formData.append(`n`, openAIImageEditRequest.n.toString())
 }
if(openAIImageEditRequest.output_compression !== undefined) {
 formData.append(`output_compression`, openAIImageEditRequest.output_compression.toString())
 }
if(openAIImageEditRequest.output_format !== undefined) {
 formData.append(`output_format`, openAIImageEditRequest.output_format);
 }
formData.append(`prompt`, openAIImageEditRequest.prompt);
if(openAIImageEditRequest.quality !== undefined) {
 formData.append(`quality`, openAIImageEditRequest.quality);
 }
if(openAIImageEditRequest.size !== undefined) {
 formData.append(`size`, openAIImageEditRequest.size);
 }
if(openAIImageEditRequest.user !== undefined) {
 formData.append(`user`, openAIImageEditRequest.user);
 }

  return customInstance<openAIEditImageResponse>(getOpenAIEditImageUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getOpenAIEditImageMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof openAIEditImage>>, TError,{data: OpenAIImageEditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof openAIEditImage>>, TError,{data: OpenAIImageEditRequest}, TContext> => {

const mutationKey = ['openAIEditImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof openAIEditImage>>, {data: OpenAIImageEditRequest}> = (props) => {
          const {data} = props ?? {};

          return  openAIEditImage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type OpenAIEditImageMutationResult = NonNullable<Awaited<ReturnType<typeof openAIEditImage>>>
    export type OpenAIEditImageMutationBody = OpenAIImageEditRequest
    export type OpenAIEditImageMutationError = ErrorResponse | void

    /**
 * @summary Edit an image using OpenAI's DALL-E model
 */
export const useOpenAIEditImage = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof openAIEditImage>>, TError,{data: OpenAIImageEditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof openAIEditImage>>,
        TError,
        {data: OpenAIImageEditRequest},
        TContext
      > => {
      return useMutation(getOpenAIEditImageMutationOptions(options), queryClient);
    }
    
/**
 * @summary Generate an image using OpenAI's models
 */
export type openAIGenerateImageResponse200 = {
  data: OpenAIImageGenerationResponse
  status: 200
}

export type openAIGenerateImageResponse400 = {
  data: ErrorResponse
  status: 400
}

export type openAIGenerateImageResponse401 = {
  data: void
  status: 401
}

export type openAIGenerateImageResponse402 = {
  data: void
  status: 402
}

export type openAIGenerateImageResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type openAIGenerateImageResponseSuccess = (openAIGenerateImageResponse200) & {
  headers: Headers;
};
export type openAIGenerateImageResponseError = (openAIGenerateImageResponse400 | openAIGenerateImageResponse401 | openAIGenerateImageResponse402 | openAIGenerateImageResponse500) & {
  headers: Headers;
};

export type openAIGenerateImageResponse = (openAIGenerateImageResponseSuccess | openAIGenerateImageResponseError)

export const getOpenAIGenerateImageUrl = () => {


  

  return `/proxy/openai/images/generations`
}

export const openAIGenerateImage = async (openAIImageGenerationRequest: OpenAIImageGenerationRequest, options?: RequestInit): Promise<openAIGenerateImageResponse> => {
  
  return customInstance<openAIGenerateImageResponse>(getOpenAIGenerateImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      openAIImageGenerationRequest,)
  }
);}




export const getOpenAIGenerateImageMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof openAIGenerateImage>>, TError,{data: OpenAIImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof openAIGenerateImage>>, TError,{data: OpenAIImageGenerationRequest}, TContext> => {

const mutationKey = ['openAIGenerateImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof openAIGenerateImage>>, {data: OpenAIImageGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  openAIGenerateImage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type OpenAIGenerateImageMutationResult = NonNullable<Awaited<ReturnType<typeof openAIGenerateImage>>>
    export type OpenAIGenerateImageMutationBody = OpenAIImageGenerationRequest
    export type OpenAIGenerateImageMutationError = ErrorResponse | void

    /**
 * @summary Generate an image using OpenAI's models
 */
export const useOpenAIGenerateImage = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof openAIGenerateImage>>, TError,{data: OpenAIImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof openAIGenerateImage>>,
        TError,
        {data: OpenAIImageGenerationRequest},
        TContext
      > => {
      return useMutation(getOpenAIGenerateImageMutationOptions(options), queryClient);
    }
    
export type createOpenAIResponseResponse200ApplicationJson = {
  data: OpenAIResponse
  status: 200
}

export type createOpenAIResponseResponse200TextEventStream = {
  data: OpenAIResponseStreamEvent
  status: 200
}
    
export type createOpenAIResponseResponseSuccess = (createOpenAIResponseResponse200ApplicationJson | createOpenAIResponseResponse200TextEventStream) & {
  headers: Headers;
};
;

export type createOpenAIResponseResponse = (createOpenAIResponseResponseSuccess)

export const getCreateOpenAIResponseUrl = () => {


  

  return `/proxy/openai/v1/responses`
}

export const createOpenAIResponse = async (openAICreateResponse: OpenAICreateResponse, options?: RequestInit): Promise<createOpenAIResponseResponse> => {
  
  return customInstance<createOpenAIResponseResponse>(getCreateOpenAIResponseUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      openAICreateResponse,)
  }
);}




export const getCreateOpenAIResponseMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOpenAIResponse>>, TError,{data: OpenAICreateResponse}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createOpenAIResponse>>, TError,{data: OpenAICreateResponse}, TContext> => {

const mutationKey = ['createOpenAIResponse'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOpenAIResponse>>, {data: OpenAICreateResponse}> = (props) => {
          const {data} = props ?? {};

          return  createOpenAIResponse(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOpenAIResponseMutationResult = NonNullable<Awaited<ReturnType<typeof createOpenAIResponse>>>
    export type CreateOpenAIResponseMutationBody = OpenAICreateResponse
    export type CreateOpenAIResponseMutationError = unknown

    export const useCreateOpenAIResponse = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOpenAIResponse>>, TError,{data: OpenAICreateResponse}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOpenAIResponse>>,
        TError,
        {data: OpenAICreateResponse},
        TContext
      > => {
      return useMutation(getCreateOpenAIResponseMutationOptions(options), queryClient);
    }
    
/**
 * @summary Retrieves a model response with the given ID.

 */
export type getOpenAIResponseResponse200 = {
  data: OpenAIResponse
  status: 200
}
    
export type getOpenAIResponseResponseSuccess = (getOpenAIResponseResponse200) & {
  headers: Headers;
};
;

export type getOpenAIResponseResponse = (getOpenAIResponseResponseSuccess)

export const getGetOpenAIResponseUrl = (id: string,
    params?: GetOpenAIResponseParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/openai/v1/responses/${id}?${stringifiedParams}` : `/proxy/openai/v1/responses/${id}`
}

export const getOpenAIResponse = async (id: string,
    params?: GetOpenAIResponseParams, options?: RequestInit): Promise<getOpenAIResponseResponse> => {
  
  return customInstance<getOpenAIResponseResponse>(getGetOpenAIResponseUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetOpenAIResponseQueryKey = (id: string,
    params?: GetOpenAIResponseParams,) => {
    return [
    `/proxy/openai/v1/responses/${id}`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetOpenAIResponseQueryOptions = <TData = Awaited<ReturnType<typeof getOpenAIResponse>>, TError = unknown>(id: string,
    params?: GetOpenAIResponseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOpenAIResponse>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOpenAIResponseQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOpenAIResponse>>> = ({ signal }) => getOpenAIResponse(id,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOpenAIResponse>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOpenAIResponseQueryResult = NonNullable<Awaited<ReturnType<typeof getOpenAIResponse>>>
export type GetOpenAIResponseQueryError = unknown


export function useGetOpenAIResponse<TData = Awaited<ReturnType<typeof getOpenAIResponse>>, TError = unknown>(
 id: string,
    params: undefined |  GetOpenAIResponseParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOpenAIResponse>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOpenAIResponse>>,
          TError,
          Awaited<ReturnType<typeof getOpenAIResponse>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOpenAIResponse<TData = Awaited<ReturnType<typeof getOpenAIResponse>>, TError = unknown>(
 id: string,
    params?: GetOpenAIResponseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOpenAIResponse>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOpenAIResponse>>,
          TError,
          Awaited<ReturnType<typeof getOpenAIResponse>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOpenAIResponse<TData = Awaited<ReturnType<typeof getOpenAIResponse>>, TError = unknown>(
 id: string,
    params?: GetOpenAIResponseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOpenAIResponse>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a model response with the given ID.

 */

export function useGetOpenAIResponse<TData = Awaited<ReturnType<typeof getOpenAIResponse>>, TError = unknown>(
 id: string,
    params?: GetOpenAIResponseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOpenAIResponse>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOpenAIResponseQueryOptions(id,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a video using OpenAI's Sora model
 */
export type openAICreateVideoResponse200 = {
  data: OpenAIVideoJob
  status: 200
}

export type openAICreateVideoResponse400 = {
  data: ErrorResponse
  status: 400
}

export type openAICreateVideoResponse401 = {
  data: void
  status: 401
}

export type openAICreateVideoResponse402 = {
  data: void
  status: 402
}

export type openAICreateVideoResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type openAICreateVideoResponseSuccess = (openAICreateVideoResponse200) & {
  headers: Headers;
};
export type openAICreateVideoResponseError = (openAICreateVideoResponse400 | openAICreateVideoResponse401 | openAICreateVideoResponse402 | openAICreateVideoResponse500) & {
  headers: Headers;
};

export type openAICreateVideoResponse = (openAICreateVideoResponseSuccess | openAICreateVideoResponseError)

export const getOpenAICreateVideoUrl = () => {


  

  return `/proxy/openai/v1/videos`
}

export const openAICreateVideo = async (openAIVideoCreateRequest: OpenAIVideoCreateRequest, options?: RequestInit): Promise<openAICreateVideoResponse> => {
    const formData = new FormData();
if(openAIVideoCreateRequest.input_reference !== undefined) {
 formData.append(`input_reference`, openAIVideoCreateRequest.input_reference);
 }
if(openAIVideoCreateRequest.model !== undefined) {
 formData.append(`model`, openAIVideoCreateRequest.model);
 }
formData.append(`prompt`, openAIVideoCreateRequest.prompt);
if(openAIVideoCreateRequest.seconds !== undefined) {
 formData.append(`seconds`, openAIVideoCreateRequest.seconds);
 }
if(openAIVideoCreateRequest.size !== undefined) {
 formData.append(`size`, openAIVideoCreateRequest.size);
 }

  return customInstance<openAICreateVideoResponse>(getOpenAICreateVideoUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getOpenAICreateVideoMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof openAICreateVideo>>, TError,{data: OpenAIVideoCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof openAICreateVideo>>, TError,{data: OpenAIVideoCreateRequest}, TContext> => {

const mutationKey = ['openAICreateVideo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof openAICreateVideo>>, {data: OpenAIVideoCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  openAICreateVideo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type OpenAICreateVideoMutationResult = NonNullable<Awaited<ReturnType<typeof openAICreateVideo>>>
    export type OpenAICreateVideoMutationBody = OpenAIVideoCreateRequest
    export type OpenAICreateVideoMutationError = ErrorResponse | void

    /**
 * @summary Create a video using OpenAI's Sora model
 */
export const useOpenAICreateVideo = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof openAICreateVideo>>, TError,{data: OpenAIVideoCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof openAICreateVideo>>,
        TError,
        {data: OpenAIVideoCreateRequest},
        TContext
      > => {
      return useMutation(getOpenAICreateVideoMutationOptions(options), queryClient);
    }
    
/**
 * @summary Retrieve a video
 */
export type openAIGetVideoResponse200 = {
  data: OpenAIVideoJob
  status: 200
}

export type openAIGetVideoResponse400 = {
  data: ErrorResponse
  status: 400
}

export type openAIGetVideoResponse401 = {
  data: void
  status: 401
}

export type openAIGetVideoResponse404 = {
  data: void
  status: 404
}

export type openAIGetVideoResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type openAIGetVideoResponseSuccess = (openAIGetVideoResponse200) & {
  headers: Headers;
};
export type openAIGetVideoResponseError = (openAIGetVideoResponse400 | openAIGetVideoResponse401 | openAIGetVideoResponse404 | openAIGetVideoResponse500) & {
  headers: Headers;
};

export type openAIGetVideoResponse = (openAIGetVideoResponseSuccess | openAIGetVideoResponseError)

export const getOpenAIGetVideoUrl = (videoId: string,) => {


  

  return `/proxy/openai/v1/videos/${videoId}`
}

export const openAIGetVideo = async (videoId: string, options?: RequestInit): Promise<openAIGetVideoResponse> => {
  
  return customInstance<openAIGetVideoResponse>(getOpenAIGetVideoUrl(videoId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getOpenAIGetVideoQueryKey = (videoId: string,) => {
    return [
    `/proxy/openai/v1/videos/${videoId}`
    ] as const;
    }

    
export const getOpenAIGetVideoQueryOptions = <TData = Awaited<ReturnType<typeof openAIGetVideo>>, TError = ErrorResponse | void>(videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof openAIGetVideo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOpenAIGetVideoQueryKey(videoId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof openAIGetVideo>>> = ({ signal }) => openAIGetVideo(videoId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(videoId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof openAIGetVideo>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OpenAIGetVideoQueryResult = NonNullable<Awaited<ReturnType<typeof openAIGetVideo>>>
export type OpenAIGetVideoQueryError = ErrorResponse | void


export function useOpenAIGetVideo<TData = Awaited<ReturnType<typeof openAIGetVideo>>, TError = ErrorResponse | void>(
 videoId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof openAIGetVideo>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof openAIGetVideo>>,
          TError,
          Awaited<ReturnType<typeof openAIGetVideo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOpenAIGetVideo<TData = Awaited<ReturnType<typeof openAIGetVideo>>, TError = ErrorResponse | void>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof openAIGetVideo>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof openAIGetVideo>>,
          TError,
          Awaited<ReturnType<typeof openAIGetVideo>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOpenAIGetVideo<TData = Awaited<ReturnType<typeof openAIGetVideo>>, TError = ErrorResponse | void>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof openAIGetVideo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a video
 */

export function useOpenAIGetVideo<TData = Awaited<ReturnType<typeof openAIGetVideo>>, TError = ErrorResponse | void>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof openAIGetVideo>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOpenAIGetVideoQueryOptions(videoId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Download video content
 */
export type openAIDownloadVideoContentResponse200 = {
  data: Blob
  status: 200
}

export type openAIDownloadVideoContentResponse400 = {
  data: ErrorResponse
  status: 400
}

export type openAIDownloadVideoContentResponse401 = {
  data: void
  status: 401
}

export type openAIDownloadVideoContentResponse404 = {
  data: void
  status: 404
}

export type openAIDownloadVideoContentResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type openAIDownloadVideoContentResponseSuccess = (openAIDownloadVideoContentResponse200) & {
  headers: Headers;
};
export type openAIDownloadVideoContentResponseError = (openAIDownloadVideoContentResponse400 | openAIDownloadVideoContentResponse401 | openAIDownloadVideoContentResponse404 | openAIDownloadVideoContentResponse500) & {
  headers: Headers;
};

export type openAIDownloadVideoContentResponse = (openAIDownloadVideoContentResponseSuccess | openAIDownloadVideoContentResponseError)

export const getOpenAIDownloadVideoContentUrl = (videoId: string,
    params?: OpenAIDownloadVideoContentParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/proxy/openai/v1/videos/${videoId}/content?${stringifiedParams}` : `/proxy/openai/v1/videos/${videoId}/content`
}

export const openAIDownloadVideoContent = async (videoId: string,
    params?: OpenAIDownloadVideoContentParams, options?: RequestInit): Promise<openAIDownloadVideoContentResponse> => {
  
  return customInstance<openAIDownloadVideoContentResponse>(getOpenAIDownloadVideoContentUrl(videoId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getOpenAIDownloadVideoContentQueryKey = (videoId: string,
    params?: OpenAIDownloadVideoContentParams,) => {
    return [
    `/proxy/openai/v1/videos/${videoId}/content`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getOpenAIDownloadVideoContentQueryOptions = <TData = Awaited<ReturnType<typeof openAIDownloadVideoContent>>, TError = ErrorResponse | void>(videoId: string,
    params?: OpenAIDownloadVideoContentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof openAIDownloadVideoContent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOpenAIDownloadVideoContentQueryKey(videoId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof openAIDownloadVideoContent>>> = ({ signal }) => openAIDownloadVideoContent(videoId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(videoId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof openAIDownloadVideoContent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OpenAIDownloadVideoContentQueryResult = NonNullable<Awaited<ReturnType<typeof openAIDownloadVideoContent>>>
export type OpenAIDownloadVideoContentQueryError = ErrorResponse | void


export function useOpenAIDownloadVideoContent<TData = Awaited<ReturnType<typeof openAIDownloadVideoContent>>, TError = ErrorResponse | void>(
 videoId: string,
    params: undefined |  OpenAIDownloadVideoContentParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof openAIDownloadVideoContent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof openAIDownloadVideoContent>>,
          TError,
          Awaited<ReturnType<typeof openAIDownloadVideoContent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOpenAIDownloadVideoContent<TData = Awaited<ReturnType<typeof openAIDownloadVideoContent>>, TError = ErrorResponse | void>(
 videoId: string,
    params?: OpenAIDownloadVideoContentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof openAIDownloadVideoContent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof openAIDownloadVideoContent>>,
          TError,
          Awaited<ReturnType<typeof openAIDownloadVideoContent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOpenAIDownloadVideoContent<TData = Awaited<ReturnType<typeof openAIDownloadVideoContent>>, TError = ErrorResponse | void>(
 videoId: string,
    params?: OpenAIDownloadVideoContentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof openAIDownloadVideoContent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download video content
 */

export function useOpenAIDownloadVideoContent<TData = Awaited<ReturnType<typeof openAIDownloadVideoContent>>, TError = ErrorResponse | void>(
 videoId: string,
    params?: OpenAIDownloadVideoContentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof openAIDownloadVideoContent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOpenAIDownloadVideoContentQueryOptions(videoId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Generate 2 2 I2V
 */
export type pikaGenerate22I2vGenerate22I2vPostResponse200 = {
  data: PikaGenerateResponse
  status: 200
}

export type pikaGenerate22I2vGenerate22I2vPostResponse422 = {
  data: PikaHTTPValidationError
  status: 422
}
    
export type pikaGenerate22I2vGenerate22I2vPostResponseSuccess = (pikaGenerate22I2vGenerate22I2vPostResponse200) & {
  headers: Headers;
};
export type pikaGenerate22I2vGenerate22I2vPostResponseError = (pikaGenerate22I2vGenerate22I2vPostResponse422) & {
  headers: Headers;
};

export type pikaGenerate22I2vGenerate22I2vPostResponse = (pikaGenerate22I2vGenerate22I2vPostResponseSuccess | pikaGenerate22I2vGenerate22I2vPostResponseError)

export const getPikaGenerate22I2vGenerate22I2vPostUrl = () => {


  

  return `/proxy/pika/generate/2.2/i2v`
}

export const pikaGenerate22I2vGenerate22I2vPost = async (pikaBodyGenerate22I2vGenerate22I2vPost: PikaBodyGenerate22I2vGenerate22I2vPost, options?: RequestInit): Promise<pikaGenerate22I2vGenerate22I2vPostResponse> => {
    const formData = new FormData();
if(pikaBodyGenerate22I2vGenerate22I2vPost.duration !== undefined) {
 formData.append(`duration`, pikaBodyGenerate22I2vGenerate22I2vPost.duration.toString())
 }
if(pikaBodyGenerate22I2vGenerate22I2vPost.image !== undefined && pikaBodyGenerate22I2vGenerate22I2vPost.image !== null) {
 formData.append(`image`, pikaBodyGenerate22I2vGenerate22I2vPost.image);
 }
if(pikaBodyGenerate22I2vGenerate22I2vPost.negativePrompt !== undefined && pikaBodyGenerate22I2vGenerate22I2vPost.negativePrompt !== null) {
 formData.append(`negativePrompt`, pikaBodyGenerate22I2vGenerate22I2vPost.negativePrompt);
 }
if(pikaBodyGenerate22I2vGenerate22I2vPost.promptText !== undefined && pikaBodyGenerate22I2vGenerate22I2vPost.promptText !== null) {
 formData.append(`promptText`, pikaBodyGenerate22I2vGenerate22I2vPost.promptText);
 }
if(pikaBodyGenerate22I2vGenerate22I2vPost.resolution !== undefined) {
 formData.append(`resolution`, pikaBodyGenerate22I2vGenerate22I2vPost.resolution);
 }
if(pikaBodyGenerate22I2vGenerate22I2vPost.seed !== undefined && pikaBodyGenerate22I2vGenerate22I2vPost.seed !== null) {
 formData.append(`seed`, pikaBodyGenerate22I2vGenerate22I2vPost.seed.toString())
 }

  return customInstance<pikaGenerate22I2vGenerate22I2vPostResponse>(getPikaGenerate22I2vGenerate22I2vPostUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getPikaGenerate22I2vGenerate22I2vPostMutationOptions = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>, TError,{data: PikaBodyGenerate22I2vGenerate22I2vPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>, TError,{data: PikaBodyGenerate22I2vGenerate22I2vPost}, TContext> => {

const mutationKey = ['pikaGenerate22I2vGenerate22I2vPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>, {data: PikaBodyGenerate22I2vGenerate22I2vPost}> = (props) => {
          const {data} = props ?? {};

          return  pikaGenerate22I2vGenerate22I2vPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PikaGenerate22I2vGenerate22I2vPostMutationResult = NonNullable<Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>>
    export type PikaGenerate22I2vGenerate22I2vPostMutationBody = PikaBodyGenerate22I2vGenerate22I2vPost
    export type PikaGenerate22I2vGenerate22I2vPostMutationError = PikaHTTPValidationError

    /**
 * @summary Generate 2 2 I2V
 */
export const usePikaGenerate22I2vGenerate22I2vPost = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>, TError,{data: PikaBodyGenerate22I2vGenerate22I2vPost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>,
        TError,
        {data: PikaBodyGenerate22I2vGenerate22I2vPost},
        TContext
      > => {
      return useMutation(getPikaGenerate22I2vGenerate22I2vPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Generate 2 2 Keyframe
 */
export type pikaGenerate22KeyframeGenerate22PikaframesPostResponse200 = {
  data: PikaGenerateResponse
  status: 200
}

export type pikaGenerate22KeyframeGenerate22PikaframesPostResponse422 = {
  data: PikaHTTPValidationError
  status: 422
}
    
export type pikaGenerate22KeyframeGenerate22PikaframesPostResponseSuccess = (pikaGenerate22KeyframeGenerate22PikaframesPostResponse200) & {
  headers: Headers;
};
export type pikaGenerate22KeyframeGenerate22PikaframesPostResponseError = (pikaGenerate22KeyframeGenerate22PikaframesPostResponse422) & {
  headers: Headers;
};

export type pikaGenerate22KeyframeGenerate22PikaframesPostResponse = (pikaGenerate22KeyframeGenerate22PikaframesPostResponseSuccess | pikaGenerate22KeyframeGenerate22PikaframesPostResponseError)

export const getPikaGenerate22KeyframeGenerate22PikaframesPostUrl = () => {


  

  return `/proxy/pika/generate/2.2/pikaframes`
}

export const pikaGenerate22KeyframeGenerate22PikaframesPost = async (pikaBodyGenerate22KeyframeGenerate22PikaframesPost: PikaBodyGenerate22KeyframeGenerate22PikaframesPost, options?: RequestInit): Promise<pikaGenerate22KeyframeGenerate22PikaframesPostResponse> => {
    const formData = new FormData();
if(pikaBodyGenerate22KeyframeGenerate22PikaframesPost.duration !== undefined) {
 formData.append(`duration`, pikaBodyGenerate22KeyframeGenerate22PikaframesPost.duration.toString())
 }
if(pikaBodyGenerate22KeyframeGenerate22PikaframesPost.keyFrames !== undefined) {
 pikaBodyGenerate22KeyframeGenerate22PikaframesPost.keyFrames.forEach(value => formData.append(`keyFrames`, value));
 }
if(pikaBodyGenerate22KeyframeGenerate22PikaframesPost.negativePrompt !== undefined) {
 formData.append(`negativePrompt`, pikaBodyGenerate22KeyframeGenerate22PikaframesPost.negativePrompt);
 }
formData.append(`promptText`, pikaBodyGenerate22KeyframeGenerate22PikaframesPost.promptText);
if(pikaBodyGenerate22KeyframeGenerate22PikaframesPost.resolution !== undefined) {
 formData.append(`resolution`, pikaBodyGenerate22KeyframeGenerate22PikaframesPost.resolution);
 }
if(pikaBodyGenerate22KeyframeGenerate22PikaframesPost.seed !== undefined) {
 formData.append(`seed`, pikaBodyGenerate22KeyframeGenerate22PikaframesPost.seed.toString())
 }

  return customInstance<pikaGenerate22KeyframeGenerate22PikaframesPostResponse>(getPikaGenerate22KeyframeGenerate22PikaframesPostUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getPikaGenerate22KeyframeGenerate22PikaframesPostMutationOptions = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22KeyframeGenerate22PikaframesPost>>, TError,{data: PikaBodyGenerate22KeyframeGenerate22PikaframesPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22KeyframeGenerate22PikaframesPost>>, TError,{data: PikaBodyGenerate22KeyframeGenerate22PikaframesPost}, TContext> => {

const mutationKey = ['pikaGenerate22KeyframeGenerate22PikaframesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pikaGenerate22KeyframeGenerate22PikaframesPost>>, {data: PikaBodyGenerate22KeyframeGenerate22PikaframesPost}> = (props) => {
          const {data} = props ?? {};

          return  pikaGenerate22KeyframeGenerate22PikaframesPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PikaGenerate22KeyframeGenerate22PikaframesPostMutationResult = NonNullable<Awaited<ReturnType<typeof pikaGenerate22KeyframeGenerate22PikaframesPost>>>
    export type PikaGenerate22KeyframeGenerate22PikaframesPostMutationBody = PikaBodyGenerate22KeyframeGenerate22PikaframesPost
    export type PikaGenerate22KeyframeGenerate22PikaframesPostMutationError = PikaHTTPValidationError

    /**
 * @summary Generate 2 2 Keyframe
 */
export const usePikaGenerate22KeyframeGenerate22PikaframesPost = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22KeyframeGenerate22PikaframesPost>>, TError,{data: PikaBodyGenerate22KeyframeGenerate22PikaframesPost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pikaGenerate22KeyframeGenerate22PikaframesPost>>,
        TError,
        {data: PikaBodyGenerate22KeyframeGenerate22PikaframesPost},
        TContext
      > => {
      return useMutation(getPikaGenerate22KeyframeGenerate22PikaframesPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Generate 2 2 C2V
 */
export type pikaGenerate22C2vGenerate22PikascenesPostResponse200 = {
  data: PikaGenerateResponse
  status: 200
}

export type pikaGenerate22C2vGenerate22PikascenesPostResponse422 = {
  data: PikaHTTPValidationError
  status: 422
}
    
export type pikaGenerate22C2vGenerate22PikascenesPostResponseSuccess = (pikaGenerate22C2vGenerate22PikascenesPostResponse200) & {
  headers: Headers;
};
export type pikaGenerate22C2vGenerate22PikascenesPostResponseError = (pikaGenerate22C2vGenerate22PikascenesPostResponse422) & {
  headers: Headers;
};

export type pikaGenerate22C2vGenerate22PikascenesPostResponse = (pikaGenerate22C2vGenerate22PikascenesPostResponseSuccess | pikaGenerate22C2vGenerate22PikascenesPostResponseError)

export const getPikaGenerate22C2vGenerate22PikascenesPostUrl = () => {


  

  return `/proxy/pika/generate/2.2/pikascenes`
}

export const pikaGenerate22C2vGenerate22PikascenesPost = async (pikaBodyGenerate22C2vGenerate22PikascenesPost: PikaBodyGenerate22C2vGenerate22PikascenesPost, options?: RequestInit): Promise<pikaGenerate22C2vGenerate22PikascenesPostResponse> => {
    const formData = new FormData();
if(pikaBodyGenerate22C2vGenerate22PikascenesPost.aspectRatio !== undefined) {
 formData.append(`aspectRatio`, pikaBodyGenerate22C2vGenerate22PikascenesPost.aspectRatio.toString())
 }
if(pikaBodyGenerate22C2vGenerate22PikascenesPost.duration !== undefined) {
 formData.append(`duration`, pikaBodyGenerate22C2vGenerate22PikascenesPost.duration.toString())
 }
if(pikaBodyGenerate22C2vGenerate22PikascenesPost.images !== undefined) {
 pikaBodyGenerate22C2vGenerate22PikascenesPost.images.forEach(value => formData.append(`images`, value));
 }
formData.append(`ingredientsMode`, pikaBodyGenerate22C2vGenerate22PikascenesPost.ingredientsMode);
if(pikaBodyGenerate22C2vGenerate22PikascenesPost.negativePrompt !== undefined) {
 formData.append(`negativePrompt`, pikaBodyGenerate22C2vGenerate22PikascenesPost.negativePrompt);
 }
if(pikaBodyGenerate22C2vGenerate22PikascenesPost.promptText !== undefined) {
 formData.append(`promptText`, pikaBodyGenerate22C2vGenerate22PikascenesPost.promptText);
 }
if(pikaBodyGenerate22C2vGenerate22PikascenesPost.resolution !== undefined) {
 formData.append(`resolution`, pikaBodyGenerate22C2vGenerate22PikascenesPost.resolution);
 }
if(pikaBodyGenerate22C2vGenerate22PikascenesPost.seed !== undefined) {
 formData.append(`seed`, pikaBodyGenerate22C2vGenerate22PikascenesPost.seed.toString())
 }

  return customInstance<pikaGenerate22C2vGenerate22PikascenesPostResponse>(getPikaGenerate22C2vGenerate22PikascenesPostUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getPikaGenerate22C2vGenerate22PikascenesPostMutationOptions = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>>, TError,{data: PikaBodyGenerate22C2vGenerate22PikascenesPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>>, TError,{data: PikaBodyGenerate22C2vGenerate22PikascenesPost}, TContext> => {

const mutationKey = ['pikaGenerate22C2vGenerate22PikascenesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>>, {data: PikaBodyGenerate22C2vGenerate22PikascenesPost}> = (props) => {
          const {data} = props ?? {};

          return  pikaGenerate22C2vGenerate22PikascenesPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PikaGenerate22C2vGenerate22PikascenesPostMutationResult = NonNullable<Awaited<ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>>>
    export type PikaGenerate22C2vGenerate22PikascenesPostMutationBody = PikaBodyGenerate22C2vGenerate22PikascenesPost
    export type PikaGenerate22C2vGenerate22PikascenesPostMutationError = PikaHTTPValidationError

    /**
 * @summary Generate 2 2 C2V
 */
export const usePikaGenerate22C2vGenerate22PikascenesPost = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>>, TError,{data: PikaBodyGenerate22C2vGenerate22PikascenesPost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>>,
        TError,
        {data: PikaBodyGenerate22C2vGenerate22PikascenesPost},
        TContext
      > => {
      return useMutation(getPikaGenerate22C2vGenerate22PikascenesPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Generate 2 2 T2V
 */
export type pikaGenerate22T2vGenerate22T2vPostResponse200 = {
  data: PikaGenerateResponse
  status: 200
}

export type pikaGenerate22T2vGenerate22T2vPostResponse422 = {
  data: PikaHTTPValidationError
  status: 422
}
    
export type pikaGenerate22T2vGenerate22T2vPostResponseSuccess = (pikaGenerate22T2vGenerate22T2vPostResponse200) & {
  headers: Headers;
};
export type pikaGenerate22T2vGenerate22T2vPostResponseError = (pikaGenerate22T2vGenerate22T2vPostResponse422) & {
  headers: Headers;
};

export type pikaGenerate22T2vGenerate22T2vPostResponse = (pikaGenerate22T2vGenerate22T2vPostResponseSuccess | pikaGenerate22T2vGenerate22T2vPostResponseError)

export const getPikaGenerate22T2vGenerate22T2vPostUrl = () => {


  

  return `/proxy/pika/generate/2.2/t2v`
}

export const pikaGenerate22T2vGenerate22T2vPost = async (pikaBodyGenerate22T2vGenerate22T2vPost: PikaBodyGenerate22T2vGenerate22T2vPost, options?: RequestInit): Promise<pikaGenerate22T2vGenerate22T2vPostResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(pikaBodyGenerate22T2vGenerate22T2vPost.aspectRatio !== undefined) {
 formUrlEncoded.append(`aspectRatio`, pikaBodyGenerate22T2vGenerate22T2vPost.aspectRatio.toString())
 }
if(pikaBodyGenerate22T2vGenerate22T2vPost.duration !== undefined) {
 formUrlEncoded.append(`duration`, pikaBodyGenerate22T2vGenerate22T2vPost.duration.toString())
 }
if(pikaBodyGenerate22T2vGenerate22T2vPost.negativePrompt !== undefined && pikaBodyGenerate22T2vGenerate22T2vPost.negativePrompt !== null) {
 formUrlEncoded.append(`negativePrompt`, pikaBodyGenerate22T2vGenerate22T2vPost.negativePrompt);
 }
formUrlEncoded.append(`promptText`, pikaBodyGenerate22T2vGenerate22T2vPost.promptText);
if(pikaBodyGenerate22T2vGenerate22T2vPost.resolution !== undefined) {
 formUrlEncoded.append(`resolution`, pikaBodyGenerate22T2vGenerate22T2vPost.resolution);
 }
if(pikaBodyGenerate22T2vGenerate22T2vPost.seed !== undefined && pikaBodyGenerate22T2vGenerate22T2vPost.seed !== null) {
 formUrlEncoded.append(`seed`, pikaBodyGenerate22T2vGenerate22T2vPost.seed.toString())
 }

  return customInstance<pikaGenerate22T2vGenerate22T2vPostResponse>(getPikaGenerate22T2vGenerate22T2vPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
);}




export const getPikaGenerate22T2vGenerate22T2vPostMutationOptions = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>, TError,{data: PikaBodyGenerate22T2vGenerate22T2vPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>, TError,{data: PikaBodyGenerate22T2vGenerate22T2vPost}, TContext> => {

const mutationKey = ['pikaGenerate22T2vGenerate22T2vPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>, {data: PikaBodyGenerate22T2vGenerate22T2vPost}> = (props) => {
          const {data} = props ?? {};

          return  pikaGenerate22T2vGenerate22T2vPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PikaGenerate22T2vGenerate22T2vPostMutationResult = NonNullable<Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>>
    export type PikaGenerate22T2vGenerate22T2vPostMutationBody = PikaBodyGenerate22T2vGenerate22T2vPost
    export type PikaGenerate22T2vGenerate22T2vPostMutationError = PikaHTTPValidationError

    /**
 * @summary Generate 2 2 T2V
 */
export const usePikaGenerate22T2vGenerate22T2vPost = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>, TError,{data: PikaBodyGenerate22T2vGenerate22T2vPost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>,
        TError,
        {data: PikaBodyGenerate22T2vGenerate22T2vPost},
        TContext
      > => {
      return useMutation(getPikaGenerate22T2vGenerate22T2vPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Generate Pikadditions
 */
export type pikaGeneratePikadditionsGeneratePikadditionsPostResponse200 = {
  data: PikaGenerateResponse
  status: 200
}

export type pikaGeneratePikadditionsGeneratePikadditionsPostResponse422 = {
  data: PikaHTTPValidationError
  status: 422
}
    
export type pikaGeneratePikadditionsGeneratePikadditionsPostResponseSuccess = (pikaGeneratePikadditionsGeneratePikadditionsPostResponse200) & {
  headers: Headers;
};
export type pikaGeneratePikadditionsGeneratePikadditionsPostResponseError = (pikaGeneratePikadditionsGeneratePikadditionsPostResponse422) & {
  headers: Headers;
};

export type pikaGeneratePikadditionsGeneratePikadditionsPostResponse = (pikaGeneratePikadditionsGeneratePikadditionsPostResponseSuccess | pikaGeneratePikadditionsGeneratePikadditionsPostResponseError)

export const getPikaGeneratePikadditionsGeneratePikadditionsPostUrl = () => {


  

  return `/proxy/pika/generate/pikadditions`
}

export const pikaGeneratePikadditionsGeneratePikadditionsPost = async (pikaBodyGeneratePikadditionsGeneratePikadditionsPost: PikaBodyGeneratePikadditionsGeneratePikadditionsPost, options?: RequestInit): Promise<pikaGeneratePikadditionsGeneratePikadditionsPostResponse> => {
    const formData = new FormData();
if(pikaBodyGeneratePikadditionsGeneratePikadditionsPost.image !== undefined) {
 formData.append(`image`, pikaBodyGeneratePikadditionsGeneratePikadditionsPost.image);
 }
if(pikaBodyGeneratePikadditionsGeneratePikadditionsPost.negativePrompt !== undefined) {
 formData.append(`negativePrompt`, pikaBodyGeneratePikadditionsGeneratePikadditionsPost.negativePrompt);
 }
if(pikaBodyGeneratePikadditionsGeneratePikadditionsPost.promptText !== undefined) {
 formData.append(`promptText`, pikaBodyGeneratePikadditionsGeneratePikadditionsPost.promptText);
 }
if(pikaBodyGeneratePikadditionsGeneratePikadditionsPost.seed !== undefined) {
 formData.append(`seed`, pikaBodyGeneratePikadditionsGeneratePikadditionsPost.seed.toString())
 }
if(pikaBodyGeneratePikadditionsGeneratePikadditionsPost.video !== undefined) {
 formData.append(`video`, pikaBodyGeneratePikadditionsGeneratePikadditionsPost.video);
 }

  return customInstance<pikaGeneratePikadditionsGeneratePikadditionsPostResponse>(getPikaGeneratePikadditionsGeneratePikadditionsPostUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getPikaGeneratePikadditionsGeneratePikadditionsPostMutationOptions = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGeneratePikadditionsGeneratePikadditionsPost>>, TError,{data: PikaBodyGeneratePikadditionsGeneratePikadditionsPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pikaGeneratePikadditionsGeneratePikadditionsPost>>, TError,{data: PikaBodyGeneratePikadditionsGeneratePikadditionsPost}, TContext> => {

const mutationKey = ['pikaGeneratePikadditionsGeneratePikadditionsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pikaGeneratePikadditionsGeneratePikadditionsPost>>, {data: PikaBodyGeneratePikadditionsGeneratePikadditionsPost}> = (props) => {
          const {data} = props ?? {};

          return  pikaGeneratePikadditionsGeneratePikadditionsPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PikaGeneratePikadditionsGeneratePikadditionsPostMutationResult = NonNullable<Awaited<ReturnType<typeof pikaGeneratePikadditionsGeneratePikadditionsPost>>>
    export type PikaGeneratePikadditionsGeneratePikadditionsPostMutationBody = PikaBodyGeneratePikadditionsGeneratePikadditionsPost
    export type PikaGeneratePikadditionsGeneratePikadditionsPostMutationError = PikaHTTPValidationError

    /**
 * @summary Generate Pikadditions
 */
export const usePikaGeneratePikadditionsGeneratePikadditionsPost = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGeneratePikadditionsGeneratePikadditionsPost>>, TError,{data: PikaBodyGeneratePikadditionsGeneratePikadditionsPost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pikaGeneratePikadditionsGeneratePikadditionsPost>>,
        TError,
        {data: PikaBodyGeneratePikadditionsGeneratePikadditionsPost},
        TContext
      > => {
      return useMutation(getPikaGeneratePikadditionsGeneratePikadditionsPostMutationOptions(options), queryClient);
    }
    
/**
 * Generate a video with a specific Pikaffect. Supported Pikaffects: Cake-ify, Crumble, Crush, Decapitate, Deflate, Dissolve, Explode, Eye-pop, Inflate, Levitate, Melt, Peel, Poke, Squish, Ta-da, Tear
 * @summary Generate Pikaffects
 */
export type pikaGeneratePikaffectsGeneratePikaffectsPostResponse200 = {
  data: PikaGenerateResponse
  status: 200
}

export type pikaGeneratePikaffectsGeneratePikaffectsPostResponse422 = {
  data: PikaHTTPValidationError
  status: 422
}
    
export type pikaGeneratePikaffectsGeneratePikaffectsPostResponseSuccess = (pikaGeneratePikaffectsGeneratePikaffectsPostResponse200) & {
  headers: Headers;
};
export type pikaGeneratePikaffectsGeneratePikaffectsPostResponseError = (pikaGeneratePikaffectsGeneratePikaffectsPostResponse422) & {
  headers: Headers;
};

export type pikaGeneratePikaffectsGeneratePikaffectsPostResponse = (pikaGeneratePikaffectsGeneratePikaffectsPostResponseSuccess | pikaGeneratePikaffectsGeneratePikaffectsPostResponseError)

export const getPikaGeneratePikaffectsGeneratePikaffectsPostUrl = () => {


  

  return `/proxy/pika/generate/pikaffects`
}

export const pikaGeneratePikaffectsGeneratePikaffectsPost = async (pikaBodyGeneratePikaffectsGeneratePikaffectsPost: PikaBodyGeneratePikaffectsGeneratePikaffectsPost, options?: RequestInit): Promise<pikaGeneratePikaffectsGeneratePikaffectsPostResponse> => {
    const formData = new FormData();
if(pikaBodyGeneratePikaffectsGeneratePikaffectsPost.image !== undefined) {
 formData.append(`image`, pikaBodyGeneratePikaffectsGeneratePikaffectsPost.image);
 }
if(pikaBodyGeneratePikaffectsGeneratePikaffectsPost.negativePrompt !== undefined) {
 formData.append(`negativePrompt`, pikaBodyGeneratePikaffectsGeneratePikaffectsPost.negativePrompt);
 }
if(pikaBodyGeneratePikaffectsGeneratePikaffectsPost.pikaffect !== undefined) {
 formData.append(`pikaffect`, pikaBodyGeneratePikaffectsGeneratePikaffectsPost.pikaffect);
 }
if(pikaBodyGeneratePikaffectsGeneratePikaffectsPost.promptText !== undefined) {
 formData.append(`promptText`, pikaBodyGeneratePikaffectsGeneratePikaffectsPost.promptText);
 }
if(pikaBodyGeneratePikaffectsGeneratePikaffectsPost.seed !== undefined) {
 formData.append(`seed`, pikaBodyGeneratePikaffectsGeneratePikaffectsPost.seed.toString())
 }

  return customInstance<pikaGeneratePikaffectsGeneratePikaffectsPostResponse>(getPikaGeneratePikaffectsGeneratePikaffectsPostUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getPikaGeneratePikaffectsGeneratePikaffectsPostMutationOptions = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>>, TError,{data: PikaBodyGeneratePikaffectsGeneratePikaffectsPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>>, TError,{data: PikaBodyGeneratePikaffectsGeneratePikaffectsPost}, TContext> => {

const mutationKey = ['pikaGeneratePikaffectsGeneratePikaffectsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>>, {data: PikaBodyGeneratePikaffectsGeneratePikaffectsPost}> = (props) => {
          const {data} = props ?? {};

          return  pikaGeneratePikaffectsGeneratePikaffectsPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PikaGeneratePikaffectsGeneratePikaffectsPostMutationResult = NonNullable<Awaited<ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>>>
    export type PikaGeneratePikaffectsGeneratePikaffectsPostMutationBody = PikaBodyGeneratePikaffectsGeneratePikaffectsPost
    export type PikaGeneratePikaffectsGeneratePikaffectsPostMutationError = PikaHTTPValidationError

    /**
 * @summary Generate Pikaffects
 */
export const usePikaGeneratePikaffectsGeneratePikaffectsPost = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>>, TError,{data: PikaBodyGeneratePikaffectsGeneratePikaffectsPost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>>,
        TError,
        {data: PikaBodyGeneratePikaffectsGeneratePikaffectsPost},
        TContext
      > => {
      return useMutation(getPikaGeneratePikaffectsGeneratePikaffectsPostMutationOptions(options), queryClient);
    }
    
/**
 * Exactly one of `modifyRegionMask` and `modifyRegionRoi` must be provided.
 * @summary Generate Pikaswaps
 */
export type pikaGeneratePikaswapsGeneratePikaswapsPostResponse200 = {
  data: PikaGenerateResponse
  status: 200
}

export type pikaGeneratePikaswapsGeneratePikaswapsPostResponse422 = {
  data: PikaHTTPValidationError
  status: 422
}
    
export type pikaGeneratePikaswapsGeneratePikaswapsPostResponseSuccess = (pikaGeneratePikaswapsGeneratePikaswapsPostResponse200) & {
  headers: Headers;
};
export type pikaGeneratePikaswapsGeneratePikaswapsPostResponseError = (pikaGeneratePikaswapsGeneratePikaswapsPostResponse422) & {
  headers: Headers;
};

export type pikaGeneratePikaswapsGeneratePikaswapsPostResponse = (pikaGeneratePikaswapsGeneratePikaswapsPostResponseSuccess | pikaGeneratePikaswapsGeneratePikaswapsPostResponseError)

export const getPikaGeneratePikaswapsGeneratePikaswapsPostUrl = () => {


  

  return `/proxy/pika/generate/pikaswaps`
}

export const pikaGeneratePikaswapsGeneratePikaswapsPost = async (pikaBodyGeneratePikaswapsGeneratePikaswapsPost: PikaBodyGeneratePikaswapsGeneratePikaswapsPost, options?: RequestInit): Promise<pikaGeneratePikaswapsGeneratePikaswapsPostResponse> => {
    const formData = new FormData();
if(pikaBodyGeneratePikaswapsGeneratePikaswapsPost.image !== undefined) {
 formData.append(`image`, pikaBodyGeneratePikaswapsGeneratePikaswapsPost.image);
 }
if(pikaBodyGeneratePikaswapsGeneratePikaswapsPost.modifyRegionMask !== undefined) {
 formData.append(`modifyRegionMask`, pikaBodyGeneratePikaswapsGeneratePikaswapsPost.modifyRegionMask);
 }
if(pikaBodyGeneratePikaswapsGeneratePikaswapsPost.modifyRegionRoi !== undefined) {
 formData.append(`modifyRegionRoi`, pikaBodyGeneratePikaswapsGeneratePikaswapsPost.modifyRegionRoi);
 }
if(pikaBodyGeneratePikaswapsGeneratePikaswapsPost.negativePrompt !== undefined) {
 formData.append(`negativePrompt`, pikaBodyGeneratePikaswapsGeneratePikaswapsPost.negativePrompt);
 }
if(pikaBodyGeneratePikaswapsGeneratePikaswapsPost.promptText !== undefined) {
 formData.append(`promptText`, pikaBodyGeneratePikaswapsGeneratePikaswapsPost.promptText);
 }
if(pikaBodyGeneratePikaswapsGeneratePikaswapsPost.seed !== undefined) {
 formData.append(`seed`, pikaBodyGeneratePikaswapsGeneratePikaswapsPost.seed.toString())
 }
if(pikaBodyGeneratePikaswapsGeneratePikaswapsPost.video !== undefined) {
 formData.append(`video`, pikaBodyGeneratePikaswapsGeneratePikaswapsPost.video);
 }

  return customInstance<pikaGeneratePikaswapsGeneratePikaswapsPostResponse>(getPikaGeneratePikaswapsGeneratePikaswapsPostUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getPikaGeneratePikaswapsGeneratePikaswapsPostMutationOptions = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>>, TError,{data: PikaBodyGeneratePikaswapsGeneratePikaswapsPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>>, TError,{data: PikaBodyGeneratePikaswapsGeneratePikaswapsPost}, TContext> => {

const mutationKey = ['pikaGeneratePikaswapsGeneratePikaswapsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>>, {data: PikaBodyGeneratePikaswapsGeneratePikaswapsPost}> = (props) => {
          const {data} = props ?? {};

          return  pikaGeneratePikaswapsGeneratePikaswapsPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PikaGeneratePikaswapsGeneratePikaswapsPostMutationResult = NonNullable<Awaited<ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>>>
    export type PikaGeneratePikaswapsGeneratePikaswapsPostMutationBody = PikaBodyGeneratePikaswapsGeneratePikaswapsPost
    export type PikaGeneratePikaswapsGeneratePikaswapsPostMutationError = PikaHTTPValidationError

    /**
 * @summary Generate Pikaswaps
 */
export const usePikaGeneratePikaswapsGeneratePikaswapsPost = <TError = PikaHTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>>, TError,{data: PikaBodyGeneratePikaswapsGeneratePikaswapsPost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>>,
        TError,
        {data: PikaBodyGeneratePikaswapsGeneratePikaswapsPost},
        TContext
      > => {
      return useMutation(getPikaGeneratePikaswapsGeneratePikaswapsPostMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get Video
 */
export type pikaGetVideoVideosVideoIdGetResponse200 = {
  data: PikaVideoResponse
  status: 200
}

export type pikaGetVideoVideosVideoIdGetResponse422 = {
  data: PikaHTTPValidationError
  status: 422
}
    
export type pikaGetVideoVideosVideoIdGetResponseSuccess = (pikaGetVideoVideosVideoIdGetResponse200) & {
  headers: Headers;
};
export type pikaGetVideoVideosVideoIdGetResponseError = (pikaGetVideoVideosVideoIdGetResponse422) & {
  headers: Headers;
};

export type pikaGetVideoVideosVideoIdGetResponse = (pikaGetVideoVideosVideoIdGetResponseSuccess | pikaGetVideoVideosVideoIdGetResponseError)

export const getPikaGetVideoVideosVideoIdGetUrl = (videoId: string,) => {


  

  return `/proxy/pika/videos/${videoId}`
}

export const pikaGetVideoVideosVideoIdGet = async (videoId: string, options?: RequestInit): Promise<pikaGetVideoVideosVideoIdGetResponse> => {
  
  return customInstance<pikaGetVideoVideosVideoIdGetResponse>(getPikaGetVideoVideosVideoIdGetUrl(videoId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getPikaGetVideoVideosVideoIdGetQueryKey = (videoId: string,) => {
    return [
    `/proxy/pika/videos/${videoId}`
    ] as const;
    }

    
export const getPikaGetVideoVideosVideoIdGetQueryOptions = <TData = Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>, TError = PikaHTTPValidationError>(videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPikaGetVideoVideosVideoIdGetQueryKey(videoId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>> = ({ signal }) => pikaGetVideoVideosVideoIdGet(videoId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(videoId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PikaGetVideoVideosVideoIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>>
export type PikaGetVideoVideosVideoIdGetQueryError = PikaHTTPValidationError


export function usePikaGetVideoVideosVideoIdGet<TData = Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>, TError = PikaHTTPValidationError>(
 videoId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
          TError,
          Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePikaGetVideoVideosVideoIdGet<TData = Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>, TError = PikaHTTPValidationError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
          TError,
          Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePikaGetVideoVideosVideoIdGet<TData = Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>, TError = PikaHTTPValidationError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Video
 */

export function usePikaGetVideoVideosVideoIdGet<TData = Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>, TError = PikaHTTPValidationError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPikaGetVideoVideosVideoIdGetQueryOptions(videoId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Upload an image to the server.
 */
export type pixverseUploadImageResponse200 = {
  data: PixverseImageUploadResponse
  status: 200
}

export type pixverseUploadImageResponse400 = {
  data: ErrorResponse
  status: 400
}

export type pixverseUploadImageResponse401 = {
  data: void
  status: 401
}

export type pixverseUploadImageResponse402 = {
  data: void
  status: 402
}

export type pixverseUploadImageResponse429 = {
  data: ErrorResponse
  status: 429
}

export type pixverseUploadImageResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type pixverseUploadImageResponseSuccess = (pixverseUploadImageResponse200) & {
  headers: Headers;
};
export type pixverseUploadImageResponseError = (pixverseUploadImageResponse400 | pixverseUploadImageResponse401 | pixverseUploadImageResponse402 | pixverseUploadImageResponse429 | pixverseUploadImageResponse500) & {
  headers: Headers;
};

export type pixverseUploadImageResponse = (pixverseUploadImageResponseSuccess | pixverseUploadImageResponseError)

export const getPixverseUploadImageUrl = () => {


  

  return `/proxy/pixverse/image/upload`
}

export const pixverseUploadImage = async (pixverseUploadImageBody: PixverseUploadImageBody, options?: RequestInit): Promise<pixverseUploadImageResponse> => {
    const formData = new FormData();
if(pixverseUploadImageBody.image !== undefined) {
 formData.append(`image`, pixverseUploadImageBody.image);
 }

  return customInstance<pixverseUploadImageResponse>(getPixverseUploadImageUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getPixverseUploadImageMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pixverseUploadImage>>, TError,{data: PixverseUploadImageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pixverseUploadImage>>, TError,{data: PixverseUploadImageBody}, TContext> => {

const mutationKey = ['pixverseUploadImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pixverseUploadImage>>, {data: PixverseUploadImageBody}> = (props) => {
          const {data} = props ?? {};

          return  pixverseUploadImage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PixverseUploadImageMutationResult = NonNullable<Awaited<ReturnType<typeof pixverseUploadImage>>>
    export type PixverseUploadImageMutationBody = PixverseUploadImageBody
    export type PixverseUploadImageMutationError = ErrorResponse | void

    /**
 * @summary Upload an image to the server.
 */
export const usePixverseUploadImage = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pixverseUploadImage>>, TError,{data: PixverseUploadImageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pixverseUploadImage>>,
        TError,
        {data: PixverseUploadImageBody},
        TContext
      > => {
      return useMutation(getPixverseUploadImageMutationOptions(options), queryClient);
    }
    
/**
 * @summary Generate video from image.
 */
export type pixverseGenerateImageVideoResponse200 = {
  data: PixverseVideoResponse
  status: 200
}

export type pixverseGenerateImageVideoResponse400 = {
  data: ErrorResponse
  status: 400
}

export type pixverseGenerateImageVideoResponse401 = {
  data: void
  status: 401
}

export type pixverseGenerateImageVideoResponse402 = {
  data: void
  status: 402
}

export type pixverseGenerateImageVideoResponse429 = {
  data: ErrorResponse
  status: 429
}

export type pixverseGenerateImageVideoResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type pixverseGenerateImageVideoResponseSuccess = (pixverseGenerateImageVideoResponse200) & {
  headers: Headers;
};
export type pixverseGenerateImageVideoResponseError = (pixverseGenerateImageVideoResponse400 | pixverseGenerateImageVideoResponse401 | pixverseGenerateImageVideoResponse402 | pixverseGenerateImageVideoResponse429 | pixverseGenerateImageVideoResponse500) & {
  headers: Headers;
};

export type pixverseGenerateImageVideoResponse = (pixverseGenerateImageVideoResponseSuccess | pixverseGenerateImageVideoResponseError)

export const getPixverseGenerateImageVideoUrl = () => {


  

  return `/proxy/pixverse/video/img/generate`
}

export const pixverseGenerateImageVideo = async (pixverseImageVideoRequest: PixverseImageVideoRequest, options?: RequestInit): Promise<pixverseGenerateImageVideoResponse> => {
  
  return customInstance<pixverseGenerateImageVideoResponse>(getPixverseGenerateImageVideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pixverseImageVideoRequest,)
  }
);}




export const getPixverseGenerateImageVideoMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pixverseGenerateImageVideo>>, TError,{data: PixverseImageVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pixverseGenerateImageVideo>>, TError,{data: PixverseImageVideoRequest}, TContext> => {

const mutationKey = ['pixverseGenerateImageVideo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pixverseGenerateImageVideo>>, {data: PixverseImageVideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  pixverseGenerateImageVideo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PixverseGenerateImageVideoMutationResult = NonNullable<Awaited<ReturnType<typeof pixverseGenerateImageVideo>>>
    export type PixverseGenerateImageVideoMutationBody = PixverseImageVideoRequest
    export type PixverseGenerateImageVideoMutationError = ErrorResponse | void

    /**
 * @summary Generate video from image.
 */
export const usePixverseGenerateImageVideo = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pixverseGenerateImageVideo>>, TError,{data: PixverseImageVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pixverseGenerateImageVideo>>,
        TError,
        {data: PixverseImageVideoRequest},
        TContext
      > => {
      return useMutation(getPixverseGenerateImageVideoMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get the result of a video generation.
 */
export type pixverseGetVideoResultResponse200 = {
  data: PixverseVideoResultResponse
  status: 200
}
    
export type pixverseGetVideoResultResponseSuccess = (pixverseGetVideoResultResponse200) & {
  headers: Headers;
};
;

export type pixverseGetVideoResultResponse = (pixverseGetVideoResultResponseSuccess)

export const getPixverseGetVideoResultUrl = (id: number,) => {


  

  return `/proxy/pixverse/video/result/${id}`
}

export const pixverseGetVideoResult = async (id: number, options?: RequestInit): Promise<pixverseGetVideoResultResponse> => {
  
  return customInstance<pixverseGetVideoResultResponse>(getPixverseGetVideoResultUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getPixverseGetVideoResultQueryKey = (id: number,) => {
    return [
    `/proxy/pixverse/video/result/${id}`
    ] as const;
    }

    
export const getPixverseGetVideoResultQueryOptions = <TData = Awaited<ReturnType<typeof pixverseGetVideoResult>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pixverseGetVideoResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPixverseGetVideoResultQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pixverseGetVideoResult>>> = ({ signal }) => pixverseGetVideoResult(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pixverseGetVideoResult>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PixverseGetVideoResultQueryResult = NonNullable<Awaited<ReturnType<typeof pixverseGetVideoResult>>>
export type PixverseGetVideoResultQueryError = unknown


export function usePixverseGetVideoResult<TData = Awaited<ReturnType<typeof pixverseGetVideoResult>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pixverseGetVideoResult>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pixverseGetVideoResult>>,
          TError,
          Awaited<ReturnType<typeof pixverseGetVideoResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePixverseGetVideoResult<TData = Awaited<ReturnType<typeof pixverseGetVideoResult>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pixverseGetVideoResult>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pixverseGetVideoResult>>,
          TError,
          Awaited<ReturnType<typeof pixverseGetVideoResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePixverseGetVideoResult<TData = Awaited<ReturnType<typeof pixverseGetVideoResult>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pixverseGetVideoResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the result of a video generation.
 */

export function usePixverseGetVideoResult<TData = Awaited<ReturnType<typeof pixverseGetVideoResult>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pixverseGetVideoResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPixverseGetVideoResultQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Generate video from text prompt.
 */
export type pixverseGenerateTextVideoResponse200 = {
  data: PixverseVideoResponse
  status: 200
}

export type pixverseGenerateTextVideoResponse400 = {
  data: ErrorResponse
  status: 400
}

export type pixverseGenerateTextVideoResponse401 = {
  data: void
  status: 401
}

export type pixverseGenerateTextVideoResponse402 = {
  data: void
  status: 402
}

export type pixverseGenerateTextVideoResponse429 = {
  data: ErrorResponse
  status: 429
}

export type pixverseGenerateTextVideoResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type pixverseGenerateTextVideoResponseSuccess = (pixverseGenerateTextVideoResponse200) & {
  headers: Headers;
};
export type pixverseGenerateTextVideoResponseError = (pixverseGenerateTextVideoResponse400 | pixverseGenerateTextVideoResponse401 | pixverseGenerateTextVideoResponse402 | pixverseGenerateTextVideoResponse429 | pixverseGenerateTextVideoResponse500) & {
  headers: Headers;
};

export type pixverseGenerateTextVideoResponse = (pixverseGenerateTextVideoResponseSuccess | pixverseGenerateTextVideoResponseError)

export const getPixverseGenerateTextVideoUrl = () => {


  

  return `/proxy/pixverse/video/text/generate`
}

export const pixverseGenerateTextVideo = async (pixverseTextVideoRequest: PixverseTextVideoRequest, options?: RequestInit): Promise<pixverseGenerateTextVideoResponse> => {
  
  return customInstance<pixverseGenerateTextVideoResponse>(getPixverseGenerateTextVideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pixverseTextVideoRequest,)
  }
);}




export const getPixverseGenerateTextVideoMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pixverseGenerateTextVideo>>, TError,{data: PixverseTextVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pixverseGenerateTextVideo>>, TError,{data: PixverseTextVideoRequest}, TContext> => {

const mutationKey = ['pixverseGenerateTextVideo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pixverseGenerateTextVideo>>, {data: PixverseTextVideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  pixverseGenerateTextVideo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PixverseGenerateTextVideoMutationResult = NonNullable<Awaited<ReturnType<typeof pixverseGenerateTextVideo>>>
    export type PixverseGenerateTextVideoMutationBody = PixverseTextVideoRequest
    export type PixverseGenerateTextVideoMutationError = ErrorResponse | void

    /**
 * @summary Generate video from text prompt.
 */
export const usePixverseGenerateTextVideo = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pixverseGenerateTextVideo>>, TError,{data: PixverseTextVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pixverseGenerateTextVideo>>,
        TError,
        {data: PixverseTextVideoRequest},
        TContext
      > => {
      return useMutation(getPixverseGenerateTextVideoMutationOptions(options), queryClient);
    }
    
/**
 * @summary Generate transition video between two images.
 */
export type pixverseGenerateTransitionVideoResponse200 = {
  data: PixverseVideoResponse
  status: 200
}

export type pixverseGenerateTransitionVideoResponse400 = {
  data: ErrorResponse
  status: 400
}

export type pixverseGenerateTransitionVideoResponse401 = {
  data: void
  status: 401
}

export type pixverseGenerateTransitionVideoResponse402 = {
  data: void
  status: 402
}

export type pixverseGenerateTransitionVideoResponse429 = {
  data: ErrorResponse
  status: 429
}

export type pixverseGenerateTransitionVideoResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type pixverseGenerateTransitionVideoResponseSuccess = (pixverseGenerateTransitionVideoResponse200) & {
  headers: Headers;
};
export type pixverseGenerateTransitionVideoResponseError = (pixverseGenerateTransitionVideoResponse400 | pixverseGenerateTransitionVideoResponse401 | pixverseGenerateTransitionVideoResponse402 | pixverseGenerateTransitionVideoResponse429 | pixverseGenerateTransitionVideoResponse500) & {
  headers: Headers;
};

export type pixverseGenerateTransitionVideoResponse = (pixverseGenerateTransitionVideoResponseSuccess | pixverseGenerateTransitionVideoResponseError)

export const getPixverseGenerateTransitionVideoUrl = () => {


  

  return `/proxy/pixverse/video/transition/generate`
}

export const pixverseGenerateTransitionVideo = async (pixverseTransitionVideoRequest: PixverseTransitionVideoRequest, options?: RequestInit): Promise<pixverseGenerateTransitionVideoResponse> => {
  
  return customInstance<pixverseGenerateTransitionVideoResponse>(getPixverseGenerateTransitionVideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pixverseTransitionVideoRequest,)
  }
);}




export const getPixverseGenerateTransitionVideoMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>, TError,{data: PixverseTransitionVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>, TError,{data: PixverseTransitionVideoRequest}, TContext> => {

const mutationKey = ['pixverseGenerateTransitionVideo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>, {data: PixverseTransitionVideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  pixverseGenerateTransitionVideo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PixverseGenerateTransitionVideoMutationResult = NonNullable<Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>>
    export type PixverseGenerateTransitionVideoMutationBody = PixverseTransitionVideoRequest
    export type PixverseGenerateTransitionVideoMutationError = ErrorResponse | void

    /**
 * @summary Generate transition video between two images.
 */
export const usePixverseGenerateTransitionVideo = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>, TError,{data: PixverseTransitionVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>,
        TError,
        {data: PixverseTransitionVideoRequest},
        TContext
      > => {
      return useMutation(getPixverseGenerateTransitionVideoMutationOptions(options), queryClient);
    }
    
/**
 * Forwards image generation requests to Recraft's API and returns the generated images.
 * @summary Proxy request to Recraft for image generation
 */
export type recraftImageGenerationResponse200 = {
  data: RecraftImageGenerationResponse
  status: 200
}

export type recraftImageGenerationResponse400 = {
  data: ErrorResponse
  status: 400
}

export type recraftImageGenerationResponse401 = {
  data: void
  status: 401
}

export type recraftImageGenerationResponse402 = {
  data: void
  status: 402
}

export type recraftImageGenerationResponse429 = {
  data: ErrorResponse
  status: 429
}

export type recraftImageGenerationResponse500 = {
  data: ErrorResponse
  status: 500
}

export type recraftImageGenerationResponse502 = {
  data: ErrorResponse
  status: 502
}

export type recraftImageGenerationResponse504 = {
  data: ErrorResponse
  status: 504
}
    
export type recraftImageGenerationResponseSuccess = (recraftImageGenerationResponse200) & {
  headers: Headers;
};
export type recraftImageGenerationResponseError = (recraftImageGenerationResponse400 | recraftImageGenerationResponse401 | recraftImageGenerationResponse402 | recraftImageGenerationResponse429 | recraftImageGenerationResponse500 | recraftImageGenerationResponse502 | recraftImageGenerationResponse504) & {
  headers: Headers;
};

export type recraftImageGenerationResponse = (recraftImageGenerationResponseSuccess | recraftImageGenerationResponseError)

export const getRecraftImageGenerationUrl = () => {


  

  return `/proxy/recraft/image_generation`
}

export const recraftImageGeneration = async (recraftImageGenerationRequest: RecraftImageGenerationRequest, options?: RequestInit): Promise<recraftImageGenerationResponse> => {
  
  return customInstance<recraftImageGenerationResponse>(getRecraftImageGenerationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      recraftImageGenerationRequest,)
  }
);}




export const getRecraftImageGenerationMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftImageGeneration>>, TError,{data: RecraftImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof recraftImageGeneration>>, TError,{data: RecraftImageGenerationRequest}, TContext> => {

const mutationKey = ['recraftImageGeneration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recraftImageGeneration>>, {data: RecraftImageGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  recraftImageGeneration(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RecraftImageGenerationMutationResult = NonNullable<Awaited<ReturnType<typeof recraftImageGeneration>>>
    export type RecraftImageGenerationMutationBody = RecraftImageGenerationRequest
    export type RecraftImageGenerationMutationError = ErrorResponse | void

    /**
 * @summary Proxy request to Recraft for image generation
 */
export const useRecraftImageGeneration = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftImageGeneration>>, TError,{data: RecraftImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recraftImageGeneration>>,
        TError,
        {data: RecraftImageGenerationRequest},
        TContext
      > => {
      return useMutation(getRecraftImageGenerationMutationOptions(options), queryClient);
    }
    
/**
 * @summary Creative Upscale
 */
export type recraftCreativeUpscaleResponse200 = {
  data: RecraftProcessImageResponse
  status: 200
}
    
export type recraftCreativeUpscaleResponseSuccess = (recraftCreativeUpscaleResponse200) & {
  headers: Headers;
};
;

export type recraftCreativeUpscaleResponse = (recraftCreativeUpscaleResponseSuccess)

export const getRecraftCreativeUpscaleUrl = () => {


  

  return `/proxy/recraft/images/creativeUpscale`
}

export const recraftCreativeUpscale = async (recraftProcessImageRequest: RecraftProcessImageRequest, options?: RequestInit): Promise<recraftCreativeUpscaleResponse> => {
    const formData = new FormData();
formData.append(`image`, recraftProcessImageRequest.image);
if(recraftProcessImageRequest.image_format !== undefined) {
 formData.append(`image_format`, recraftProcessImageRequest.image_format);
 }
if(recraftProcessImageRequest.response_format !== undefined) {
 formData.append(`response_format`, recraftProcessImageRequest.response_format);
 }

  return customInstance<recraftCreativeUpscaleResponse>(getRecraftCreativeUpscaleUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getRecraftCreativeUpscaleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftCreativeUpscale>>, TError,{data: RecraftProcessImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof recraftCreativeUpscale>>, TError,{data: RecraftProcessImageRequest}, TContext> => {

const mutationKey = ['recraftCreativeUpscale'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recraftCreativeUpscale>>, {data: RecraftProcessImageRequest}> = (props) => {
          const {data} = props ?? {};

          return  recraftCreativeUpscale(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RecraftCreativeUpscaleMutationResult = NonNullable<Awaited<ReturnType<typeof recraftCreativeUpscale>>>
    export type RecraftCreativeUpscaleMutationBody = RecraftProcessImageRequest
    export type RecraftCreativeUpscaleMutationError = unknown

    /**
 * @summary Creative Upscale
 */
export const useRecraftCreativeUpscale = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftCreativeUpscale>>, TError,{data: RecraftProcessImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recraftCreativeUpscale>>,
        TError,
        {data: RecraftProcessImageRequest},
        TContext
      > => {
      return useMutation(getRecraftCreativeUpscaleMutationOptions(options), queryClient);
    }
    
/**
 * @summary Upscale an image
 */
export type recraftCrispUpscaleResponse200 = {
  data: RecraftImageGenerationResponse
  status: 200
}

export type recraftCrispUpscaleResponse400 = {
  data: void
  status: 400
}

export type recraftCrispUpscaleResponse401 = {
  data: void
  status: 401
}
    
export type recraftCrispUpscaleResponseSuccess = (recraftCrispUpscaleResponse200) & {
  headers: Headers;
};
export type recraftCrispUpscaleResponseError = (recraftCrispUpscaleResponse400 | recraftCrispUpscaleResponse401) & {
  headers: Headers;
};

export type recraftCrispUpscaleResponse = (recraftCrispUpscaleResponseSuccess | recraftCrispUpscaleResponseError)

export const getRecraftCrispUpscaleUrl = () => {


  

  return `/proxy/recraft/images/crispUpscale`
}

export const recraftCrispUpscale = async (recraftCrispUpscaleBody: RecraftCrispUpscaleBody, options?: RequestInit): Promise<recraftCrispUpscaleResponse> => {
    const formData = new FormData();
formData.append(`file`, recraftCrispUpscaleBody.file);

  return customInstance<recraftCrispUpscaleResponse>(getRecraftCrispUpscaleUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getRecraftCrispUpscaleMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftCrispUpscale>>, TError,{data: RecraftCrispUpscaleBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof recraftCrispUpscale>>, TError,{data: RecraftCrispUpscaleBody}, TContext> => {

const mutationKey = ['recraftCrispUpscale'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recraftCrispUpscale>>, {data: RecraftCrispUpscaleBody}> = (props) => {
          const {data} = props ?? {};

          return  recraftCrispUpscale(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RecraftCrispUpscaleMutationResult = NonNullable<Awaited<ReturnType<typeof recraftCrispUpscale>>>
    export type RecraftCrispUpscaleMutationBody = RecraftCrispUpscaleBody
    export type RecraftCrispUpscaleMutationError = void

    /**
 * @summary Upscale an image
 */
export const useRecraftCrispUpscale = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftCrispUpscale>>, TError,{data: RecraftCrispUpscaleBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recraftCrispUpscale>>,
        TError,
        {data: RecraftCrispUpscaleBody},
        TContext
      > => {
      return useMutation(getRecraftCrispUpscaleMutationOptions(options), queryClient);
    }
    
/**
 * @summary Generate image from image and prompt
 */
export type recraftImageToImageResponse200 = {
  data: RecraftGenerateImageResponse
  status: 200
}
    
export type recraftImageToImageResponseSuccess = (recraftImageToImageResponse200) & {
  headers: Headers;
};
;

export type recraftImageToImageResponse = (recraftImageToImageResponseSuccess)

export const getRecraftImageToImageUrl = () => {


  

  return `/proxy/recraft/images/imageToImage`
}

export const recraftImageToImage = async (recraftImageToImageRequest: RecraftImageToImageRequest, options?: RequestInit): Promise<recraftImageToImageResponse> => {
    const formData = new FormData();
if(recraftImageToImageRequest.block_nsfw !== undefined) {
 formData.append(`block_nsfw`, recraftImageToImageRequest.block_nsfw.toString())
 }
if(recraftImageToImageRequest.calculate_features !== undefined) {
 formData.append(`calculate_features`, recraftImageToImageRequest.calculate_features.toString())
 }
if(recraftImageToImageRequest.controls !== undefined) {
 formData.append(`controls`, JSON.stringify(recraftImageToImageRequest.controls));
 }
formData.append(`image`, recraftImageToImageRequest.image);
if(recraftImageToImageRequest.image_format !== undefined) {
 formData.append(`image_format`, recraftImageToImageRequest.image_format);
 }
if(recraftImageToImageRequest.model !== undefined) {
 formData.append(`model`, recraftImageToImageRequest.model);
 }
if(recraftImageToImageRequest.n !== undefined) {
 formData.append(`n`, recraftImageToImageRequest.n.toString())
 }
if(recraftImageToImageRequest.negative_prompt !== undefined) {
 formData.append(`negative_prompt`, recraftImageToImageRequest.negative_prompt);
 }
formData.append(`prompt`, recraftImageToImageRequest.prompt);
if(recraftImageToImageRequest.response_format !== undefined) {
 formData.append(`response_format`, recraftImageToImageRequest.response_format);
 }
formData.append(`strength`, recraftImageToImageRequest.strength.toString())
if(recraftImageToImageRequest.style !== undefined) {
 formData.append(`style`, recraftImageToImageRequest.style);
 }
if(recraftImageToImageRequest.style_id !== undefined) {
 formData.append(`style_id`, recraftImageToImageRequest.style_id);
 }
if(recraftImageToImageRequest.substyle !== undefined) {
 formData.append(`substyle`, recraftImageToImageRequest.substyle);
 }
if(recraftImageToImageRequest.text_layout !== undefined) {
 recraftImageToImageRequest.text_layout.forEach(value => formData.append(`text_layout`, JSON.stringify(value)));
 }

  return customInstance<recraftImageToImageResponse>(getRecraftImageToImageUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getRecraftImageToImageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftImageToImage>>, TError,{data: RecraftImageToImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof recraftImageToImage>>, TError,{data: RecraftImageToImageRequest}, TContext> => {

const mutationKey = ['recraftImageToImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recraftImageToImage>>, {data: RecraftImageToImageRequest}> = (props) => {
          const {data} = props ?? {};

          return  recraftImageToImage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RecraftImageToImageMutationResult = NonNullable<Awaited<ReturnType<typeof recraftImageToImage>>>
    export type RecraftImageToImageMutationBody = RecraftImageToImageRequest
    export type RecraftImageToImageMutationError = unknown

    /**
 * @summary Generate image from image and prompt
 */
export const useRecraftImageToImage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftImageToImage>>, TError,{data: RecraftImageToImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recraftImageToImage>>,
        TError,
        {data: RecraftImageToImageRequest},
        TContext
      > => {
      return useMutation(getRecraftImageToImageMutationOptions(options), queryClient);
    }
    
/**
 * @summary Inpaint Image
 */
export type recraftInpaintImageResponse200 = {
  data: RecraftGenerateImageResponse
  status: 200
}
    
export type recraftInpaintImageResponseSuccess = (recraftInpaintImageResponse200) & {
  headers: Headers;
};
;

export type recraftInpaintImageResponse = (recraftInpaintImageResponseSuccess)

export const getRecraftInpaintImageUrl = () => {


  

  return `/proxy/recraft/images/inpaint`
}

export const recraftInpaintImage = async (recraftTransformImageWithMaskRequest: RecraftTransformImageWithMaskRequest, options?: RequestInit): Promise<recraftInpaintImageResponse> => {
    const formData = new FormData();
if(recraftTransformImageWithMaskRequest.block_nsfw !== undefined) {
 formData.append(`block_nsfw`, recraftTransformImageWithMaskRequest.block_nsfw.toString())
 }
if(recraftTransformImageWithMaskRequest.calculate_features !== undefined) {
 formData.append(`calculate_features`, recraftTransformImageWithMaskRequest.calculate_features.toString())
 }
formData.append(`image`, recraftTransformImageWithMaskRequest.image);
if(recraftTransformImageWithMaskRequest.image_format !== undefined) {
 formData.append(`image_format`, recraftTransformImageWithMaskRequest.image_format);
 }
formData.append(`mask`, recraftTransformImageWithMaskRequest.mask);
if(recraftTransformImageWithMaskRequest.model !== undefined) {
 formData.append(`model`, recraftTransformImageWithMaskRequest.model);
 }
if(recraftTransformImageWithMaskRequest.n !== undefined) {
 formData.append(`n`, recraftTransformImageWithMaskRequest.n.toString())
 }
if(recraftTransformImageWithMaskRequest.negative_prompt !== undefined) {
 formData.append(`negative_prompt`, recraftTransformImageWithMaskRequest.negative_prompt);
 }
formData.append(`prompt`, recraftTransformImageWithMaskRequest.prompt);
if(recraftTransformImageWithMaskRequest.response_format !== undefined) {
 formData.append(`response_format`, recraftTransformImageWithMaskRequest.response_format);
 }
if(recraftTransformImageWithMaskRequest.style !== undefined) {
 formData.append(`style`, recraftTransformImageWithMaskRequest.style);
 }
if(recraftTransformImageWithMaskRequest.style_id !== undefined) {
 formData.append(`style_id`, recraftTransformImageWithMaskRequest.style_id);
 }
if(recraftTransformImageWithMaskRequest.substyle !== undefined) {
 formData.append(`substyle`, recraftTransformImageWithMaskRequest.substyle);
 }
if(recraftTransformImageWithMaskRequest.text_layout !== undefined) {
 recraftTransformImageWithMaskRequest.text_layout.forEach(value => formData.append(`text_layout`, JSON.stringify(value)));
 }

  return customInstance<recraftInpaintImageResponse>(getRecraftInpaintImageUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getRecraftInpaintImageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftInpaintImage>>, TError,{data: RecraftTransformImageWithMaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof recraftInpaintImage>>, TError,{data: RecraftTransformImageWithMaskRequest}, TContext> => {

const mutationKey = ['recraftInpaintImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recraftInpaintImage>>, {data: RecraftTransformImageWithMaskRequest}> = (props) => {
          const {data} = props ?? {};

          return  recraftInpaintImage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RecraftInpaintImageMutationResult = NonNullable<Awaited<ReturnType<typeof recraftInpaintImage>>>
    export type RecraftInpaintImageMutationBody = RecraftTransformImageWithMaskRequest
    export type RecraftInpaintImageMutationError = unknown

    /**
 * @summary Inpaint Image
 */
export const useRecraftInpaintImage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftInpaintImage>>, TError,{data: RecraftTransformImageWithMaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recraftInpaintImage>>,
        TError,
        {data: RecraftTransformImageWithMaskRequest},
        TContext
      > => {
      return useMutation(getRecraftInpaintImageMutationOptions(options), queryClient);
    }
    
/**
 * @summary Remove background from an image
 */
export type recraftRemoveBackgroundResponse200 = {
  data: RecraftRemoveBackground200
  status: 200
}

export type recraftRemoveBackgroundResponse400 = {
  data: void
  status: 400
}

export type recraftRemoveBackgroundResponse401 = {
  data: void
  status: 401
}
    
export type recraftRemoveBackgroundResponseSuccess = (recraftRemoveBackgroundResponse200) & {
  headers: Headers;
};
export type recraftRemoveBackgroundResponseError = (recraftRemoveBackgroundResponse400 | recraftRemoveBackgroundResponse401) & {
  headers: Headers;
};

export type recraftRemoveBackgroundResponse = (recraftRemoveBackgroundResponseSuccess | recraftRemoveBackgroundResponseError)

export const getRecraftRemoveBackgroundUrl = () => {


  

  return `/proxy/recraft/images/removeBackground`
}

export const recraftRemoveBackground = async (recraftRemoveBackgroundBody: RecraftRemoveBackgroundBody, options?: RequestInit): Promise<recraftRemoveBackgroundResponse> => {
    const formData = new FormData();
formData.append(`file`, recraftRemoveBackgroundBody.file);

  return customInstance<recraftRemoveBackgroundResponse>(getRecraftRemoveBackgroundUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getRecraftRemoveBackgroundMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftRemoveBackground>>, TError,{data: RecraftRemoveBackgroundBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof recraftRemoveBackground>>, TError,{data: RecraftRemoveBackgroundBody}, TContext> => {

const mutationKey = ['recraftRemoveBackground'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recraftRemoveBackground>>, {data: RecraftRemoveBackgroundBody}> = (props) => {
          const {data} = props ?? {};

          return  recraftRemoveBackground(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RecraftRemoveBackgroundMutationResult = NonNullable<Awaited<ReturnType<typeof recraftRemoveBackground>>>
    export type RecraftRemoveBackgroundMutationBody = RecraftRemoveBackgroundBody
    export type RecraftRemoveBackgroundMutationError = void

    /**
 * @summary Remove background from an image
 */
export const useRecraftRemoveBackground = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftRemoveBackground>>, TError,{data: RecraftRemoveBackgroundBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recraftRemoveBackground>>,
        TError,
        {data: RecraftRemoveBackgroundBody},
        TContext
      > => {
      return useMutation(getRecraftRemoveBackgroundMutationOptions(options), queryClient);
    }
    
/**
 * @summary Replace Background
 */
export type recraftReplaceBackgroundResponse200 = {
  data: RecraftGenerateImageResponse
  status: 200
}
    
export type recraftReplaceBackgroundResponseSuccess = (recraftReplaceBackgroundResponse200) & {
  headers: Headers;
};
;

export type recraftReplaceBackgroundResponse = (recraftReplaceBackgroundResponseSuccess)

export const getRecraftReplaceBackgroundUrl = () => {


  

  return `/proxy/recraft/images/replaceBackground`
}

export const recraftReplaceBackground = async (recraftTransformImageWithMaskRequest: RecraftTransformImageWithMaskRequest, options?: RequestInit): Promise<recraftReplaceBackgroundResponse> => {
    const formData = new FormData();
if(recraftTransformImageWithMaskRequest.block_nsfw !== undefined) {
 formData.append(`block_nsfw`, recraftTransformImageWithMaskRequest.block_nsfw.toString())
 }
if(recraftTransformImageWithMaskRequest.calculate_features !== undefined) {
 formData.append(`calculate_features`, recraftTransformImageWithMaskRequest.calculate_features.toString())
 }
formData.append(`image`, recraftTransformImageWithMaskRequest.image);
if(recraftTransformImageWithMaskRequest.image_format !== undefined) {
 formData.append(`image_format`, recraftTransformImageWithMaskRequest.image_format);
 }
formData.append(`mask`, recraftTransformImageWithMaskRequest.mask);
if(recraftTransformImageWithMaskRequest.model !== undefined) {
 formData.append(`model`, recraftTransformImageWithMaskRequest.model);
 }
if(recraftTransformImageWithMaskRequest.n !== undefined) {
 formData.append(`n`, recraftTransformImageWithMaskRequest.n.toString())
 }
if(recraftTransformImageWithMaskRequest.negative_prompt !== undefined) {
 formData.append(`negative_prompt`, recraftTransformImageWithMaskRequest.negative_prompt);
 }
formData.append(`prompt`, recraftTransformImageWithMaskRequest.prompt);
if(recraftTransformImageWithMaskRequest.response_format !== undefined) {
 formData.append(`response_format`, recraftTransformImageWithMaskRequest.response_format);
 }
if(recraftTransformImageWithMaskRequest.style !== undefined) {
 formData.append(`style`, recraftTransformImageWithMaskRequest.style);
 }
if(recraftTransformImageWithMaskRequest.style_id !== undefined) {
 formData.append(`style_id`, recraftTransformImageWithMaskRequest.style_id);
 }
if(recraftTransformImageWithMaskRequest.substyle !== undefined) {
 formData.append(`substyle`, recraftTransformImageWithMaskRequest.substyle);
 }
if(recraftTransformImageWithMaskRequest.text_layout !== undefined) {
 recraftTransformImageWithMaskRequest.text_layout.forEach(value => formData.append(`text_layout`, JSON.stringify(value)));
 }

  return customInstance<recraftReplaceBackgroundResponse>(getRecraftReplaceBackgroundUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getRecraftReplaceBackgroundMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftReplaceBackground>>, TError,{data: RecraftTransformImageWithMaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof recraftReplaceBackground>>, TError,{data: RecraftTransformImageWithMaskRequest}, TContext> => {

const mutationKey = ['recraftReplaceBackground'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recraftReplaceBackground>>, {data: RecraftTransformImageWithMaskRequest}> = (props) => {
          const {data} = props ?? {};

          return  recraftReplaceBackground(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RecraftReplaceBackgroundMutationResult = NonNullable<Awaited<ReturnType<typeof recraftReplaceBackground>>>
    export type RecraftReplaceBackgroundMutationBody = RecraftTransformImageWithMaskRequest
    export type RecraftReplaceBackgroundMutationError = unknown

    /**
 * @summary Replace Background
 */
export const useRecraftReplaceBackground = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftReplaceBackground>>, TError,{data: RecraftTransformImageWithMaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recraftReplaceBackground>>,
        TError,
        {data: RecraftTransformImageWithMaskRequest},
        TContext
      > => {
      return useMutation(getRecraftReplaceBackgroundMutationOptions(options), queryClient);
    }
    
/**
 * @summary Vectorize an image
 */
export type recraftVectorizeResponse200 = {
  data: RecraftImageGenerationResponse
  status: 200
}

export type recraftVectorizeResponse400 = {
  data: void
  status: 400
}

export type recraftVectorizeResponse401 = {
  data: void
  status: 401
}
    
export type recraftVectorizeResponseSuccess = (recraftVectorizeResponse200) & {
  headers: Headers;
};
export type recraftVectorizeResponseError = (recraftVectorizeResponse400 | recraftVectorizeResponse401) & {
  headers: Headers;
};

export type recraftVectorizeResponse = (recraftVectorizeResponseSuccess | recraftVectorizeResponseError)

export const getRecraftVectorizeUrl = () => {


  

  return `/proxy/recraft/images/vectorize`
}

export const recraftVectorize = async (recraftVectorizeBody: RecraftVectorizeBody, options?: RequestInit): Promise<recraftVectorizeResponse> => {
    const formData = new FormData();
formData.append(`file`, recraftVectorizeBody.file);

  return customInstance<recraftVectorizeResponse>(getRecraftVectorizeUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getRecraftVectorizeMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftVectorize>>, TError,{data: RecraftVectorizeBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof recraftVectorize>>, TError,{data: RecraftVectorizeBody}, TContext> => {

const mutationKey = ['recraftVectorize'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recraftVectorize>>, {data: RecraftVectorizeBody}> = (props) => {
          const {data} = props ?? {};

          return  recraftVectorize(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RecraftVectorizeMutationResult = NonNullable<Awaited<ReturnType<typeof recraftVectorize>>>
    export type RecraftVectorizeMutationBody = RecraftVectorizeBody
    export type RecraftVectorizeMutationError = void

    /**
 * @summary Vectorize an image
 */
export const useRecraftVectorize = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftVectorize>>, TError,{data: RecraftVectorizeBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recraftVectorize>>,
        TError,
        {data: RecraftVectorizeBody},
        TContext
      > => {
      return useMutation(getRecraftVectorizeMutationOptions(options), queryClient);
    }
    
/**
 * Upload a set of images to create a style reference.
 * @summary Create Style
 */
export type recraftCreateStyleResponse200 = {
  data: RecraftCreateStyleResponse
  status: 200
}
    
export type recraftCreateStyleResponseSuccess = (recraftCreateStyleResponse200) & {
  headers: Headers;
};
;

export type recraftCreateStyleResponse = (recraftCreateStyleResponseSuccess)

export const getRecraftCreateStyleUrl = () => {


  

  return `/proxy/recraft/styles`
}

export const recraftCreateStyle = async (recraftCreateStyleRequest: RecraftCreateStyleRequest, options?: RequestInit): Promise<recraftCreateStyleResponse> => {
    const formData = new FormData();
formData.append(`file1`, recraftCreateStyleRequest.file1);
if(recraftCreateStyleRequest.file2 !== undefined) {
 formData.append(`file2`, recraftCreateStyleRequest.file2);
 }
if(recraftCreateStyleRequest.file3 !== undefined) {
 formData.append(`file3`, recraftCreateStyleRequest.file3);
 }
if(recraftCreateStyleRequest.file4 !== undefined) {
 formData.append(`file4`, recraftCreateStyleRequest.file4);
 }
if(recraftCreateStyleRequest.file5 !== undefined) {
 formData.append(`file5`, recraftCreateStyleRequest.file5);
 }
formData.append(`style`, recraftCreateStyleRequest.style);

  return customInstance<recraftCreateStyleResponse>(getRecraftCreateStyleUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getRecraftCreateStyleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftCreateStyle>>, TError,{data: RecraftCreateStyleRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof recraftCreateStyle>>, TError,{data: RecraftCreateStyleRequest}, TContext> => {

const mutationKey = ['recraftCreateStyle'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recraftCreateStyle>>, {data: RecraftCreateStyleRequest}> = (props) => {
          const {data} = props ?? {};

          return  recraftCreateStyle(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RecraftCreateStyleMutationResult = NonNullable<Awaited<ReturnType<typeof recraftCreateStyle>>>
    export type RecraftCreateStyleMutationBody = RecraftCreateStyleRequest
    export type RecraftCreateStyleMutationError = unknown

    /**
 * @summary Create Style
 */
export const useRecraftCreateStyle = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recraftCreateStyle>>, TError,{data: RecraftCreateStyleRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recraftCreateStyle>>,
        TError,
        {data: RecraftCreateStyleRequest},
        TContext
      > => {
      return useMutation(getRecraftCreateStyleMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get rodin 3D Assets download list.
 */
export type rodinDownloadResponse200 = {
  data: Rodin3DDownloadResponse
  status: 200
}

export type rodinDownloadResponse400 = {
  data: void
  status: 400
}

export type rodinDownloadResponse401 = {
  data: void
  status: 401
}

export type rodinDownloadResponse403 = {
  data: void
  status: 403
}

export type rodinDownloadResponse404 = {
  data: void
  status: 404
}

export type rodinDownloadResponse500 = {
  data: void
  status: 500
}
    
export type rodinDownloadResponseSuccess = (rodinDownloadResponse200) & {
  headers: Headers;
};
export type rodinDownloadResponseError = (rodinDownloadResponse400 | rodinDownloadResponse401 | rodinDownloadResponse403 | rodinDownloadResponse404 | rodinDownloadResponse500) & {
  headers: Headers;
};

export type rodinDownloadResponse = (rodinDownloadResponseSuccess | rodinDownloadResponseError)

export const getRodinDownloadUrl = () => {


  

  return `/proxy/rodin/api/v2/download`
}

export const rodinDownload = async (rodin3DDownloadRequest: Rodin3DDownloadRequest, options?: RequestInit): Promise<rodinDownloadResponse> => {
    const formData = new FormData();
formData.append(`task_uuid`, rodin3DDownloadRequest.task_uuid);

  return customInstance<rodinDownloadResponse>(getRodinDownloadUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getRodinDownloadMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rodinDownload>>, TError,{data: Rodin3DDownloadRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof rodinDownload>>, TError,{data: Rodin3DDownloadRequest}, TContext> => {

const mutationKey = ['rodinDownload'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rodinDownload>>, {data: Rodin3DDownloadRequest}> = (props) => {
          const {data} = props ?? {};

          return  rodinDownload(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RodinDownloadMutationResult = NonNullable<Awaited<ReturnType<typeof rodinDownload>>>
    export type RodinDownloadMutationBody = Rodin3DDownloadRequest
    export type RodinDownloadMutationError = void

    /**
 * @summary Get rodin 3D Assets download list.
 */
export const useRodinDownload = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rodinDownload>>, TError,{data: Rodin3DDownloadRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rodinDownload>>,
        TError,
        {data: Rodin3DDownloadRequest},
        TContext
      > => {
      return useMutation(getRodinDownloadMutationOptions(options), queryClient);
    }
    
/**
 * @summary Create 3D generate Task using Rodin API.
 */
export type rodinGenerate3DAssetResponse200 = {
  data: Rodin3DGenerateResponse
  status: 200
}

export type rodinGenerate3DAssetResponse400 = {
  data: void
  status: 400
}

export type rodinGenerate3DAssetResponse401 = {
  data: void
  status: 401
}

export type rodinGenerate3DAssetResponse403 = {
  data: void
  status: 403
}

export type rodinGenerate3DAssetResponse404 = {
  data: void
  status: 404
}

export type rodinGenerate3DAssetResponse500 = {
  data: void
  status: 500
}
    
export type rodinGenerate3DAssetResponseSuccess = (rodinGenerate3DAssetResponse200) & {
  headers: Headers;
};
export type rodinGenerate3DAssetResponseError = (rodinGenerate3DAssetResponse400 | rodinGenerate3DAssetResponse401 | rodinGenerate3DAssetResponse403 | rodinGenerate3DAssetResponse404 | rodinGenerate3DAssetResponse500) & {
  headers: Headers;
};

export type rodinGenerate3DAssetResponse = (rodinGenerate3DAssetResponseSuccess | rodinGenerate3DAssetResponseError)

export const getRodinGenerate3DAssetUrl = () => {


  

  return `/proxy/rodin/api/v2/rodin`
}

export const rodinGenerate3DAsset = async (rodin3DGenerateRequest: Rodin3DGenerateRequest, options?: RequestInit): Promise<rodinGenerate3DAssetResponse> => {
    const formData = new FormData();
formData.append(`images`, rodin3DGenerateRequest.images);
if(rodin3DGenerateRequest.material !== undefined) {
 formData.append(`material`, rodin3DGenerateRequest.material);
 }
if(rodin3DGenerateRequest.mesh_mode !== undefined) {
 formData.append(`mesh_mode`, rodin3DGenerateRequest.mesh_mode);
 }
if(rodin3DGenerateRequest.quality !== undefined) {
 formData.append(`quality`, rodin3DGenerateRequest.quality);
 }
if(rodin3DGenerateRequest.seed !== undefined) {
 formData.append(`seed`, rodin3DGenerateRequest.seed.toString())
 }
if(rodin3DGenerateRequest.tier !== undefined) {
 formData.append(`tier`, rodin3DGenerateRequest.tier);
 }

  return customInstance<rodinGenerate3DAssetResponse>(getRodinGenerate3DAssetUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getRodinGenerate3DAssetMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rodinGenerate3DAsset>>, TError,{data: Rodin3DGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof rodinGenerate3DAsset>>, TError,{data: Rodin3DGenerateRequest}, TContext> => {

const mutationKey = ['rodinGenerate3DAsset'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rodinGenerate3DAsset>>, {data: Rodin3DGenerateRequest}> = (props) => {
          const {data} = props ?? {};

          return  rodinGenerate3DAsset(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RodinGenerate3DAssetMutationResult = NonNullable<Awaited<ReturnType<typeof rodinGenerate3DAsset>>>
    export type RodinGenerate3DAssetMutationBody = Rodin3DGenerateRequest
    export type RodinGenerate3DAssetMutationError = void

    /**
 * @summary Create 3D generate Task using Rodin API.
 */
export const useRodinGenerate3DAsset = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rodinGenerate3DAsset>>, TError,{data: Rodin3DGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rodinGenerate3DAsset>>,
        TError,
        {data: Rodin3DGenerateRequest},
        TContext
      > => {
      return useMutation(getRodinGenerate3DAssetMutationOptions(options), queryClient);
    }
    
/**
 * @summary Check Rodin 3D Generate Status.
 */
export type rodinCheckStatusResponse200 = {
  data: Rodin3DCheckStatusResponse
  status: 200
}

export type rodinCheckStatusResponse400 = {
  data: void
  status: 400
}

export type rodinCheckStatusResponse401 = {
  data: void
  status: 401
}

export type rodinCheckStatusResponse403 = {
  data: void
  status: 403
}

export type rodinCheckStatusResponse404 = {
  data: void
  status: 404
}

export type rodinCheckStatusResponse500 = {
  data: void
  status: 500
}
    
export type rodinCheckStatusResponseSuccess = (rodinCheckStatusResponse200) & {
  headers: Headers;
};
export type rodinCheckStatusResponseError = (rodinCheckStatusResponse400 | rodinCheckStatusResponse401 | rodinCheckStatusResponse403 | rodinCheckStatusResponse404 | rodinCheckStatusResponse500) & {
  headers: Headers;
};

export type rodinCheckStatusResponse = (rodinCheckStatusResponseSuccess | rodinCheckStatusResponseError)

export const getRodinCheckStatusUrl = () => {


  

  return `/proxy/rodin/api/v2/status`
}

export const rodinCheckStatus = async (rodin3DCheckStatusRequest: Rodin3DCheckStatusRequest, options?: RequestInit): Promise<rodinCheckStatusResponse> => {
    const formData = new FormData();
formData.append(`subscription_key`, rodin3DCheckStatusRequest.subscription_key);

  return customInstance<rodinCheckStatusResponse>(getRodinCheckStatusUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getRodinCheckStatusMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rodinCheckStatus>>, TError,{data: Rodin3DCheckStatusRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof rodinCheckStatus>>, TError,{data: Rodin3DCheckStatusRequest}, TContext> => {

const mutationKey = ['rodinCheckStatus'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rodinCheckStatus>>, {data: Rodin3DCheckStatusRequest}> = (props) => {
          const {data} = props ?? {};

          return  rodinCheckStatus(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RodinCheckStatusMutationResult = NonNullable<Awaited<ReturnType<typeof rodinCheckStatus>>>
    export type RodinCheckStatusMutationBody = Rodin3DCheckStatusRequest
    export type RodinCheckStatusMutationError = void

    /**
 * @summary Check Rodin 3D Generate Status.
 */
export const useRodinCheckStatus = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rodinCheckStatus>>, TError,{data: Rodin3DCheckStatusRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rodinCheckStatus>>,
        TError,
        {data: Rodin3DCheckStatusRequest},
        TContext
      > => {
      return useMutation(getRodinCheckStatusMutationOptions(options), queryClient);
    }
    
/**
 * Converts an image to a video using Runway's API
 * @summary Runway Image to Video Generation
 */
export type runwayImageToVideoResponse200 = {
  data: RunwayImageToVideoResponse
  status: 200
}

export type runwayImageToVideoResponse400 = {
  data: ErrorResponse
  status: 400
}

export type runwayImageToVideoResponse401 = {
  data: void
  status: 401
}

export type runwayImageToVideoResponse402 = {
  data: ErrorResponse
  status: 402
}

export type runwayImageToVideoResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type runwayImageToVideoResponseSuccess = (runwayImageToVideoResponse200) & {
  headers: Headers;
};
export type runwayImageToVideoResponseError = (runwayImageToVideoResponse400 | runwayImageToVideoResponse401 | runwayImageToVideoResponse402 | runwayImageToVideoResponse500) & {
  headers: Headers;
};

export type runwayImageToVideoResponse = (runwayImageToVideoResponseSuccess | runwayImageToVideoResponseError)

export const getRunwayImageToVideoUrl = () => {


  

  return `/proxy/runway/image_to_video`
}

export const runwayImageToVideo = async (runwayImageToVideoRequest: RunwayImageToVideoRequest, options?: RequestInit): Promise<runwayImageToVideoResponse> => {
  
  return customInstance<runwayImageToVideoResponse>(getRunwayImageToVideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      runwayImageToVideoRequest,)
  }
);}




export const getRunwayImageToVideoMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runwayImageToVideo>>, TError,{data: RunwayImageToVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof runwayImageToVideo>>, TError,{data: RunwayImageToVideoRequest}, TContext> => {

const mutationKey = ['runwayImageToVideo'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof runwayImageToVideo>>, {data: RunwayImageToVideoRequest}> = (props) => {
          const {data} = props ?? {};

          return  runwayImageToVideo(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RunwayImageToVideoMutationResult = NonNullable<Awaited<ReturnType<typeof runwayImageToVideo>>>
    export type RunwayImageToVideoMutationBody = RunwayImageToVideoRequest
    export type RunwayImageToVideoMutationError = ErrorResponse | void

    /**
 * @summary Runway Image to Video Generation
 */
export const useRunwayImageToVideo = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runwayImageToVideo>>, TError,{data: RunwayImageToVideoRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof runwayImageToVideo>>,
        TError,
        {data: RunwayImageToVideoRequest},
        TContext
      > => {
      return useMutation(getRunwayImageToVideoMutationOptions(options), queryClient);
    }
    
/**
 * Get the status and output of a Runway task
 * @summary Get Runway Task Status
 */
export type runwayGetTaskStatusResponse200 = {
  data: RunwayTaskStatusResponse
  status: 200
}

export type runwayGetTaskStatusResponse400 = {
  data: ErrorResponse
  status: 400
}

export type runwayGetTaskStatusResponse401 = {
  data: void
  status: 401
}

export type runwayGetTaskStatusResponse402 = {
  data: ErrorResponse
  status: 402
}

export type runwayGetTaskStatusResponse404 = {
  data: ErrorResponse
  status: 404
}

export type runwayGetTaskStatusResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type runwayGetTaskStatusResponseSuccess = (runwayGetTaskStatusResponse200) & {
  headers: Headers;
};
export type runwayGetTaskStatusResponseError = (runwayGetTaskStatusResponse400 | runwayGetTaskStatusResponse401 | runwayGetTaskStatusResponse402 | runwayGetTaskStatusResponse404 | runwayGetTaskStatusResponse500) & {
  headers: Headers;
};

export type runwayGetTaskStatusResponse = (runwayGetTaskStatusResponseSuccess | runwayGetTaskStatusResponseError)

export const getRunwayGetTaskStatusUrl = (taskId: string,) => {


  

  return `/proxy/runway/tasks/${taskId}`
}

export const runwayGetTaskStatus = async (taskId: string, options?: RequestInit): Promise<runwayGetTaskStatusResponse> => {
  
  return customInstance<runwayGetTaskStatusResponse>(getRunwayGetTaskStatusUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getRunwayGetTaskStatusQueryKey = (taskId: string,) => {
    return [
    `/proxy/runway/tasks/${taskId}`
    ] as const;
    }

    
export const getRunwayGetTaskStatusQueryOptions = <TData = Awaited<ReturnType<typeof runwayGetTaskStatus>>, TError = ErrorResponse | void>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof runwayGetTaskStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRunwayGetTaskStatusQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof runwayGetTaskStatus>>> = ({ signal }) => runwayGetTaskStatus(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof runwayGetTaskStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RunwayGetTaskStatusQueryResult = NonNullable<Awaited<ReturnType<typeof runwayGetTaskStatus>>>
export type RunwayGetTaskStatusQueryError = ErrorResponse | void


export function useRunwayGetTaskStatus<TData = Awaited<ReturnType<typeof runwayGetTaskStatus>>, TError = ErrorResponse | void>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof runwayGetTaskStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof runwayGetTaskStatus>>,
          TError,
          Awaited<ReturnType<typeof runwayGetTaskStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRunwayGetTaskStatus<TData = Awaited<ReturnType<typeof runwayGetTaskStatus>>, TError = ErrorResponse | void>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof runwayGetTaskStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof runwayGetTaskStatus>>,
          TError,
          Awaited<ReturnType<typeof runwayGetTaskStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRunwayGetTaskStatus<TData = Awaited<ReturnType<typeof runwayGetTaskStatus>>, TError = ErrorResponse | void>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof runwayGetTaskStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Runway Task Status
 */

export function useRunwayGetTaskStatus<TData = Awaited<ReturnType<typeof runwayGetTaskStatus>>, TError = ErrorResponse | void>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof runwayGetTaskStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRunwayGetTaskStatusQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Generates an image from text using Runway's API
 * @summary Runway Text to Image Generation
 */
export type runwayTextToImageResponse200 = {
  data: RunwayTextToImageResponse
  status: 200
}

export type runwayTextToImageResponse400 = {
  data: ErrorResponse
  status: 400
}

export type runwayTextToImageResponse401 = {
  data: void
  status: 401
}

export type runwayTextToImageResponse402 = {
  data: ErrorResponse
  status: 402
}

export type runwayTextToImageResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type runwayTextToImageResponseSuccess = (runwayTextToImageResponse200) & {
  headers: Headers;
};
export type runwayTextToImageResponseError = (runwayTextToImageResponse400 | runwayTextToImageResponse401 | runwayTextToImageResponse402 | runwayTextToImageResponse500) & {
  headers: Headers;
};

export type runwayTextToImageResponse = (runwayTextToImageResponseSuccess | runwayTextToImageResponseError)

export const getRunwayTextToImageUrl = () => {


  

  return `/proxy/runway/text_to_image`
}

export const runwayTextToImage = async (runwayTextToImageRequest: RunwayTextToImageRequest, options?: RequestInit): Promise<runwayTextToImageResponse> => {
  
  return customInstance<runwayTextToImageResponse>(getRunwayTextToImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      runwayTextToImageRequest,)
  }
);}




export const getRunwayTextToImageMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runwayTextToImage>>, TError,{data: RunwayTextToImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof runwayTextToImage>>, TError,{data: RunwayTextToImageRequest}, TContext> => {

const mutationKey = ['runwayTextToImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof runwayTextToImage>>, {data: RunwayTextToImageRequest}> = (props) => {
          const {data} = props ?? {};

          return  runwayTextToImage(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RunwayTextToImageMutationResult = NonNullable<Awaited<ReturnType<typeof runwayTextToImage>>>
    export type RunwayTextToImageMutationBody = RunwayTextToImageRequest
    export type RunwayTextToImageMutationError = ErrorResponse | void

    /**
 * @summary Runway Text to Image Generation
 */
export const useRunwayTextToImage = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof runwayTextToImage>>, TError,{data: RunwayTextToImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof runwayTextToImage>>,
        TError,
        {data: RunwayTextToImageRequest},
        TContext
      > => {
      return useMutation(getRunwayTextToImageMutationOptions(options), queryClient);
    }
    
/**
 * @summary Proxy request to Stable Audio for audio-to-audio transformation
 */
export type stableAudio25AudioToAudioResponse200 = {
  data: StableAudio25AudioResponse
  status: 200
}

export type stableAudio25AudioToAudioResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type stableAudio25AudioToAudioResponseSuccess = (stableAudio25AudioToAudioResponse200) & {
  headers: Headers;
};
export type stableAudio25AudioToAudioResponseError = (stableAudio25AudioToAudioResponseDefault) & {
  headers: Headers;
};

export type stableAudio25AudioToAudioResponse = (stableAudio25AudioToAudioResponseSuccess | stableAudio25AudioToAudioResponseError)

export const getStableAudio25AudioToAudioUrl = () => {


  

  return `/proxy/stability/v2beta/audio/stable-audio-2/audio-to-audio`
}

export const stableAudio25AudioToAudio = async (stableAudio25AudioToAudioRequest: StableAudio25AudioToAudioRequest, options?: RequestInit): Promise<stableAudio25AudioToAudioResponse> => {
    const formData = new FormData();
formData.append(`audio`, stableAudio25AudioToAudioRequest.audio);
if(stableAudio25AudioToAudioRequest.cfg_scale !== undefined) {
 formData.append(`cfg_scale`, stableAudio25AudioToAudioRequest.cfg_scale.toString())
 }
if(stableAudio25AudioToAudioRequest.duration !== undefined) {
 formData.append(`duration`, stableAudio25AudioToAudioRequest.duration.toString())
 }
formData.append(`model`, stableAudio25AudioToAudioRequest.model);
if(stableAudio25AudioToAudioRequest.output_format !== undefined) {
 formData.append(`output_format`, stableAudio25AudioToAudioRequest.output_format);
 }
formData.append(`prompt`, stableAudio25AudioToAudioRequest.prompt);
if(stableAudio25AudioToAudioRequest.seed !== undefined) {
 formData.append(`seed`, stableAudio25AudioToAudioRequest.seed.toString())
 }
if(stableAudio25AudioToAudioRequest.steps !== undefined) {
 formData.append(`steps`, stableAudio25AudioToAudioRequest.steps.toString())
 }
if(stableAudio25AudioToAudioRequest.strength !== undefined) {
 formData.append(`strength`, stableAudio25AudioToAudioRequest.strength.toString())
 }

  return customInstance<stableAudio25AudioToAudioResponse>(getStableAudio25AudioToAudioUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getStableAudio25AudioToAudioMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stableAudio25AudioToAudio>>, TError,{data: StableAudio25AudioToAudioRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stableAudio25AudioToAudio>>, TError,{data: StableAudio25AudioToAudioRequest}, TContext> => {

const mutationKey = ['stableAudio25AudioToAudio'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stableAudio25AudioToAudio>>, {data: StableAudio25AudioToAudioRequest}> = (props) => {
          const {data} = props ?? {};

          return  stableAudio25AudioToAudio(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StableAudio25AudioToAudioMutationResult = NonNullable<Awaited<ReturnType<typeof stableAudio25AudioToAudio>>>
    export type StableAudio25AudioToAudioMutationBody = StableAudio25AudioToAudioRequest
    export type StableAudio25AudioToAudioMutationError = ErrorResponse

    /**
 * @summary Proxy request to Stable Audio for audio-to-audio transformation
 */
export const useStableAudio25AudioToAudio = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stableAudio25AudioToAudio>>, TError,{data: StableAudio25AudioToAudioRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stableAudio25AudioToAudio>>,
        TError,
        {data: StableAudio25AudioToAudioRequest},
        TContext
      > => {
      return useMutation(getStableAudio25AudioToAudioMutationOptions(options), queryClient);
    }
    
/**
 * @summary Proxy request to Stable Audio 2.5 for audio inpainting
 */
export type stableAudio25InpaintResponse200 = {
  data: StableAudio25AudioResponse
  status: 200
}

export type stableAudio25InpaintResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type stableAudio25InpaintResponseSuccess = (stableAudio25InpaintResponse200) & {
  headers: Headers;
};
export type stableAudio25InpaintResponseError = (stableAudio25InpaintResponseDefault) & {
  headers: Headers;
};

export type stableAudio25InpaintResponse = (stableAudio25InpaintResponseSuccess | stableAudio25InpaintResponseError)

export const getStableAudio25InpaintUrl = () => {


  

  return `/proxy/stability/v2beta/audio/stable-audio-2/inpaint`
}

export const stableAudio25Inpaint = async (stableAudio25InpaintRequest: StableAudio25InpaintRequest, options?: RequestInit): Promise<stableAudio25InpaintResponse> => {
    const formData = new FormData();
formData.append(`audio`, stableAudio25InpaintRequest.audio);
if(stableAudio25InpaintRequest.duration !== undefined) {
 formData.append(`duration`, stableAudio25InpaintRequest.duration.toString())
 }
if(stableAudio25InpaintRequest.mask_end !== undefined) {
 formData.append(`mask_end`, stableAudio25InpaintRequest.mask_end.toString())
 }
if(stableAudio25InpaintRequest.mask_start !== undefined) {
 formData.append(`mask_start`, stableAudio25InpaintRequest.mask_start.toString())
 }
if(stableAudio25InpaintRequest.output_format !== undefined) {
 formData.append(`output_format`, stableAudio25InpaintRequest.output_format);
 }
formData.append(`prompt`, stableAudio25InpaintRequest.prompt);
if(stableAudio25InpaintRequest.seed !== undefined) {
 formData.append(`seed`, stableAudio25InpaintRequest.seed.toString())
 }
if(stableAudio25InpaintRequest.steps !== undefined) {
 formData.append(`steps`, stableAudio25InpaintRequest.steps.toString())
 }

  return customInstance<stableAudio25InpaintResponse>(getStableAudio25InpaintUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getStableAudio25InpaintMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stableAudio25Inpaint>>, TError,{data: StableAudio25InpaintRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stableAudio25Inpaint>>, TError,{data: StableAudio25InpaintRequest}, TContext> => {

const mutationKey = ['stableAudio25Inpaint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stableAudio25Inpaint>>, {data: StableAudio25InpaintRequest}> = (props) => {
          const {data} = props ?? {};

          return  stableAudio25Inpaint(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StableAudio25InpaintMutationResult = NonNullable<Awaited<ReturnType<typeof stableAudio25Inpaint>>>
    export type StableAudio25InpaintMutationBody = StableAudio25InpaintRequest
    export type StableAudio25InpaintMutationError = ErrorResponse

    /**
 * @summary Proxy request to Stable Audio 2.5 for audio inpainting
 */
export const useStableAudio25Inpaint = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stableAudio25Inpaint>>, TError,{data: StableAudio25InpaintRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stableAudio25Inpaint>>,
        TError,
        {data: StableAudio25InpaintRequest},
        TContext
      > => {
      return useMutation(getStableAudio25InpaintMutationOptions(options), queryClient);
    }
    
/**
 * @summary Proxy request to Stable Audio 2.5 for text-to-audio generation
 */
export type stableAudio25TextToAudioResponse200 = {
  data: StableAudio25AudioResponse
  status: 200
}

export type stableAudio25TextToAudioResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type stableAudio25TextToAudioResponseSuccess = (stableAudio25TextToAudioResponse200) & {
  headers: Headers;
};
export type stableAudio25TextToAudioResponseError = (stableAudio25TextToAudioResponseDefault) & {
  headers: Headers;
};

export type stableAudio25TextToAudioResponse = (stableAudio25TextToAudioResponseSuccess | stableAudio25TextToAudioResponseError)

export const getStableAudio25TextToAudioUrl = () => {


  

  return `/proxy/stability/v2beta/audio/stable-audio-2/text-to-audio`
}

export const stableAudio25TextToAudio = async (stableAudio25TextToAudioRequest: StableAudio25TextToAudioRequest, options?: RequestInit): Promise<stableAudio25TextToAudioResponse> => {
    const formData = new FormData();
if(stableAudio25TextToAudioRequest.cfg_scale !== undefined) {
 formData.append(`cfg_scale`, stableAudio25TextToAudioRequest.cfg_scale.toString())
 }
if(stableAudio25TextToAudioRequest.duration !== undefined) {
 formData.append(`duration`, stableAudio25TextToAudioRequest.duration.toString())
 }
formData.append(`model`, stableAudio25TextToAudioRequest.model);
if(stableAudio25TextToAudioRequest.output_format !== undefined) {
 formData.append(`output_format`, stableAudio25TextToAudioRequest.output_format);
 }
formData.append(`prompt`, stableAudio25TextToAudioRequest.prompt);
if(stableAudio25TextToAudioRequest.seed !== undefined) {
 formData.append(`seed`, stableAudio25TextToAudioRequest.seed.toString())
 }
if(stableAudio25TextToAudioRequest.steps !== undefined) {
 formData.append(`steps`, stableAudio25TextToAudioRequest.steps.toString())
 }

  return customInstance<stableAudio25TextToAudioResponse>(getStableAudio25TextToAudioUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getStableAudio25TextToAudioMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stableAudio25TextToAudio>>, TError,{data: StableAudio25TextToAudioRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stableAudio25TextToAudio>>, TError,{data: StableAudio25TextToAudioRequest}, TContext> => {

const mutationKey = ['stableAudio25TextToAudio'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stableAudio25TextToAudio>>, {data: StableAudio25TextToAudioRequest}> = (props) => {
          const {data} = props ?? {};

          return  stableAudio25TextToAudio(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StableAudio25TextToAudioMutationResult = NonNullable<Awaited<ReturnType<typeof stableAudio25TextToAudio>>>
    export type StableAudio25TextToAudioMutationBody = StableAudio25TextToAudioRequest
    export type StableAudio25TextToAudioMutationError = ErrorResponse

    /**
 * @summary Proxy request to Stable Audio 2.5 for text-to-audio generation
 */
export const useStableAudio25TextToAudio = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stableAudio25TextToAudio>>, TError,{data: StableAudio25TextToAudioRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stableAudio25TextToAudio>>,
        TError,
        {data: StableAudio25TextToAudioRequest},
        TContext
      > => {
      return useMutation(getStableAudio25TextToAudioMutationOptions(options), queryClient);
    }
    
/**
 * Get the result of a generation
 * @summary Get Result
 */
export type stabilityGetResultResponse200 = {
  data: Blob
  status: 200
}

export type stabilityGetResultResponse202 = {
  data: StabilityGetResultResponse202
  status: 202
}

export type stabilityGetResultResponse400 = {
  data: StabilityError
  status: 400
}

export type stabilityGetResultResponse404 = {
  data: StabilityError
  status: 404
}

export type stabilityGetResultResponse500 = {
  data: StabilityError
  status: 500
}
    
export type stabilityGetResultResponseSuccess = (stabilityGetResultResponse200 | stabilityGetResultResponse202) & {
  headers: Headers;
};
export type stabilityGetResultResponseError = (stabilityGetResultResponse400 | stabilityGetResultResponse404 | stabilityGetResultResponse500) & {
  headers: Headers;
};

export type stabilityGetResultResponse = (stabilityGetResultResponseSuccess | stabilityGetResultResponseError)

export const getStabilityGetResultUrl = (id: string,) => {


  

  return `/proxy/stability/v2beta/results/${id}`
}

export const stabilityGetResult = async (id: string, options?: RequestInit): Promise<stabilityGetResultResponse> => {
  
  return customInstance<stabilityGetResultResponse>(getStabilityGetResultUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getStabilityGetResultQueryKey = (id: string,) => {
    return [
    `/proxy/stability/v2beta/results/${id}`
    ] as const;
    }

    
export const getStabilityGetResultQueryOptions = <TData = Awaited<ReturnType<typeof stabilityGetResult>>, TError = StabilityError>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stabilityGetResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStabilityGetResultQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof stabilityGetResult>>> = ({ signal }) => stabilityGetResult(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof stabilityGetResult>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StabilityGetResultQueryResult = NonNullable<Awaited<ReturnType<typeof stabilityGetResult>>>
export type StabilityGetResultQueryError = StabilityError


export function useStabilityGetResult<TData = Awaited<ReturnType<typeof stabilityGetResult>>, TError = StabilityError>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof stabilityGetResult>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stabilityGetResult>>,
          TError,
          Awaited<ReturnType<typeof stabilityGetResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStabilityGetResult<TData = Awaited<ReturnType<typeof stabilityGetResult>>, TError = StabilityError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stabilityGetResult>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stabilityGetResult>>,
          TError,
          Awaited<ReturnType<typeof stabilityGetResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStabilityGetResult<TData = Awaited<ReturnType<typeof stabilityGetResult>>, TError = StabilityError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stabilityGetResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Result
 */

export function useStabilityGetResult<TData = Awaited<ReturnType<typeof stabilityGetResult>>, TError = StabilityError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof stabilityGetResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStabilityGetResultQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Generate using Stable Diffusion 3.5 models, Stability AI latest base model:

- **Stable Diffusion 3.5 Large**: At 8 billion parameters, with superior quality and



  prompt adherence, this base model is the most powerful in the Stable Diffusion
  family. This model is ideal for professional use cases at 1 megapixel resolution.

- **Stable Diffusion 3.5 Large Turbo**: A distilled version of Stable Diffusion 3.5 Large.



  SD3.5 Large Turbo generates high-quality images with exceptional prompt adherence
  in just 4 steps, making it considerably faster than Stable Diffusion 3.5 Large.

- **Stable Diffusion 3.5 Medium**: With 2.5 billion parameters, the model delivers an



  optimal balance between prompt accuracy and image quality, making it an efficient
  choice for fast high-performance image generation.

Read more about the model capabilities [here](https://stability.ai/news/introducing-stable-diffusion-3-5).

As of April 17, 2025, we have deprecated the Stable Diffusion 3.0 APIs and will be automatically
re-routing calls to Stable Diffusion 3.0 models to Stable Diffusion 3.5 APIs at no extra cost.
You can read more in the [release notes](/docs/release-notes#api-deprecation-notice).

### Try it out
Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/SD3_API.ipynb)

### How to use
Please invoke this endpoint with a `POST` request.

The headers of the request must include an API key in the `authorization` field. The body of the request must be
`multipart/form-data`.  The accept header should be set to one of the following:
- `image/*` to receive the image in the format specified by the `output_format` parameter.
- `application/json` to receive the image encoded as base64 in a JSON response.

#### **Generating with a prompt**
Commonly referred to as **text-to-image**, this mode generates an image from text alone. While the only required
parameter is the `prompt`, it also supports an `aspect_ratio` parameter which can be used to control the
aspect ratio of the generated image.

#### **Generating with a prompt *and* an image**
Commonly referred to as **image-to-image**, this mode also generates an image from text but uses an existing image as the
starting point. The required parameters are:
- `prompt` - text to generate the image from
- `image` - the image to use as the starting point for the generation
- `strength` - controls how much influence the `image` parameter has on the output image
- `mode` - must be set to `image-to-image`

> **Note:** maximum request size is 10MiB.

#### **Optional Parameters:**
Both modes support the following optional parameters:
- `model` - the model to use (SD3.5 Large, SD3.5 Large Turbo, SD3.5 Medium)
- `output_format` - the the format of the output image
- `seed` - the randomness seed to use for the generation
- `negative_prompt` - keywords of what you **do not** wish to see in the output image
- `cfg_scale` - controls how strictly the diffusion process adheres to the prompt text
- `style_preset` - guides the image model towards a particular style

> **Note:** for more details about these parameters please see the request schema below.

### Output
The resolution of the generated image will be 1MP. The default resolution is 1024x1024.

### Credits
- **SD 3.5 Large**: Flat rate of 6.5 credits per successful generation.
- **SD 3.5 Large Turbo**: Flat rate of 4 credits per successful generation.
- **SD 3.5 Medium**: Flat rate of 3.5 credits per successful generation.

As always, you will not be charged for failed generations.
 * @summary Stable Diffusion 3.5
 */
export type stabilityImageGenrationSD3Response200 = {
  data: Blob
  status: 200
}

export type stabilityImageGenrationSD3Response400 = {
  data: StabilityImageGenrationSD3Response400
  status: 400
}

export type stabilityImageGenrationSD3Response403 = {
  data: StabilityContentModerationResponse
  status: 403
}

export type stabilityImageGenrationSD3Response413 = {
  data: StabilityImageGenrationSD3Response413
  status: 413
}

export type stabilityImageGenrationSD3Response422 = {
  data: StabilityImageGenrationSD3Response422
  status: 422
}

export type stabilityImageGenrationSD3Response429 = {
  data: StabilityImageGenrationSD3Response429
  status: 429
}

export type stabilityImageGenrationSD3Response500 = {
  data: StabilityImageGenrationSD3Response500
  status: 500
}
    
export type stabilityImageGenrationSD3ResponseSuccess = (stabilityImageGenrationSD3Response200) & {
  headers: Headers;
};
export type stabilityImageGenrationSD3ResponseError = (stabilityImageGenrationSD3Response400 | stabilityImageGenrationSD3Response403 | stabilityImageGenrationSD3Response413 | stabilityImageGenrationSD3Response422 | stabilityImageGenrationSD3Response429 | stabilityImageGenrationSD3Response500) & {
  headers: Headers;
};

export type stabilityImageGenrationSD3Response = (stabilityImageGenrationSD3ResponseSuccess | stabilityImageGenrationSD3ResponseError)

export const getStabilityImageGenrationSD3Url = () => {


  

  return `/proxy/stability/v2beta/stable-image/generate/sd3`
}

export const stabilityImageGenrationSD3 = async (stabilityImageGenerationSD3Request: StabilityImageGenerationSD3Request, options?: RequestInit): Promise<stabilityImageGenrationSD3Response> => {
    const formData = new FormData();
if(stabilityImageGenerationSD3Request.aspect_ratio !== undefined) {
 formData.append(`aspect_ratio`, stabilityImageGenerationSD3Request.aspect_ratio);
 }
if(stabilityImageGenerationSD3Request.cfg_scale !== undefined) {
 formData.append(`cfg_scale`, stabilityImageGenerationSD3Request.cfg_scale.toString())
 }
if(stabilityImageGenerationSD3Request.image !== undefined) {
 formData.append(`image`, stabilityImageGenerationSD3Request.image);
 }
if(stabilityImageGenerationSD3Request.mode !== undefined) {
 formData.append(`mode`, stabilityImageGenerationSD3Request.mode);
 }
if(stabilityImageGenerationSD3Request.model !== undefined) {
 formData.append(`model`, stabilityImageGenerationSD3Request.model);
 }
if(stabilityImageGenerationSD3Request.negative_prompt !== undefined) {
 formData.append(`negative_prompt`, stabilityImageGenerationSD3Request.negative_prompt);
 }
if(stabilityImageGenerationSD3Request.output_format !== undefined) {
 formData.append(`output_format`, stabilityImageGenerationSD3Request.output_format);
 }
formData.append(`prompt`, stabilityImageGenerationSD3Request.prompt);
if(stabilityImageGenerationSD3Request.seed !== undefined) {
 formData.append(`seed`, stabilityImageGenerationSD3Request.seed.toString())
 }
if(stabilityImageGenerationSD3Request.strength !== undefined) {
 formData.append(`strength`, stabilityImageGenerationSD3Request.strength.toString())
 }
if(stabilityImageGenerationSD3Request.style_preset !== undefined) {
 formData.append(`style_preset`, stabilityImageGenerationSD3Request.style_preset);
 }

  return customInstance<stabilityImageGenrationSD3Response>(getStabilityImageGenrationSD3Url(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getStabilityImageGenrationSD3MutationOptions = <TError = StabilityImageGenrationSD3Response400 | StabilityContentModerationResponse | StabilityImageGenrationSD3Response413 | StabilityImageGenrationSD3Response422 | StabilityImageGenrationSD3Response429 | StabilityImageGenrationSD3Response500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationSD3>>, TError,{data: StabilityImageGenerationSD3Request}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationSD3>>, TError,{data: StabilityImageGenerationSD3Request}, TContext> => {

const mutationKey = ['stabilityImageGenrationSD3'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stabilityImageGenrationSD3>>, {data: StabilityImageGenerationSD3Request}> = (props) => {
          const {data} = props ?? {};

          return  stabilityImageGenrationSD3(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StabilityImageGenrationSD3MutationResult = NonNullable<Awaited<ReturnType<typeof stabilityImageGenrationSD3>>>
    export type StabilityImageGenrationSD3MutationBody = StabilityImageGenerationSD3Request
    export type StabilityImageGenrationSD3MutationError = StabilityImageGenrationSD3Response400 | StabilityContentModerationResponse | StabilityImageGenrationSD3Response413 | StabilityImageGenrationSD3Response422 | StabilityImageGenrationSD3Response429 | StabilityImageGenrationSD3Response500

    /**
 * @summary Stable Diffusion 3.5
 */
export const useStabilityImageGenrationSD3 = <TError = StabilityImageGenrationSD3Response400 | StabilityContentModerationResponse | StabilityImageGenrationSD3Response413 | StabilityImageGenrationSD3Response422 | StabilityImageGenrationSD3Response429 | StabilityImageGenrationSD3Response500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationSD3>>, TError,{data: StabilityImageGenerationSD3Request}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stabilityImageGenrationSD3>>,
        TError,
        {data: StabilityImageGenerationSD3Request},
        TContext
      > => {
      return useMutation(getStabilityImageGenrationSD3MutationOptions(options), queryClient);
    }
    
/**
 * Our most advanced text to image generation service, Stable Image Ultra creates the highest quality images with unprecedented prompt understanding. Ultra excels in typography, complex compositions, dynamic lighting, vibrant hues, and overall cohesion and structure of an art piece. Made from the most advanced models, including Stable Diffusion 3.5, Ultra offers the best of the Stable Diffusion ecosystem. ### Try it out Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=yXhs626oZdr1) ### How to use Please invoke this endpoint with a `POST` request. The headers of the request must include an API key in the `authorization` field. The body of the request must be `multipart/form-data`.  The accept header should be set to one of the following: - `image/*` to receive the image in the format specified by the `output_format` parameter. - `application/json` to receive the image in the format specified by the `output_format` parameter, but encoded to base64 in a JSON response. The only required parameter is the `prompt` field, which should contain the text prompt for the image generation. The body of the request should include: - `prompt` - text to generate the image from The body may optionally include: - `image` - the image to use as the starting point for the generation - `strength` - controls how much influence the `image` parameter has on the output image - `aspect_ratio` - the aspect ratio of the output image - `negative_prompt` - keywords of what you **do not** wish to see in the output image - `seed` - the randomness seed to use for the generation - `output_format` - the the format of the output image > **Note:** for the full list of optional parameters, please see the request schema below. ### Output The resolution of the generated image will be 1 megapixel. The default resolution is 1024x1024. ### Credits The Ultra service uses 8 credits per successful result. You will not be charged for failed results.
 * @summary Stable Image Ultra
 */
export type stabilityImageGenrationUltraResponse200 = {
  data: Blob
  status: 200
}

export type stabilityImageGenrationUltraResponse400 = {
  data: StabilityImageGenrationUltra400
  status: 400
}

export type stabilityImageGenrationUltraResponse403 = {
  data: StabilityContentModerationResponse
  status: 403
}

export type stabilityImageGenrationUltraResponse413 = {
  data: StabilityImageGenrationUltra413
  status: 413
}

export type stabilityImageGenrationUltraResponse422 = {
  data: StabilityImageGenrationUltra422
  status: 422
}

export type stabilityImageGenrationUltraResponse429 = {
  data: StabilityImageGenrationUltra429
  status: 429
}

export type stabilityImageGenrationUltraResponse500 = {
  data: StabilityImageGenrationUltra500
  status: 500
}
    
export type stabilityImageGenrationUltraResponseSuccess = (stabilityImageGenrationUltraResponse200) & {
  headers: Headers;
};
export type stabilityImageGenrationUltraResponseError = (stabilityImageGenrationUltraResponse400 | stabilityImageGenrationUltraResponse403 | stabilityImageGenrationUltraResponse413 | stabilityImageGenrationUltraResponse422 | stabilityImageGenrationUltraResponse429 | stabilityImageGenrationUltraResponse500) & {
  headers: Headers;
};

export type stabilityImageGenrationUltraResponse = (stabilityImageGenrationUltraResponseSuccess | stabilityImageGenrationUltraResponseError)

export const getStabilityImageGenrationUltraUrl = () => {


  

  return `/proxy/stability/v2beta/stable-image/generate/ultra`
}

export const stabilityImageGenrationUltra = async (stabilityImageGenrationUltraBody: StabilityImageGenrationUltraBody, options?: RequestInit): Promise<stabilityImageGenrationUltraResponse> => {
    const formData = new FormData();
if(stabilityImageGenrationUltraBody.aspect_ratio !== undefined) {
 formData.append(`aspect_ratio`, stabilityImageGenrationUltraBody.aspect_ratio);
 }
if(stabilityImageGenrationUltraBody.image !== undefined) {
 formData.append(`image`, stabilityImageGenrationUltraBody.image);
 }
if(stabilityImageGenrationUltraBody.negative_prompt !== undefined) {
 formData.append(`negative_prompt`, stabilityImageGenrationUltraBody.negative_prompt);
 }
if(stabilityImageGenrationUltraBody.output_format !== undefined) {
 formData.append(`output_format`, stabilityImageGenrationUltraBody.output_format);
 }
formData.append(`prompt`, stabilityImageGenrationUltraBody.prompt);
if(stabilityImageGenrationUltraBody.seed !== undefined) {
 formData.append(`seed`, stabilityImageGenrationUltraBody.seed.toString())
 }
if(stabilityImageGenrationUltraBody.strength !== undefined) {
 formData.append(`strength`, stabilityImageGenrationUltraBody.strength.toString())
 }
if(stabilityImageGenrationUltraBody.style_preset !== undefined) {
 formData.append(`style_preset`, stabilityImageGenrationUltraBody.style_preset);
 }

  return customInstance<stabilityImageGenrationUltraResponse>(getStabilityImageGenrationUltraUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getStabilityImageGenrationUltraMutationOptions = <TError = StabilityImageGenrationUltra400 | StabilityContentModerationResponse | StabilityImageGenrationUltra413 | StabilityImageGenrationUltra422 | StabilityImageGenrationUltra429 | StabilityImageGenrationUltra500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationUltra>>, TError,{data: StabilityImageGenrationUltraBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationUltra>>, TError,{data: StabilityImageGenrationUltraBody}, TContext> => {

const mutationKey = ['stabilityImageGenrationUltra'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stabilityImageGenrationUltra>>, {data: StabilityImageGenrationUltraBody}> = (props) => {
          const {data} = props ?? {};

          return  stabilityImageGenrationUltra(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StabilityImageGenrationUltraMutationResult = NonNullable<Awaited<ReturnType<typeof stabilityImageGenrationUltra>>>
    export type StabilityImageGenrationUltraMutationBody = StabilityImageGenrationUltraBody
    export type StabilityImageGenrationUltraMutationError = StabilityImageGenrationUltra400 | StabilityContentModerationResponse | StabilityImageGenrationUltra413 | StabilityImageGenrationUltra422 | StabilityImageGenrationUltra429 | StabilityImageGenrationUltra500

    /**
 * @summary Stable Image Ultra
 */
export const useStabilityImageGenrationUltra = <TError = StabilityImageGenrationUltra400 | StabilityContentModerationResponse | StabilityImageGenrationUltra413 | StabilityImageGenrationUltra422 | StabilityImageGenrationUltra429 | StabilityImageGenrationUltra500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationUltra>>, TError,{data: StabilityImageGenrationUltraBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stabilityImageGenrationUltra>>,
        TError,
        {data: StabilityImageGenrationUltraBody},
        TContext
      > => {
      return useMutation(getStabilityImageGenrationUltraMutationOptions(options), queryClient);
    }
    
/**
 * Takes images between 64x64 and 1 megapixel and upscales them all the way to 4K resolution. Put more generally, it can upscale images ~20-40x times while preserving all aspects. Conservative Upscale minimizes alterations to the image and should not be used to reimagine an image.

### Try it out
Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=t1Q4w2uvvza0)

### How to use

Please invoke this endpoint with a `POST` request.

The headers of the request must include an API key in the `authorization` field. The body of the request must be
`multipart/form-data`, and the `accept` header should be set to one of the following:



  - `image/*` to receive the image in the format specified by the `output_format` parameter.
  - `application/json` to receive the image encoded as base64 in a JSON response.

The body of the request must include:
- `image`
- `prompt`

Optionally, the body of the request may also include:
- `negative_prompt`
- `seed`
- `output_format`
- `creativity`

> **Note:** for more details about these parameters please see the request schema below.

### Output
The resolution of the generated image will be 4 megapixels.

### Credits
Flat rate of 25 credits per successful generation.  You will not be charged for failed generations.
 * @summary Conservative
 */
export type stabilityImageGenrationUpscaleConservativeResponse200 = {
  data: Blob
  status: 200
}

export type stabilityImageGenrationUpscaleConservativeResponse400 = {
  data: StabilityImageGenrationUpscaleConservativeResponse400
  status: 400
}

export type stabilityImageGenrationUpscaleConservativeResponse403 = {
  data: StabilityContentModerationResponse
  status: 403
}

export type stabilityImageGenrationUpscaleConservativeResponse413 = {
  data: StabilityImageGenrationUpscaleConservativeResponse413
  status: 413
}

export type stabilityImageGenrationUpscaleConservativeResponse422 = {
  data: StabilityImageGenrationUpscaleConservativeResponse422
  status: 422
}

export type stabilityImageGenrationUpscaleConservativeResponse429 = {
  data: StabilityImageGenrationUpscaleConservativeResponse429
  status: 429
}

export type stabilityImageGenrationUpscaleConservativeResponse500 = {
  data: StabilityImageGenrationUpscaleConservativeResponse500
  status: 500
}
    
export type stabilityImageGenrationUpscaleConservativeResponseSuccess = (stabilityImageGenrationUpscaleConservativeResponse200) & {
  headers: Headers;
};
export type stabilityImageGenrationUpscaleConservativeResponseError = (stabilityImageGenrationUpscaleConservativeResponse400 | stabilityImageGenrationUpscaleConservativeResponse403 | stabilityImageGenrationUpscaleConservativeResponse413 | stabilityImageGenrationUpscaleConservativeResponse422 | stabilityImageGenrationUpscaleConservativeResponse429 | stabilityImageGenrationUpscaleConservativeResponse500) & {
  headers: Headers;
};

export type stabilityImageGenrationUpscaleConservativeResponse = (stabilityImageGenrationUpscaleConservativeResponseSuccess | stabilityImageGenrationUpscaleConservativeResponseError)

export const getStabilityImageGenrationUpscaleConservativeUrl = () => {


  

  return `/proxy/stability/v2beta/stable-image/upscale/conservative`
}

export const stabilityImageGenrationUpscaleConservative = async (stabilityImageGenrationUpscaleConservativeRequest: StabilityImageGenrationUpscaleConservativeRequest, options?: RequestInit): Promise<stabilityImageGenrationUpscaleConservativeResponse> => {
    const formData = new FormData();
if(stabilityImageGenrationUpscaleConservativeRequest.creativity !== undefined) {
 formData.append(`creativity`, stabilityImageGenrationUpscaleConservativeRequest.creativity.toString())
 }
formData.append(`image`, stabilityImageGenrationUpscaleConservativeRequest.image);
if(stabilityImageGenrationUpscaleConservativeRequest.negative_prompt !== undefined) {
 formData.append(`negative_prompt`, stabilityImageGenrationUpscaleConservativeRequest.negative_prompt);
 }
if(stabilityImageGenrationUpscaleConservativeRequest.output_format !== undefined) {
 formData.append(`output_format`, stabilityImageGenrationUpscaleConservativeRequest.output_format);
 }
formData.append(`prompt`, stabilityImageGenrationUpscaleConservativeRequest.prompt);
if(stabilityImageGenrationUpscaleConservativeRequest.seed !== undefined) {
 formData.append(`seed`, stabilityImageGenrationUpscaleConservativeRequest.seed.toString())
 }

  return customInstance<stabilityImageGenrationUpscaleConservativeResponse>(getStabilityImageGenrationUpscaleConservativeUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getStabilityImageGenrationUpscaleConservativeMutationOptions = <TError = StabilityImageGenrationUpscaleConservativeResponse400 | StabilityContentModerationResponse | StabilityImageGenrationUpscaleConservativeResponse413 | StabilityImageGenrationUpscaleConservativeResponse422 | StabilityImageGenrationUpscaleConservativeResponse429 | StabilityImageGenrationUpscaleConservativeResponse500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationUpscaleConservative>>, TError,{data: StabilityImageGenrationUpscaleConservativeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationUpscaleConservative>>, TError,{data: StabilityImageGenrationUpscaleConservativeRequest}, TContext> => {

const mutationKey = ['stabilityImageGenrationUpscaleConservative'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stabilityImageGenrationUpscaleConservative>>, {data: StabilityImageGenrationUpscaleConservativeRequest}> = (props) => {
          const {data} = props ?? {};

          return  stabilityImageGenrationUpscaleConservative(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StabilityImageGenrationUpscaleConservativeMutationResult = NonNullable<Awaited<ReturnType<typeof stabilityImageGenrationUpscaleConservative>>>
    export type StabilityImageGenrationUpscaleConservativeMutationBody = StabilityImageGenrationUpscaleConservativeRequest
    export type StabilityImageGenrationUpscaleConservativeMutationError = StabilityImageGenrationUpscaleConservativeResponse400 | StabilityContentModerationResponse | StabilityImageGenrationUpscaleConservativeResponse413 | StabilityImageGenrationUpscaleConservativeResponse422 | StabilityImageGenrationUpscaleConservativeResponse429 | StabilityImageGenrationUpscaleConservativeResponse500

    /**
 * @summary Conservative
 */
export const useStabilityImageGenrationUpscaleConservative = <TError = StabilityImageGenrationUpscaleConservativeResponse400 | StabilityContentModerationResponse | StabilityImageGenrationUpscaleConservativeResponse413 | StabilityImageGenrationUpscaleConservativeResponse422 | StabilityImageGenrationUpscaleConservativeResponse429 | StabilityImageGenrationUpscaleConservativeResponse500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationUpscaleConservative>>, TError,{data: StabilityImageGenrationUpscaleConservativeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stabilityImageGenrationUpscaleConservative>>,
        TError,
        {data: StabilityImageGenrationUpscaleConservativeRequest},
        TContext
      > => {
      return useMutation(getStabilityImageGenrationUpscaleConservativeMutationOptions(options), queryClient);
    }
    
/**
 * Takes images between 64x64 and 1 megapixel and upscales them all the way to **4K** resolution.  Put more
generally, it can upscale images ~20-40x times while preserving, and often enhancing, quality.
Creative Upscale **works best on highly degraded images and is not for photos of 1mp or above** as it performs
heavy reimagining (controlled by creativity scale).

### Try it out
Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=QXxi9tfI425t)


### How to use
Please invoke this endpoint with a `POST` request.

The headers of the request must include an API key in the `authorization` field. The body of the request must be
`multipart/form-data`.

The body of the request should include:
- `image`
- `prompt`

The body may optionally include:
- `seed`
- `negative_prompt`
- `output_format`
- `creativity`
- `style_preset`

> **Note:** for more details about these parameters please see the request schema below.

### Results
After invoking this endpoint with the required parameters, use the `id` in the response to poll for results at the
[results/{id} endpoint](#tag/Results/paths/~1v2beta~1results~1%7Bid%7D/get).  Rate-limiting or other errors may occur if you poll more than once every 10 seconds.

### Credits
Flat rate of 25 credits per successful generation.  You will not be charged for failed generations.
 * @summary Creative Upscale (async)
 */
export type stabilityImageGenrationUpscaleCreativeResponse200 = {
  data: StabilityImageGenrationUpscaleCreativeResponse200
  status: 200
}

export type stabilityImageGenrationUpscaleCreativeResponse400 = {
  data: StabilityImageGenrationUpscaleCreativeResponse400
  status: 400
}

export type stabilityImageGenrationUpscaleCreativeResponse403 = {
  data: StabilityContentModerationResponse
  status: 403
}

export type stabilityImageGenrationUpscaleCreativeResponse413 = {
  data: StabilityImageGenrationUpscaleCreativeResponse413
  status: 413
}

export type stabilityImageGenrationUpscaleCreativeResponse422 = {
  data: StabilityImageGenrationUpscaleCreativeResponse422
  status: 422
}

export type stabilityImageGenrationUpscaleCreativeResponse429 = {
  data: StabilityImageGenrationUpscaleCreativeResponse429
  status: 429
}

export type stabilityImageGenrationUpscaleCreativeResponse500 = {
  data: StabilityImageGenrationUpscaleCreativeResponse500
  status: 500
}
    
export type stabilityImageGenrationUpscaleCreativeResponseSuccess = (stabilityImageGenrationUpscaleCreativeResponse200) & {
  headers: Headers;
};
export type stabilityImageGenrationUpscaleCreativeResponseError = (stabilityImageGenrationUpscaleCreativeResponse400 | stabilityImageGenrationUpscaleCreativeResponse403 | stabilityImageGenrationUpscaleCreativeResponse413 | stabilityImageGenrationUpscaleCreativeResponse422 | stabilityImageGenrationUpscaleCreativeResponse429 | stabilityImageGenrationUpscaleCreativeResponse500) & {
  headers: Headers;
};

export type stabilityImageGenrationUpscaleCreativeResponse = (stabilityImageGenrationUpscaleCreativeResponseSuccess | stabilityImageGenrationUpscaleCreativeResponseError)

export const getStabilityImageGenrationUpscaleCreativeUrl = () => {


  

  return `/proxy/stability/v2beta/stable-image/upscale/creative`
}

export const stabilityImageGenrationUpscaleCreative = async (stabilityImageGenrationUpscaleCreativeRequest: StabilityImageGenrationUpscaleCreativeRequest, options?: RequestInit): Promise<stabilityImageGenrationUpscaleCreativeResponse> => {
    const formData = new FormData();
if(stabilityImageGenrationUpscaleCreativeRequest.creativity !== undefined) {
 formData.append(`creativity`, stabilityImageGenrationUpscaleCreativeRequest.creativity.toString())
 }
formData.append(`image`, stabilityImageGenrationUpscaleCreativeRequest.image);
if(stabilityImageGenrationUpscaleCreativeRequest.negative_prompt !== undefined) {
 formData.append(`negative_prompt`, stabilityImageGenrationUpscaleCreativeRequest.negative_prompt);
 }
if(stabilityImageGenrationUpscaleCreativeRequest.output_format !== undefined) {
 formData.append(`output_format`, stabilityImageGenrationUpscaleCreativeRequest.output_format);
 }
formData.append(`prompt`, stabilityImageGenrationUpscaleCreativeRequest.prompt);
if(stabilityImageGenrationUpscaleCreativeRequest.seed !== undefined) {
 formData.append(`seed`, stabilityImageGenrationUpscaleCreativeRequest.seed.toString())
 }
if(stabilityImageGenrationUpscaleCreativeRequest.style_preset !== undefined) {
 formData.append(`style_preset`, stabilityImageGenrationUpscaleCreativeRequest.style_preset);
 }

  return customInstance<stabilityImageGenrationUpscaleCreativeResponse>(getStabilityImageGenrationUpscaleCreativeUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getStabilityImageGenrationUpscaleCreativeMutationOptions = <TError = StabilityImageGenrationUpscaleCreativeResponse400 | StabilityContentModerationResponse | StabilityImageGenrationUpscaleCreativeResponse413 | StabilityImageGenrationUpscaleCreativeResponse422 | StabilityImageGenrationUpscaleCreativeResponse429 | StabilityImageGenrationUpscaleCreativeResponse500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>, TError,{data: StabilityImageGenrationUpscaleCreativeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>, TError,{data: StabilityImageGenrationUpscaleCreativeRequest}, TContext> => {

const mutationKey = ['stabilityImageGenrationUpscaleCreative'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>, {data: StabilityImageGenrationUpscaleCreativeRequest}> = (props) => {
          const {data} = props ?? {};

          return  stabilityImageGenrationUpscaleCreative(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StabilityImageGenrationUpscaleCreativeMutationResult = NonNullable<Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>>
    export type StabilityImageGenrationUpscaleCreativeMutationBody = StabilityImageGenrationUpscaleCreativeRequest
    export type StabilityImageGenrationUpscaleCreativeMutationError = StabilityImageGenrationUpscaleCreativeResponse400 | StabilityContentModerationResponse | StabilityImageGenrationUpscaleCreativeResponse413 | StabilityImageGenrationUpscaleCreativeResponse422 | StabilityImageGenrationUpscaleCreativeResponse429 | StabilityImageGenrationUpscaleCreativeResponse500

    /**
 * @summary Creative Upscale (async)
 */
export const useStabilityImageGenrationUpscaleCreative = <TError = StabilityImageGenrationUpscaleCreativeResponse400 | StabilityContentModerationResponse | StabilityImageGenrationUpscaleCreativeResponse413 | StabilityImageGenrationUpscaleCreativeResponse422 | StabilityImageGenrationUpscaleCreativeResponse429 | StabilityImageGenrationUpscaleCreativeResponse500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>, TError,{data: StabilityImageGenrationUpscaleCreativeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>,
        TError,
        {data: StabilityImageGenrationUpscaleCreativeRequest},
        TContext
      > => {
      return useMutation(getStabilityImageGenrationUpscaleCreativeMutationOptions(options), queryClient);
    }
    
/**
 * Our Fast Upscaler service enhances image resolution by 4x using predictive and generative AI. This lightweight and fast service (processing in ~1 second) is ideal for enhancing the quality of compressed images, making it suitable for social media posts and other applications.

### Try it out
Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=t1Q4w2uvvza0)

### How to use

Please invoke this endpoint with a `POST` request.

The headers of the request must include an API key in the `authorization` field. The body of the request must be
`multipart/form-data`, and the `accept` header should be set to one of the following:



  - `image/*` to receive the image in the format specified by the `output_format` parameter.
  - `application/json` to receive the image encoded as base64 in a JSON response.

The body of the request must include:
- `image`

Optionally, the body of the request may also include:
- `output_format`

> **Note:** for more details about these parameters please see the request schema below.

### Output
The resolution of the generated image is 4 times that of the input image with a maximum size of 16 megapixels.

### Credits
Flat rate of 1 credit per successful generation. You will not be charged for failed generations.
 * @summary Fast
 */
export type stabilityImageGenerationUpscaleFastResponse200 = {
  data: Blob
  status: 200
}

export type stabilityImageGenerationUpscaleFastResponse400 = {
  data: StabilityImageGenrationUpscaleFastResponse400
  status: 400
}

export type stabilityImageGenerationUpscaleFastResponse403 = {
  data: StabilityContentModerationResponse
  status: 403
}

export type stabilityImageGenerationUpscaleFastResponse413 = {
  data: StabilityImageGenrationUpscaleFastResponse413
  status: 413
}

export type stabilityImageGenerationUpscaleFastResponse422 = {
  data: StabilityImageGenrationUpscaleFastResponse422
  status: 422
}

export type stabilityImageGenerationUpscaleFastResponse429 = {
  data: StabilityImageGenrationUpscaleFastResponse429
  status: 429
}

export type stabilityImageGenerationUpscaleFastResponse500 = {
  data: StabilityImageGenrationUpscaleFastResponse500
  status: 500
}
    
export type stabilityImageGenerationUpscaleFastResponseSuccess = (stabilityImageGenerationUpscaleFastResponse200) & {
  headers: Headers;
};
export type stabilityImageGenerationUpscaleFastResponseError = (stabilityImageGenerationUpscaleFastResponse400 | stabilityImageGenerationUpscaleFastResponse403 | stabilityImageGenerationUpscaleFastResponse413 | stabilityImageGenerationUpscaleFastResponse422 | stabilityImageGenerationUpscaleFastResponse429 | stabilityImageGenerationUpscaleFastResponse500) & {
  headers: Headers;
};

export type stabilityImageGenerationUpscaleFastResponse = (stabilityImageGenerationUpscaleFastResponseSuccess | stabilityImageGenerationUpscaleFastResponseError)

export const getStabilityImageGenerationUpscaleFastUrl = () => {


  

  return `/proxy/stability/v2beta/stable-image/upscale/fast`
}

export const stabilityImageGenerationUpscaleFast = async (stabilityImageGenrationUpscaleFastRequest: StabilityImageGenrationUpscaleFastRequest, options?: RequestInit): Promise<stabilityImageGenerationUpscaleFastResponse> => {
    const formData = new FormData();
formData.append(`image`, stabilityImageGenrationUpscaleFastRequest.image);
if(stabilityImageGenrationUpscaleFastRequest.output_format !== undefined) {
 formData.append(`output_format`, stabilityImageGenrationUpscaleFastRequest.output_format);
 }

  return customInstance<stabilityImageGenerationUpscaleFastResponse>(getStabilityImageGenerationUpscaleFastUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getStabilityImageGenerationUpscaleFastMutationOptions = <TError = StabilityImageGenrationUpscaleFastResponse400 | StabilityContentModerationResponse | StabilityImageGenrationUpscaleFastResponse413 | StabilityImageGenrationUpscaleFastResponse422 | StabilityImageGenrationUpscaleFastResponse429 | StabilityImageGenrationUpscaleFastResponse500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>, TError,{data: StabilityImageGenrationUpscaleFastRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>, TError,{data: StabilityImageGenrationUpscaleFastRequest}, TContext> => {

const mutationKey = ['stabilityImageGenerationUpscaleFast'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>, {data: StabilityImageGenrationUpscaleFastRequest}> = (props) => {
          const {data} = props ?? {};

          return  stabilityImageGenerationUpscaleFast(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StabilityImageGenerationUpscaleFastMutationResult = NonNullable<Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>>
    export type StabilityImageGenerationUpscaleFastMutationBody = StabilityImageGenrationUpscaleFastRequest
    export type StabilityImageGenerationUpscaleFastMutationError = StabilityImageGenrationUpscaleFastResponse400 | StabilityContentModerationResponse | StabilityImageGenrationUpscaleFastResponse413 | StabilityImageGenrationUpscaleFastResponse422 | StabilityImageGenrationUpscaleFastResponse429 | StabilityImageGenrationUpscaleFastResponse500

    /**
 * @summary Fast
 */
export const useStabilityImageGenerationUpscaleFast = <TError = StabilityImageGenrationUpscaleFastResponse400 | StabilityContentModerationResponse | StabilityImageGenrationUpscaleFastResponse413 | StabilityImageGenrationUpscaleFastResponse422 | StabilityImageGenrationUpscaleFastResponse429 | StabilityImageGenrationUpscaleFastResponse500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>, TError,{data: StabilityImageGenrationUpscaleFastRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>,
        TError,
        {data: StabilityImageGenrationUpscaleFastRequest},
        TContext
      > => {
      return useMutation(getStabilityImageGenerationUpscaleFastMutationOptions(options), queryClient);
    }
    
/**
 * Submit a component identification and generation task using Tencent Hunyuan.
Automatically performs component splitting based on the model structure after inputting a 3D model file.
Recommends inputting 3D models generated by AIGC. File size not greater than 100MB, face count not greater than 30,000. FBX format only.

The returned JobId can be used with the query endpoint to check task status.

 * @summary Submit Tencent Hunyuan 3D Part (Component Splitting) Task
 */
export type tencentHunyuan3DPartSubmitResponse200 = {
  data: TencentHunyuan3DUVResponse
  status: 200
}

export type tencentHunyuan3DPartSubmitResponse400 = {
  data: TencentErrorResponse
  status: 400
}

export type tencentHunyuan3DPartSubmitResponse401 = {
  data: void
  status: 401
}

export type tencentHunyuan3DPartSubmitResponse402 = {
  data: ErrorResponse
  status: 402
}

export type tencentHunyuan3DPartSubmitResponse500 = {
  data: TencentErrorResponse
  status: 500
}
    
export type tencentHunyuan3DPartSubmitResponseSuccess = (tencentHunyuan3DPartSubmitResponse200) & {
  headers: Headers;
};
export type tencentHunyuan3DPartSubmitResponseError = (tencentHunyuan3DPartSubmitResponse400 | tencentHunyuan3DPartSubmitResponse401 | tencentHunyuan3DPartSubmitResponse402 | tencentHunyuan3DPartSubmitResponse500) & {
  headers: Headers;
};

export type tencentHunyuan3DPartSubmitResponse = (tencentHunyuan3DPartSubmitResponseSuccess | tencentHunyuan3DPartSubmitResponseError)

export const getTencentHunyuan3DPartSubmitUrl = () => {


  

  return `/proxy/tencent/hunyuan/3d-part`
}

export const tencentHunyuan3DPartSubmit = async (tencentHunyuan3DUVRequest: TencentHunyuan3DUVRequest, options?: RequestInit): Promise<tencentHunyuan3DPartSubmitResponse> => {
  
  return customInstance<tencentHunyuan3DPartSubmitResponse>(getTencentHunyuan3DPartSubmitUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tencentHunyuan3DUVRequest,)
  }
);}




export const getTencentHunyuan3DPartSubmitMutationOptions = <TError = TencentErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DPartSubmit>>, TError,{data: TencentHunyuan3DUVRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DPartSubmit>>, TError,{data: TencentHunyuan3DUVRequest}, TContext> => {

const mutationKey = ['tencentHunyuan3DPartSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tencentHunyuan3DPartSubmit>>, {data: TencentHunyuan3DUVRequest}> = (props) => {
          const {data} = props ?? {};

          return  tencentHunyuan3DPartSubmit(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TencentHunyuan3DPartSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof tencentHunyuan3DPartSubmit>>>
    export type TencentHunyuan3DPartSubmitMutationBody = TencentHunyuan3DUVRequest
    export type TencentHunyuan3DPartSubmitMutationError = TencentErrorResponse | void | ErrorResponse

    /**
 * @summary Submit Tencent Hunyuan 3D Part (Component Splitting) Task
 */
export const useTencentHunyuan3DPartSubmit = <TError = TencentErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DPartSubmit>>, TError,{data: TencentHunyuan3DUVRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tencentHunyuan3DPartSubmit>>,
        TError,
        {data: TencentHunyuan3DUVRequest},
        TContext
      > => {
      return useMutation(getTencentHunyuan3DPartSubmitMutationOptions(options), queryClient);
    }
    
/**
 * Query the status and result of a previously submitted 3D part (component splitting) task.

Poll this endpoint until the task status indicates completion.

 * @summary Query Tencent Hunyuan 3D Part Task Status
 */
export type tencentHunyuan3DPartQueryResponse200 = {
  data: TencentHunyuan3DQueryResponse
  status: 200
}

export type tencentHunyuan3DPartQueryResponse400 = {
  data: TencentErrorResponse
  status: 400
}

export type tencentHunyuan3DPartQueryResponse401 = {
  data: void
  status: 401
}

export type tencentHunyuan3DPartQueryResponse500 = {
  data: TencentErrorResponse
  status: 500
}
    
export type tencentHunyuan3DPartQueryResponseSuccess = (tencentHunyuan3DPartQueryResponse200) & {
  headers: Headers;
};
export type tencentHunyuan3DPartQueryResponseError = (tencentHunyuan3DPartQueryResponse400 | tencentHunyuan3DPartQueryResponse401 | tencentHunyuan3DPartQueryResponse500) & {
  headers: Headers;
};

export type tencentHunyuan3DPartQueryResponse = (tencentHunyuan3DPartQueryResponseSuccess | tencentHunyuan3DPartQueryResponseError)

export const getTencentHunyuan3DPartQueryUrl = () => {


  

  return `/proxy/tencent/hunyuan/3d-part/query`
}

export const tencentHunyuan3DPartQuery = async (tencentHunyuan3DQueryRequest: TencentHunyuan3DQueryRequest, options?: RequestInit): Promise<tencentHunyuan3DPartQueryResponse> => {
  
  return customInstance<tencentHunyuan3DPartQueryResponse>(getTencentHunyuan3DPartQueryUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tencentHunyuan3DQueryRequest,)
  }
);}




export const getTencentHunyuan3DPartQueryMutationOptions = <TError = TencentErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DPartQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DPartQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext> => {

const mutationKey = ['tencentHunyuan3DPartQuery'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tencentHunyuan3DPartQuery>>, {data: TencentHunyuan3DQueryRequest}> = (props) => {
          const {data} = props ?? {};

          return  tencentHunyuan3DPartQuery(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TencentHunyuan3DPartQueryMutationResult = NonNullable<Awaited<ReturnType<typeof tencentHunyuan3DPartQuery>>>
    export type TencentHunyuan3DPartQueryMutationBody = TencentHunyuan3DQueryRequest
    export type TencentHunyuan3DPartQueryMutationError = TencentErrorResponse | void

    /**
 * @summary Query Tencent Hunyuan 3D Part Task Status
 */
export const useTencentHunyuan3DPartQuery = <TError = TencentErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DPartQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tencentHunyuan3DPartQuery>>,
        TError,
        {data: TencentHunyuan3DQueryRequest},
        TContext
      > => {
      return useMutation(getTencentHunyuan3DPartQueryMutationOptions(options), queryClient);
    }
    
/**
 * Submit a task to generate 3D content using Tencent HunYuan Large Model.
Supports text-to-3D and image-to-3D generation.

This API provides 3 concurrent tasks by default. A new task can be processed 
only after the previous one is completed.

The returned JobId can be used with the query endpoint to check task status.

 * @summary Submit Tencent Hunyuan 3D Pro Generation Task
 */
export type tencentHunyuan3DProSubmitResponse200 = {
  data: TencentHunyuan3DProResponse
  status: 200
}

export type tencentHunyuan3DProSubmitResponse400 = {
  data: TencentErrorResponse
  status: 400
}

export type tencentHunyuan3DProSubmitResponse401 = {
  data: void
  status: 401
}

export type tencentHunyuan3DProSubmitResponse402 = {
  data: ErrorResponse
  status: 402
}

export type tencentHunyuan3DProSubmitResponse500 = {
  data: TencentErrorResponse
  status: 500
}
    
export type tencentHunyuan3DProSubmitResponseSuccess = (tencentHunyuan3DProSubmitResponse200) & {
  headers: Headers;
};
export type tencentHunyuan3DProSubmitResponseError = (tencentHunyuan3DProSubmitResponse400 | tencentHunyuan3DProSubmitResponse401 | tencentHunyuan3DProSubmitResponse402 | tencentHunyuan3DProSubmitResponse500) & {
  headers: Headers;
};

export type tencentHunyuan3DProSubmitResponse = (tencentHunyuan3DProSubmitResponseSuccess | tencentHunyuan3DProSubmitResponseError)

export const getTencentHunyuan3DProSubmitUrl = () => {


  

  return `/proxy/tencent/hunyuan/3d-pro`
}

export const tencentHunyuan3DProSubmit = async (tencentHunyuan3DProRequest: TencentHunyuan3DProRequest, options?: RequestInit): Promise<tencentHunyuan3DProSubmitResponse> => {
  
  return customInstance<tencentHunyuan3DProSubmitResponse>(getTencentHunyuan3DProSubmitUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tencentHunyuan3DProRequest,)
  }
);}




export const getTencentHunyuan3DProSubmitMutationOptions = <TError = TencentErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DProSubmit>>, TError,{data: TencentHunyuan3DProRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DProSubmit>>, TError,{data: TencentHunyuan3DProRequest}, TContext> => {

const mutationKey = ['tencentHunyuan3DProSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tencentHunyuan3DProSubmit>>, {data: TencentHunyuan3DProRequest}> = (props) => {
          const {data} = props ?? {};

          return  tencentHunyuan3DProSubmit(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TencentHunyuan3DProSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof tencentHunyuan3DProSubmit>>>
    export type TencentHunyuan3DProSubmitMutationBody = TencentHunyuan3DProRequest
    export type TencentHunyuan3DProSubmitMutationError = TencentErrorResponse | void | ErrorResponse

    /**
 * @summary Submit Tencent Hunyuan 3D Pro Generation Task
 */
export const useTencentHunyuan3DProSubmit = <TError = TencentErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DProSubmit>>, TError,{data: TencentHunyuan3DProRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tencentHunyuan3DProSubmit>>,
        TError,
        {data: TencentHunyuan3DProRequest},
        TContext
      > => {
      return useMutation(getTencentHunyuan3DProSubmitMutationOptions(options), queryClient);
    }
    
/**
 * Query the status and result of a previously submitted 3D generation task.

Poll this endpoint until the task status indicates completion.

 * @summary Query Tencent Hunyuan 3D Pro Task Status
 */
export type tencentHunyuan3DProQueryResponse200 = {
  data: TencentHunyuan3DQueryResponse
  status: 200
}

export type tencentHunyuan3DProQueryResponse400 = {
  data: TencentErrorResponse
  status: 400
}

export type tencentHunyuan3DProQueryResponse401 = {
  data: void
  status: 401
}

export type tencentHunyuan3DProQueryResponse500 = {
  data: TencentErrorResponse
  status: 500
}
    
export type tencentHunyuan3DProQueryResponseSuccess = (tencentHunyuan3DProQueryResponse200) & {
  headers: Headers;
};
export type tencentHunyuan3DProQueryResponseError = (tencentHunyuan3DProQueryResponse400 | tencentHunyuan3DProQueryResponse401 | tencentHunyuan3DProQueryResponse500) & {
  headers: Headers;
};

export type tencentHunyuan3DProQueryResponse = (tencentHunyuan3DProQueryResponseSuccess | tencentHunyuan3DProQueryResponseError)

export const getTencentHunyuan3DProQueryUrl = () => {


  

  return `/proxy/tencent/hunyuan/3d-pro/query`
}

export const tencentHunyuan3DProQuery = async (tencentHunyuan3DQueryRequest: TencentHunyuan3DQueryRequest, options?: RequestInit): Promise<tencentHunyuan3DProQueryResponse> => {
  
  return customInstance<tencentHunyuan3DProQueryResponse>(getTencentHunyuan3DProQueryUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tencentHunyuan3DQueryRequest,)
  }
);}




export const getTencentHunyuan3DProQueryMutationOptions = <TError = TencentErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DProQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DProQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext> => {

const mutationKey = ['tencentHunyuan3DProQuery'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tencentHunyuan3DProQuery>>, {data: TencentHunyuan3DQueryRequest}> = (props) => {
          const {data} = props ?? {};

          return  tencentHunyuan3DProQuery(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TencentHunyuan3DProQueryMutationResult = NonNullable<Awaited<ReturnType<typeof tencentHunyuan3DProQuery>>>
    export type TencentHunyuan3DProQueryMutationBody = TencentHunyuan3DQueryRequest
    export type TencentHunyuan3DProQueryMutationError = TencentErrorResponse | void

    /**
 * @summary Query Tencent Hunyuan 3D Pro Task Status
 */
export const useTencentHunyuan3DProQuery = <TError = TencentErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DProQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tencentHunyuan3DProQuery>>,
        TError,
        {data: TencentHunyuan3DQueryRequest},
        TContext
      > => {
      return useMutation(getTencentHunyuan3DProQueryMutationOptions(options), queryClient);
    }
    
/**
 * Submit a 3D model texture redrawing task using Tencent Hunyuan.
After inputting the 3D model, perform 3D model texture redrawing based on semantics or images.
Supported format: FBX. 3D model limit: less than 100000 faces.
Either Image or Prompt is required; they cannot coexist. EnablePBR only supports enabling when using Prompt.

The returned JobId can be used with the query endpoint to check task status.

 * @summary Submit Tencent Hunyuan 3D Texture Edit Task
 */
export type tencentHunyuan3DTextureEditSubmitResponse200 = {
  data: TencentHunyuan3DUVResponse
  status: 200
}

export type tencentHunyuan3DTextureEditSubmitResponse400 = {
  data: TencentErrorResponse
  status: 400
}

export type tencentHunyuan3DTextureEditSubmitResponse401 = {
  data: void
  status: 401
}

export type tencentHunyuan3DTextureEditSubmitResponse402 = {
  data: ErrorResponse
  status: 402
}

export type tencentHunyuan3DTextureEditSubmitResponse500 = {
  data: TencentErrorResponse
  status: 500
}
    
export type tencentHunyuan3DTextureEditSubmitResponseSuccess = (tencentHunyuan3DTextureEditSubmitResponse200) & {
  headers: Headers;
};
export type tencentHunyuan3DTextureEditSubmitResponseError = (tencentHunyuan3DTextureEditSubmitResponse400 | tencentHunyuan3DTextureEditSubmitResponse401 | tencentHunyuan3DTextureEditSubmitResponse402 | tencentHunyuan3DTextureEditSubmitResponse500) & {
  headers: Headers;
};

export type tencentHunyuan3DTextureEditSubmitResponse = (tencentHunyuan3DTextureEditSubmitResponseSuccess | tencentHunyuan3DTextureEditSubmitResponseError)

export const getTencentHunyuan3DTextureEditSubmitUrl = () => {


  

  return `/proxy/tencent/hunyuan/3d-texture-edit`
}

export const tencentHunyuan3DTextureEditSubmit = async (tencentHunyuan3DTextureEditRequest: TencentHunyuan3DTextureEditRequest, options?: RequestInit): Promise<tencentHunyuan3DTextureEditSubmitResponse> => {
  
  return customInstance<tencentHunyuan3DTextureEditSubmitResponse>(getTencentHunyuan3DTextureEditSubmitUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tencentHunyuan3DTextureEditRequest,)
  }
);}




export const getTencentHunyuan3DTextureEditSubmitMutationOptions = <TError = TencentErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DTextureEditSubmit>>, TError,{data: TencentHunyuan3DTextureEditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DTextureEditSubmit>>, TError,{data: TencentHunyuan3DTextureEditRequest}, TContext> => {

const mutationKey = ['tencentHunyuan3DTextureEditSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tencentHunyuan3DTextureEditSubmit>>, {data: TencentHunyuan3DTextureEditRequest}> = (props) => {
          const {data} = props ?? {};

          return  tencentHunyuan3DTextureEditSubmit(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TencentHunyuan3DTextureEditSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof tencentHunyuan3DTextureEditSubmit>>>
    export type TencentHunyuan3DTextureEditSubmitMutationBody = TencentHunyuan3DTextureEditRequest
    export type TencentHunyuan3DTextureEditSubmitMutationError = TencentErrorResponse | void | ErrorResponse

    /**
 * @summary Submit Tencent Hunyuan 3D Texture Edit Task
 */
export const useTencentHunyuan3DTextureEditSubmit = <TError = TencentErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DTextureEditSubmit>>, TError,{data: TencentHunyuan3DTextureEditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tencentHunyuan3DTextureEditSubmit>>,
        TError,
        {data: TencentHunyuan3DTextureEditRequest},
        TContext
      > => {
      return useMutation(getTencentHunyuan3DTextureEditSubmitMutationOptions(options), queryClient);
    }
    
/**
 * Query the status and result of a previously submitted 3D texture edit task.

Poll this endpoint until the task status indicates completion.

 * @summary Query Tencent Hunyuan 3D Texture Edit Task Status
 */
export type tencentHunyuan3DTextureEditQueryResponse200 = {
  data: TencentHunyuan3DQueryResponse
  status: 200
}

export type tencentHunyuan3DTextureEditQueryResponse400 = {
  data: TencentErrorResponse
  status: 400
}

export type tencentHunyuan3DTextureEditQueryResponse401 = {
  data: void
  status: 401
}

export type tencentHunyuan3DTextureEditQueryResponse500 = {
  data: TencentErrorResponse
  status: 500
}
    
export type tencentHunyuan3DTextureEditQueryResponseSuccess = (tencentHunyuan3DTextureEditQueryResponse200) & {
  headers: Headers;
};
export type tencentHunyuan3DTextureEditQueryResponseError = (tencentHunyuan3DTextureEditQueryResponse400 | tencentHunyuan3DTextureEditQueryResponse401 | tencentHunyuan3DTextureEditQueryResponse500) & {
  headers: Headers;
};

export type tencentHunyuan3DTextureEditQueryResponse = (tencentHunyuan3DTextureEditQueryResponseSuccess | tencentHunyuan3DTextureEditQueryResponseError)

export const getTencentHunyuan3DTextureEditQueryUrl = () => {


  

  return `/proxy/tencent/hunyuan/3d-texture-edit/query`
}

export const tencentHunyuan3DTextureEditQuery = async (tencentHunyuan3DQueryRequest: TencentHunyuan3DQueryRequest, options?: RequestInit): Promise<tencentHunyuan3DTextureEditQueryResponse> => {
  
  return customInstance<tencentHunyuan3DTextureEditQueryResponse>(getTencentHunyuan3DTextureEditQueryUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tencentHunyuan3DQueryRequest,)
  }
);}




export const getTencentHunyuan3DTextureEditQueryMutationOptions = <TError = TencentErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DTextureEditQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DTextureEditQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext> => {

const mutationKey = ['tencentHunyuan3DTextureEditQuery'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tencentHunyuan3DTextureEditQuery>>, {data: TencentHunyuan3DQueryRequest}> = (props) => {
          const {data} = props ?? {};

          return  tencentHunyuan3DTextureEditQuery(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TencentHunyuan3DTextureEditQueryMutationResult = NonNullable<Awaited<ReturnType<typeof tencentHunyuan3DTextureEditQuery>>>
    export type TencentHunyuan3DTextureEditQueryMutationBody = TencentHunyuan3DQueryRequest
    export type TencentHunyuan3DTextureEditQueryMutationError = TencentErrorResponse | void

    /**
 * @summary Query Tencent Hunyuan 3D Texture Edit Task Status
 */
export const useTencentHunyuan3DTextureEditQuery = <TError = TencentErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DTextureEditQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tencentHunyuan3DTextureEditQuery>>,
        TError,
        {data: TencentHunyuan3DQueryRequest},
        TContext
      > => {
      return useMutation(getTencentHunyuan3DTextureEditQueryMutationOptions(options), queryClient);
    }
    
/**
 * Submit a UV unwrapping task for a 3D model using Tencent Hunyuan.
After inputting the model, UV unwrapping can be performed based on the 
model texture to output the corresponding UV map.

The returned JobId can be used with the query endpoint to check task status.

 * @summary Submit Tencent Hunyuan 3D UV Unfolding Task
 */
export type tencentHunyuan3DUVSubmitResponse200 = {
  data: TencentHunyuan3DUVResponse
  status: 200
}

export type tencentHunyuan3DUVSubmitResponse400 = {
  data: TencentErrorResponse
  status: 400
}

export type tencentHunyuan3DUVSubmitResponse401 = {
  data: void
  status: 401
}

export type tencentHunyuan3DUVSubmitResponse402 = {
  data: ErrorResponse
  status: 402
}

export type tencentHunyuan3DUVSubmitResponse500 = {
  data: TencentErrorResponse
  status: 500
}
    
export type tencentHunyuan3DUVSubmitResponseSuccess = (tencentHunyuan3DUVSubmitResponse200) & {
  headers: Headers;
};
export type tencentHunyuan3DUVSubmitResponseError = (tencentHunyuan3DUVSubmitResponse400 | tencentHunyuan3DUVSubmitResponse401 | tencentHunyuan3DUVSubmitResponse402 | tencentHunyuan3DUVSubmitResponse500) & {
  headers: Headers;
};

export type tencentHunyuan3DUVSubmitResponse = (tencentHunyuan3DUVSubmitResponseSuccess | tencentHunyuan3DUVSubmitResponseError)

export const getTencentHunyuan3DUVSubmitUrl = () => {


  

  return `/proxy/tencent/hunyuan/3d-uv`
}

export const tencentHunyuan3DUVSubmit = async (tencentHunyuan3DUVRequest: TencentHunyuan3DUVRequest, options?: RequestInit): Promise<tencentHunyuan3DUVSubmitResponse> => {
  
  return customInstance<tencentHunyuan3DUVSubmitResponse>(getTencentHunyuan3DUVSubmitUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tencentHunyuan3DUVRequest,)
  }
);}




export const getTencentHunyuan3DUVSubmitMutationOptions = <TError = TencentErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DUVSubmit>>, TError,{data: TencentHunyuan3DUVRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DUVSubmit>>, TError,{data: TencentHunyuan3DUVRequest}, TContext> => {

const mutationKey = ['tencentHunyuan3DUVSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tencentHunyuan3DUVSubmit>>, {data: TencentHunyuan3DUVRequest}> = (props) => {
          const {data} = props ?? {};

          return  tencentHunyuan3DUVSubmit(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TencentHunyuan3DUVSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof tencentHunyuan3DUVSubmit>>>
    export type TencentHunyuan3DUVSubmitMutationBody = TencentHunyuan3DUVRequest
    export type TencentHunyuan3DUVSubmitMutationError = TencentErrorResponse | void | ErrorResponse

    /**
 * @summary Submit Tencent Hunyuan 3D UV Unfolding Task
 */
export const useTencentHunyuan3DUVSubmit = <TError = TencentErrorResponse | void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DUVSubmit>>, TError,{data: TencentHunyuan3DUVRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tencentHunyuan3DUVSubmit>>,
        TError,
        {data: TencentHunyuan3DUVRequest},
        TContext
      > => {
      return useMutation(getTencentHunyuan3DUVSubmitMutationOptions(options), queryClient);
    }
    
/**
 * Query the status and result of a previously submitted UV unwrapping task.

Poll this endpoint until the task status indicates completion.

 * @summary Query Tencent Hunyuan 3D UV Unfolding Task Status
 */
export type tencentHunyuan3DUVQueryResponse200 = {
  data: TencentHunyuan3DQueryResponse
  status: 200
}

export type tencentHunyuan3DUVQueryResponse400 = {
  data: TencentErrorResponse
  status: 400
}

export type tencentHunyuan3DUVQueryResponse401 = {
  data: void
  status: 401
}

export type tencentHunyuan3DUVQueryResponse500 = {
  data: TencentErrorResponse
  status: 500
}
    
export type tencentHunyuan3DUVQueryResponseSuccess = (tencentHunyuan3DUVQueryResponse200) & {
  headers: Headers;
};
export type tencentHunyuan3DUVQueryResponseError = (tencentHunyuan3DUVQueryResponse400 | tencentHunyuan3DUVQueryResponse401 | tencentHunyuan3DUVQueryResponse500) & {
  headers: Headers;
};

export type tencentHunyuan3DUVQueryResponse = (tencentHunyuan3DUVQueryResponseSuccess | tencentHunyuan3DUVQueryResponseError)

export const getTencentHunyuan3DUVQueryUrl = () => {


  

  return `/proxy/tencent/hunyuan/3d-uv/query`
}

export const tencentHunyuan3DUVQuery = async (tencentHunyuan3DQueryRequest: TencentHunyuan3DQueryRequest, options?: RequestInit): Promise<tencentHunyuan3DUVQueryResponse> => {
  
  return customInstance<tencentHunyuan3DUVQueryResponse>(getTencentHunyuan3DUVQueryUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tencentHunyuan3DQueryRequest,)
  }
);}




export const getTencentHunyuan3DUVQueryMutationOptions = <TError = TencentErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DUVQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DUVQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext> => {

const mutationKey = ['tencentHunyuan3DUVQuery'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tencentHunyuan3DUVQuery>>, {data: TencentHunyuan3DQueryRequest}> = (props) => {
          const {data} = props ?? {};

          return  tencentHunyuan3DUVQuery(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TencentHunyuan3DUVQueryMutationResult = NonNullable<Awaited<ReturnType<typeof tencentHunyuan3DUVQuery>>>
    export type TencentHunyuan3DUVQueryMutationBody = TencentHunyuan3DQueryRequest
    export type TencentHunyuan3DUVQueryMutationError = TencentErrorResponse | void

    /**
 * @summary Query Tencent Hunyuan 3D UV Unfolding Task Status
 */
export const useTencentHunyuan3DUVQuery = <TError = TencentErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tencentHunyuan3DUVQuery>>, TError,{data: TencentHunyuan3DQueryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tencentHunyuan3DUVQuery>>,
        TError,
        {data: TencentHunyuan3DQueryRequest},
        TContext
      > => {
      return useMutation(getTencentHunyuan3DUVQueryMutationOptions(options), queryClient);
    }
    
export type topazDownloadResultResponse200 = {
  data: TopazDownloadResponse
  status: 200
}

export type topazDownloadResultResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type topazDownloadResultResponseSuccess = (topazDownloadResultResponse200) & {
  headers: Headers;
};
export type topazDownloadResultResponseError = (topazDownloadResultResponseDefault) & {
  headers: Headers;
};

export type topazDownloadResultResponse = (topazDownloadResultResponseSuccess | topazDownloadResultResponseError)

export const getTopazDownloadResultUrl = (processId: string,) => {


  

  return `/proxy/topaz/image/v1/download/${processId}`
}

export const topazDownloadResult = async (processId: string, options?: RequestInit): Promise<topazDownloadResultResponse> => {
  
  return customInstance<topazDownloadResultResponse>(getTopazDownloadResultUrl(processId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getTopazDownloadResultQueryKey = (processId: string,) => {
    return [
    `/proxy/topaz/image/v1/download/${processId}`
    ] as const;
    }

    
export const getTopazDownloadResultQueryOptions = <TData = Awaited<ReturnType<typeof topazDownloadResult>>, TError = Error>(processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazDownloadResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTopazDownloadResultQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof topazDownloadResult>>> = ({ signal }) => topazDownloadResult(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof topazDownloadResult>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TopazDownloadResultQueryResult = NonNullable<Awaited<ReturnType<typeof topazDownloadResult>>>
export type TopazDownloadResultQueryError = Error


export function useTopazDownloadResult<TData = Awaited<ReturnType<typeof topazDownloadResult>>, TError = Error>(
 processId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazDownloadResult>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof topazDownloadResult>>,
          TError,
          Awaited<ReturnType<typeof topazDownloadResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTopazDownloadResult<TData = Awaited<ReturnType<typeof topazDownloadResult>>, TError = Error>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazDownloadResult>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof topazDownloadResult>>,
          TError,
          Awaited<ReturnType<typeof topazDownloadResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTopazDownloadResult<TData = Awaited<ReturnType<typeof topazDownloadResult>>, TError = Error>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazDownloadResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTopazDownloadResult<TData = Awaited<ReturnType<typeof topazDownloadResult>>, TError = Error>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazDownloadResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTopazDownloadResultQueryOptions(processId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type topazEnhanceGenAsyncResponse200 = {
  data: TopazEnhanceGenResponse
  status: 200
}

export type topazEnhanceGenAsyncResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type topazEnhanceGenAsyncResponseSuccess = (topazEnhanceGenAsyncResponse200) & {
  headers: Headers;
};
export type topazEnhanceGenAsyncResponseError = (topazEnhanceGenAsyncResponseDefault) & {
  headers: Headers;
};

export type topazEnhanceGenAsyncResponse = (topazEnhanceGenAsyncResponseSuccess | topazEnhanceGenAsyncResponseError)

export const getTopazEnhanceGenAsyncUrl = () => {


  

  return `/proxy/topaz/image/v1/enhance-gen/async`
}

export const topazEnhanceGenAsync = async (topazEnhanceGenRequest: TopazEnhanceGenRequest, options?: RequestInit): Promise<topazEnhanceGenAsyncResponse> => {
    const formData = new FormData();
if(topazEnhanceGenRequest.color_preservation !== undefined) {
 formData.append(`color_preservation`, topazEnhanceGenRequest.color_preservation);
 }
if(topazEnhanceGenRequest.creativity !== undefined) {
 formData.append(`creativity`, topazEnhanceGenRequest.creativity.toString())
 }
if(topazEnhanceGenRequest.crop_to_fill !== undefined) {
 formData.append(`crop_to_fill`, topazEnhanceGenRequest.crop_to_fill.toString())
 }
if(topazEnhanceGenRequest.face_enhancement !== undefined) {
 formData.append(`face_enhancement`, topazEnhanceGenRequest.face_enhancement.toString())
 }
if(topazEnhanceGenRequest.face_enhancement_creativity !== undefined) {
 formData.append(`face_enhancement_creativity`, topazEnhanceGenRequest.face_enhancement_creativity.toString())
 }
if(topazEnhanceGenRequest.face_enhancement_strength !== undefined) {
 formData.append(`face_enhancement_strength`, topazEnhanceGenRequest.face_enhancement_strength.toString())
 }
if(topazEnhanceGenRequest.face_preservation !== undefined) {
 formData.append(`face_preservation`, topazEnhanceGenRequest.face_preservation);
 }
if(topazEnhanceGenRequest.image !== undefined) {
 formData.append(`image`, topazEnhanceGenRequest.image);
 }
formData.append(`model`, topazEnhanceGenRequest.model);
if(topazEnhanceGenRequest.output_format !== undefined) {
 formData.append(`output_format`, topazEnhanceGenRequest.output_format);
 }
if(topazEnhanceGenRequest.output_height !== undefined) {
 formData.append(`output_height`, topazEnhanceGenRequest.output_height.toString())
 }
if(topazEnhanceGenRequest.output_width !== undefined) {
 formData.append(`output_width`, topazEnhanceGenRequest.output_width.toString())
 }
if(topazEnhanceGenRequest.prompt !== undefined) {
 formData.append(`prompt`, topazEnhanceGenRequest.prompt);
 }
if(topazEnhanceGenRequest.source_id !== undefined) {
 formData.append(`source_id`, topazEnhanceGenRequest.source_id);
 }
if(topazEnhanceGenRequest.source_url !== undefined) {
 formData.append(`source_url`, topazEnhanceGenRequest.source_url);
 }
if(topazEnhanceGenRequest.subject_detection !== undefined) {
 formData.append(`subject_detection`, topazEnhanceGenRequest.subject_detection);
 }

  return customInstance<topazEnhanceGenAsyncResponse>(getTopazEnhanceGenAsyncUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getTopazEnhanceGenAsyncMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof topazEnhanceGenAsync>>, TError,{data: TopazEnhanceGenRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof topazEnhanceGenAsync>>, TError,{data: TopazEnhanceGenRequest}, TContext> => {

const mutationKey = ['topazEnhanceGenAsync'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof topazEnhanceGenAsync>>, {data: TopazEnhanceGenRequest}> = (props) => {
          const {data} = props ?? {};

          return  topazEnhanceGenAsync(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TopazEnhanceGenAsyncMutationResult = NonNullable<Awaited<ReturnType<typeof topazEnhanceGenAsync>>>
    export type TopazEnhanceGenAsyncMutationBody = TopazEnhanceGenRequest
    export type TopazEnhanceGenAsyncMutationError = Error

    export const useTopazEnhanceGenAsync = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof topazEnhanceGenAsync>>, TError,{data: TopazEnhanceGenRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof topazEnhanceGenAsync>>,
        TError,
        {data: TopazEnhanceGenRequest},
        TContext
      > => {
      return useMutation(getTopazEnhanceGenAsyncMutationOptions(options), queryClient);
    }
    
export type topazGetStatusResponse200 = {
  data: TopazStatusResponse
  status: 200
}

export type topazGetStatusResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type topazGetStatusResponseSuccess = (topazGetStatusResponse200) & {
  headers: Headers;
};
export type topazGetStatusResponseError = (topazGetStatusResponseDefault) & {
  headers: Headers;
};

export type topazGetStatusResponse = (topazGetStatusResponseSuccess | topazGetStatusResponseError)

export const getTopazGetStatusUrl = (processId: string,) => {


  

  return `/proxy/topaz/image/v1/status/${processId}`
}

export const topazGetStatus = async (processId: string, options?: RequestInit): Promise<topazGetStatusResponse> => {
  
  return customInstance<topazGetStatusResponse>(getTopazGetStatusUrl(processId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getTopazGetStatusQueryKey = (processId: string,) => {
    return [
    `/proxy/topaz/image/v1/status/${processId}`
    ] as const;
    }

    
export const getTopazGetStatusQueryOptions = <TData = Awaited<ReturnType<typeof topazGetStatus>>, TError = Error>(processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTopazGetStatusQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof topazGetStatus>>> = ({ signal }) => topazGetStatus(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof topazGetStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TopazGetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof topazGetStatus>>>
export type TopazGetStatusQueryError = Error


export function useTopazGetStatus<TData = Awaited<ReturnType<typeof topazGetStatus>>, TError = Error>(
 processId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazGetStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof topazGetStatus>>,
          TError,
          Awaited<ReturnType<typeof topazGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTopazGetStatus<TData = Awaited<ReturnType<typeof topazGetStatus>>, TError = Error>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazGetStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof topazGetStatus>>,
          TError,
          Awaited<ReturnType<typeof topazGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTopazGetStatus<TData = Awaited<ReturnType<typeof topazGetStatus>>, TError = Error>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTopazGetStatus<TData = Awaited<ReturnType<typeof topazGetStatus>>, TError = Error>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTopazGetStatusQueryOptions(processId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type topazVideoCreateResponse200 = {
  data: TopazVideoCreateResponse
  status: 200
}

export type topazVideoCreateResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type topazVideoCreateResponseSuccess = (topazVideoCreateResponse200) & {
  headers: Headers;
};
export type topazVideoCreateResponseError = (topazVideoCreateResponseDefault) & {
  headers: Headers;
};

export type topazVideoCreateResponse = (topazVideoCreateResponseSuccess | topazVideoCreateResponseError)

export const getTopazVideoCreateUrl = () => {


  

  return `/proxy/topaz/video/`
}

export const topazVideoCreate = async (topazVideoCreateRequest: TopazVideoCreateRequest, options?: RequestInit): Promise<topazVideoCreateResponse> => {
  
  return customInstance<topazVideoCreateResponse>(getTopazVideoCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      topazVideoCreateRequest,)
  }
);}




export const getTopazVideoCreateMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof topazVideoCreate>>, TError,{data: TopazVideoCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof topazVideoCreate>>, TError,{data: TopazVideoCreateRequest}, TContext> => {

const mutationKey = ['topazVideoCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof topazVideoCreate>>, {data: TopazVideoCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  topazVideoCreate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TopazVideoCreateMutationResult = NonNullable<Awaited<ReturnType<typeof topazVideoCreate>>>
    export type TopazVideoCreateMutationBody = TopazVideoCreateRequest
    export type TopazVideoCreateMutationError = Error

    export const useTopazVideoCreate = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof topazVideoCreate>>, TError,{data: TopazVideoCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof topazVideoCreate>>,
        TError,
        {data: TopazVideoCreateRequest},
        TContext
      > => {
      return useMutation(getTopazVideoCreateMutationOptions(options), queryClient);
    }
    
export type topazVideoAcceptResponse200 = {
  data: TopazVideoAcceptResponse
  status: 200
}

export type topazVideoAcceptResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type topazVideoAcceptResponseSuccess = (topazVideoAcceptResponse200) & {
  headers: Headers;
};
export type topazVideoAcceptResponseError = (topazVideoAcceptResponseDefault) & {
  headers: Headers;
};

export type topazVideoAcceptResponse = (topazVideoAcceptResponseSuccess | topazVideoAcceptResponseError)

export const getTopazVideoAcceptUrl = (requestId: string,) => {


  

  return `/proxy/topaz/video/${requestId}/accept`
}

export const topazVideoAccept = async (requestId: string, options?: RequestInit): Promise<topazVideoAcceptResponse> => {
  
  return customInstance<topazVideoAcceptResponse>(getTopazVideoAcceptUrl(requestId),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
);}




export const getTopazVideoAcceptMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof topazVideoAccept>>, TError,{requestId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof topazVideoAccept>>, TError,{requestId: string}, TContext> => {

const mutationKey = ['topazVideoAccept'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof topazVideoAccept>>, {requestId: string}> = (props) => {
          const {requestId} = props ?? {};

          return  topazVideoAccept(requestId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TopazVideoAcceptMutationResult = NonNullable<Awaited<ReturnType<typeof topazVideoAccept>>>
    
    export type TopazVideoAcceptMutationError = Error

    export const useTopazVideoAccept = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof topazVideoAccept>>, TError,{requestId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof topazVideoAccept>>,
        TError,
        {requestId: string},
        TContext
      > => {
      return useMutation(getTopazVideoAcceptMutationOptions(options), queryClient);
    }
    
/**
 * Send metadata of the multi-part uploads to complete the upload and begin processing the video.

Optionally include the MD5 hash of the source video file to validate successful upload before processing.

 * @summary Complete Video Upload
 */
export type topazVideoCompleteUploadResponse202 = {
  data: TopazVideoCompleteUploadResponse
  status: 202
}

export type topazVideoCompleteUploadResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 202>
}
    
export type topazVideoCompleteUploadResponseSuccess = (topazVideoCompleteUploadResponse202) & {
  headers: Headers;
};
export type topazVideoCompleteUploadResponseError = (topazVideoCompleteUploadResponseDefault) & {
  headers: Headers;
};

export type topazVideoCompleteUploadResponse = (topazVideoCompleteUploadResponseSuccess | topazVideoCompleteUploadResponseError)

export const getTopazVideoCompleteUploadUrl = (requestId: string,) => {


  

  return `/proxy/topaz/video/${requestId}/complete-upload`
}

export const topazVideoCompleteUpload = async (requestId: string,
    topazVideoCompleteUploadRequest: TopazVideoCompleteUploadRequest, options?: RequestInit): Promise<topazVideoCompleteUploadResponse> => {
  
  return customInstance<topazVideoCompleteUploadResponse>(getTopazVideoCompleteUploadUrl(requestId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      topazVideoCompleteUploadRequest,)
  }
);}




export const getTopazVideoCompleteUploadMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof topazVideoCompleteUpload>>, TError,{requestId: string;data: TopazVideoCompleteUploadRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof topazVideoCompleteUpload>>, TError,{requestId: string;data: TopazVideoCompleteUploadRequest}, TContext> => {

const mutationKey = ['topazVideoCompleteUpload'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof topazVideoCompleteUpload>>, {requestId: string;data: TopazVideoCompleteUploadRequest}> = (props) => {
          const {requestId,data} = props ?? {};

          return  topazVideoCompleteUpload(requestId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TopazVideoCompleteUploadMutationResult = NonNullable<Awaited<ReturnType<typeof topazVideoCompleteUpload>>>
    export type TopazVideoCompleteUploadMutationBody = TopazVideoCompleteUploadRequest
    export type TopazVideoCompleteUploadMutationError = Error

    /**
 * @summary Complete Video Upload
 */
export const useTopazVideoCompleteUpload = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof topazVideoCompleteUpload>>, TError,{requestId: string;data: TopazVideoCompleteUploadRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof topazVideoCompleteUpload>>,
        TError,
        {requestId: string;data: TopazVideoCompleteUploadRequest},
        TContext
      > => {
      return useMutation(getTopazVideoCompleteUploadMutationOptions(options), queryClient);
    }
    
export type topazVideoGetStatusResponse200 = {
  data: TopazVideoStatusResponse
  status: 200
}

export type topazVideoGetStatusResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type topazVideoGetStatusResponseSuccess = (topazVideoGetStatusResponse200) & {
  headers: Headers;
};
export type topazVideoGetStatusResponseError = (topazVideoGetStatusResponseDefault) & {
  headers: Headers;
};

export type topazVideoGetStatusResponse = (topazVideoGetStatusResponseSuccess | topazVideoGetStatusResponseError)

export const getTopazVideoGetStatusUrl = (requestId: string,) => {


  

  return `/proxy/topaz/video/${requestId}/status`
}

export const topazVideoGetStatus = async (requestId: string, options?: RequestInit): Promise<topazVideoGetStatusResponse> => {
  
  return customInstance<topazVideoGetStatusResponse>(getTopazVideoGetStatusUrl(requestId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getTopazVideoGetStatusQueryKey = (requestId: string,) => {
    return [
    `/proxy/topaz/video/${requestId}/status`
    ] as const;
    }

    
export const getTopazVideoGetStatusQueryOptions = <TData = Awaited<ReturnType<typeof topazVideoGetStatus>>, TError = Error>(requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazVideoGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTopazVideoGetStatusQueryKey(requestId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof topazVideoGetStatus>>> = ({ signal }) => topazVideoGetStatus(requestId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(requestId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof topazVideoGetStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TopazVideoGetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof topazVideoGetStatus>>>
export type TopazVideoGetStatusQueryError = Error


export function useTopazVideoGetStatus<TData = Awaited<ReturnType<typeof topazVideoGetStatus>>, TError = Error>(
 requestId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazVideoGetStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof topazVideoGetStatus>>,
          TError,
          Awaited<ReturnType<typeof topazVideoGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTopazVideoGetStatus<TData = Awaited<ReturnType<typeof topazVideoGetStatus>>, TError = Error>(
 requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazVideoGetStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof topazVideoGetStatus>>,
          TError,
          Awaited<ReturnType<typeof topazVideoGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTopazVideoGetStatus<TData = Awaited<ReturnType<typeof topazVideoGetStatus>>, TError = Error>(
 requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazVideoGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTopazVideoGetStatus<TData = Awaited<ReturnType<typeof topazVideoGetStatus>>, TError = Error>(
 requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof topazVideoGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTopazVideoGetStatusQueryOptions(requestId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create 3D Generation Task
 */
export type tripoCreateTaskResponse200 = {
  data: TripoSuccessTask
  status: 200
}

export type tripoCreateTaskResponse400 = {
  data: TripoErrorResponse
  status: 400
}

export type tripoCreateTaskResponse401 = {
  data: TripoErrorResponse
  status: 401
}

export type tripoCreateTaskResponse403 = {
  data: TripoErrorResponse
  status: 403
}

export type tripoCreateTaskResponse404 = {
  data: TripoErrorResponse
  status: 404
}

export type tripoCreateTaskResponse429 = {
  data: TripoErrorResponse
  status: 429
}

export type tripoCreateTaskResponse500 = {
  data: TripoErrorResponse
  status: 500
}

export type tripoCreateTaskResponse503 = {
  data: TripoErrorResponse
  status: 503
}

export type tripoCreateTaskResponse504 = {
  data: TripoErrorResponse
  status: 504
}
    
export type tripoCreateTaskResponseSuccess = (tripoCreateTaskResponse200) & {
  headers: Headers;
};
export type tripoCreateTaskResponseError = (tripoCreateTaskResponse400 | tripoCreateTaskResponse401 | tripoCreateTaskResponse403 | tripoCreateTaskResponse404 | tripoCreateTaskResponse429 | tripoCreateTaskResponse500 | tripoCreateTaskResponse503 | tripoCreateTaskResponse504) & {
  headers: Headers;
};

export type tripoCreateTaskResponse = (tripoCreateTaskResponseSuccess | tripoCreateTaskResponseError)

export const getTripoCreateTaskUrl = () => {


  

  return `/proxy/tripo/v2/openapi/task`
}

export const tripoCreateTask = async (tripoCreateTaskBody: TripoCreateTaskBody, options?: RequestInit): Promise<tripoCreateTaskResponse> => {
  
  return customInstance<tripoCreateTaskResponse>(getTripoCreateTaskUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tripoCreateTaskBody,)
  }
);}




export const getTripoCreateTaskMutationOptions = <TError = TripoErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tripoCreateTask>>, TError,{data: TripoCreateTaskBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tripoCreateTask>>, TError,{data: TripoCreateTaskBody}, TContext> => {

const mutationKey = ['tripoCreateTask'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tripoCreateTask>>, {data: TripoCreateTaskBody}> = (props) => {
          const {data} = props ?? {};

          return  tripoCreateTask(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TripoCreateTaskMutationResult = NonNullable<Awaited<ReturnType<typeof tripoCreateTask>>>
    export type TripoCreateTaskMutationBody = TripoCreateTaskBody
    export type TripoCreateTaskMutationError = TripoErrorResponse

    /**
 * @summary Create 3D Generation Task
 */
export const useTripoCreateTask = <TError = TripoErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tripoCreateTask>>, TError,{data: TripoCreateTaskBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tripoCreateTask>>,
        TError,
        {data: TripoCreateTaskBody},
        TContext
      > => {
      return useMutation(getTripoCreateTaskMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get Task Status
 */
export type tripoGetTaskResponse200 = {
  data: TripoGetTask200
  status: 200
}

export type tripoGetTaskResponse400 = {
  data: TripoErrorResponse
  status: 400
}

export type tripoGetTaskResponse401 = {
  data: TripoErrorResponse
  status: 401
}

export type tripoGetTaskResponse403 = {
  data: TripoErrorResponse
  status: 403
}

export type tripoGetTaskResponse404 = {
  data: TripoErrorResponse
  status: 404
}

export type tripoGetTaskResponse429 = {
  data: TripoErrorResponse
  status: 429
}

export type tripoGetTaskResponse500 = {
  data: TripoErrorResponse
  status: 500
}

export type tripoGetTaskResponse503 = {
  data: TripoErrorResponse
  status: 503
}

export type tripoGetTaskResponse504 = {
  data: TripoErrorResponse
  status: 504
}
    
export type tripoGetTaskResponseSuccess = (tripoGetTaskResponse200) & {
  headers: Headers;
};
export type tripoGetTaskResponseError = (tripoGetTaskResponse400 | tripoGetTaskResponse401 | tripoGetTaskResponse403 | tripoGetTaskResponse404 | tripoGetTaskResponse429 | tripoGetTaskResponse500 | tripoGetTaskResponse503 | tripoGetTaskResponse504) & {
  headers: Headers;
};

export type tripoGetTaskResponse = (tripoGetTaskResponseSuccess | tripoGetTaskResponseError)

export const getTripoGetTaskUrl = (taskId: string,) => {


  

  return `/proxy/tripo/v2/openapi/task/${taskId}`
}

export const tripoGetTask = async (taskId: string, options?: RequestInit): Promise<tripoGetTaskResponse> => {
  
  return customInstance<tripoGetTaskResponse>(getTripoGetTaskUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getTripoGetTaskQueryKey = (taskId: string,) => {
    return [
    `/proxy/tripo/v2/openapi/task/${taskId}`
    ] as const;
    }

    
export const getTripoGetTaskQueryOptions = <TData = Awaited<ReturnType<typeof tripoGetTask>>, TError = TripoErrorResponse>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tripoGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTripoGetTaskQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tripoGetTask>>> = ({ signal }) => tripoGetTask(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tripoGetTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TripoGetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof tripoGetTask>>>
export type TripoGetTaskQueryError = TripoErrorResponse


export function useTripoGetTask<TData = Awaited<ReturnType<typeof tripoGetTask>>, TError = TripoErrorResponse>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tripoGetTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tripoGetTask>>,
          TError,
          Awaited<ReturnType<typeof tripoGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTripoGetTask<TData = Awaited<ReturnType<typeof tripoGetTask>>, TError = TripoErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tripoGetTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tripoGetTask>>,
          TError,
          Awaited<ReturnType<typeof tripoGetTask>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTripoGetTask<TData = Awaited<ReturnType<typeof tripoGetTask>>, TError = TripoErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tripoGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Task Status
 */

export function useTripoGetTask<TData = Awaited<ReturnType<typeof tripoGetTask>>, TError = TripoErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tripoGetTask>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTripoGetTaskQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Upload File for 3D Generation
 */
export type tripoUploadFileResponse200 = {
  data: TripoUploadFile200
  status: 200
}

export type tripoUploadFileResponse400 = {
  data: TripoErrorResponse
  status: 400
}

export type tripoUploadFileResponse401 = {
  data: TripoErrorResponse
  status: 401
}

export type tripoUploadFileResponse403 = {
  data: TripoErrorResponse
  status: 403
}

export type tripoUploadFileResponse404 = {
  data: TripoErrorResponse
  status: 404
}

export type tripoUploadFileResponse429 = {
  data: TripoErrorResponse
  status: 429
}

export type tripoUploadFileResponse500 = {
  data: TripoErrorResponse
  status: 500
}

export type tripoUploadFileResponse503 = {
  data: TripoErrorResponse
  status: 503
}

export type tripoUploadFileResponse504 = {
  data: TripoErrorResponse
  status: 504
}
    
export type tripoUploadFileResponseSuccess = (tripoUploadFileResponse200) & {
  headers: Headers;
};
export type tripoUploadFileResponseError = (tripoUploadFileResponse400 | tripoUploadFileResponse401 | tripoUploadFileResponse403 | tripoUploadFileResponse404 | tripoUploadFileResponse429 | tripoUploadFileResponse500 | tripoUploadFileResponse503 | tripoUploadFileResponse504) & {
  headers: Headers;
};

export type tripoUploadFileResponse = (tripoUploadFileResponseSuccess | tripoUploadFileResponseError)

export const getTripoUploadFileUrl = () => {


  

  return `/proxy/tripo/v2/openapi/upload`
}

export const tripoUploadFile = async (tripoUploadFileBody: TripoUploadFileBody, options?: RequestInit): Promise<tripoUploadFileResponse> => {
    const formData = new FormData();
formData.append(`file`, tripoUploadFileBody.file);

  return customInstance<tripoUploadFileResponse>(getTripoUploadFileUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getTripoUploadFileMutationOptions = <TError = TripoErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tripoUploadFile>>, TError,{data: TripoUploadFileBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tripoUploadFile>>, TError,{data: TripoUploadFileBody}, TContext> => {

const mutationKey = ['tripoUploadFile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tripoUploadFile>>, {data: TripoUploadFileBody}> = (props) => {
          const {data} = props ?? {};

          return  tripoUploadFile(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type TripoUploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof tripoUploadFile>>>
    export type TripoUploadFileMutationBody = TripoUploadFileBody
    export type TripoUploadFileMutationError = TripoErrorResponse

    /**
 * @summary Upload File for 3D Generation
 */
export const useTripoUploadFile = <TError = TripoErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tripoUploadFile>>, TError,{data: TripoUploadFileBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tripoUploadFile>>,
        TError,
        {data: TripoUploadFileBody},
        TContext
      > => {
      return useMutation(getTripoUploadFileMutationOptions(options), queryClient);
    }
    
/**
 * @summary Query Account Balance
 */
export type tripoGetBalanceResponse200 = {
  data: TripoGetBalance200
  status: 200
}

export type tripoGetBalanceResponse400 = {
  data: TripoErrorResponse
  status: 400
}

export type tripoGetBalanceResponse401 = {
  data: TripoErrorResponse
  status: 401
}

export type tripoGetBalanceResponse403 = {
  data: TripoErrorResponse
  status: 403
}

export type tripoGetBalanceResponse404 = {
  data: TripoErrorResponse
  status: 404
}

export type tripoGetBalanceResponse429 = {
  data: TripoErrorResponse
  status: 429
}

export type tripoGetBalanceResponse500 = {
  data: TripoErrorResponse
  status: 500
}

export type tripoGetBalanceResponse503 = {
  data: TripoErrorResponse
  status: 503
}

export type tripoGetBalanceResponse504 = {
  data: TripoErrorResponse
  status: 504
}
    
export type tripoGetBalanceResponseSuccess = (tripoGetBalanceResponse200) & {
  headers: Headers;
};
export type tripoGetBalanceResponseError = (tripoGetBalanceResponse400 | tripoGetBalanceResponse401 | tripoGetBalanceResponse403 | tripoGetBalanceResponse404 | tripoGetBalanceResponse429 | tripoGetBalanceResponse500 | tripoGetBalanceResponse503 | tripoGetBalanceResponse504) & {
  headers: Headers;
};

export type tripoGetBalanceResponse = (tripoGetBalanceResponseSuccess | tripoGetBalanceResponseError)

export const getTripoGetBalanceUrl = () => {


  

  return `/proxy/tripo/v2/openapi/user/balance`
}

export const tripoGetBalance = async ( options?: RequestInit): Promise<tripoGetBalanceResponse> => {
  
  return customInstance<tripoGetBalanceResponse>(getTripoGetBalanceUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getTripoGetBalanceQueryKey = () => {
    return [
    `/proxy/tripo/v2/openapi/user/balance`
    ] as const;
    }

    
export const getTripoGetBalanceQueryOptions = <TData = Awaited<ReturnType<typeof tripoGetBalance>>, TError = TripoErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tripoGetBalance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTripoGetBalanceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tripoGetBalance>>> = ({ signal }) => tripoGetBalance({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tripoGetBalance>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TripoGetBalanceQueryResult = NonNullable<Awaited<ReturnType<typeof tripoGetBalance>>>
export type TripoGetBalanceQueryError = TripoErrorResponse


export function useTripoGetBalance<TData = Awaited<ReturnType<typeof tripoGetBalance>>, TError = TripoErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tripoGetBalance>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tripoGetBalance>>,
          TError,
          Awaited<ReturnType<typeof tripoGetBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTripoGetBalance<TData = Awaited<ReturnType<typeof tripoGetBalance>>, TError = TripoErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tripoGetBalance>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tripoGetBalance>>,
          TError,
          Awaited<ReturnType<typeof tripoGetBalance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTripoGetBalance<TData = Awaited<ReturnType<typeof tripoGetBalance>>, TError = TripoErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tripoGetBalance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Query Account Balance
 */

export function useTripoGetBalance<TData = Awaited<ReturnType<typeof tripoGetBalance>>, TError = TripoErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tripoGetBalance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTripoGetBalanceQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Generate a video from a text prompt and optional image. Deprecated. Use /proxy/veo/{modelId}/generate instead.
 */
export type veoGenerateResponse200 = {
  data: Veo2GenVidResponse
  status: 200
}

export type veoGenerateResponse400 = {
  data: void
  status: 400
}

export type veoGenerateResponse401 = {
  data: void
  status: 401
}

export type veoGenerateResponse403 = {
  data: void
  status: 403
}

export type veoGenerateResponse500 = {
  data: void
  status: 500
}
    
export type veoGenerateResponseSuccess = (veoGenerateResponse200) & {
  headers: Headers;
};
export type veoGenerateResponseError = (veoGenerateResponse400 | veoGenerateResponse401 | veoGenerateResponse403 | veoGenerateResponse500) & {
  headers: Headers;
};

export type veoGenerateResponse = (veoGenerateResponseSuccess | veoGenerateResponseError)

export const getVeoGenerateUrl = () => {


  

  return `/proxy/veo/generate`
}

export const veoGenerate = async (veo2GenVidRequest: Veo2GenVidRequest, options?: RequestInit): Promise<veoGenerateResponse> => {
  
  return customInstance<veoGenerateResponse>(getVeoGenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      veo2GenVidRequest,)
  }
);}




export const getVeoGenerateMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof veoGenerate>>, TError,{data: Veo2GenVidRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof veoGenerate>>, TError,{data: Veo2GenVidRequest}, TContext> => {

const mutationKey = ['veoGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof veoGenerate>>, {data: Veo2GenVidRequest}> = (props) => {
          const {data} = props ?? {};

          return  veoGenerate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VeoGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof veoGenerate>>>
    export type VeoGenerateMutationBody = Veo2GenVidRequest
    export type VeoGenerateMutationError = void

    /**
 * @summary Generate a video from a text prompt and optional image. Deprecated. Use /proxy/veo/{modelId}/generate instead.
 */
export const useVeoGenerate = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof veoGenerate>>, TError,{data: Veo2GenVidRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof veoGenerate>>,
        TError,
        {data: Veo2GenVidRequest},
        TContext
      > => {
      return useMutation(getVeoGenerateMutationOptions(options), queryClient);
    }
    
/**
 * @summary Poll the status of a Veo prediction operation. Deprecated. Use /proxy/veo/{modelId}/generate instead.
 */
export type veoPollResponse200 = {
  data: Veo2GenVidPollResponse
  status: 200
}

export type veoPollResponse400 = {
  data: void
  status: 400
}

export type veoPollResponse401 = {
  data: void
  status: 401
}

export type veoPollResponse404 = {
  data: void
  status: 404
}

export type veoPollResponse500 = {
  data: void
  status: 500
}
    
export type veoPollResponseSuccess = (veoPollResponse200) & {
  headers: Headers;
};
export type veoPollResponseError = (veoPollResponse400 | veoPollResponse401 | veoPollResponse404 | veoPollResponse500) & {
  headers: Headers;
};

export type veoPollResponse = (veoPollResponseSuccess | veoPollResponseError)

export const getVeoPollUrl = () => {


  

  return `/proxy/veo/poll`
}

export const veoPoll = async (veo2GenVidPollRequest: Veo2GenVidPollRequest, options?: RequestInit): Promise<veoPollResponse> => {
  
  return customInstance<veoPollResponse>(getVeoPollUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      veo2GenVidPollRequest,)
  }
);}




export const getVeoPollMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof veoPoll>>, TError,{data: Veo2GenVidPollRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof veoPoll>>, TError,{data: Veo2GenVidPollRequest}, TContext> => {

const mutationKey = ['veoPoll'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof veoPoll>>, {data: Veo2GenVidPollRequest}> = (props) => {
          const {data} = props ?? {};

          return  veoPoll(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VeoPollMutationResult = NonNullable<Awaited<ReturnType<typeof veoPoll>>>
    export type VeoPollMutationBody = Veo2GenVidPollRequest
    export type VeoPollMutationError = void

    /**
 * @summary Poll the status of a Veo prediction operation. Deprecated. Use /proxy/veo/{modelId}/generate instead.
 */
export const useVeoPoll = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof veoPoll>>, TError,{data: Veo2GenVidPollRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof veoPoll>>,
        TError,
        {data: Veo2GenVidPollRequest},
        TContext
      > => {
      return useMutation(getVeoPollMutationOptions(options), queryClient);
    }
    
/**
 * @summary Generate a video from a text prompt and optional image
 */
export type veoGenerateNewResponse200 = {
  data: VeoGenVidResponse
  status: 200
}

export type veoGenerateNewResponse400 = {
  data: void
  status: 400
}

export type veoGenerateNewResponse401 = {
  data: void
  status: 401
}

export type veoGenerateNewResponse403 = {
  data: void
  status: 403
}

export type veoGenerateNewResponse500 = {
  data: void
  status: 500
}
    
export type veoGenerateNewResponseSuccess = (veoGenerateNewResponse200) & {
  headers: Headers;
};
export type veoGenerateNewResponseError = (veoGenerateNewResponse400 | veoGenerateNewResponse401 | veoGenerateNewResponse403 | veoGenerateNewResponse500) & {
  headers: Headers;
};

export type veoGenerateNewResponse = (veoGenerateNewResponseSuccess | veoGenerateNewResponseError)

export const getVeoGenerateNewUrl = (modelId: string,) => {


  

  return `/proxy/veo/${modelId}/generate`
}

export const veoGenerateNew = async (modelId: string,
    veoGenVidRequest: VeoGenVidRequest, options?: RequestInit): Promise<veoGenerateNewResponse> => {
  
  return customInstance<veoGenerateNewResponse>(getVeoGenerateNewUrl(modelId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      veoGenVidRequest,)
  }
);}




export const getVeoGenerateNewMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof veoGenerateNew>>, TError,{modelId: string;data: VeoGenVidRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof veoGenerateNew>>, TError,{modelId: string;data: VeoGenVidRequest}, TContext> => {

const mutationKey = ['veoGenerateNew'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof veoGenerateNew>>, {modelId: string;data: VeoGenVidRequest}> = (props) => {
          const {modelId,data} = props ?? {};

          return  veoGenerateNew(modelId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VeoGenerateNewMutationResult = NonNullable<Awaited<ReturnType<typeof veoGenerateNew>>>
    export type VeoGenerateNewMutationBody = VeoGenVidRequest
    export type VeoGenerateNewMutationError = void

    /**
 * @summary Generate a video from a text prompt and optional image
 */
export const useVeoGenerateNew = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof veoGenerateNew>>, TError,{modelId: string;data: VeoGenVidRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof veoGenerateNew>>,
        TError,
        {modelId: string;data: VeoGenVidRequest},
        TContext
      > => {
      return useMutation(getVeoGenerateNewMutationOptions(options), queryClient);
    }
    
/**
 * @summary Poll the status of a Veo prediction operation
 */
export type veoPollNewResponse200 = {
  data: VeoGenVidPollResponse
  status: 200
}

export type veoPollNewResponse400 = {
  data: void
  status: 400
}

export type veoPollNewResponse401 = {
  data: void
  status: 401
}

export type veoPollNewResponse404 = {
  data: void
  status: 404
}

export type veoPollNewResponse500 = {
  data: void
  status: 500
}
    
export type veoPollNewResponseSuccess = (veoPollNewResponse200) & {
  headers: Headers;
};
export type veoPollNewResponseError = (veoPollNewResponse400 | veoPollNewResponse401 | veoPollNewResponse404 | veoPollNewResponse500) & {
  headers: Headers;
};

export type veoPollNewResponse = (veoPollNewResponseSuccess | veoPollNewResponseError)

export const getVeoPollNewUrl = (modelId: string,) => {


  

  return `/proxy/veo/${modelId}/poll`
}

export const veoPollNew = async (modelId: string,
    veoGenVidPollRequest: VeoGenVidPollRequest, options?: RequestInit): Promise<veoPollNewResponse> => {
  
  return customInstance<veoPollNewResponse>(getVeoPollNewUrl(modelId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      veoGenVidPollRequest,)
  }
);}




export const getVeoPollNewMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof veoPollNew>>, TError,{modelId: string;data: VeoGenVidPollRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof veoPollNew>>, TError,{modelId: string;data: VeoGenVidPollRequest}, TContext> => {

const mutationKey = ['veoPollNew'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof veoPollNew>>, {modelId: string;data: VeoGenVidPollRequest}> = (props) => {
          const {modelId,data} = props ?? {};

          return  veoPollNew(modelId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VeoPollNewMutationResult = NonNullable<Awaited<ReturnType<typeof veoPollNew>>>
    export type VeoPollNewMutationBody = VeoGenVidPollRequest
    export type VeoPollNewMutationError = void

    /**
 * @summary Poll the status of a Veo prediction operation
 */
export const useVeoPollNew = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof veoPollNew>>, TError,{modelId: string;data: VeoGenVidPollRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof veoPollNew>>,
        TError,
        {modelId: string;data: VeoGenVidPollRequest},
        TContext
      > => {
      return useMutation(getVeoPollNewMutationOptions(options), queryClient);
    }
    
/**
 * @summary Generate content using a specified model.
 */
export type geminiGenerateContentResponse200 = {
  data: GeminiGenerateContentResponse
  status: 200
}

export type geminiGenerateContentResponse400 = {
  data: void
  status: 400
}

export type geminiGenerateContentResponse401 = {
  data: void
  status: 401
}

export type geminiGenerateContentResponse403 = {
  data: void
  status: 403
}

export type geminiGenerateContentResponse404 = {
  data: void
  status: 404
}

export type geminiGenerateContentResponse500 = {
  data: void
  status: 500
}
    
export type geminiGenerateContentResponseSuccess = (geminiGenerateContentResponse200) & {
  headers: Headers;
};
export type geminiGenerateContentResponseError = (geminiGenerateContentResponse400 | geminiGenerateContentResponse401 | geminiGenerateContentResponse403 | geminiGenerateContentResponse404 | geminiGenerateContentResponse500) & {
  headers: Headers;
};

export type geminiGenerateContentResponse = (geminiGenerateContentResponseSuccess | geminiGenerateContentResponseError)

export const getGeminiGenerateContentUrl = (model: string,) => {


  

  return `/proxy/vertexai/gemini/${model}`
}

export const geminiGenerateContent = async (model: string,
    geminiGenerateContentRequest: GeminiGenerateContentRequest, options?: RequestInit): Promise<geminiGenerateContentResponse> => {
  
  return customInstance<geminiGenerateContentResponse>(getGeminiGenerateContentUrl(model),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      geminiGenerateContentRequest,)
  }
);}




export const getGeminiGenerateContentMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof geminiGenerateContent>>, TError,{model: string;data: GeminiGenerateContentRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof geminiGenerateContent>>, TError,{model: string;data: GeminiGenerateContentRequest}, TContext> => {

const mutationKey = ['geminiGenerateContent'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof geminiGenerateContent>>, {model: string;data: GeminiGenerateContentRequest}> = (props) => {
          const {model,data} = props ?? {};

          return  geminiGenerateContent(model,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type GeminiGenerateContentMutationResult = NonNullable<Awaited<ReturnType<typeof geminiGenerateContent>>>
    export type GeminiGenerateContentMutationBody = GeminiGenerateContentRequest
    export type GeminiGenerateContentMutationError = void

    /**
 * @summary Generate content using a specified model.
 */
export const useGeminiGenerateContent = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof geminiGenerateContent>>, TError,{model: string;data: GeminiGenerateContentRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof geminiGenerateContent>>,
        TError,
        {model: string;data: GeminiGenerateContentRequest},
        TContext
      > => {
      return useMutation(getGeminiGenerateContentMutationOptions(options), queryClient);
    }
    
/**
 * @summary Generate images from a text prompt
 */
export type imagenGenerateImagesResponse200 = {
  data: ImagenGenerateImageResponse
  status: 200
}

export type imagenGenerateImagesResponse4xx = {
  data: void
  status: HTTPStatusCode4xx
}

export type imagenGenerateImagesResponse5xx = {
  data: void
  status: HTTPStatusCode5xx
}
    
export type imagenGenerateImagesResponseSuccess = (imagenGenerateImagesResponse200) & {
  headers: Headers;
};
export type imagenGenerateImagesResponseError = (imagenGenerateImagesResponse4xx | imagenGenerateImagesResponse5xx) & {
  headers: Headers;
};

export type imagenGenerateImagesResponse = (imagenGenerateImagesResponseSuccess | imagenGenerateImagesResponseError)

export const getImagenGenerateImagesUrl = (model: 'imagen-3.0-generate-002' | 'imagen-3.0-generate-001' | 'imagen-3.0-fast-generate-001' | 'imagegeneration@006' | 'imagegeneration@005' | 'imagegeneration@002',) => {


  

  return `/proxy/vertexai/imagen/${model}`
}

export const imagenGenerateImages = async (model: 'imagen-3.0-generate-002' | 'imagen-3.0-generate-001' | 'imagen-3.0-fast-generate-001' | 'imagegeneration@006' | 'imagegeneration@005' | 'imagegeneration@002',
    imagenGenerateImageRequest: ImagenGenerateImageRequest, options?: RequestInit): Promise<imagenGenerateImagesResponse> => {
  
  return customInstance<imagenGenerateImagesResponse>(getImagenGenerateImagesUrl(model),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      imagenGenerateImageRequest,)
  }
);}




export const getImagenGenerateImagesMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagenGenerateImages>>, TError,{model: 'imagen-3.0-generate-002' | 'imagen-3.0-generate-001' | 'imagen-3.0-fast-generate-001' | 'imagegeneration@006' | 'imagegeneration@005' | 'imagegeneration@002';data: ImagenGenerateImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagenGenerateImages>>, TError,{model: 'imagen-3.0-generate-002' | 'imagen-3.0-generate-001' | 'imagen-3.0-fast-generate-001' | 'imagegeneration@006' | 'imagegeneration@005' | 'imagegeneration@002';data: ImagenGenerateImageRequest}, TContext> => {

const mutationKey = ['imagenGenerateImages'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagenGenerateImages>>, {model: 'imagen-3.0-generate-002' | 'imagen-3.0-generate-001' | 'imagen-3.0-fast-generate-001' | 'imagegeneration@006' | 'imagegeneration@005' | 'imagegeneration@002';data: ImagenGenerateImageRequest}> = (props) => {
          const {model,data} = props ?? {};

          return  imagenGenerateImages(model,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ImagenGenerateImagesMutationResult = NonNullable<Awaited<ReturnType<typeof imagenGenerateImages>>>
    export type ImagenGenerateImagesMutationBody = ImagenGenerateImageRequest
    export type ImagenGenerateImagesMutationError = void

    /**
 * @summary Generate images from a text prompt
 */
export const useImagenGenerateImages = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagenGenerateImages>>, TError,{model: 'imagen-3.0-generate-002' | 'imagen-3.0-generate-001' | 'imagen-3.0-fast-generate-001' | 'imagegeneration@006' | 'imagegeneration@005' | 'imagegeneration@002';data: ImagenGenerateImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagenGenerateImages>>,
        TError,
        {model: 'imagen-3.0-generate-002' | 'imagen-3.0-generate-001' | 'imagen-3.0-fast-generate-001' | 'imagegeneration@006' | 'imagegeneration@005' | 'imagegeneration@002';data: ImagenGenerateImageRequest},
        TContext
      > => {
      return useMutation(getImagenGenerateImagesMutationOptions(options), queryClient);
    }
    
export type viduExtendResponse200 = {
  data: ViduExtendReply
  status: 200
}

export type viduExtendResponse400 = {
  data: Error
  status: 400
}

export type viduExtendResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400>
}
    
export type viduExtendResponseSuccess = (viduExtendResponse200) & {
  headers: Headers;
};
export type viduExtendResponseError = (viduExtendResponse400 | viduExtendResponseDefault) & {
  headers: Headers;
};

export type viduExtendResponse = (viduExtendResponseSuccess | viduExtendResponseError)

export const getViduExtendUrl = () => {


  

  return `/proxy/vidu/extend`
}

export const viduExtend = async (viduExtendRequest: ViduExtendRequest, options?: RequestInit): Promise<viduExtendResponse> => {
  
  return customInstance<viduExtendResponse>(getViduExtendUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      viduExtendRequest,)
  }
);}




export const getViduExtendMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduExtend>>, TError,{data: ViduExtendRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof viduExtend>>, TError,{data: ViduExtendRequest}, TContext> => {

const mutationKey = ['viduExtend'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof viduExtend>>, {data: ViduExtendRequest}> = (props) => {
          const {data} = props ?? {};

          return  viduExtend(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ViduExtendMutationResult = NonNullable<Awaited<ReturnType<typeof viduExtend>>>
    export type ViduExtendMutationBody = ViduExtendRequest
    export type ViduExtendMutationError = Error

    export const useViduExtend = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduExtend>>, TError,{data: ViduExtendRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof viduExtend>>,
        TError,
        {data: ViduExtendRequest},
        TContext
      > => {
      return useMutation(getViduExtendMutationOptions(options), queryClient);
    }
    
export type viduImg2VideoResponse200 = {
  data: ViduTaskReply
  status: 200
}

export type viduImg2VideoResponse400 = {
  data: Error
  status: 400
}

export type viduImg2VideoResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400>
}
    
export type viduImg2VideoResponseSuccess = (viduImg2VideoResponse200) & {
  headers: Headers;
};
export type viduImg2VideoResponseError = (viduImg2VideoResponse400 | viduImg2VideoResponseDefault) & {
  headers: Headers;
};

export type viduImg2VideoResponse = (viduImg2VideoResponseSuccess | viduImg2VideoResponseError)

export const getViduImg2VideoUrl = () => {


  

  return `/proxy/vidu/img2video`
}

export const viduImg2Video = async (viduTaskRequest: ViduTaskRequest, options?: RequestInit): Promise<viduImg2VideoResponse> => {
  
  return customInstance<viduImg2VideoResponse>(getViduImg2VideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      viduTaskRequest,)
  }
);}




export const getViduImg2VideoMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduImg2Video>>, TError,{data: ViduTaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof viduImg2Video>>, TError,{data: ViduTaskRequest}, TContext> => {

const mutationKey = ['viduImg2Video'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof viduImg2Video>>, {data: ViduTaskRequest}> = (props) => {
          const {data} = props ?? {};

          return  viduImg2Video(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ViduImg2VideoMutationResult = NonNullable<Awaited<ReturnType<typeof viduImg2Video>>>
    export type ViduImg2VideoMutationBody = ViduTaskRequest
    export type ViduImg2VideoMutationError = Error

    export const useViduImg2Video = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduImg2Video>>, TError,{data: ViduTaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof viduImg2Video>>,
        TError,
        {data: ViduTaskRequest},
        TContext
      > => {
      return useMutation(getViduImg2VideoMutationOptions(options), queryClient);
    }
    
export type viduMultiframeResponse200 = {
  data: ViduMultiframeReply
  status: 200
}

export type viduMultiframeResponse400 = {
  data: Error
  status: 400
}

export type viduMultiframeResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400>
}
    
export type viduMultiframeResponseSuccess = (viduMultiframeResponse200) & {
  headers: Headers;
};
export type viduMultiframeResponseError = (viduMultiframeResponse400 | viduMultiframeResponseDefault) & {
  headers: Headers;
};

export type viduMultiframeResponse = (viduMultiframeResponseSuccess | viduMultiframeResponseError)

export const getViduMultiframeUrl = () => {


  

  return `/proxy/vidu/multiframe`
}

export const viduMultiframe = async (viduMultiframeRequest: ViduMultiframeRequest, options?: RequestInit): Promise<viduMultiframeResponse> => {
  
  return customInstance<viduMultiframeResponse>(getViduMultiframeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      viduMultiframeRequest,)
  }
);}




export const getViduMultiframeMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduMultiframe>>, TError,{data: ViduMultiframeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof viduMultiframe>>, TError,{data: ViduMultiframeRequest}, TContext> => {

const mutationKey = ['viduMultiframe'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof viduMultiframe>>, {data: ViduMultiframeRequest}> = (props) => {
          const {data} = props ?? {};

          return  viduMultiframe(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ViduMultiframeMutationResult = NonNullable<Awaited<ReturnType<typeof viduMultiframe>>>
    export type ViduMultiframeMutationBody = ViduMultiframeRequest
    export type ViduMultiframeMutationError = Error

    export const useViduMultiframe = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduMultiframe>>, TError,{data: ViduMultiframeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof viduMultiframe>>,
        TError,
        {data: ViduMultiframeRequest},
        TContext
      > => {
      return useMutation(getViduMultiframeMutationOptions(options), queryClient);
    }
    
export type viduReference2VideoResponse200 = {
  data: ViduTaskReply
  status: 200
}

export type viduReference2VideoResponse400 = {
  data: Error
  status: 400
}

export type viduReference2VideoResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400>
}
    
export type viduReference2VideoResponseSuccess = (viduReference2VideoResponse200) & {
  headers: Headers;
};
export type viduReference2VideoResponseError = (viduReference2VideoResponse400 | viduReference2VideoResponseDefault) & {
  headers: Headers;
};

export type viduReference2VideoResponse = (viduReference2VideoResponseSuccess | viduReference2VideoResponseError)

export const getViduReference2VideoUrl = () => {


  

  return `/proxy/vidu/reference2video`
}

export const viduReference2Video = async (viduTaskRequest: ViduTaskRequest, options?: RequestInit): Promise<viduReference2VideoResponse> => {
  
  return customInstance<viduReference2VideoResponse>(getViduReference2VideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      viduTaskRequest,)
  }
);}




export const getViduReference2VideoMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduReference2Video>>, TError,{data: ViduTaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof viduReference2Video>>, TError,{data: ViduTaskRequest}, TContext> => {

const mutationKey = ['viduReference2Video'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof viduReference2Video>>, {data: ViduTaskRequest}> = (props) => {
          const {data} = props ?? {};

          return  viduReference2Video(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ViduReference2VideoMutationResult = NonNullable<Awaited<ReturnType<typeof viduReference2Video>>>
    export type ViduReference2VideoMutationBody = ViduTaskRequest
    export type ViduReference2VideoMutationError = Error

    export const useViduReference2Video = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduReference2Video>>, TError,{data: ViduTaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof viduReference2Video>>,
        TError,
        {data: ViduTaskRequest},
        TContext
      > => {
      return useMutation(getViduReference2VideoMutationOptions(options), queryClient);
    }
    
export type viduStartEnd2VideoResponse200 = {
  data: ViduTaskReply
  status: 200
}

export type viduStartEnd2VideoResponse400 = {
  data: Error
  status: 400
}

export type viduStartEnd2VideoResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400>
}
    
export type viduStartEnd2VideoResponseSuccess = (viduStartEnd2VideoResponse200) & {
  headers: Headers;
};
export type viduStartEnd2VideoResponseError = (viduStartEnd2VideoResponse400 | viduStartEnd2VideoResponseDefault) & {
  headers: Headers;
};

export type viduStartEnd2VideoResponse = (viduStartEnd2VideoResponseSuccess | viduStartEnd2VideoResponseError)

export const getViduStartEnd2VideoUrl = () => {


  

  return `/proxy/vidu/start-end2video`
}

export const viduStartEnd2Video = async (viduTaskRequest: ViduTaskRequest, options?: RequestInit): Promise<viduStartEnd2VideoResponse> => {
  
  return customInstance<viduStartEnd2VideoResponse>(getViduStartEnd2VideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      viduTaskRequest,)
  }
);}




export const getViduStartEnd2VideoMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduStartEnd2Video>>, TError,{data: ViduTaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof viduStartEnd2Video>>, TError,{data: ViduTaskRequest}, TContext> => {

const mutationKey = ['viduStartEnd2Video'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof viduStartEnd2Video>>, {data: ViduTaskRequest}> = (props) => {
          const {data} = props ?? {};

          return  viduStartEnd2Video(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ViduStartEnd2VideoMutationResult = NonNullable<Awaited<ReturnType<typeof viduStartEnd2Video>>>
    export type ViduStartEnd2VideoMutationBody = ViduTaskRequest
    export type ViduStartEnd2VideoMutationError = Error

    export const useViduStartEnd2Video = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduStartEnd2Video>>, TError,{data: ViduTaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof viduStartEnd2Video>>,
        TError,
        {data: ViduTaskRequest},
        TContext
      > => {
      return useMutation(getViduStartEnd2VideoMutationOptions(options), queryClient);
    }
    
export type viduGetCreationsResponse200 = {
  data: ViduGetCreationsReply
  status: 200
}

export type viduGetCreationsResponse400 = {
  data: Error
  status: 400
}

export type viduGetCreationsResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400>
}
    
export type viduGetCreationsResponseSuccess = (viduGetCreationsResponse200) & {
  headers: Headers;
};
export type viduGetCreationsResponseError = (viduGetCreationsResponse400 | viduGetCreationsResponseDefault) & {
  headers: Headers;
};

export type viduGetCreationsResponse = (viduGetCreationsResponseSuccess | viduGetCreationsResponseError)

export const getViduGetCreationsUrl = (id: string,) => {


  

  return `/proxy/vidu/tasks/${id}/creations`
}

export const viduGetCreations = async (id: string, options?: RequestInit): Promise<viduGetCreationsResponse> => {
  
  return customInstance<viduGetCreationsResponse>(getViduGetCreationsUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getViduGetCreationsQueryKey = (id: string,) => {
    return [
    `/proxy/vidu/tasks/${id}/creations`
    ] as const;
    }

    
export const getViduGetCreationsQueryOptions = <TData = Awaited<ReturnType<typeof viduGetCreations>>, TError = Error>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof viduGetCreations>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getViduGetCreationsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof viduGetCreations>>> = ({ signal }) => viduGetCreations(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof viduGetCreations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ViduGetCreationsQueryResult = NonNullable<Awaited<ReturnType<typeof viduGetCreations>>>
export type ViduGetCreationsQueryError = Error


export function useViduGetCreations<TData = Awaited<ReturnType<typeof viduGetCreations>>, TError = Error>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof viduGetCreations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof viduGetCreations>>,
          TError,
          Awaited<ReturnType<typeof viduGetCreations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useViduGetCreations<TData = Awaited<ReturnType<typeof viduGetCreations>>, TError = Error>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof viduGetCreations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof viduGetCreations>>,
          TError,
          Awaited<ReturnType<typeof viduGetCreations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useViduGetCreations<TData = Awaited<ReturnType<typeof viduGetCreations>>, TError = Error>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof viduGetCreations>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useViduGetCreations<TData = Awaited<ReturnType<typeof viduGetCreations>>, TError = Error>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof viduGetCreations>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getViduGetCreationsQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





export type viduText2VideoResponse200 = {
  data: ViduTaskReply
  status: 200
}

export type viduText2VideoResponse400 = {
  data: Error
  status: 400
}

export type viduText2VideoResponseDefault = {
  data: Error
  status: Exclude<HTTPStatusCodes, 200 | 400>
}
    
export type viduText2VideoResponseSuccess = (viduText2VideoResponse200) & {
  headers: Headers;
};
export type viduText2VideoResponseError = (viduText2VideoResponse400 | viduText2VideoResponseDefault) & {
  headers: Headers;
};

export type viduText2VideoResponse = (viduText2VideoResponseSuccess | viduText2VideoResponseError)

export const getViduText2VideoUrl = () => {


  

  return `/proxy/vidu/text2video`
}

export const viduText2Video = async (viduTaskRequest: ViduTaskRequest, options?: RequestInit): Promise<viduText2VideoResponse> => {
  
  return customInstance<viduText2VideoResponse>(getViduText2VideoUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      viduTaskRequest,)
  }
);}




export const getViduText2VideoMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduText2Video>>, TError,{data: ViduTaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof viduText2Video>>, TError,{data: ViduTaskRequest}, TContext> => {

const mutationKey = ['viduText2Video'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof viduText2Video>>, {data: ViduTaskRequest}> = (props) => {
          const {data} = props ?? {};

          return  viduText2Video(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ViduText2VideoMutationResult = NonNullable<Awaited<ReturnType<typeof viduText2Video>>>
    export type ViduText2VideoMutationBody = ViduTaskRequest
    export type ViduText2VideoMutationError = Error

    export const useViduText2Video = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof viduText2Video>>, TError,{data: ViduTaskRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof viduText2Video>>,
        TError,
        {data: ViduTaskRequest},
        TContext
      > => {
      return useMutation(getViduText2VideoMutationOptions(options), queryClient);
    }
    
export type wanImage2ImageGenerationResponse200 = {
  data: WanImage2ImageGenerationResponse
  status: 200
}

export type wanImage2ImageGenerationResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type wanImage2ImageGenerationResponseSuccess = (wanImage2ImageGenerationResponse200) & {
  headers: Headers;
};
export type wanImage2ImageGenerationResponseError = (wanImage2ImageGenerationResponseDefault) & {
  headers: Headers;
};

export type wanImage2ImageGenerationResponse = (wanImage2ImageGenerationResponseSuccess | wanImage2ImageGenerationResponseError)

export const getWanImage2ImageGenerationUrl = () => {


  

  return `/proxy/wan/api/v1/services/aigc/image2image/image-synthesis`
}

export const wanImage2ImageGeneration = async (wanImage2ImageGenerationRequest: WanImage2ImageGenerationRequest, options?: RequestInit): Promise<wanImage2ImageGenerationResponse> => {
  
  return customInstance<wanImage2ImageGenerationResponse>(getWanImage2ImageGenerationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      wanImage2ImageGenerationRequest,)
  }
);}




export const getWanImage2ImageGenerationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wanImage2ImageGeneration>>, TError,{data: WanImage2ImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof wanImage2ImageGeneration>>, TError,{data: WanImage2ImageGenerationRequest}, TContext> => {

const mutationKey = ['wanImage2ImageGeneration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof wanImage2ImageGeneration>>, {data: WanImage2ImageGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  wanImage2ImageGeneration(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type WanImage2ImageGenerationMutationResult = NonNullable<Awaited<ReturnType<typeof wanImage2ImageGeneration>>>
    export type WanImage2ImageGenerationMutationBody = WanImage2ImageGenerationRequest
    export type WanImage2ImageGenerationMutationError = ErrorResponse

    export const useWanImage2ImageGeneration = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wanImage2ImageGeneration>>, TError,{data: WanImage2ImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof wanImage2ImageGeneration>>,
        TError,
        {data: WanImage2ImageGenerationRequest},
        TContext
      > => {
      return useMutation(getWanImage2ImageGenerationMutationOptions(options), queryClient);
    }
    
export type wanImageGenerationResponse200 = {
  data: WanImageGenerationResponse
  status: 200
}

export type wanImageGenerationResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type wanImageGenerationResponseSuccess = (wanImageGenerationResponse200) & {
  headers: Headers;
};
export type wanImageGenerationResponseError = (wanImageGenerationResponseDefault) & {
  headers: Headers;
};

export type wanImageGenerationResponse = (wanImageGenerationResponseSuccess | wanImageGenerationResponseError)

export const getWanImageGenerationUrl = () => {


  

  return `/proxy/wan/api/v1/services/aigc/text2image/image-synthesis`
}

export const wanImageGeneration = async (wanImageGenerationRequest: WanImageGenerationRequest, options?: RequestInit): Promise<wanImageGenerationResponse> => {
  
  return customInstance<wanImageGenerationResponse>(getWanImageGenerationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      wanImageGenerationRequest,)
  }
);}




export const getWanImageGenerationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wanImageGeneration>>, TError,{data: WanImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof wanImageGeneration>>, TError,{data: WanImageGenerationRequest}, TContext> => {

const mutationKey = ['wanImageGeneration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof wanImageGeneration>>, {data: WanImageGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  wanImageGeneration(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type WanImageGenerationMutationResult = NonNullable<Awaited<ReturnType<typeof wanImageGeneration>>>
    export type WanImageGenerationMutationBody = WanImageGenerationRequest
    export type WanImageGenerationMutationError = ErrorResponse

    export const useWanImageGeneration = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wanImageGeneration>>, TError,{data: WanImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof wanImageGeneration>>,
        TError,
        {data: WanImageGenerationRequest},
        TContext
      > => {
      return useMutation(getWanImageGenerationMutationOptions(options), queryClient);
    }
    
export type wanVideoGenerationResponse200 = {
  data: WanVideoGenerationResponse
  status: 200
}

export type wanVideoGenerationResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type wanVideoGenerationResponseSuccess = (wanVideoGenerationResponse200) & {
  headers: Headers;
};
export type wanVideoGenerationResponseError = (wanVideoGenerationResponseDefault) & {
  headers: Headers;
};

export type wanVideoGenerationResponse = (wanVideoGenerationResponseSuccess | wanVideoGenerationResponseError)

export const getWanVideoGenerationUrl = () => {


  

  return `/proxy/wan/api/v1/services/aigc/video-generation/video-synthesis`
}

export const wanVideoGeneration = async (wanVideoGenerationRequest: WanVideoGenerationRequest, options?: RequestInit): Promise<wanVideoGenerationResponse> => {
  
  return customInstance<wanVideoGenerationResponse>(getWanVideoGenerationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      wanVideoGenerationRequest,)
  }
);}




export const getWanVideoGenerationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wanVideoGeneration>>, TError,{data: WanVideoGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof wanVideoGeneration>>, TError,{data: WanVideoGenerationRequest}, TContext> => {

const mutationKey = ['wanVideoGeneration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof wanVideoGeneration>>, {data: WanVideoGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  wanVideoGeneration(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type WanVideoGenerationMutationResult = NonNullable<Awaited<ReturnType<typeof wanVideoGeneration>>>
    export type WanVideoGenerationMutationBody = WanVideoGenerationRequest
    export type WanVideoGenerationMutationError = ErrorResponse

    export const useWanVideoGeneration = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wanVideoGeneration>>, TError,{data: WanVideoGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof wanVideoGeneration>>,
        TError,
        {data: WanVideoGenerationRequest},
        TContext
      > => {
      return useMutation(getWanVideoGenerationMutationOptions(options), queryClient);
    }
    
export type wanTaskQueryProxyResponse200 = {
  data: WanTaskQueryResponse
  status: 200
}

export type wanTaskQueryProxyResponseDefault = {
  data: ErrorResponse
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type wanTaskQueryProxyResponseSuccess = (wanTaskQueryProxyResponse200) & {
  headers: Headers;
};
export type wanTaskQueryProxyResponseError = (wanTaskQueryProxyResponseDefault) & {
  headers: Headers;
};

export type wanTaskQueryProxyResponse = (wanTaskQueryProxyResponseSuccess | wanTaskQueryProxyResponseError)

export const getWanTaskQueryProxyUrl = (taskId: string,) => {


  

  return `/proxy/wan/api/v1/tasks/${taskId}`
}

export const wanTaskQueryProxy = async (taskId: string, options?: RequestInit): Promise<wanTaskQueryProxyResponse> => {
  
  return customInstance<wanTaskQueryProxyResponse>(getWanTaskQueryProxyUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getWanTaskQueryProxyQueryKey = (taskId: string,) => {
    return [
    `/proxy/wan/api/v1/tasks/${taskId}`
    ] as const;
    }

    
export const getWanTaskQueryProxyQueryOptions = <TData = Awaited<ReturnType<typeof wanTaskQueryProxy>>, TError = ErrorResponse>(taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wanTaskQueryProxy>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWanTaskQueryProxyQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof wanTaskQueryProxy>>> = ({ signal }) => wanTaskQueryProxy(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof wanTaskQueryProxy>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type WanTaskQueryProxyQueryResult = NonNullable<Awaited<ReturnType<typeof wanTaskQueryProxy>>>
export type WanTaskQueryProxyQueryError = ErrorResponse


export function useWanTaskQueryProxy<TData = Awaited<ReturnType<typeof wanTaskQueryProxy>>, TError = ErrorResponse>(
 taskId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof wanTaskQueryProxy>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof wanTaskQueryProxy>>,
          TError,
          Awaited<ReturnType<typeof wanTaskQueryProxy>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWanTaskQueryProxy<TData = Awaited<ReturnType<typeof wanTaskQueryProxy>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wanTaskQueryProxy>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof wanTaskQueryProxy>>,
          TError,
          Awaited<ReturnType<typeof wanTaskQueryProxy>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWanTaskQueryProxy<TData = Awaited<ReturnType<typeof wanTaskQueryProxy>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wanTaskQueryProxy>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useWanTaskQueryProxy<TData = Awaited<ReturnType<typeof wanTaskQueryProxy>>, TError = ErrorResponse>(
 taskId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wanTaskQueryProxy>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getWanTaskQueryProxyQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Retrieve the status and result of a FlashVSR video upscaling task.

Poll this endpoint until status is "completed" or "failed".

Status values:
- `created` - Task has been created
- `processing` - Task is being processed
- `completed` - Task completed successfully, outputs array contains result URLs
- `failed` - Task failed, check error field for details

 * @summary Get FlashVSR task result
 */
export type wavespeedFlashVSRGetResultResponse200 = {
  data: WavespeedTaskResultResponse
  status: 200
}

export type wavespeedFlashVSRGetResultResponse401 = {
  data: void
  status: 401
}

export type wavespeedFlashVSRGetResultResponse402 = {
  data: ErrorResponse
  status: 402
}

export type wavespeedFlashVSRGetResultResponse404 = {
  data: ErrorResponse
  status: 404
}

export type wavespeedFlashVSRGetResultResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type wavespeedFlashVSRGetResultResponseSuccess = (wavespeedFlashVSRGetResultResponse200) & {
  headers: Headers;
};
export type wavespeedFlashVSRGetResultResponseError = (wavespeedFlashVSRGetResultResponse401 | wavespeedFlashVSRGetResultResponse402 | wavespeedFlashVSRGetResultResponse404 | wavespeedFlashVSRGetResultResponse500) & {
  headers: Headers;
};

export type wavespeedFlashVSRGetResultResponse = (wavespeedFlashVSRGetResultResponseSuccess | wavespeedFlashVSRGetResultResponseError)

export const getWavespeedFlashVSRGetResultUrl = (predictionId: string,) => {


  

  return `/proxy/wavespeed/api/v3/predictions/${predictionId}/result`
}

export const wavespeedFlashVSRGetResult = async (predictionId: string, options?: RequestInit): Promise<wavespeedFlashVSRGetResultResponse> => {
  
  return customInstance<wavespeedFlashVSRGetResultResponse>(getWavespeedFlashVSRGetResultUrl(predictionId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getWavespeedFlashVSRGetResultQueryKey = (predictionId: string,) => {
    return [
    `/proxy/wavespeed/api/v3/predictions/${predictionId}/result`
    ] as const;
    }

    
export const getWavespeedFlashVSRGetResultQueryOptions = <TData = Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>, TError = void | ErrorResponse>(predictionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWavespeedFlashVSRGetResultQueryKey(predictionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>> = ({ signal }) => wavespeedFlashVSRGetResult(predictionId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(predictionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type WavespeedFlashVSRGetResultQueryResult = NonNullable<Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>>
export type WavespeedFlashVSRGetResultQueryError = void | ErrorResponse


export function useWavespeedFlashVSRGetResult<TData = Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>, TError = void | ErrorResponse>(
 predictionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>,
          TError,
          Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWavespeedFlashVSRGetResult<TData = Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>, TError = void | ErrorResponse>(
 predictionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>,
          TError,
          Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useWavespeedFlashVSRGetResult<TData = Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>, TError = void | ErrorResponse>(
 predictionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get FlashVSR task result
 */

export function useWavespeedFlashVSRGetResult<TData = Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>, TError = void | ErrorResponse>(
 predictionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wavespeedFlashVSRGetResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getWavespeedFlashVSRGetResultQueryOptions(predictionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Submit a video for upscaling using WavespeedAI's FlashVSR model.
FlashVSR is a fast, high-quality video upscaler that boosts resolution and restores clarity
for low-resolution or blurry footage.

Supported target resolutions: 720p, 1080p, 2k, 4k

Max clip length: up to 10 minutes
Processing speed: approximately 3-20 seconds of wall time to process 1 second of video

Returns a task ID that can be used to poll for the result.

 * @summary Submit a FlashVSR video upscaling task
 */
export type wavespeedFlashVSRSubmitResponse200 = {
  data: WavespeedTaskResponse
  status: 200
}

export type wavespeedFlashVSRSubmitResponse400 = {
  data: ErrorResponse
  status: 400
}

export type wavespeedFlashVSRSubmitResponse401 = {
  data: void
  status: 401
}

export type wavespeedFlashVSRSubmitResponse402 = {
  data: ErrorResponse
  status: 402
}

export type wavespeedFlashVSRSubmitResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type wavespeedFlashVSRSubmitResponseSuccess = (wavespeedFlashVSRSubmitResponse200) & {
  headers: Headers;
};
export type wavespeedFlashVSRSubmitResponseError = (wavespeedFlashVSRSubmitResponse400 | wavespeedFlashVSRSubmitResponse401 | wavespeedFlashVSRSubmitResponse402 | wavespeedFlashVSRSubmitResponse500) & {
  headers: Headers;
};

export type wavespeedFlashVSRSubmitResponse = (wavespeedFlashVSRSubmitResponseSuccess | wavespeedFlashVSRSubmitResponseError)

export const getWavespeedFlashVSRSubmitUrl = () => {


  

  return `/proxy/wavespeed/api/v3/wavespeed-ai/flashvsr`
}

export const wavespeedFlashVSRSubmit = async (wavespeedFlashVSRRequest: WavespeedFlashVSRRequest, options?: RequestInit): Promise<wavespeedFlashVSRSubmitResponse> => {
  
  return customInstance<wavespeedFlashVSRSubmitResponse>(getWavespeedFlashVSRSubmitUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      wavespeedFlashVSRRequest,)
  }
);}




export const getWavespeedFlashVSRSubmitMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wavespeedFlashVSRSubmit>>, TError,{data: WavespeedFlashVSRRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof wavespeedFlashVSRSubmit>>, TError,{data: WavespeedFlashVSRRequest}, TContext> => {

const mutationKey = ['wavespeedFlashVSRSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof wavespeedFlashVSRSubmit>>, {data: WavespeedFlashVSRRequest}> = (props) => {
          const {data} = props ?? {};

          return  wavespeedFlashVSRSubmit(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type WavespeedFlashVSRSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof wavespeedFlashVSRSubmit>>>
    export type WavespeedFlashVSRSubmitMutationBody = WavespeedFlashVSRRequest
    export type WavespeedFlashVSRSubmitMutationError = ErrorResponse | void

    /**
 * @summary Submit a FlashVSR video upscaling task
 */
export const useWavespeedFlashVSRSubmit = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wavespeedFlashVSRSubmit>>, TError,{data: WavespeedFlashVSRRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof wavespeedFlashVSRSubmit>>,
        TError,
        {data: WavespeedFlashVSRRequest},
        TContext
      > => {
      return useMutation(getWavespeedFlashVSRSubmitMutationOptions(options), queryClient);
    }
    
/**
 * Upscale an image using WavespeedAI's SeedVR2 Image Upscaler.
SeedVR2 boosts image resolution and quality, upscaling photos to 2K, 4K, or 8K
for sharp, detailed results.

 * @summary Submit a SeedVR2 image upscaling task
 */
export type wavespeedSeedVR2ImageSubmitResponse200 = {
  data: WavespeedTaskResponse
  status: 200
}

export type wavespeedSeedVR2ImageSubmitResponse400 = {
  data: ErrorResponse
  status: 400
}

export type wavespeedSeedVR2ImageSubmitResponse401 = {
  data: void
  status: 401
}

export type wavespeedSeedVR2ImageSubmitResponse402 = {
  data: ErrorResponse
  status: 402
}

export type wavespeedSeedVR2ImageSubmitResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type wavespeedSeedVR2ImageSubmitResponseSuccess = (wavespeedSeedVR2ImageSubmitResponse200) & {
  headers: Headers;
};
export type wavespeedSeedVR2ImageSubmitResponseError = (wavespeedSeedVR2ImageSubmitResponse400 | wavespeedSeedVR2ImageSubmitResponse401 | wavespeedSeedVR2ImageSubmitResponse402 | wavespeedSeedVR2ImageSubmitResponse500) & {
  headers: Headers;
};

export type wavespeedSeedVR2ImageSubmitResponse = (wavespeedSeedVR2ImageSubmitResponseSuccess | wavespeedSeedVR2ImageSubmitResponseError)

export const getWavespeedSeedVR2ImageSubmitUrl = () => {


  

  return `/proxy/wavespeed/api/v3/wavespeed-ai/seedvr2/image`
}

export const wavespeedSeedVR2ImageSubmit = async (wavespeedSeedVR2ImageRequest: WavespeedSeedVR2ImageRequest, options?: RequestInit): Promise<wavespeedSeedVR2ImageSubmitResponse> => {
  
  return customInstance<wavespeedSeedVR2ImageSubmitResponse>(getWavespeedSeedVR2ImageSubmitUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      wavespeedSeedVR2ImageRequest,)
  }
);}




export const getWavespeedSeedVR2ImageSubmitMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wavespeedSeedVR2ImageSubmit>>, TError,{data: WavespeedSeedVR2ImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof wavespeedSeedVR2ImageSubmit>>, TError,{data: WavespeedSeedVR2ImageRequest}, TContext> => {

const mutationKey = ['wavespeedSeedVR2ImageSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof wavespeedSeedVR2ImageSubmit>>, {data: WavespeedSeedVR2ImageRequest}> = (props) => {
          const {data} = props ?? {};

          return  wavespeedSeedVR2ImageSubmit(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type WavespeedSeedVR2ImageSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof wavespeedSeedVR2ImageSubmit>>>
    export type WavespeedSeedVR2ImageSubmitMutationBody = WavespeedSeedVR2ImageRequest
    export type WavespeedSeedVR2ImageSubmitMutationError = ErrorResponse | void

    /**
 * @summary Submit a SeedVR2 image upscaling task
 */
export const useWavespeedSeedVR2ImageSubmit = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wavespeedSeedVR2ImageSubmit>>, TError,{data: WavespeedSeedVR2ImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof wavespeedSeedVR2ImageSubmit>>,
        TError,
        {data: WavespeedSeedVR2ImageRequest},
        TContext
      > => {
      return useMutation(getWavespeedSeedVR2ImageSubmitMutationOptions(options), queryClient);
    }
    
/**
 * Upscale an image using WavespeedAI's Ultimate Image Upscaler.
The most advanced AI enhancer that reimagines fine detail while upscaling images to 2K, 4K, or 8K.

 * @summary Submit an Ultimate Image Upscaler task
 */
export type wavespeedUltimateImageUpscalerSubmitResponse200 = {
  data: WavespeedTaskResponse
  status: 200
}

export type wavespeedUltimateImageUpscalerSubmitResponse400 = {
  data: ErrorResponse
  status: 400
}

export type wavespeedUltimateImageUpscalerSubmitResponse401 = {
  data: void
  status: 401
}

export type wavespeedUltimateImageUpscalerSubmitResponse402 = {
  data: ErrorResponse
  status: 402
}

export type wavespeedUltimateImageUpscalerSubmitResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type wavespeedUltimateImageUpscalerSubmitResponseSuccess = (wavespeedUltimateImageUpscalerSubmitResponse200) & {
  headers: Headers;
};
export type wavespeedUltimateImageUpscalerSubmitResponseError = (wavespeedUltimateImageUpscalerSubmitResponse400 | wavespeedUltimateImageUpscalerSubmitResponse401 | wavespeedUltimateImageUpscalerSubmitResponse402 | wavespeedUltimateImageUpscalerSubmitResponse500) & {
  headers: Headers;
};

export type wavespeedUltimateImageUpscalerSubmitResponse = (wavespeedUltimateImageUpscalerSubmitResponseSuccess | wavespeedUltimateImageUpscalerSubmitResponseError)

export const getWavespeedUltimateImageUpscalerSubmitUrl = () => {


  

  return `/proxy/wavespeed/api/v3/wavespeed-ai/ultimate-image-upscaler`
}

export const wavespeedUltimateImageUpscalerSubmit = async (wavespeedSeedVR2ImageRequest: WavespeedSeedVR2ImageRequest, options?: RequestInit): Promise<wavespeedUltimateImageUpscalerSubmitResponse> => {
  
  return customInstance<wavespeedUltimateImageUpscalerSubmitResponse>(getWavespeedUltimateImageUpscalerSubmitUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      wavespeedSeedVR2ImageRequest,)
  }
);}




export const getWavespeedUltimateImageUpscalerSubmitMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wavespeedUltimateImageUpscalerSubmit>>, TError,{data: WavespeedSeedVR2ImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof wavespeedUltimateImageUpscalerSubmit>>, TError,{data: WavespeedSeedVR2ImageRequest}, TContext> => {

const mutationKey = ['wavespeedUltimateImageUpscalerSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof wavespeedUltimateImageUpscalerSubmit>>, {data: WavespeedSeedVR2ImageRequest}> = (props) => {
          const {data} = props ?? {};

          return  wavespeedUltimateImageUpscalerSubmit(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type WavespeedUltimateImageUpscalerSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof wavespeedUltimateImageUpscalerSubmit>>>
    export type WavespeedUltimateImageUpscalerSubmitMutationBody = WavespeedSeedVR2ImageRequest
    export type WavespeedUltimateImageUpscalerSubmitMutationError = ErrorResponse | void

    /**
 * @summary Submit an Ultimate Image Upscaler task
 */
export const useWavespeedUltimateImageUpscalerSubmit = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wavespeedUltimateImageUpscalerSubmit>>, TError,{data: WavespeedSeedVR2ImageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof wavespeedUltimateImageUpscalerSubmit>>,
        TError,
        {data: WavespeedSeedVR2ImageRequest},
        TContext
      > => {
      return useMutation(getWavespeedUltimateImageUpscalerSubmitMutationOptions(options), queryClient);
    }
    
/**
 * Modify an existing image based on a text prompt using the Grok Imagine API.
 * @summary Edit images using xAI Grok Imagine
 */
export type xaiImageEditResponse200 = {
  data: XAIImageGenerationResponse
  status: 200
}

export type xaiImageEditResponse400 = {
  data: ErrorResponse
  status: 400
}

export type xaiImageEditResponse401 = {
  data: void
  status: 401
}

export type xaiImageEditResponse402 = {
  data: void
  status: 402
}

export type xaiImageEditResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type xaiImageEditResponseSuccess = (xaiImageEditResponse200) & {
  headers: Headers;
};
export type xaiImageEditResponseError = (xaiImageEditResponse400 | xaiImageEditResponse401 | xaiImageEditResponse402 | xaiImageEditResponse500) & {
  headers: Headers;
};

export type xaiImageEditResponse = (xaiImageEditResponseSuccess | xaiImageEditResponseError)

export const getXaiImageEditUrl = () => {


  

  return `/proxy/xai/v1/images/edits`
}

export const xaiImageEdit = async (xAIImageEditRequest: XAIImageEditRequest, options?: RequestInit): Promise<xaiImageEditResponse> => {
  
  return customInstance<xaiImageEditResponse>(getXaiImageEditUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      xAIImageEditRequest,)
  }
);}




export const getXaiImageEditMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof xaiImageEdit>>, TError,{data: XAIImageEditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof xaiImageEdit>>, TError,{data: XAIImageEditRequest}, TContext> => {

const mutationKey = ['xaiImageEdit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof xaiImageEdit>>, {data: XAIImageEditRequest}> = (props) => {
          const {data} = props ?? {};

          return  xaiImageEdit(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type XaiImageEditMutationResult = NonNullable<Awaited<ReturnType<typeof xaiImageEdit>>>
    export type XaiImageEditMutationBody = XAIImageEditRequest
    export type XaiImageEditMutationError = ErrorResponse | void

    /**
 * @summary Edit images using xAI Grok Imagine
 */
export const useXaiImageEdit = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof xaiImageEdit>>, TError,{data: XAIImageEditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof xaiImageEdit>>,
        TError,
        {data: XAIImageEditRequest},
        TContext
      > => {
      return useMutation(getXaiImageEditMutationOptions(options), queryClient);
    }
    
/**
 * Generate one or more images from a text prompt using the Grok Imagine API.
 * @summary Generate images using xAI Grok Imagine
 */
export type xaiImageGenerateResponse200 = {
  data: XAIImageGenerationResponse
  status: 200
}

export type xaiImageGenerateResponse400 = {
  data: ErrorResponse
  status: 400
}

export type xaiImageGenerateResponse401 = {
  data: void
  status: 401
}

export type xaiImageGenerateResponse402 = {
  data: void
  status: 402
}

export type xaiImageGenerateResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type xaiImageGenerateResponseSuccess = (xaiImageGenerateResponse200) & {
  headers: Headers;
};
export type xaiImageGenerateResponseError = (xaiImageGenerateResponse400 | xaiImageGenerateResponse401 | xaiImageGenerateResponse402 | xaiImageGenerateResponse500) & {
  headers: Headers;
};

export type xaiImageGenerateResponse = (xaiImageGenerateResponseSuccess | xaiImageGenerateResponseError)

export const getXaiImageGenerateUrl = () => {


  

  return `/proxy/xai/v1/images/generations`
}

export const xaiImageGenerate = async (xAIImageGenerationRequest: XAIImageGenerationRequest, options?: RequestInit): Promise<xaiImageGenerateResponse> => {
  
  return customInstance<xaiImageGenerateResponse>(getXaiImageGenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      xAIImageGenerationRequest,)
  }
);}




export const getXaiImageGenerateMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof xaiImageGenerate>>, TError,{data: XAIImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof xaiImageGenerate>>, TError,{data: XAIImageGenerationRequest}, TContext> => {

const mutationKey = ['xaiImageGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof xaiImageGenerate>>, {data: XAIImageGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  xaiImageGenerate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type XaiImageGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof xaiImageGenerate>>>
    export type XaiImageGenerateMutationBody = XAIImageGenerationRequest
    export type XaiImageGenerateMutationError = ErrorResponse | void

    /**
 * @summary Generate images using xAI Grok Imagine
 */
export const useXaiImageGenerate = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof xaiImageGenerate>>, TError,{data: XAIImageGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof xaiImageGenerate>>,
        TError,
        {data: XAIImageGenerationRequest},
        TContext
      > => {
      return useMutation(getXaiImageGenerateMutationOptions(options), queryClient);
    }
    
/**
 * Edit an existing video based on a text prompt (video-to-video editing).
Video editing is asynchronous. Returns a request_id to poll for the completed video.
Input video limit is 8 seconds. Audio will not be modified.

 * @summary Edit videos using xAI Grok Imagine
 */
export type xaiVideoEditResponse200 = {
  data: XAIVideoAsyncResponse
  status: 200
}

export type xaiVideoEditResponse400 = {
  data: ErrorResponse
  status: 400
}

export type xaiVideoEditResponse401 = {
  data: void
  status: 401
}

export type xaiVideoEditResponse402 = {
  data: void
  status: 402
}

export type xaiVideoEditResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type xaiVideoEditResponseSuccess = (xaiVideoEditResponse200) & {
  headers: Headers;
};
export type xaiVideoEditResponseError = (xaiVideoEditResponse400 | xaiVideoEditResponse401 | xaiVideoEditResponse402 | xaiVideoEditResponse500) & {
  headers: Headers;
};

export type xaiVideoEditResponse = (xaiVideoEditResponseSuccess | xaiVideoEditResponseError)

export const getXaiVideoEditUrl = () => {


  

  return `/proxy/xai/v1/videos/edits`
}

export const xaiVideoEdit = async (xAIVideoEditRequest: XAIVideoEditRequest, options?: RequestInit): Promise<xaiVideoEditResponse> => {
  
  return customInstance<xaiVideoEditResponse>(getXaiVideoEditUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      xAIVideoEditRequest,)
  }
);}




export const getXaiVideoEditMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof xaiVideoEdit>>, TError,{data: XAIVideoEditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof xaiVideoEdit>>, TError,{data: XAIVideoEditRequest}, TContext> => {

const mutationKey = ['xaiVideoEdit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof xaiVideoEdit>>, {data: XAIVideoEditRequest}> = (props) => {
          const {data} = props ?? {};

          return  xaiVideoEdit(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type XaiVideoEditMutationResult = NonNullable<Awaited<ReturnType<typeof xaiVideoEdit>>>
    export type XaiVideoEditMutationBody = XAIVideoEditRequest
    export type XaiVideoEditMutationError = ErrorResponse | void

    /**
 * @summary Edit videos using xAI Grok Imagine
 */
export const useXaiVideoEdit = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof xaiVideoEdit>>, TError,{data: XAIVideoEditRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof xaiVideoEdit>>,
        TError,
        {data: XAIVideoEditRequest},
        TContext
      > => {
      return useMutation(getXaiVideoEditMutationOptions(options), queryClient);
    }
    
/**
 * Generate a video from a text prompt (text-to-video) or from an image with optional text (image-to-video).
Video generation is asynchronous. Returns a request_id to poll for the completed video.

 * @summary Generate videos using xAI Grok Imagine
 */
export type xaiVideoGenerateResponse200 = {
  data: XAIVideoAsyncResponse
  status: 200
}

export type xaiVideoGenerateResponse400 = {
  data: ErrorResponse
  status: 400
}

export type xaiVideoGenerateResponse401 = {
  data: void
  status: 401
}

export type xaiVideoGenerateResponse402 = {
  data: void
  status: 402
}

export type xaiVideoGenerateResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type xaiVideoGenerateResponseSuccess = (xaiVideoGenerateResponse200) & {
  headers: Headers;
};
export type xaiVideoGenerateResponseError = (xaiVideoGenerateResponse400 | xaiVideoGenerateResponse401 | xaiVideoGenerateResponse402 | xaiVideoGenerateResponse500) & {
  headers: Headers;
};

export type xaiVideoGenerateResponse = (xaiVideoGenerateResponseSuccess | xaiVideoGenerateResponseError)

export const getXaiVideoGenerateUrl = () => {


  

  return `/proxy/xai/v1/videos/generations`
}

export const xaiVideoGenerate = async (xAIVideoGenerationRequest: XAIVideoGenerationRequest, options?: RequestInit): Promise<xaiVideoGenerateResponse> => {
  
  return customInstance<xaiVideoGenerateResponse>(getXaiVideoGenerateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      xAIVideoGenerationRequest,)
  }
);}




export const getXaiVideoGenerateMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof xaiVideoGenerate>>, TError,{data: XAIVideoGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof xaiVideoGenerate>>, TError,{data: XAIVideoGenerationRequest}, TContext> => {

const mutationKey = ['xaiVideoGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof xaiVideoGenerate>>, {data: XAIVideoGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  xaiVideoGenerate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type XaiVideoGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof xaiVideoGenerate>>>
    export type XaiVideoGenerateMutationBody = XAIVideoGenerationRequest
    export type XaiVideoGenerateMutationError = ErrorResponse | void

    /**
 * @summary Generate videos using xAI Grok Imagine
 */
export const useXaiVideoGenerate = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof xaiVideoGenerate>>, TError,{data: XAIVideoGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof xaiVideoGenerate>>,
        TError,
        {data: XAIVideoGenerationRequest},
        TContext
      > => {
      return useMutation(getXaiVideoGenerateMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve the result of a video generation or editing request.
Poll this endpoint until the response includes a video object with the completed video URL.

 * @summary Get xAI video generation result
 */
export type xaiVideoGetResultResponse200 = {
  data: XAIVideoResultResponse
  status: 200
}

export type xaiVideoGetResultResponse202 = {
  data: XAIVideoPendingResponse
  status: 202
}

export type xaiVideoGetResultResponse401 = {
  data: void
  status: 401
}

export type xaiVideoGetResultResponse402 = {
  data: void
  status: 402
}

export type xaiVideoGetResultResponse404 = {
  data: void
  status: 404
}

export type xaiVideoGetResultResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type xaiVideoGetResultResponseSuccess = (xaiVideoGetResultResponse200 | xaiVideoGetResultResponse202) & {
  headers: Headers;
};
export type xaiVideoGetResultResponseError = (xaiVideoGetResultResponse401 | xaiVideoGetResultResponse402 | xaiVideoGetResultResponse404 | xaiVideoGetResultResponse500) & {
  headers: Headers;
};

export type xaiVideoGetResultResponse = (xaiVideoGetResultResponseSuccess | xaiVideoGetResultResponseError)

export const getXaiVideoGetResultUrl = (requestId: string,) => {


  

  return `/proxy/xai/v1/videos/${requestId}`
}

export const xaiVideoGetResult = async (requestId: string, options?: RequestInit): Promise<xaiVideoGetResultResponse> => {
  
  return customInstance<xaiVideoGetResultResponse>(getXaiVideoGetResultUrl(requestId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getXaiVideoGetResultQueryKey = (requestId: string,) => {
    return [
    `/proxy/xai/v1/videos/${requestId}`
    ] as const;
    }

    
export const getXaiVideoGetResultQueryOptions = <TData = Awaited<ReturnType<typeof xaiVideoGetResult>>, TError = void | ErrorResponse>(requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof xaiVideoGetResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getXaiVideoGetResultQueryKey(requestId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof xaiVideoGetResult>>> = ({ signal }) => xaiVideoGetResult(requestId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(requestId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof xaiVideoGetResult>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type XaiVideoGetResultQueryResult = NonNullable<Awaited<ReturnType<typeof xaiVideoGetResult>>>
export type XaiVideoGetResultQueryError = void | ErrorResponse


export function useXaiVideoGetResult<TData = Awaited<ReturnType<typeof xaiVideoGetResult>>, TError = void | ErrorResponse>(
 requestId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof xaiVideoGetResult>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof xaiVideoGetResult>>,
          TError,
          Awaited<ReturnType<typeof xaiVideoGetResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useXaiVideoGetResult<TData = Awaited<ReturnType<typeof xaiVideoGetResult>>, TError = void | ErrorResponse>(
 requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof xaiVideoGetResult>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof xaiVideoGetResult>>,
          TError,
          Awaited<ReturnType<typeof xaiVideoGetResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useXaiVideoGetResult<TData = Awaited<ReturnType<typeof xaiVideoGetResult>>, TError = void | ErrorResponse>(
 requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof xaiVideoGetResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get xAI video generation result
 */

export function useXaiVideoGetResult<TData = Awaited<ReturnType<typeof xaiVideoGetResult>>, TError = void | ErrorResponse>(
 requestId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof xaiVideoGetResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getXaiVideoGetResultQueryOptions(requestId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Retrieve all publishers
 */
export type listPublishersResponse200 = {
  data: Publisher[]
  status: 200
}

export type listPublishersResponse400 = {
  data: ErrorResponse
  status: 400
}

export type listPublishersResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listPublishersResponseSuccess = (listPublishersResponse200) & {
  headers: Headers;
};
export type listPublishersResponseError = (listPublishersResponse400 | listPublishersResponse500) & {
  headers: Headers;
};

export type listPublishersResponse = (listPublishersResponseSuccess | listPublishersResponseError)

export const getListPublishersUrl = () => {


  

  return `/publishers`
}

export const listPublishers = async ( options?: RequestInit): Promise<listPublishersResponse> => {
  
  return customInstance<listPublishersResponse>(getListPublishersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListPublishersQueryKey = () => {
    return [
    `/publishers`
    ] as const;
    }

    
export const getListPublishersQueryOptions = <TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPublishersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPublishers>>> = ({ signal }) => listPublishers({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPublishersQueryResult = NonNullable<Awaited<ReturnType<typeof listPublishers>>>
export type ListPublishersQueryError = ErrorResponse


export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPublishers>>,
          TError,
          Awaited<ReturnType<typeof listPublishers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPublishers>>,
          TError,
          Awaited<ReturnType<typeof listPublishers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve all publishers
 */

export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPublishersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a new publisher
 */
export type createPublisherResponse201 = {
  data: Publisher
  status: 201
}

export type createPublisherResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createPublisherResponse401 = {
  data: void
  status: 401
}

export type createPublisherResponse403 = {
  data: ErrorResponse
  status: 403
}

export type createPublisherResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createPublisherResponseSuccess = (createPublisherResponse201) & {
  headers: Headers;
};
export type createPublisherResponseError = (createPublisherResponse400 | createPublisherResponse401 | createPublisherResponse403 | createPublisherResponse500) & {
  headers: Headers;
};

export type createPublisherResponse = (createPublisherResponseSuccess | createPublisherResponseError)

export const getCreatePublisherUrl = () => {


  

  return `/publishers`
}

export const createPublisher = async (publisher: Publisher, options?: RequestInit): Promise<createPublisherResponse> => {
  
  return customInstance<createPublisherResponse>(getCreatePublisherUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      publisher,)
  }
);}




export const getCreatePublisherMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext> => {

const mutationKey = ['createPublisher'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPublisher>>, {data: Publisher}> = (props) => {
          const {data} = props ?? {};

          return  createPublisher(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof createPublisher>>>
    export type CreatePublisherMutationBody = Publisher
    export type CreatePublisherMutationError = ErrorResponse | void

    /**
 * @summary Create a new publisher
 */
export const useCreatePublisher = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPublisher>>,
        TError,
        {data: Publisher},
        TContext
      > => {
      return useMutation(getCreatePublisherMutationOptions(options), queryClient);
    }
    
/**
 * Checks if the publisher username is already taken.
 * @summary Validate if a publisher username is available
 */
export type validatePublisherResponse200 = {
  data: ValidatePublisher200
  status: 200
}

export type validatePublisherResponse400 = {
  data: ErrorResponse
  status: 400
}

export type validatePublisherResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type validatePublisherResponseSuccess = (validatePublisherResponse200) & {
  headers: Headers;
};
export type validatePublisherResponseError = (validatePublisherResponse400 | validatePublisherResponse500) & {
  headers: Headers;
};

export type validatePublisherResponse = (validatePublisherResponseSuccess | validatePublisherResponseError)

export const getValidatePublisherUrl = (params: ValidatePublisherParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/publishers/validate?${stringifiedParams}` : `/publishers/validate`
}

export const validatePublisher = async (params: ValidatePublisherParams, options?: RequestInit): Promise<validatePublisherResponse> => {
  
  return customInstance<validatePublisherResponse>(getValidatePublisherUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getValidatePublisherQueryKey = (params?: ValidatePublisherParams,) => {
    return [
    `/publishers/validate`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getValidatePublisherQueryOptions = <TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidatePublisherQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validatePublisher>>> = ({ signal }) => validatePublisher(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ValidatePublisherQueryResult = NonNullable<Awaited<ReturnType<typeof validatePublisher>>>
export type ValidatePublisherQueryError = ErrorResponse


export function useValidatePublisher<TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(
 params: ValidatePublisherParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validatePublisher>>,
          TError,
          Awaited<ReturnType<typeof validatePublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidatePublisher<TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(
 params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validatePublisher>>,
          TError,
          Awaited<ReturnType<typeof validatePublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useValidatePublisher<TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(
 params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Validate if a publisher username is available
 */

export function useValidatePublisher<TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(
 params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getValidatePublisherQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Delete a publisher
 */
export type deletePublisherResponse204 = {
  data: void
  status: 204
}

export type deletePublisherResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deletePublisherResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type deletePublisherResponseSuccess = (deletePublisherResponse204) & {
  headers: Headers;
};
export type deletePublisherResponseError = (deletePublisherResponse404 | deletePublisherResponse500) & {
  headers: Headers;
};

export type deletePublisherResponse = (deletePublisherResponseSuccess | deletePublisherResponseError)

export const getDeletePublisherUrl = (publisherId: string,) => {


  

  return `/publishers/${publisherId}`
}

export const deletePublisher = async (publisherId: string, options?: RequestInit): Promise<deletePublisherResponse> => {
  
  return customInstance<deletePublisherResponse>(getDeletePublisherUrl(publisherId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeletePublisherMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext> => {

const mutationKey = ['deletePublisher'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePublisher>>, {publisherId: string}> = (props) => {
          const {publisherId} = props ?? {};

          return  deletePublisher(publisherId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof deletePublisher>>>
    
    export type DeletePublisherMutationError = ErrorResponse

    /**
 * @summary Delete a publisher
 */
export const useDeletePublisher = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePublisher>>,
        TError,
        {publisherId: string},
        TContext
      > => {
      return useMutation(getDeletePublisherMutationOptions(options), queryClient);
    }
    
/**
 * @summary Retrieve a publisher by ID
 */
export type getPublisherResponse200 = {
  data: Publisher
  status: 200
}

export type getPublisherResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getPublisherResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getPublisherResponseSuccess = (getPublisherResponse200) & {
  headers: Headers;
};
export type getPublisherResponseError = (getPublisherResponse404 | getPublisherResponse500) & {
  headers: Headers;
};

export type getPublisherResponse = (getPublisherResponseSuccess | getPublisherResponseError)

export const getGetPublisherUrl = (publisherId: string,) => {


  

  return `/publishers/${publisherId}`
}

export const getPublisher = async (publisherId: string, options?: RequestInit): Promise<getPublisherResponse> => {
  
  return customInstance<getPublisherResponse>(getGetPublisherUrl(publisherId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPublisherQueryKey = (publisherId: string,) => {
    return [
    `/publishers/${publisherId}`
    ] as const;
    }

    
export const getGetPublisherQueryOptions = <TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublisherQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublisher>>> = ({ signal }) => getPublisher(publisherId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof getPublisher>>>
export type GetPublisherQueryError = ErrorResponse


export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(
 publisherId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublisher>>,
          TError,
          Awaited<ReturnType<typeof getPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublisher>>,
          TError,
          Awaited<ReturnType<typeof getPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a publisher by ID
 */

export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPublisherQueryOptions(publisherId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Update a publisher
 */
export type updatePublisherResponse200 = {
  data: Publisher
  status: 200
}

export type updatePublisherResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updatePublisherResponse401 = {
  data: void
  status: 401
}

export type updatePublisherResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updatePublisherResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type updatePublisherResponseSuccess = (updatePublisherResponse200) & {
  headers: Headers;
};
export type updatePublisherResponseError = (updatePublisherResponse400 | updatePublisherResponse401 | updatePublisherResponse404 | updatePublisherResponse500) & {
  headers: Headers;
};

export type updatePublisherResponse = (updatePublisherResponseSuccess | updatePublisherResponseError)

export const getUpdatePublisherUrl = (publisherId: string,) => {


  

  return `/publishers/${publisherId}`
}

export const updatePublisher = async (publisherId: string,
    publisher: Publisher, options?: RequestInit): Promise<updatePublisherResponse> => {
  
  return customInstance<updatePublisherResponse>(getUpdatePublisherUrl(publisherId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      publisher,)
  }
);}




export const getUpdatePublisherMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext> => {

const mutationKey = ['updatePublisher'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePublisher>>, {publisherId: string;data: Publisher}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  updatePublisher(publisherId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof updatePublisher>>>
    export type UpdatePublisherMutationBody = Publisher
    export type UpdatePublisherMutationError = ErrorResponse | void

    /**
 * @summary Update a publisher
 */
export const useUpdatePublisher = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePublisher>>,
        TError,
        {publisherId: string;data: Publisher},
        TContext
      > => {
      return useMutation(getUpdatePublisherMutationOptions(options), queryClient);
    }
    
/**
 * @summary Ban a publisher
 */
export type banPublisherResponse204 = {
  data: void
  status: 204
}

export type banPublisherResponse401 = {
  data: void
  status: 401
}

export type banPublisherResponse403 = {
  data: ErrorResponse
  status: 403
}

export type banPublisherResponse404 = {
  data: ErrorResponse
  status: 404
}

export type banPublisherResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type banPublisherResponseSuccess = (banPublisherResponse204) & {
  headers: Headers;
};
export type banPublisherResponseError = (banPublisherResponse401 | banPublisherResponse403 | banPublisherResponse404 | banPublisherResponse500) & {
  headers: Headers;
};

export type banPublisherResponse = (banPublisherResponseSuccess | banPublisherResponseError)

export const getBanPublisherUrl = (publisherId: string,) => {


  

  return `/publishers/${publisherId}/ban`
}

export const banPublisher = async (publisherId: string, options?: RequestInit): Promise<banPublisherResponse> => {
  
  return customInstance<banPublisherResponse>(getBanPublisherUrl(publisherId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getBanPublisherMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof banPublisher>>, TError,{publisherId: string}, TContext> => {

const mutationKey = ['banPublisher'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof banPublisher>>, {publisherId: string}> = (props) => {
          const {publisherId} = props ?? {};

          return  banPublisher(publisherId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BanPublisherMutationResult = NonNullable<Awaited<ReturnType<typeof banPublisher>>>
    
    export type BanPublisherMutationError = void | ErrorResponse

    /**
 * @summary Ban a publisher
 */
export const useBanPublisher = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof banPublisher>>,
        TError,
        {publisherId: string},
        TContext
      > => {
      return useMutation(getBanPublisherMutationOptions(options), queryClient);
    }
    
/**
 * @summary Retrieve all nodes
 */
export type listNodesForPublisherResponse200 = {
  data: Node[]
  status: 200
}

export type listNodesForPublisherResponse400 = {
  data: ErrorResponse
  status: 400
}

export type listNodesForPublisherResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listNodesForPublisherResponseSuccess = (listNodesForPublisherResponse200) & {
  headers: Headers;
};
export type listNodesForPublisherResponseError = (listNodesForPublisherResponse400 | listNodesForPublisherResponse500) & {
  headers: Headers;
};

export type listNodesForPublisherResponse = (listNodesForPublisherResponseSuccess | listNodesForPublisherResponseError)

export const getListNodesForPublisherUrl = (publisherId: string,
    params?: ListNodesForPublisherParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/publishers/${publisherId}/nodes?${stringifiedParams}` : `/publishers/${publisherId}/nodes`
}

export const listNodesForPublisher = async (publisherId: string,
    params?: ListNodesForPublisherParams, options?: RequestInit): Promise<listNodesForPublisherResponse> => {
  
  return customInstance<listNodesForPublisherResponse>(getListNodesForPublisherUrl(publisherId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListNodesForPublisherQueryKey = (publisherId: string,
    params?: ListNodesForPublisherParams,) => {
    return [
    `/publishers/${publisherId}/nodes`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListNodesForPublisherQueryOptions = <TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(publisherId: string,
    params?: ListNodesForPublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListNodesForPublisherQueryKey(publisherId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodesForPublisher>>> = ({ signal }) => listNodesForPublisher(publisherId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListNodesForPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof listNodesForPublisher>>>
export type ListNodesForPublisherQueryError = ErrorResponse


export function useListNodesForPublisher<TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(
 publisherId: string,
    params: undefined |  ListNodesForPublisherParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodesForPublisher>>,
          TError,
          Awaited<ReturnType<typeof listNodesForPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListNodesForPublisher<TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodesForPublisher>>,
          TError,
          Awaited<ReturnType<typeof listNodesForPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListNodesForPublisher<TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve all nodes
 */

export function useListNodesForPublisher<TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListNodesForPublisherQueryOptions(publisherId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a new custom node
 */
export type createNodeResponse201 = {
  data: Node
  status: 201
}

export type createNodeResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createNodeResponse401 = {
  data: void
  status: 401
}

export type createNodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createNodeResponseSuccess = (createNodeResponse201) & {
  headers: Headers;
};
export type createNodeResponseError = (createNodeResponse400 | createNodeResponse401 | createNodeResponse500) & {
  headers: Headers;
};

export type createNodeResponse = (createNodeResponseSuccess | createNodeResponseError)

export const getCreateNodeUrl = (publisherId: string,) => {


  

  return `/publishers/${publisherId}/nodes`
}

export const createNode = async (publisherId: string,
    node: Node, options?: RequestInit): Promise<createNodeResponse> => {
  
  return customInstance<createNodeResponse>(getCreateNodeUrl(publisherId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      node,)
  }
);}




export const getCreateNodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext> => {

const mutationKey = ['createNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNode>>, {publisherId: string;data: Node}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  createNode(publisherId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof createNode>>>
    export type CreateNodeMutationBody = Node
    export type CreateNodeMutationError = ErrorResponse | void

    /**
 * @summary Create a new custom node
 */
export const useCreateNode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createNode>>,
        TError,
        {publisherId: string;data: Node},
        TContext
      > => {
      return useMutation(getCreateNodeMutationOptions(options), queryClient);
    }
    
/**
 * @summary Retrieve all nodes
 */
export type listNodesForPublisherV2Response200 = {
  data: ListNodesForPublisherV2200
  status: 200
}

export type listNodesForPublisherV2Response400 = {
  data: ErrorResponse
  status: 400
}

export type listNodesForPublisherV2Response500 = {
  data: ErrorResponse
  status: 500
}
    
export type listNodesForPublisherV2ResponseSuccess = (listNodesForPublisherV2Response200) & {
  headers: Headers;
};
export type listNodesForPublisherV2ResponseError = (listNodesForPublisherV2Response400 | listNodesForPublisherV2Response500) & {
  headers: Headers;
};

export type listNodesForPublisherV2Response = (listNodesForPublisherV2ResponseSuccess | listNodesForPublisherV2ResponseError)

export const getListNodesForPublisherV2Url = (publisherId: string,
    params?: ListNodesForPublisherV2Params,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/publishers/${publisherId}/nodes/v2?${stringifiedParams}` : `/publishers/${publisherId}/nodes/v2`
}

export const listNodesForPublisherV2 = async (publisherId: string,
    params?: ListNodesForPublisherV2Params, options?: RequestInit): Promise<listNodesForPublisherV2Response> => {
  
  return customInstance<listNodesForPublisherV2Response>(getListNodesForPublisherV2Url(publisherId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListNodesForPublisherV2QueryKey = (publisherId: string,
    params?: ListNodesForPublisherV2Params,) => {
    return [
    `/publishers/${publisherId}/nodes/v2`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListNodesForPublisherV2QueryOptions = <TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError = ErrorResponse>(publisherId: string,
    params?: ListNodesForPublisherV2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListNodesForPublisherV2QueryKey(publisherId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodesForPublisherV2>>> = ({ signal }) => listNodesForPublisherV2(publisherId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListNodesForPublisherV2QueryResult = NonNullable<Awaited<ReturnType<typeof listNodesForPublisherV2>>>
export type ListNodesForPublisherV2QueryError = ErrorResponse


export function useListNodesForPublisherV2<TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError = ErrorResponse>(
 publisherId: string,
    params: undefined |  ListNodesForPublisherV2Params, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodesForPublisherV2>>,
          TError,
          Awaited<ReturnType<typeof listNodesForPublisherV2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListNodesForPublisherV2<TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherV2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodesForPublisherV2>>,
          TError,
          Awaited<ReturnType<typeof listNodesForPublisherV2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListNodesForPublisherV2<TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherV2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve all nodes
 */

export function useListNodesForPublisherV2<TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherV2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListNodesForPublisherV2QueryOptions(publisherId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Delete a specific node
 */
export type deleteNodeResponse204 = {
  data: void
  status: 204
}

export type deleteNodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type deleteNodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deleteNodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type deleteNodeResponseSuccess = (deleteNodeResponse204) & {
  headers: Headers;
};
export type deleteNodeResponseError = (deleteNodeResponse403 | deleteNodeResponse404 | deleteNodeResponse500) & {
  headers: Headers;
};

export type deleteNodeResponse = (deleteNodeResponseSuccess | deleteNodeResponseError)

export const getDeleteNodeUrl = (publisherId: string,
    nodeId: string,) => {


  

  return `/publishers/${publisherId}/nodes/${nodeId}`
}

export const deleteNode = async (publisherId: string,
    nodeId: string, options?: RequestInit): Promise<deleteNodeResponse> => {
  
  return customInstance<deleteNodeResponse>(getDeleteNodeUrl(publisherId,nodeId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteNodeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext> => {

const mutationKey = ['deleteNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNode>>, {publisherId: string;nodeId: string}> = (props) => {
          const {publisherId,nodeId} = props ?? {};

          return  deleteNode(publisherId,nodeId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteNodeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNode>>>
    
    export type DeleteNodeMutationError = ErrorResponse

    /**
 * @summary Delete a specific node
 */
export const useDeleteNode = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteNode>>,
        TError,
        {publisherId: string;nodeId: string},
        TContext
      > => {
      return useMutation(getDeleteNodeMutationOptions(options), queryClient);
    }
    
/**
 * @summary Update a specific node
 */
export type updateNodeResponse200 = {
  data: Node
  status: 200
}

export type updateNodeResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateNodeResponse401 = {
  data: void
  status: 401
}

export type updateNodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type updateNodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateNodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type updateNodeResponseSuccess = (updateNodeResponse200) & {
  headers: Headers;
};
export type updateNodeResponseError = (updateNodeResponse400 | updateNodeResponse401 | updateNodeResponse403 | updateNodeResponse404 | updateNodeResponse500) & {
  headers: Headers;
};

export type updateNodeResponse = (updateNodeResponseSuccess | updateNodeResponseError)

export const getUpdateNodeUrl = (publisherId: string,
    nodeId: string,) => {


  

  return `/publishers/${publisherId}/nodes/${nodeId}`
}

export const updateNode = async (publisherId: string,
    nodeId: string,
    node: Node, options?: RequestInit): Promise<updateNodeResponse> => {
  
  return customInstance<updateNodeResponse>(getUpdateNodeUrl(publisherId,nodeId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      node,)
  }
);}




export const getUpdateNodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext> => {

const mutationKey = ['updateNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNode>>, {publisherId: string;nodeId: string;data: Node}> = (props) => {
          const {publisherId,nodeId,data} = props ?? {};

          return  updateNode(publisherId,nodeId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof updateNode>>>
    export type UpdateNodeMutationBody = Node
    export type UpdateNodeMutationError = ErrorResponse | void

    /**
 * @summary Update a specific node
 */
export const useUpdateNode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateNode>>,
        TError,
        {publisherId: string;nodeId: string;data: Node},
        TContext
      > => {
      return useMutation(getUpdateNodeMutationOptions(options), queryClient);
    }
    
/**
 * @summary Ban a publisher's Node
 */
export type banPublisherNodeResponse204 = {
  data: void
  status: 204
}

export type banPublisherNodeResponse401 = {
  data: void
  status: 401
}

export type banPublisherNodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type banPublisherNodeResponse404 = {
  data: ErrorResponse
  status: 404
}

export type banPublisherNodeResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type banPublisherNodeResponseSuccess = (banPublisherNodeResponse204) & {
  headers: Headers;
};
export type banPublisherNodeResponseError = (banPublisherNodeResponse401 | banPublisherNodeResponse403 | banPublisherNodeResponse404 | banPublisherNodeResponse500) & {
  headers: Headers;
};

export type banPublisherNodeResponse = (banPublisherNodeResponseSuccess | banPublisherNodeResponseError)

export const getBanPublisherNodeUrl = (publisherId: string,
    nodeId: string,) => {


  

  return `/publishers/${publisherId}/nodes/${nodeId}/ban`
}

export const banPublisherNode = async (publisherId: string,
    nodeId: string, options?: RequestInit): Promise<banPublisherNodeResponse> => {
  
  return customInstance<banPublisherNodeResponse>(getBanPublisherNodeUrl(publisherId,nodeId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getBanPublisherNodeMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisherNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof banPublisherNode>>, TError,{publisherId: string;nodeId: string}, TContext> => {

const mutationKey = ['banPublisherNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof banPublisherNode>>, {publisherId: string;nodeId: string}> = (props) => {
          const {publisherId,nodeId} = props ?? {};

          return  banPublisherNode(publisherId,nodeId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BanPublisherNodeMutationResult = NonNullable<Awaited<ReturnType<typeof banPublisherNode>>>
    
    export type BanPublisherNodeMutationError = void | ErrorResponse

    /**
 * @summary Ban a publisher's Node
 */
export const useBanPublisherNode = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisherNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof banPublisherNode>>,
        TError,
        {publisherId: string;nodeId: string},
        TContext
      > => {
      return useMutation(getBanPublisherNodeMutationOptions(options), queryClient);
    }
    
/**
 * This endpoint allows a publisher to claim an unclaimed node that they own the repo, which is identified by the nodeId. The unclaimed node's repository must be owned by the authenticated user.

 * @summary Claim nodeId into publisherId for the authenticated publisher
 */
export type claimMyNodeResponse204 = {
  data: void
  status: 204
}

export type claimMyNodeResponse400 = {
  data: ErrorResponse
  status: 400
}

export type claimMyNodeResponse401 = {
  data: void
  status: 401
}

export type claimMyNodeResponse403 = {
  data: ErrorResponse
  status: 403
}

export type claimMyNodeResponse429 = {
  data: ErrorResponse
  status: 429
}

export type claimMyNodeResponse500 = {
  data: ErrorResponse
  status: 500
}

export type claimMyNodeResponse503 = {
  data: ErrorResponse
  status: 503
}
    
export type claimMyNodeResponseSuccess = (claimMyNodeResponse204) & {
  headers: Headers;
};
export type claimMyNodeResponseError = (claimMyNodeResponse400 | claimMyNodeResponse401 | claimMyNodeResponse403 | claimMyNodeResponse429 | claimMyNodeResponse500 | claimMyNodeResponse503) & {
  headers: Headers;
};

export type claimMyNodeResponse = (claimMyNodeResponseSuccess | claimMyNodeResponseError)

export const getClaimMyNodeUrl = (publisherId: string,
    nodeId: string,) => {


  

  return `/publishers/${publisherId}/nodes/${nodeId}/claim-my-node`
}

export const claimMyNode = async (publisherId: string,
    nodeId: string,
    claimMyNodeRequest: ClaimMyNodeRequest, options?: RequestInit): Promise<claimMyNodeResponse> => {
  
  return customInstance<claimMyNodeResponse>(getClaimMyNodeUrl(publisherId,nodeId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      claimMyNodeRequest,)
  }
);}




export const getClaimMyNodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof claimMyNode>>, TError,{publisherId: string;nodeId: string;data: ClaimMyNodeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof claimMyNode>>, TError,{publisherId: string;nodeId: string;data: ClaimMyNodeRequest}, TContext> => {

const mutationKey = ['claimMyNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof claimMyNode>>, {publisherId: string;nodeId: string;data: ClaimMyNodeRequest}> = (props) => {
          const {publisherId,nodeId,data} = props ?? {};

          return  claimMyNode(publisherId,nodeId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ClaimMyNodeMutationResult = NonNullable<Awaited<ReturnType<typeof claimMyNode>>>
    export type ClaimMyNodeMutationBody = ClaimMyNodeRequest
    export type ClaimMyNodeMutationError = ErrorResponse | void

    /**
 * @summary Claim nodeId into publisherId for the authenticated publisher
 */
export const useClaimMyNode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof claimMyNode>>, TError,{publisherId: string;nodeId: string;data: ClaimMyNodeRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof claimMyNode>>,
        TError,
        {publisherId: string;nodeId: string;data: ClaimMyNodeRequest},
        TContext
      > => {
      return useMutation(getClaimMyNodeMutationOptions(options), queryClient);
    }
    
/**
 * @summary Retrieve permissions the user has for a given publisher
 */
export type getPermissionOnPublisherNodesResponse200 = {
  data: GetPermissionOnPublisherNodes200
  status: 200
}

export type getPermissionOnPublisherNodesResponse400 = {
  data: ErrorResponse
  status: 400
}

export type getPermissionOnPublisherNodesResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getPermissionOnPublisherNodesResponseSuccess = (getPermissionOnPublisherNodesResponse200) & {
  headers: Headers;
};
export type getPermissionOnPublisherNodesResponseError = (getPermissionOnPublisherNodesResponse400 | getPermissionOnPublisherNodesResponse500) & {
  headers: Headers;
};

export type getPermissionOnPublisherNodesResponse = (getPermissionOnPublisherNodesResponseSuccess | getPermissionOnPublisherNodesResponseError)

export const getGetPermissionOnPublisherNodesUrl = (publisherId: string,
    nodeId: string,) => {


  

  return `/publishers/${publisherId}/nodes/${nodeId}/permissions`
}

export const getPermissionOnPublisherNodes = async (publisherId: string,
    nodeId: string, options?: RequestInit): Promise<getPermissionOnPublisherNodesResponse> => {
  
  return customInstance<getPermissionOnPublisherNodesResponse>(getGetPermissionOnPublisherNodesUrl(publisherId,nodeId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPermissionOnPublisherNodesQueryKey = (publisherId: string,
    nodeId: string,) => {
    return [
    `/publishers/${publisherId}/nodes/${nodeId}/permissions`
    ] as const;
    }

    
export const getGetPermissionOnPublisherNodesQueryOptions = <TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPermissionOnPublisherNodesQueryKey(publisherId,nodeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>> = ({ signal }) => getPermissionOnPublisherNodes(publisherId,nodeId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId && nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPermissionOnPublisherNodesQueryResult = NonNullable<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>>
export type GetPermissionOnPublisherNodesQueryError = ErrorResponse


export function useGetPermissionOnPublisherNodes<TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(
 publisherId: string,
    nodeId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
          TError,
          Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPermissionOnPublisherNodes<TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(
 publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
          TError,
          Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPermissionOnPublisherNodes<TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(
 publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve permissions the user has for a given publisher
 */

export function useGetPermissionOnPublisherNodes<TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(
 publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPermissionOnPublisherNodesQueryOptions(publisherId,nodeId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Publish a new version of a node
 */
export type publishNodeVersionResponse201 = {
  data: PublishNodeVersion201
  status: 201
}

export type publishNodeVersionResponse400 = {
  data: ErrorResponse
  status: 400
}

export type publishNodeVersionResponse403 = {
  data: ErrorResponse
  status: 403
}

export type publishNodeVersionResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type publishNodeVersionResponseSuccess = (publishNodeVersionResponse201) & {
  headers: Headers;
};
export type publishNodeVersionResponseError = (publishNodeVersionResponse400 | publishNodeVersionResponse403 | publishNodeVersionResponse500) & {
  headers: Headers;
};

export type publishNodeVersionResponse = (publishNodeVersionResponseSuccess | publishNodeVersionResponseError)

export const getPublishNodeVersionUrl = (publisherId: string,
    nodeId: string,) => {


  

  return `/publishers/${publisherId}/nodes/${nodeId}/versions`
}

export const publishNodeVersion = async (publisherId: string,
    nodeId: string,
    publishNodeVersionBody: PublishNodeVersionBody, options?: RequestInit): Promise<publishNodeVersionResponse> => {
  
  return customInstance<publishNodeVersionResponse>(getPublishNodeVersionUrl(publisherId,nodeId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      publishNodeVersionBody,)
  }
);}




export const getPublishNodeVersionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext> => {

const mutationKey = ['publishNodeVersion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof publishNodeVersion>>, {publisherId: string;nodeId: string;data: PublishNodeVersionBody}> = (props) => {
          const {publisherId,nodeId,data} = props ?? {};

          return  publishNodeVersion(publisherId,nodeId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PublishNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof publishNodeVersion>>>
    export type PublishNodeVersionMutationBody = PublishNodeVersionBody
    export type PublishNodeVersionMutationError = ErrorResponse

    /**
 * @summary Publish a new version of a node
 */
export const usePublishNodeVersion = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof publishNodeVersion>>,
        TError,
        {publisherId: string;nodeId: string;data: PublishNodeVersionBody},
        TContext
      > => {
      return useMutation(getPublishNodeVersionMutationOptions(options), queryClient);
    }
    
/**
 * @summary Unpublish (delete) a specific version of a node
 */
export type deleteNodeVersionResponse204 = {
  data: void
  status: 204
}

export type deleteNodeVersionResponse403 = {
  data: ErrorResponse
  status: 403
}

export type deleteNodeVersionResponse404 = {
  data: Error
  status: 404
}

export type deleteNodeVersionResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type deleteNodeVersionResponseSuccess = (deleteNodeVersionResponse204) & {
  headers: Headers;
};
export type deleteNodeVersionResponseError = (deleteNodeVersionResponse403 | deleteNodeVersionResponse404 | deleteNodeVersionResponse500) & {
  headers: Headers;
};

export type deleteNodeVersionResponse = (deleteNodeVersionResponseSuccess | deleteNodeVersionResponseError)

export const getDeleteNodeVersionUrl = (publisherId: string,
    nodeId: string,
    versionId: string,) => {


  

  return `/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`
}

export const deleteNodeVersion = async (publisherId: string,
    nodeId: string,
    versionId: string, options?: RequestInit): Promise<deleteNodeVersionResponse> => {
  
  return customInstance<deleteNodeVersionResponse>(getDeleteNodeVersionUrl(publisherId,nodeId,versionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteNodeVersionMutationOptions = <TError = ErrorResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext> => {

const mutationKey = ['deleteNodeVersion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNodeVersion>>, {publisherId: string;nodeId: string;versionId: string}> = (props) => {
          const {publisherId,nodeId,versionId} = props ?? {};

          return  deleteNodeVersion(publisherId,nodeId,versionId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNodeVersion>>>
    
    export type DeleteNodeVersionMutationError = ErrorResponse | Error

    /**
 * @summary Unpublish (delete) a specific version of a node
 */
export const useDeleteNodeVersion = <TError = ErrorResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteNodeVersion>>,
        TError,
        {publisherId: string;nodeId: string;versionId: string},
        TContext
      > => {
      return useMutation(getDeleteNodeVersionMutationOptions(options), queryClient);
    }
    
/**
 * Update only the changelog and deprecated status of a specific version of a node.
 * @summary Update changelog and deprecation status of a node version
 */
export type updateNodeVersionResponse200 = {
  data: NodeVersion
  status: 200
}

export type updateNodeVersionResponse400 = {
  data: ErrorResponse
  status: 400
}

export type updateNodeVersionResponse401 = {
  data: void
  status: 401
}

export type updateNodeVersionResponse403 = {
  data: ErrorResponse
  status: 403
}

export type updateNodeVersionResponse404 = {
  data: ErrorResponse
  status: 404
}

export type updateNodeVersionResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type updateNodeVersionResponseSuccess = (updateNodeVersionResponse200) & {
  headers: Headers;
};
export type updateNodeVersionResponseError = (updateNodeVersionResponse400 | updateNodeVersionResponse401 | updateNodeVersionResponse403 | updateNodeVersionResponse404 | updateNodeVersionResponse500) & {
  headers: Headers;
};

export type updateNodeVersionResponse = (updateNodeVersionResponseSuccess | updateNodeVersionResponseError)

export const getUpdateNodeVersionUrl = (publisherId: string,
    nodeId: string,
    versionId: string,) => {


  

  return `/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`
}

export const updateNodeVersion = async (publisherId: string,
    nodeId: string,
    versionId: string,
    nodeVersionUpdateRequest: NodeVersionUpdateRequest, options?: RequestInit): Promise<updateNodeVersionResponse> => {
  
  return customInstance<updateNodeVersionResponse>(getUpdateNodeVersionUrl(publisherId,nodeId,versionId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      nodeVersionUpdateRequest,)
  }
);}




export const getUpdateNodeVersionMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext> => {

const mutationKey = ['updateNodeVersion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNodeVersion>>, {publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}> = (props) => {
          const {publisherId,nodeId,versionId,data} = props ?? {};

          return  updateNodeVersion(publisherId,nodeId,versionId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof updateNodeVersion>>>
    export type UpdateNodeVersionMutationBody = NodeVersionUpdateRequest
    export type UpdateNodeVersionMutationError = ErrorResponse | void

    /**
 * @summary Update changelog and deprecation status of a node version
 */
export const useUpdateNodeVersion = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateNodeVersion>>,
        TError,
        {publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest},
        TContext
      > => {
      return useMutation(getUpdateNodeVersionMutationOptions(options), queryClient);
    }
    
/**
 * @summary Retrieve permissions the user has for a given publisher
 */
export type getPermissionOnPublisherResponse200 = {
  data: GetPermissionOnPublisher200
  status: 200
}

export type getPermissionOnPublisherResponse400 = {
  data: ErrorResponse
  status: 400
}

export type getPermissionOnPublisherResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getPermissionOnPublisherResponseSuccess = (getPermissionOnPublisherResponse200) & {
  headers: Headers;
};
export type getPermissionOnPublisherResponseError = (getPermissionOnPublisherResponse400 | getPermissionOnPublisherResponse500) & {
  headers: Headers;
};

export type getPermissionOnPublisherResponse = (getPermissionOnPublisherResponseSuccess | getPermissionOnPublisherResponseError)

export const getGetPermissionOnPublisherUrl = (publisherId: string,) => {


  

  return `/publishers/${publisherId}/permissions`
}

export const getPermissionOnPublisher = async (publisherId: string, options?: RequestInit): Promise<getPermissionOnPublisherResponse> => {
  
  return customInstance<getPermissionOnPublisherResponse>(getGetPermissionOnPublisherUrl(publisherId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPermissionOnPublisherQueryKey = (publisherId: string,) => {
    return [
    `/publishers/${publisherId}/permissions`
    ] as const;
    }

    
export const getGetPermissionOnPublisherQueryOptions = <TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPermissionOnPublisherQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPermissionOnPublisher>>> = ({ signal }) => getPermissionOnPublisher(publisherId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPermissionOnPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof getPermissionOnPublisher>>>
export type GetPermissionOnPublisherQueryError = ErrorResponse


export function useGetPermissionOnPublisher<TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(
 publisherId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPermissionOnPublisher>>,
          TError,
          Awaited<ReturnType<typeof getPermissionOnPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPermissionOnPublisher<TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPermissionOnPublisher>>,
          TError,
          Awaited<ReturnType<typeof getPermissionOnPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPermissionOnPublisher<TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve permissions the user has for a given publisher
 */

export function useGetPermissionOnPublisher<TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPermissionOnPublisherQueryOptions(publisherId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Retrieve all personal access tokens for a publisher
 */
export type listPersonalAccessTokensResponse200 = {
  data: PersonalAccessToken[]
  status: 200
}

export type listPersonalAccessTokensResponse403 = {
  data: ErrorResponse
  status: 403
}

export type listPersonalAccessTokensResponse404 = {
  data: ErrorResponse
  status: 404
}

export type listPersonalAccessTokensResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listPersonalAccessTokensResponseSuccess = (listPersonalAccessTokensResponse200) & {
  headers: Headers;
};
export type listPersonalAccessTokensResponseError = (listPersonalAccessTokensResponse403 | listPersonalAccessTokensResponse404 | listPersonalAccessTokensResponse500) & {
  headers: Headers;
};

export type listPersonalAccessTokensResponse = (listPersonalAccessTokensResponseSuccess | listPersonalAccessTokensResponseError)

export const getListPersonalAccessTokensUrl = (publisherId: string,) => {


  

  return `/publishers/${publisherId}/tokens`
}

export const listPersonalAccessTokens = async (publisherId: string, options?: RequestInit): Promise<listPersonalAccessTokensResponse> => {
  
  return customInstance<listPersonalAccessTokensResponse>(getListPersonalAccessTokensUrl(publisherId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListPersonalAccessTokensQueryKey = (publisherId: string,) => {
    return [
    `/publishers/${publisherId}/tokens`
    ] as const;
    }

    
export const getListPersonalAccessTokensQueryOptions = <TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPersonalAccessTokensQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPersonalAccessTokens>>> = ({ signal }) => listPersonalAccessTokens(publisherId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPersonalAccessTokensQueryResult = NonNullable<Awaited<ReturnType<typeof listPersonalAccessTokens>>>
export type ListPersonalAccessTokensQueryError = ErrorResponse


export function useListPersonalAccessTokens<TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(
 publisherId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPersonalAccessTokens>>,
          TError,
          Awaited<ReturnType<typeof listPersonalAccessTokens>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPersonalAccessTokens<TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPersonalAccessTokens>>,
          TError,
          Awaited<ReturnType<typeof listPersonalAccessTokens>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPersonalAccessTokens<TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve all personal access tokens for a publisher
 */

export function useListPersonalAccessTokens<TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPersonalAccessTokensQueryOptions(publisherId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a new personal access token
 */
export type createPersonalAccessTokenResponse201 = {
  data: CreatePersonalAccessToken201
  status: 201
}

export type createPersonalAccessTokenResponse400 = {
  data: ErrorResponse
  status: 400
}

export type createPersonalAccessTokenResponse403 = {
  data: ErrorResponse
  status: 403
}

export type createPersonalAccessTokenResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type createPersonalAccessTokenResponseSuccess = (createPersonalAccessTokenResponse201) & {
  headers: Headers;
};
export type createPersonalAccessTokenResponseError = (createPersonalAccessTokenResponse400 | createPersonalAccessTokenResponse403 | createPersonalAccessTokenResponse500) & {
  headers: Headers;
};

export type createPersonalAccessTokenResponse = (createPersonalAccessTokenResponseSuccess | createPersonalAccessTokenResponseError)

export const getCreatePersonalAccessTokenUrl = (publisherId: string,) => {


  

  return `/publishers/${publisherId}/tokens`
}

export const createPersonalAccessToken = async (publisherId: string,
    personalAccessToken: PersonalAccessToken, options?: RequestInit): Promise<createPersonalAccessTokenResponse> => {
  
  return customInstance<createPersonalAccessTokenResponse>(getCreatePersonalAccessTokenUrl(publisherId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      personalAccessToken,)
  }
);}




export const getCreatePersonalAccessTokenMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext> => {

const mutationKey = ['createPersonalAccessToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPersonalAccessToken>>, {publisherId: string;data: PersonalAccessToken}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  createPersonalAccessToken(publisherId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePersonalAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof createPersonalAccessToken>>>
    export type CreatePersonalAccessTokenMutationBody = PersonalAccessToken
    export type CreatePersonalAccessTokenMutationError = ErrorResponse

    /**
 * @summary Create a new personal access token
 */
export const useCreatePersonalAccessToken = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPersonalAccessToken>>,
        TError,
        {publisherId: string;data: PersonalAccessToken},
        TContext
      > => {
      return useMutation(getCreatePersonalAccessTokenMutationOptions(options), queryClient);
    }
    
/**
 * @summary Delete a specific personal access token
 */
export type deletePersonalAccessTokenResponse204 = {
  data: void
  status: 204
}

export type deletePersonalAccessTokenResponse403 = {
  data: ErrorResponse
  status: 403
}

export type deletePersonalAccessTokenResponse404 = {
  data: ErrorResponse
  status: 404
}

export type deletePersonalAccessTokenResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type deletePersonalAccessTokenResponseSuccess = (deletePersonalAccessTokenResponse204) & {
  headers: Headers;
};
export type deletePersonalAccessTokenResponseError = (deletePersonalAccessTokenResponse403 | deletePersonalAccessTokenResponse404 | deletePersonalAccessTokenResponse500) & {
  headers: Headers;
};

export type deletePersonalAccessTokenResponse = (deletePersonalAccessTokenResponseSuccess | deletePersonalAccessTokenResponseError)

export const getDeletePersonalAccessTokenUrl = (publisherId: string,
    tokenId: string,) => {


  

  return `/publishers/${publisherId}/tokens/${tokenId}`
}

export const deletePersonalAccessToken = async (publisherId: string,
    tokenId: string, options?: RequestInit): Promise<deletePersonalAccessTokenResponse> => {
  
  return customInstance<deletePersonalAccessTokenResponse>(getDeletePersonalAccessTokenUrl(publisherId,tokenId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeletePersonalAccessTokenMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext> => {

const mutationKey = ['deletePersonalAccessToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePersonalAccessToken>>, {publisherId: string;tokenId: string}> = (props) => {
          const {publisherId,tokenId} = props ?? {};

          return  deletePersonalAccessToken(publisherId,tokenId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePersonalAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof deletePersonalAccessToken>>>
    
    export type DeletePersonalAccessTokenMutationError = ErrorResponse

    /**
 * @summary Delete a specific personal access token
 */
export const useDeletePersonalAccessToken = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePersonalAccessToken>>,
        TError,
        {publisherId: string;tokenId: string},
        TContext
      > => {
      return useMutation(getDeletePersonalAccessTokenMutationOptions(options), queryClient);
    }
    
/**
 * Fetch release notes from Strapi with caching
 * @summary Get release notes
 */
export type getReleaseNotesResponse200 = {
  data: ReleaseNote[]
  status: 200
}

export type getReleaseNotesResponse400 = {
  data: ErrorResponse
  status: 400
}

export type getReleaseNotesResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getReleaseNotesResponseSuccess = (getReleaseNotesResponse200) & {
  headers: Headers;
};
export type getReleaseNotesResponseError = (getReleaseNotesResponse400 | getReleaseNotesResponse500) & {
  headers: Headers;
};

export type getReleaseNotesResponse = (getReleaseNotesResponseSuccess | getReleaseNotesResponseError)

export const getGetReleaseNotesUrl = (params: GetReleaseNotesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/releases?${stringifiedParams}` : `/releases`
}

export const getReleaseNotes = async (params: GetReleaseNotesParams, options?: RequestInit): Promise<getReleaseNotesResponse> => {
  
  return customInstance<getReleaseNotesResponse>(getGetReleaseNotesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetReleaseNotesQueryKey = (params?: GetReleaseNotesParams,) => {
    return [
    `/releases`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetReleaseNotesQueryOptions = <TData = Awaited<ReturnType<typeof getReleaseNotes>>, TError = ErrorResponse>(params: GetReleaseNotesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReleaseNotes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReleaseNotesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReleaseNotes>>> = ({ signal }) => getReleaseNotes(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReleaseNotes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReleaseNotesQueryResult = NonNullable<Awaited<ReturnType<typeof getReleaseNotes>>>
export type GetReleaseNotesQueryError = ErrorResponse


export function useGetReleaseNotes<TData = Awaited<ReturnType<typeof getReleaseNotes>>, TError = ErrorResponse>(
 params: GetReleaseNotesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReleaseNotes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReleaseNotes>>,
          TError,
          Awaited<ReturnType<typeof getReleaseNotes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReleaseNotes<TData = Awaited<ReturnType<typeof getReleaseNotes>>, TError = ErrorResponse>(
 params: GetReleaseNotesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReleaseNotes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReleaseNotes>>,
          TError,
          Awaited<ReturnType<typeof getReleaseNotes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReleaseNotes<TData = Awaited<ReturnType<typeof getReleaseNotes>>, TError = ErrorResponse>(
 params: GetReleaseNotesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReleaseNotes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get release notes
 */

export function useGetReleaseNotes<TData = Awaited<ReturnType<typeof getReleaseNotes>>, TError = ErrorResponse>(
 params: GetReleaseNotesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReleaseNotes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReleaseNotesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Webhook endpoint to process Github release events and generate release notes
 * @summary Process Github release webhook
 */
export type processReleaseWebhookResponse200 = {
  data: void
  status: 200
}

export type processReleaseWebhookResponse400 = {
  data: ErrorResponse
  status: 400
}

export type processReleaseWebhookResponse422 = {
  data: ErrorResponse
  status: 422
}

export type processReleaseWebhookResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type processReleaseWebhookResponseSuccess = (processReleaseWebhookResponse200) & {
  headers: Headers;
};
export type processReleaseWebhookResponseError = (processReleaseWebhookResponse400 | processReleaseWebhookResponse422 | processReleaseWebhookResponse500) & {
  headers: Headers;
};

export type processReleaseWebhookResponse = (processReleaseWebhookResponseSuccess | processReleaseWebhookResponseError)

export const getProcessReleaseWebhookUrl = () => {


  

  return `/releases`
}

export const processReleaseWebhook = async (githubReleaseWebhook: GithubReleaseWebhook, options?: RequestInit): Promise<processReleaseWebhookResponse> => {
  
  return customInstance<processReleaseWebhookResponse>(getProcessReleaseWebhookUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      githubReleaseWebhook,)
  }
);}




export const getProcessReleaseWebhookMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processReleaseWebhook>>, TError,{data: GithubReleaseWebhook}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof processReleaseWebhook>>, TError,{data: GithubReleaseWebhook}, TContext> => {

const mutationKey = ['processReleaseWebhook'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processReleaseWebhook>>, {data: GithubReleaseWebhook}> = (props) => {
          const {data} = props ?? {};

          return  processReleaseWebhook(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessReleaseWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof processReleaseWebhook>>>
    export type ProcessReleaseWebhookMutationBody = GithubReleaseWebhook
    export type ProcessReleaseWebhookMutationError = ErrorResponse

    /**
 * @summary Process Github release webhook
 */
export const useProcessReleaseWebhook = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processReleaseWebhook>>, TError,{data: GithubReleaseWebhook}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof processReleaseWebhook>>,
        TError,
        {data: GithubReleaseWebhook},
        TContext
      > => {
      return useMutation(getProcessReleaseWebhookMutationOptions(options), queryClient);
    }
    
/**
 * Pull all pending node versions and conduct security scans.
 * @summary Security Scan
 */
export type securityScanResponse200 = {
  data: void
  status: 200
}

export type securityScanResponse400 = {
  data: ErrorResponse
  status: 400
}

export type securityScanResponse401 = {
  data: void
  status: 401
}

export type securityScanResponse403 = {
  data: ErrorResponse
  status: 403
}

export type securityScanResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type securityScanResponseSuccess = (securityScanResponse200) & {
  headers: Headers;
};
export type securityScanResponseError = (securityScanResponse400 | securityScanResponse401 | securityScanResponse403 | securityScanResponse500) & {
  headers: Headers;
};

export type securityScanResponse = (securityScanResponseSuccess | securityScanResponseError)

export const getSecurityScanUrl = (params?: SecurityScanParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/security-scan?${stringifiedParams}` : `/security-scan`
}

export const securityScan = async (params?: SecurityScanParams, options?: RequestInit): Promise<securityScanResponse> => {
  
  return customInstance<securityScanResponse>(getSecurityScanUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getSecurityScanQueryKey = (params?: SecurityScanParams,) => {
    return [
    `/security-scan`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getSecurityScanQueryOptions = <TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse | void>(params?: SecurityScanParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSecurityScanQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof securityScan>>> = ({ signal }) => securityScan(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SecurityScanQueryResult = NonNullable<Awaited<ReturnType<typeof securityScan>>>
export type SecurityScanQueryError = ErrorResponse | void


export function useSecurityScan<TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse | void>(
 params: undefined |  SecurityScanParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof securityScan>>,
          TError,
          Awaited<ReturnType<typeof securityScan>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSecurityScan<TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse | void>(
 params?: SecurityScanParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof securityScan>>,
          TError,
          Awaited<ReturnType<typeof securityScan>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSecurityScan<TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse | void>(
 params?: SecurityScanParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Security Scan
 */

export function useSecurityScan<TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse | void>(
 params?: SecurityScanParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSecurityScanQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Receive artifacts (output files) from the ComfyUI GitHub Action
 * @summary Receive artifacts (output files) from the ComfyUI GitHub Action
 */
export type postUploadArtifactResponse200 = {
  data: PostUploadArtifact200
  status: 200
}

export type postUploadArtifactResponse400 = {
  data: void
  status: 400
}

export type postUploadArtifactResponse500 = {
  data: void
  status: 500
}
    
export type postUploadArtifactResponseSuccess = (postUploadArtifactResponse200) & {
  headers: Headers;
};
export type postUploadArtifactResponseError = (postUploadArtifactResponse400 | postUploadArtifactResponse500) & {
  headers: Headers;
};

export type postUploadArtifactResponse = (postUploadArtifactResponseSuccess | postUploadArtifactResponseError)

export const getPostUploadArtifactUrl = () => {


  

  return `/upload-artifact`
}

export const postUploadArtifact = async (postUploadArtifactBody: PostUploadArtifactBody, options?: RequestInit): Promise<postUploadArtifactResponse> => {
  
  return customInstance<postUploadArtifactResponse>(getPostUploadArtifactUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postUploadArtifactBody,)
  }
);}




export const getPostUploadArtifactMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext> => {

const mutationKey = ['postUploadArtifact'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUploadArtifact>>, {data: PostUploadArtifactBody}> = (props) => {
          const {data} = props ?? {};

          return  postUploadArtifact(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostUploadArtifactMutationResult = NonNullable<Awaited<ReturnType<typeof postUploadArtifact>>>
    export type PostUploadArtifactMutationBody = PostUploadArtifactBody
    export type PostUploadArtifactMutationError = void

    /**
 * @summary Receive artifacts (output files) from the ComfyUI GitHub Action
 */
export const usePostUploadArtifact = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postUploadArtifact>>,
        TError,
        {data: PostUploadArtifactBody},
        TContext
      > => {
      return useMutation(getPostUploadArtifactMutationOptions(options), queryClient);
    }
    
/**
 * @summary Get information about the calling user.
 */
export type getUserResponse200 = {
  data: User
  status: 200
}

export type getUserResponse401 = {
  data: void
  status: 401
}

export type getUserResponse404 = {
  data: void
  status: 404
}
    
export type getUserResponseSuccess = (getUserResponse200) & {
  headers: Headers;
};
export type getUserResponseError = (getUserResponse401 | getUserResponse404) & {
  headers: Headers;
};

export type getUserResponse = (getUserResponseSuccess | getUserResponseError)

export const getGetUserUrl = () => {


  

  return `/users`
}

export const getUser = async ( options?: RequestInit): Promise<getUserResponse> => {
  
  return customInstance<getUserResponse>(getGetUserUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetUserQueryKey = () => {
    return [
    `/users`
    ] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = void


export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get information about the calling user.
 */

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Retrieve all publishers for a given user
 */
export type listPublishersForUserResponse200 = {
  data: Publisher[]
  status: 200
}

export type listPublishersForUserResponse400 = {
  data: ErrorResponse
  status: 400
}

export type listPublishersForUserResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listPublishersForUserResponseSuccess = (listPublishersForUserResponse200) & {
  headers: Headers;
};
export type listPublishersForUserResponseError = (listPublishersForUserResponse400 | listPublishersForUserResponse500) & {
  headers: Headers;
};

export type listPublishersForUserResponse = (listPublishersForUserResponseSuccess | listPublishersForUserResponseError)

export const getListPublishersForUserUrl = () => {


  

  return `/users/publishers/`
}

export const listPublishersForUser = async ( options?: RequestInit): Promise<listPublishersForUserResponse> => {
  
  return customInstance<listPublishersForUserResponse>(getListPublishersForUserUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListPublishersForUserQueryKey = () => {
    return [
    `/users/publishers/`
    ] as const;
    }

    
export const getListPublishersForUserQueryOptions = <TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPublishersForUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPublishersForUser>>> = ({ signal }) => listPublishersForUser({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPublishersForUserQueryResult = NonNullable<Awaited<ReturnType<typeof listPublishersForUser>>>
export type ListPublishersForUserQueryError = ErrorResponse


export function useListPublishersForUser<TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPublishersForUser>>,
          TError,
          Awaited<ReturnType<typeof listPublishersForUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPublishersForUser<TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPublishersForUser>>,
          TError,
          Awaited<ReturnType<typeof listPublishersForUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPublishersForUser<TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve all publishers for a given user
 */

export function useListPublishersForUser<TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPublishersForUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary List all node versions given some filters.
 */
export type listAllNodeVersionsResponse200 = {
  data: ListAllNodeVersions200
  status: 200
}

export type listAllNodeVersionsResponse400 = {
  data: ErrorResponse
  status: 400
}

export type listAllNodeVersionsResponse403 = {
  data: ErrorResponse
  status: 403
}

export type listAllNodeVersionsResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type listAllNodeVersionsResponseSuccess = (listAllNodeVersionsResponse200) & {
  headers: Headers;
};
export type listAllNodeVersionsResponseError = (listAllNodeVersionsResponse400 | listAllNodeVersionsResponse403 | listAllNodeVersionsResponse500) & {
  headers: Headers;
};

export type listAllNodeVersionsResponse = (listAllNodeVersionsResponseSuccess | listAllNodeVersionsResponseError)

export const getListAllNodeVersionsUrl = (params?: ListAllNodeVersionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["statuses"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/versions?${stringifiedParams}` : `/versions`
}

export const listAllNodeVersions = async (params?: ListAllNodeVersionsParams, options?: RequestInit): Promise<listAllNodeVersionsResponse> => {
  
  return customInstance<listAllNodeVersionsResponse>(getListAllNodeVersionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListAllNodeVersionsQueryKey = (params?: ListAllNodeVersionsParams,) => {
    return [
    `/versions`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListAllNodeVersionsQueryOptions = <TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(params?: ListAllNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAllNodeVersionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllNodeVersions>>> = ({ signal }) => listAllNodeVersions(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAllNodeVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof listAllNodeVersions>>>
export type ListAllNodeVersionsQueryError = ErrorResponse


export function useListAllNodeVersions<TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(
 params: undefined |  ListAllNodeVersionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllNodeVersions>>,
          TError,
          Awaited<ReturnType<typeof listAllNodeVersions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAllNodeVersions<TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(
 params?: ListAllNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllNodeVersions>>,
          TError,
          Awaited<ReturnType<typeof listAllNodeVersions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAllNodeVersions<TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(
 params?: ListAllNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all node versions given some filters.
 */

export function useListAllNodeVersions<TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(
 params?: ListAllNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListAllNodeVersionsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary receive alert on remaining balance is 0
 */
export type metronomeZeroBalanceResponse200 = {
  data: IdeogramGenerateResponse
  status: 200
}

export type metronomeZeroBalanceResponse400 = {
  data: ErrorResponse
  status: 400
}

export type metronomeZeroBalanceResponse401 = {
  data: void
  status: 401
}

export type metronomeZeroBalanceResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type metronomeZeroBalanceResponseSuccess = (metronomeZeroBalanceResponse200) & {
  headers: Headers;
};
export type metronomeZeroBalanceResponseError = (metronomeZeroBalanceResponse400 | metronomeZeroBalanceResponse401 | metronomeZeroBalanceResponse500) & {
  headers: Headers;
};

export type metronomeZeroBalanceResponse = (metronomeZeroBalanceResponseSuccess | metronomeZeroBalanceResponseError)

export const getMetronomeZeroBalanceUrl = () => {


  

  return `/webhook/metronome/zero-balance`
}

export const metronomeZeroBalance = async (metronomeZeroBalanceBody: MetronomeZeroBalanceBody, options?: RequestInit): Promise<metronomeZeroBalanceResponse> => {
  
  return customInstance<metronomeZeroBalanceResponse>(getMetronomeZeroBalanceUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      metronomeZeroBalanceBody,)
  }
);}




export const getMetronomeZeroBalanceMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof metronomeZeroBalance>>, TError,{data: MetronomeZeroBalanceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof metronomeZeroBalance>>, TError,{data: MetronomeZeroBalanceBody}, TContext> => {

const mutationKey = ['metronomeZeroBalance'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof metronomeZeroBalance>>, {data: MetronomeZeroBalanceBody}> = (props) => {
          const {data} = props ?? {};

          return  metronomeZeroBalance(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type MetronomeZeroBalanceMutationResult = NonNullable<Awaited<ReturnType<typeof metronomeZeroBalance>>>
    export type MetronomeZeroBalanceMutationBody = MetronomeZeroBalanceBody
    export type MetronomeZeroBalanceMutationError = ErrorResponse | void

    /**
 * @summary receive alert on remaining balance is 0
 */
export const useMetronomeZeroBalance = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof metronomeZeroBalance>>, TError,{data: MetronomeZeroBalanceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof metronomeZeroBalance>>,
        TError,
        {data: MetronomeZeroBalanceBody},
        TContext
      > => {
      return useMutation(getMetronomeZeroBalanceMutationOptions(options), queryClient);
    }
    
/**
 * @summary Handle Stripe invoice.paid webhook event
 */
export type stripeInvoiceStatusResponse200 = {
  data: void
  status: 200
}

export type stripeInvoiceStatusResponse400 = {
  data: ErrorResponse
  status: 400
}

export type stripeInvoiceStatusResponse401 = {
  data: void
  status: 401
}

export type stripeInvoiceStatusResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type stripeInvoiceStatusResponseSuccess = (stripeInvoiceStatusResponse200) & {
  headers: Headers;
};
export type stripeInvoiceStatusResponseError = (stripeInvoiceStatusResponse400 | stripeInvoiceStatusResponse401 | stripeInvoiceStatusResponse500) & {
  headers: Headers;
};

export type stripeInvoiceStatusResponse = (stripeInvoiceStatusResponseSuccess | stripeInvoiceStatusResponseError)

export const getStripeInvoiceStatusUrl = () => {


  

  return `/webhook/stripe/invoice-status`
}

export const stripeInvoiceStatus = async (stripeEvent: StripeEvent, options?: RequestInit): Promise<stripeInvoiceStatusResponse> => {
  
  return customInstance<stripeInvoiceStatusResponse>(getStripeInvoiceStatusUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      stripeEvent,)
  }
);}




export const getStripeInvoiceStatusMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stripeInvoiceStatus>>, TError,{data: StripeEvent}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stripeInvoiceStatus>>, TError,{data: StripeEvent}, TContext> => {

const mutationKey = ['stripeInvoiceStatus'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stripeInvoiceStatus>>, {data: StripeEvent}> = (props) => {
          const {data} = props ?? {};

          return  stripeInvoiceStatus(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StripeInvoiceStatusMutationResult = NonNullable<Awaited<ReturnType<typeof stripeInvoiceStatus>>>
    export type StripeInvoiceStatusMutationBody = StripeEvent
    export type StripeInvoiceStatusMutationError = ErrorResponse | void

    /**
 * @summary Handle Stripe invoice.paid webhook event
 */
export const useStripeInvoiceStatus = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stripeInvoiceStatus>>, TError,{data: StripeEvent}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stripeInvoiceStatus>>,
        TError,
        {data: StripeEvent},
        TContext
      > => {
      return useMutation(getStripeInvoiceStatusMutationOptions(options), queryClient);
    }
    
/**
 * @summary Handle Stripe subscription webhook events
 */
export type stripeSubscriptionWebhookResponse200 = {
  data: void
  status: 200
}

export type stripeSubscriptionWebhookResponse400 = {
  data: ErrorResponse
  status: 400
}

export type stripeSubscriptionWebhookResponse401 = {
  data: void
  status: 401
}

export type stripeSubscriptionWebhookResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type stripeSubscriptionWebhookResponseSuccess = (stripeSubscriptionWebhookResponse200) & {
  headers: Headers;
};
export type stripeSubscriptionWebhookResponseError = (stripeSubscriptionWebhookResponse400 | stripeSubscriptionWebhookResponse401 | stripeSubscriptionWebhookResponse500) & {
  headers: Headers;
};

export type stripeSubscriptionWebhookResponse = (stripeSubscriptionWebhookResponseSuccess | stripeSubscriptionWebhookResponseError)

export const getStripeSubscriptionWebhookUrl = () => {


  

  return `/webhook/stripe/subscription`
}

export const stripeSubscriptionWebhook = async (stripeSubscriptionWebhookBody: StripeSubscriptionWebhookBody, options?: RequestInit): Promise<stripeSubscriptionWebhookResponse> => {
  
  return customInstance<stripeSubscriptionWebhookResponse>(getStripeSubscriptionWebhookUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      stripeSubscriptionWebhookBody,)
  }
);}




export const getStripeSubscriptionWebhookMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stripeSubscriptionWebhook>>, TError,{data: StripeSubscriptionWebhookBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stripeSubscriptionWebhook>>, TError,{data: StripeSubscriptionWebhookBody}, TContext> => {

const mutationKey = ['stripeSubscriptionWebhook'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stripeSubscriptionWebhook>>, {data: StripeSubscriptionWebhookBody}> = (props) => {
          const {data} = props ?? {};

          return  stripeSubscriptionWebhook(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type StripeSubscriptionWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof stripeSubscriptionWebhook>>>
    export type StripeSubscriptionWebhookMutationBody = StripeSubscriptionWebhookBody
    export type StripeSubscriptionWebhookMutationError = ErrorResponse | void

    /**
 * @summary Handle Stripe subscription webhook events
 */
export const useStripeSubscriptionWebhook = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stripeSubscriptionWebhook>>, TError,{data: StripeSubscriptionWebhookBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof stripeSubscriptionWebhook>>,
        TError,
        {data: StripeSubscriptionWebhookBody},
        TContext
      > => {
      return useMutation(getStripeSubscriptionWebhookMutationOptions(options), queryClient);
    }
    
/**
 * @summary Retrieve a specific commit by ID
 */
export type getWorkflowResultResponse200 = {
  data: ActionJobResult
  status: 200
}

export type getWorkflowResultResponse404 = {
  data: ErrorResponse
  status: 404
}

export type getWorkflowResultResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getWorkflowResultResponseSuccess = (getWorkflowResultResponse200) & {
  headers: Headers;
};
export type getWorkflowResultResponseError = (getWorkflowResultResponse404 | getWorkflowResultResponse500) & {
  headers: Headers;
};

export type getWorkflowResultResponse = (getWorkflowResultResponseSuccess | getWorkflowResultResponseError)

export const getGetWorkflowResultUrl = (workflowResultId: string,) => {


  

  return `/workflowresult/${workflowResultId}`
}

export const getWorkflowResult = async (workflowResultId: string, options?: RequestInit): Promise<getWorkflowResultResponse> => {
  
  return customInstance<getWorkflowResultResponse>(getGetWorkflowResultUrl(workflowResultId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetWorkflowResultQueryKey = (workflowResultId: string,) => {
    return [
    `/workflowresult/${workflowResultId}`
    ] as const;
    }

    
export const getGetWorkflowResultQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowResult>>, TError = ErrorResponse>(workflowResultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowResultQueryKey(workflowResultId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowResult>>> = ({ signal }) => getWorkflowResult(workflowResultId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(workflowResultId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWorkflowResultQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowResult>>>
export type GetWorkflowResultQueryError = ErrorResponse


export function useGetWorkflowResult<TData = Awaited<ReturnType<typeof getWorkflowResult>>, TError = ErrorResponse>(
 workflowResultId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowResult>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowResult<TData = Awaited<ReturnType<typeof getWorkflowResult>>, TError = ErrorResponse>(
 workflowResultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowResult>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWorkflowResult<TData = Awaited<ReturnType<typeof getWorkflowResult>>, TError = ErrorResponse>(
 workflowResultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a specific commit by ID
 */

export function useGetWorkflowResult<TData = Awaited<ReturnType<typeof getWorkflowResult>>, TError = ErrorResponse>(
 workflowResultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWorkflowResultQueryOptions(workflowResultId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}
