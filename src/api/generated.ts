/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * Comfy API
 * OpenAPI spec version: 1.0
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';

import { customInstance } from './mutator/axios-instance';
export interface ActionJobResult {
  /** Identifier of the job this result belongs to */
  action_job_id?: string;
  /** Identifier of the run this result belongs to */
  action_run_id?: string;
  /** The author of the commit */
  author?: string;
  /** The average VRAM used by the job */
  avg_vram?: number;
  /** Name of the relevant git branch */
  branch_name?: string;
  /** The comfy run flags. E.g. `--low-vram` */
  comfy_run_flags?: string;
  /** The hash of the commit */
  commit_hash?: string;
  /** The ID of the commit */
  commit_id?: string;
  /** The message of the commit */
  commit_message?: string;
  /** The Unix timestamp when the commit was made */
  commit_time?: number;
  /** CUDA version used */
  cuda_version?: string;
  /** The end time of the job as a Unix timestamp. */
  end_time?: number;
  /** The repository name */
  git_repo?: string;
  /** Unique identifier for the job result */
  id?: string;
  /** The user who triggered the job. */
  job_trigger_user?: string;
  machine_stats?: MachineStats;
  /** Operating system used */
  operating_system?: string;
  /** The peak VRAM used by the job */
  peak_vram?: number;
  /** The pull request number */
  pr_number?: string;
  /** PyTorch version used */
  python_version?: string;
  /** PyTorch version used */
  pytorch_version?: string;
  /** The start time of the job as a Unix timestamp. */
  start_time?: number;
  status?: WorkflowRunStatus;
  storage_file?: StorageFile;
  /** Name of the workflow */
  workflow_name?: string;
}

export interface ComfyNode {
  /** UI category where the node is listed, used for grouping nodes. */
  category?: string;
  /** Unique identifier for the node */
  comfy_node_name?: string;
  /** Indicates if the node is deprecated. Deprecated nodes are hidden in the UI. */
  deprecated?: boolean;
  /** Brief description of the node's functionality or purpose. */
  description?: string;
  /** Indicates if the node is experimental, subject to changes or removal. */
  experimental?: boolean;
  /** Name of the entry-point function to execute the node. */
  function?: string;
  /** Defines input parameters */
  input_types?: string;
  /** Boolean values indicating if each output is a list. */
  output_is_list?: boolean[];
  /** Names of the outputs for clarity in workflows. */
  return_names?: string;
  /** Specifies the types of outputs produced by the node. */
  return_types?: string;
}

export interface ComfyNodeCloudBuildInfo {
  build_id?: string;
  location?: string;
  project_id?: string;
  project_number?: string;
}

export interface Error {
  /** Optional detailed information about the error or hints for resolving it. */
  details?: string[];
  /** A clear and concise description of the error. */
  message?: string;
}

export interface ErrorResponse {
  error: string;
  message: string;
}

/**
 * A map of operating system to status pairs
 */
export type GitCommitSummaryStatusSummary = {[key: string]: string};

export interface GitCommitSummary {
  /** The author of the commit */
  author?: string;
  /** The branch where the commit was made */
  branch_name?: string;
  /** The hash of the commit */
  commit_hash?: string;
  /** The name of the commit */
  commit_name?: string;
  /** A map of operating system to status pairs */
  status_summary?: GitCommitSummaryStatusSummary;
  /** The timestamp when the commit was made */
  timestamp?: string;
}

/**
 * Time series of VRAM usage.
 */
export type MachineStatsVramTimeSeries = { [key: string]: unknown };

export interface MachineStats {
  /** Total CPU on the machine. */
  cpu_capacity?: string;
  /** Total disk capacity on the machine. */
  disk_capacity?: string;
  /** The GPU type. eg. NVIDIA Tesla K80 */
  gpu_type?: string;
  /** Initial CPU available before the job starts. */
  initial_cpu?: string;
  /** Initial disk available before the job starts. */
  initial_disk?: string;
  /** Initial RAM available before the job starts. */
  initial_ram?: string;
  /** Name of the machine. */
  machine_name?: string;
  /** Total memory on the machine. */
  memory_capacity?: string;
  /** The operating system version. eg. Ubuntu Linux 20.04 */
  os_version?: string;
  /** The pip freeze output */
  pip_freeze?: string;
  /** Time series of VRAM usage. */
  vram_time_series?: MachineStatsVramTimeSeries;
}

export type NodeTranslations = {[key: string]: { [key: string]: unknown }};

export interface Node {
  author?: string;
  /** The category of the node. */
  category?: string;
  description?: string;
  /** The number of downloads of the node. */
  downloads?: number;
  /** URL to the node's icon. */
  icon?: string;
  /** The unique identifier of the node. */
  id?: string;
  latest_version?: NodeVersion;
  /** The path to the LICENSE file in the node's repository. */
  license?: string;
  /** The display name of the node. */
  name?: string;
  publisher?: Publisher;
  /** The average rating of the node. */
  rating?: number;
  /** URL to the node's repository. */
  repository?: string;
  status?: NodeStatus;
  /** The status detail of the node. */
  status_detail?: string;
  tags?: string[];
  translations?: NodeTranslations;
}

export type NodeStatus = typeof NodeStatus[keyof typeof NodeStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NodeStatus = {
  NodeStatusActive: 'NodeStatusActive',
  NodeStatusDeleted: 'NodeStatusDeleted',
  NodeStatusBanned: 'NodeStatusBanned',
} as const;

export interface NodeVersion {
  /** Summary of changes made in this version */
  changelog?: string;
  /** The status of comfy node extraction process. */
  comfy_node_extract_status?: string;
  /** The date and time the version was created. */
  createdAt?: string;
  /** A list of pip dependencies required by the node. */
  dependencies?: string[];
  /** Indicates if this version is deprecated. */
  deprecated?: boolean;
  /** [Output Only] URL to download this version of the node */
  downloadUrl?: string;
  id?: string;
  /** The unique identifier of the node. */
  node_id?: string;
  status?: NodeVersionStatus;
  /** The reason for the status change. */
  status_reason?: string;
  /** The version identifier, following semantic versioning. Must be unique for the node. */
  version?: string;
}

export type NodeVersionStatus = typeof NodeVersionStatus[keyof typeof NodeVersionStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NodeVersionStatus = {
  NodeVersionStatusActive: 'NodeVersionStatusActive',
  NodeVersionStatusDeleted: 'NodeVersionStatusDeleted',
  NodeVersionStatusBanned: 'NodeVersionStatusBanned',
  NodeVersionStatusPending: 'NodeVersionStatusPending',
  NodeVersionStatusFlagged: 'NodeVersionStatusFlagged',
} as const;

export interface NodeVersionUpdateRequest {
  /** The changelog describing the version changes. */
  changelog?: string;
  /** Whether the version is deprecated. */
  deprecated?: boolean;
}

export interface PersonalAccessToken {
  /** [Output Only]The date and time the token was created. */
  createdAt?: string;
  /** Optional. A more detailed description of the token's intended use. */
  description?: string;
  /** Unique identifier for the GitCommit */
  id?: string;
  /** Required. The name of the token. Can be a simple description. */
  name?: string;
  /** [Output Only]. The personal access token. Only returned during creation. */
  token?: string;
}

export interface Publisher {
  /** The date and time the publisher was created. */
  createdAt?: string;
  description?: string;
  /** The unique identifier for the publisher. It's akin to a username. Should be lowercase. */
  id?: string;
  /** URL to the publisher's logo. */
  logo?: string;
  /** A list of members in the publisher. */
  members?: PublisherMember[];
  name?: string;
  source_code_repo?: string;
  status?: PublisherStatus;
  support?: string;
  website?: string;
}

export interface PublisherMember {
  /** The unique identifier for the publisher member. */
  id?: string;
  /** The role of the user in the publisher. */
  role?: string;
  user?: PublisherUser;
}

export type PublisherStatus = typeof PublisherStatus[keyof typeof PublisherStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PublisherStatus = {
  PublisherStatusActive: 'PublisherStatusActive',
  PublisherStatusBanned: 'PublisherStatusBanned',
} as const;

export interface PublisherUser {
  /** The email address for this user. */
  email?: string;
  /** The unique id for this user. */
  id?: string;
  /** The name for this user. */
  name?: string;
}

export interface StorageFile {
  /** Path to the file in storage */
  file_path?: string;
  /** Unique identifier for the storage file */
  id?: string;
  /** Public URL */
  public_url?: string;
}

export interface User {
  /** The email address for this user. */
  email?: string;
  /** The unique id for this user. */
  id?: string;
  /** Indicates if the user has admin privileges. */
  isAdmin?: boolean;
  /** Indicates if the user is approved. */
  isApproved?: boolean;
  /** The name for this user. */
  name?: string;
}

export type WorkflowRunStatus = typeof WorkflowRunStatus[keyof typeof WorkflowRunStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkflowRunStatus = {
  WorkflowRunStatusStarted: 'WorkflowRunStatusStarted',
  WorkflowRunStatusFailed: 'WorkflowRunStatusFailed',
  WorkflowRunStatusCompleted: 'WorkflowRunStatusCompleted',
} as const;

export type AdminUpdateNodeVersionBody = {
  status?: NodeVersionStatus;
  /** The reason for the status change. */
  status_reason?: string;
};

export type GetBranchParams = {
/**
 * The repo to filter by.
 */
repo_name?: string;
};

export type GetBranch200 = {
  branches?: string[];
};

export type ComfyNodesBackfillParams = {
max_node?: number;
};

export type GetGitcommitParams = {
/**
 * The ID of the commit to fetch data for.
 */
commitId?: string;
/**
 * The operating system to filter the CI data by.
 */
operatingSystem?: string;
/**
 * The name of the workflow to filter the CI data by.
 */
workflowName?: string;
/**
 * The branch of the gitcommit to filter the CI data by.
 */
branch?: string;
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * The number of items to include per page.
 */
pageSize?: number;
/**
 * The repo to filter by.
 */
repoName?: string;
};

export type GetGitcommit200 = {
  jobResults?: ActionJobResult[];
  totalNumberOfPages?: number;
};

export type GetGitcommitsummaryParams = {
/**
 * The repository name to filter the git commits by.
 */
repoName?: string;
/**
 * The branch name to filter the git commits by.
 */
branchName?: string;
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * The number of items to include per page.
 */
pageSize?: number;
};

export type GetGitcommitsummary200 = {
  commitSummaries?: GitCommitSummary[];
  totalNumberOfPages?: number;
};

export type GetGitcommitsummary500 = {
  message?: string;
};

export type ListAllNodesParams = {
/**
 * Page number of the nodes list
 */
page?: number;
/**
 * Number of nodes to return per page
 */
limit?: number;
/**
 * Number of nodes to return per page
 */
include_banned?: boolean;
/**
 * Retrieve nodes created or updated after this timestamp (ISO 8601 format)
 */
timestamp?: string;
/**
 * Whether to fetch fresh result from database or use cached one if false
 */
latest?: boolean;
/**
 * Database column to use as ascending ordering. Add `;desc` as suffix on each column for descending sort
 */
sort?: string[];
/**
 * node_id to use as filter
 */
node_id?: string[];
/**
 * The platform requesting the nodes
 */
form_factor?: string;
};

export type ListAllNodes200 = {
  /** Maximum number of nodes per page */
  limit?: number;
  nodes?: Node[];
  /** Current page number */
  page?: number;
  /** Total number of nodes available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

export type ReindexNodesParams = {
/**
 * Maximum number of nodes to send to algolia at a time
 */
max_batch?: number;
/**
 * Minimum interval from the last time the nodes were indexed to algolia
 */
min_age?: string;
};

export type SearchNodesParams = {
/**
 * Page number of the nodes list
 */
page?: number;
/**
 * Number of nodes to return per page
 */
limit?: number;
/**
 * Keyword to search the nodes
 */
search?: string;
/**
 * Keyword to search the nodes by comfy node name
 */
comfy_node_search?: string;
/**
 * Number of nodes to return per page
 */
include_banned?: boolean;
};

export type SearchNodes200 = {
  /** Maximum number of nodes per page */
  limit?: number;
  nodes?: Node[];
  /** Current page number */
  page?: number;
  /** Total number of nodes available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

export type GetNodeParams = {
/**
 * Whether to include the translation or not
 */
include_translations?: boolean;
};

export type InstallNodeParams = {
/**
 * Specific version of the node to retrieve. If omitted, the latest version is returned.
 */
version?: string;
};

export type PostNodeReviewParams = {
/**
 * number of star given to the node version
 */
star: number;
};

export type CreateNodeTranslationsBodyData = {[key: string]: { [key: string]: unknown }};

export type CreateNodeTranslationsBody = {
  data?: CreateNodeTranslationsBodyData;
};

export type ListNodeVersionsParams = {
statuses?: NodeVersionStatus[];
include_status_reason?: boolean;
};

export type ListComfyNodesParams = {
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * The number of items to include per page.
 */
limit?: number;
};

export type ListComfyNodes200 = {
  comfy_nodes?: ComfyNode[];
  totalNumberOfPages?: number;
};

export type CreateComfyNodesBodyNodes = {[key: string]: ComfyNode};

export type CreateComfyNodesBody = {
  cloud_build_info?: ComfyNodeCloudBuildInfo;
  nodes?: CreateComfyNodesBodyNodes;
  reason?: string;
  status?: string;
  success?: boolean;
};

export type ValidatePublisherParams = {
/**
 * The publisher username to validate.
 */
username: string;
};

export type ValidatePublisher200 = {
  /** True if the username is available, false otherwise. */
  isAvailable?: boolean;
};

export type ListNodesForPublisherParams = {
/**
 * Number of nodes to return per page
 */
include_banned?: boolean;
};

export type ListNodesForPublisherV2Params = {
/**
 * Number of nodes to return per page
 */
include_banned?: boolean;
/**
 * Page number of the nodes list
 */
page?: number;
/**
 * Number of nodes to return per page
 */
limit?: number;
};

export type ListNodesForPublisherV2200 = {
  /** Maximum number of nodes per page */
  limit?: number;
  nodes?: Node[];
  /** Current page number */
  page?: number;
  /** Total number of nodes available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

export type GetPermissionOnPublisherNodes200 = {
  canEdit?: boolean;
};

export type PublishNodeVersionBody = {
  node: Node;
  node_version: NodeVersion;
  personal_access_token: string;
};

export type PublishNodeVersion201 = {
  node_version?: NodeVersion;
  /** The signed URL to upload the node version token. */
  signedUrl?: string;
};

export type GetPermissionOnPublisher200 = {
  canEdit?: boolean;
};

export type CreatePersonalAccessToken201 = {
  /** The newly created personal access token. */
  token?: string;
};

export type SecurityScanParams = {
minAge?: string;
minSecurityScanAge?: string;
maxNodes?: number;
};

export type PostUploadArtifactBody = {
  /** The author of the commit */
  author: string;
  /** The average amount of VRAM used in the run. */
  avg_vram?: number;
  branch_name: string;
  /** The name of the bucket where the output files are stored */
  bucket_name?: string;
  /** The path to ComfyUI logs. eg. gs://bucket-name/logs */
  comfy_logs_gcs_path?: string;
  /** The flags used in the comfy run */
  comfy_run_flags?: string;
  commit_hash: string;
  /** The commit message */
  commit_message: string;
  /** The time of the commit in the format of "YYYY-MM-DDTHH:MM:SSZ" (2016-10-10T00:00:00Z) */
  commit_time: string;
  /** Cuda version. */
  cuda_version?: string;
  /** The end time of the job as a Unix timestamp. */
  end_time: number;
  /** Unique identifier for the job */
  job_id: string;
  /** The user who triggered the job */
  job_trigger_user: string;
  machine_stats?: MachineStats;
  /** Operating system used in the run */
  os: string;
  /** A comma separated string that contains GCS path(s) to output files. eg. gs://bucket-name/output, gs://bucket-name/output2 */
  output_files_gcs_paths?: string;
  /** The peak amount of VRAM used in the run. */
  peak_vram?: number;
  /** The pull request number */
  pr_number: string;
  /** The python version used in the run */
  python_version: string;
  /** The pytorch version used in the run */
  pytorch_version?: string;
  /** Repository name */
  repo: string;
  /** Unique identifier for the run */
  run_id: string;
  /** The start time of the job as a Unix timestamp. */
  start_time: number;
  status: WorkflowRunStatus;
  /** The name of the workflow */
  workflow_name: string;
};

export type PostUploadArtifact200 = {
  message?: string;
};

export type ListAllNodeVersionsParams = {
nodeId?: string;
statuses?: NodeVersionStatus[];
include_status_reason?: boolean;
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * The number of items to include per page.
 */
pageSize?: number;
};

export type ListAllNodeVersions200 = {
  /** Current page number */
  page?: number;
  /** Maximum number of node versions per page. Maximum is 100. */
  pageSize?: number;
  /** Total number of node versions available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
  versions?: NodeVersion[];
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Create a new custom node using admin priviledge
 */
export const adminCreateNode = (
    node: Node,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Node>(
      {url: `/admin/nodes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: node, signal
    },
      options);
    }
  


export const getAdminCreateNodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminCreateNode>>, TError,{data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminCreateNode>>, TError,{data: Node}, TContext> => {
    
const mutationKey = ['adminCreateNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminCreateNode>>, {data: Node}> = (props) => {
          const {data} = props ?? {};

          return  adminCreateNode(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminCreateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof adminCreateNode>>>
    export type AdminCreateNodeMutationBody = Node
    export type AdminCreateNodeMutationError = ErrorResponse | void

    /**
 * @summary Create a new custom node using admin priviledge
 */
export const useAdminCreateNode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminCreateNode>>, TError,{data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminCreateNode>>,
        TError,
        {data: Node},
        TContext
      > => {

      const mutationOptions = getAdminCreateNodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Only admins can approve a node version.
 * @summary Admin Update Node Version Status
 */
export const adminUpdateNodeVersion = (
    nodeId: string,
    versionNumber: string,
    adminUpdateNodeVersionBody: AdminUpdateNodeVersionBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<NodeVersion>(
      {url: `/admin/nodes/${nodeId}/versions/${versionNumber}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: adminUpdateNodeVersionBody
    },
      options);
    }
  


export const getAdminUpdateNodeVersionMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, TError,{nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, TError,{nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}, TContext> => {
    
const mutationKey = ['adminUpdateNodeVersion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, {nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}> = (props) => {
          const {nodeId,versionNumber,data} = props ?? {};

          return  adminUpdateNodeVersion(nodeId,versionNumber,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminUpdateNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof adminUpdateNodeVersion>>>
    export type AdminUpdateNodeVersionMutationBody = AdminUpdateNodeVersionBody
    export type AdminUpdateNodeVersionMutationError = ErrorResponse | void

    /**
 * @summary Admin Update Node Version Status
 */
export const useAdminUpdateNodeVersion = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, TError,{nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof adminUpdateNodeVersion>>,
        TError,
        {nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody},
        TContext
      > => {

      const mutationOptions = getAdminUpdateNodeVersionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns all branches for a given repo.
 * @summary Retrieve all distinct branches for a given repo
 */
export const getBranch = (
    params: GetBranchParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetBranch200>(
      {url: `/branch`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetBranchQueryKey = (params: GetBranchParams,) => {
    return [`/branch`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBranchQueryOptions = <TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranch>>> = ({ signal }) => getBranch(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBranchQueryResult = NonNullable<Awaited<ReturnType<typeof getBranch>>>
export type GetBranchQueryError = void


export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(
 params: GetBranchParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranch>>,
          TError,
          Awaited<ReturnType<typeof getBranch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(
 params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBranch>>,
          TError,
          Awaited<ReturnType<typeof getBranch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(
 params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve all distinct branches for a given repo
 */

export function useGetBranch<TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(
 params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBranchQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary trigger comfy nodes backfill
 */
export const comfyNodesBackfill = (
    params?: ComfyNodesBackfillParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/comfy-nodes/backfill`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getComfyNodesBackfillMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof comfyNodesBackfill>>, TError,{params?: ComfyNodesBackfillParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof comfyNodesBackfill>>, TError,{params?: ComfyNodesBackfillParams}, TContext> => {
    
const mutationKey = ['comfyNodesBackfill'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof comfyNodesBackfill>>, {params?: ComfyNodesBackfillParams}> = (props) => {
          const {params} = props ?? {};

          return  comfyNodesBackfill(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ComfyNodesBackfillMutationResult = NonNullable<Awaited<ReturnType<typeof comfyNodesBackfill>>>
    
    export type ComfyNodesBackfillMutationError = ErrorResponse | void

    /**
 * @summary trigger comfy nodes backfill
 */
export const useComfyNodesBackfill = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof comfyNodesBackfill>>, TError,{params?: ComfyNodesBackfillParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof comfyNodesBackfill>>,
        TError,
        {params?: ComfyNodesBackfillParams},
        TContext
      > => {

      const mutationOptions = getComfyNodesBackfillMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns all runs, jobs, job results, and storage files associated with a given commit.
 * @summary Retrieve CI data for a given commit
 */
export const getGitcommit = (
    params?: GetGitcommitParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGitcommit200>(
      {url: `/gitcommit`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetGitcommitQueryKey = (params?: GetGitcommitParams,) => {
    return [`/gitcommit`, ...(params ? [params]: [])] as const;
    }

    
export const getGetGitcommitQueryOptions = <TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGitcommitQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGitcommit>>> = ({ signal }) => getGitcommit(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetGitcommitQueryResult = NonNullable<Awaited<ReturnType<typeof getGitcommit>>>
export type GetGitcommitQueryError = void


export function useGetGitcommit<TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(
 params: undefined |  GetGitcommitParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGitcommit>>,
          TError,
          Awaited<ReturnType<typeof getGitcommit>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGitcommit<TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(
 params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGitcommit>>,
          TError,
          Awaited<ReturnType<typeof getGitcommit>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGitcommit<TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(
 params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve CI data for a given commit
 */

export function useGetGitcommit<TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(
 params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetGitcommitQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a summary of git commits, including status, start time, and end time.
 * @summary Retrieve a summary of git commits
 */
export const getGitcommitsummary = (
    params?: GetGitcommitsummaryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGitcommitsummary200>(
      {url: `/gitcommitsummary`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetGitcommitsummaryQueryKey = (params?: GetGitcommitsummaryParams,) => {
    return [`/gitcommitsummary`, ...(params ? [params]: [])] as const;
    }

    
export const getGetGitcommitsummaryQueryOptions = <TData = Awaited<ReturnType<typeof getGitcommitsummary>>, TError = GetGitcommitsummary500>(params?: GetGitcommitsummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGitcommitsummaryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGitcommitsummary>>> = ({ signal }) => getGitcommitsummary(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetGitcommitsummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getGitcommitsummary>>>
export type GetGitcommitsummaryQueryError = GetGitcommitsummary500


export function useGetGitcommitsummary<TData = Awaited<ReturnType<typeof getGitcommitsummary>>, TError = GetGitcommitsummary500>(
 params: undefined |  GetGitcommitsummaryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGitcommitsummary>>,
          TError,
          Awaited<ReturnType<typeof getGitcommitsummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGitcommitsummary<TData = Awaited<ReturnType<typeof getGitcommitsummary>>, TError = GetGitcommitsummary500>(
 params?: GetGitcommitsummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGitcommitsummary>>,
          TError,
          Awaited<ReturnType<typeof getGitcommitsummary>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGitcommitsummary<TData = Awaited<ReturnType<typeof getGitcommitsummary>>, TError = GetGitcommitsummary500>(
 params?: GetGitcommitsummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve a summary of git commits
 */

export function useGetGitcommitsummary<TData = Awaited<ReturnType<typeof getGitcommitsummary>>, TError = GetGitcommitsummary500>(
 params?: GetGitcommitsummaryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommitsummary>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetGitcommitsummaryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a paginated list of nodes across all publishers.
 * @summary Retrieves a list of nodes
 */
export const listAllNodes = (
    params?: ListAllNodesParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ListAllNodes200>(
      {url: `/nodes`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListAllNodesQueryKey = (params?: ListAllNodesParams,) => {
    return [`/nodes`, ...(params ? [params]: [])] as const;
    }

    
export const getListAllNodesQueryOptions = <TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAllNodesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllNodes>>> = ({ signal }) => listAllNodes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAllNodesQueryResult = NonNullable<Awaited<ReturnType<typeof listAllNodes>>>
export type ListAllNodesQueryError = void | ErrorResponse


export function useListAllNodes<TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(
 params: undefined |  ListAllNodesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllNodes>>,
          TError,
          Awaited<ReturnType<typeof listAllNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAllNodes<TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(
 params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllNodes>>,
          TError,
          Awaited<ReturnType<typeof listAllNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAllNodes<TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(
 params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieves a list of nodes
 */

export function useListAllNodes<TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(
 params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAllNodesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Reindex all nodes for searching.
 */
export const reindexNodes = (
    params?: ReindexNodesParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/nodes/reindex`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getReindexNodesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reindexNodes>>, TError,{params?: ReindexNodesParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof reindexNodes>>, TError,{params?: ReindexNodesParams}, TContext> => {
    
const mutationKey = ['reindexNodes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reindexNodes>>, {params?: ReindexNodesParams}> = (props) => {
          const {params} = props ?? {};

          return  reindexNodes(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReindexNodesMutationResult = NonNullable<Awaited<ReturnType<typeof reindexNodes>>>
    
    export type ReindexNodesMutationError = ErrorResponse

    /**
 * @summary Reindex all nodes for searching.
 */
export const useReindexNodes = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reindexNodes>>, TError,{params?: ReindexNodesParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof reindexNodes>>,
        TError,
        {params?: ReindexNodesParams},
        TContext
      > => {

      const mutationOptions = getReindexNodesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns a paginated list of nodes across all publishers.
 * @summary Retrieves a list of nodes
 */
export const searchNodes = (
    params?: SearchNodesParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SearchNodes200>(
      {url: `/nodes/search`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSearchNodesQueryKey = (params?: SearchNodesParams,) => {
    return [`/nodes/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchNodesQueryOptions = <TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(params?: SearchNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchNodesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchNodes>>> = ({ signal }) => searchNodes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SearchNodesQueryResult = NonNullable<Awaited<ReturnType<typeof searchNodes>>>
export type SearchNodesQueryError = void | ErrorResponse


export function useSearchNodes<TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(
 params: undefined |  SearchNodesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchNodes>>,
          TError,
          Awaited<ReturnType<typeof searchNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchNodes<TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(
 params?: SearchNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchNodes>>,
          TError,
          Awaited<ReturnType<typeof searchNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchNodes<TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(
 params?: SearchNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieves a list of nodes
 */

export function useSearchNodes<TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(
 params?: SearchNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSearchNodesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the details of a specific node.
 * @summary Retrieve a specific node by ID
 */
export const getNode = (
    nodeId: string,
    params?: GetNodeParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Node>(
      {url: `/nodes/${nodeId}`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetNodeQueryKey = (nodeId: string,
    params?: GetNodeParams,) => {
    return [`/nodes/${nodeId}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetNodeQueryOptions = <TData = Awaited<ReturnType<typeof getNode>>, TError = ErrorResponse>(nodeId: string,
    params?: GetNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeQueryKey(nodeId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNode>>> = ({ signal }) => getNode(nodeId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNodeQueryResult = NonNullable<Awaited<ReturnType<typeof getNode>>>
export type GetNodeQueryError = ErrorResponse


export function useGetNode<TData = Awaited<ReturnType<typeof getNode>>, TError = ErrorResponse>(
 nodeId: string,
    params: undefined |  GetNodeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNode>>,
          TError,
          Awaited<ReturnType<typeof getNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNode<TData = Awaited<ReturnType<typeof getNode>>, TError = ErrorResponse>(
 nodeId: string,
    params?: GetNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNode>>,
          TError,
          Awaited<ReturnType<typeof getNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNode<TData = Awaited<ReturnType<typeof getNode>>, TError = ErrorResponse>(
 nodeId: string,
    params?: GetNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve a specific node by ID
 */

export function useGetNode<TData = Awaited<ReturnType<typeof getNode>>, TError = ErrorResponse>(
 nodeId: string,
    params?: GetNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNodeQueryOptions(nodeId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves the node data for installation, either the latest or a specific version.
 * @summary Returns a node version to be installed.
 */
export const installNode = (
    nodeId: string,
    params?: InstallNodeParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NodeVersion>(
      {url: `/nodes/${nodeId}/install`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getInstallNodeQueryKey = (nodeId: string,
    params?: InstallNodeParams,) => {
    return [`/nodes/${nodeId}/install`, ...(params ? [params]: [])] as const;
    }

    
export const getInstallNodeQueryOptions = <TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(nodeId: string,
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInstallNodeQueryKey(nodeId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof installNode>>> = ({ signal }) => installNode(nodeId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type InstallNodeQueryResult = NonNullable<Awaited<ReturnType<typeof installNode>>>
export type InstallNodeQueryError = ErrorResponse


export function useInstallNode<TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(
 nodeId: string,
    params: undefined |  InstallNodeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof installNode>>,
          TError,
          Awaited<ReturnType<typeof installNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInstallNode<TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(
 nodeId: string,
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof installNode>>,
          TError,
          Awaited<ReturnType<typeof installNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useInstallNode<TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(
 nodeId: string,
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Returns a node version to be installed.
 */

export function useInstallNode<TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(
 nodeId: string,
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getInstallNodeQueryOptions(nodeId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add review to a specific version of a node
 */
export const postNodeReview = (
    nodeId: string,
    params: PostNodeReviewParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Node>(
      {url: `/nodes/${nodeId}/reviews`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getPostNodeReviewMutationOptions = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postNodeReview>>, TError,{nodeId: string;params: PostNodeReviewParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postNodeReview>>, TError,{nodeId: string;params: PostNodeReviewParams}, TContext> => {
    
const mutationKey = ['postNodeReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postNodeReview>>, {nodeId: string;params: PostNodeReviewParams}> = (props) => {
          const {nodeId,params} = props ?? {};

          return  postNodeReview(nodeId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostNodeReviewMutationResult = NonNullable<Awaited<ReturnType<typeof postNodeReview>>>
    
    export type PostNodeReviewMutationError = void | Error | ErrorResponse

    /**
 * @summary Add review to a specific version of a node
 */
export const usePostNodeReview = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postNodeReview>>, TError,{nodeId: string;params: PostNodeReviewParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postNodeReview>>,
        TError,
        {nodeId: string;params: PostNodeReviewParams},
        TContext
      > => {

      const mutationOptions = getPostNodeReviewMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Create Node Translations
 */
export const createNodeTranslations = (
    nodeId: string,
    createNodeTranslationsBody: CreateNodeTranslationsBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/nodes/${nodeId}/translations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createNodeTranslationsBody, signal
    },
      options);
    }
  


export const getCreateNodeTranslationsMutationOptions = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNodeTranslations>>, TError,{nodeId: string;data: CreateNodeTranslationsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createNodeTranslations>>, TError,{nodeId: string;data: CreateNodeTranslationsBody}, TContext> => {
    
const mutationKey = ['createNodeTranslations'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNodeTranslations>>, {nodeId: string;data: CreateNodeTranslationsBody}> = (props) => {
          const {nodeId,data} = props ?? {};

          return  createNodeTranslations(nodeId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNodeTranslationsMutationResult = NonNullable<Awaited<ReturnType<typeof createNodeTranslations>>>
    export type CreateNodeTranslationsMutationBody = CreateNodeTranslationsBody
    export type CreateNodeTranslationsMutationError = void | Error | ErrorResponse

    /**
 * @summary Create Node Translations
 */
export const useCreateNodeTranslations = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNodeTranslations>>, TError,{nodeId: string;data: CreateNodeTranslationsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createNodeTranslations>>,
        TError,
        {nodeId: string;data: CreateNodeTranslationsBody},
        TContext
      > => {

      const mutationOptions = getCreateNodeTranslationsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Create Node Translations
 */
export const createNodeTranslations = (
    nodeId: string,
    createNodeTranslationsBody: CreateNodeTranslationsBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/nodes/${nodeId}/translations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createNodeTranslationsBody, signal
    },
      options);
    }
  


export const getCreateNodeTranslationsMutationOptions = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNodeTranslations>>, TError,{nodeId: string;data: CreateNodeTranslationsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createNodeTranslations>>, TError,{nodeId: string;data: CreateNodeTranslationsBody}, TContext> => {
    
const mutationKey = ['createNodeTranslations'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNodeTranslations>>, {nodeId: string;data: CreateNodeTranslationsBody}> = (props) => {
          const {nodeId,data} = props ?? {};

          return  createNodeTranslations(nodeId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNodeTranslationsMutationResult = NonNullable<Awaited<ReturnType<typeof createNodeTranslations>>>
    export type CreateNodeTranslationsMutationBody = CreateNodeTranslationsBody
    export type CreateNodeTranslationsMutationError = void | Error | ErrorResponse

    /**
 * @summary Create Node Translations
 */
export const useCreateNodeTranslations = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNodeTranslations>>, TError,{nodeId: string;data: CreateNodeTranslationsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createNodeTranslations>>,
        TError,
        {nodeId: string;data: CreateNodeTranslationsBody},
        TContext
      > => {

      const mutationOptions = getCreateNodeTranslationsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary List all versions of a node
 */
export const listNodeVersions = (
    nodeId: string,
    params?: ListNodeVersionsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NodeVersion[]>(
      {url: `/nodes/${nodeId}/versions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListNodeVersionsQueryKey = (nodeId: string,
    params?: ListNodeVersionsParams,) => {
    return [`/nodes/${nodeId}/versions`, ...(params ? [params]: [])] as const;
    }

    
export const getListNodeVersionsQueryOptions = <TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(nodeId: string,
    params?: ListNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListNodeVersionsQueryKey(nodeId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodeVersions>>> = ({ signal }) => listNodeVersions(nodeId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListNodeVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof listNodeVersions>>>
export type ListNodeVersionsQueryError = ErrorResponse | Error


export function useListNodeVersions<TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(
 nodeId: string,
    params: undefined |  ListNodeVersionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodeVersions>>,
          TError,
          Awaited<ReturnType<typeof listNodeVersions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListNodeVersions<TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(
 nodeId: string,
    params?: ListNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodeVersions>>,
          TError,
          Awaited<ReturnType<typeof listNodeVersions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListNodeVersions<TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(
 nodeId: string,
    params?: ListNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all versions of a node
 */

export function useListNodeVersions<TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(
 nodeId: string,
    params?: ListNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListNodeVersionsQueryOptions(nodeId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Retrieve a specific version of a node
 */
export const getNodeVersion = (
    nodeId: string,
    versionId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NodeVersion>(
      {url: `/nodes/${nodeId}/versions/${versionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNodeVersionQueryKey = (nodeId: string,
    versionId: string,) => {
    return [`/nodes/${nodeId}/versions/${versionId}`] as const;
    }

    
export const getGetNodeVersionQueryOptions = <TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(nodeId: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeVersionQueryKey(nodeId,versionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeVersion>>> = ({ signal }) => getNodeVersion(nodeId,versionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId && versionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNodeVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getNodeVersion>>>
export type GetNodeVersionQueryError = Error | ErrorResponse


export function useGetNodeVersion<TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(
 nodeId: string,
    versionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNodeVersion>>,
          TError,
          Awaited<ReturnType<typeof getNodeVersion>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNodeVersion<TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(
 nodeId: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNodeVersion>>,
          TError,
          Awaited<ReturnType<typeof getNodeVersion>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNodeVersion<TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(
 nodeId: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve a specific version of a node
 */

export function useGetNodeVersion<TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(
 nodeId: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNodeVersionQueryOptions(nodeId,versionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary list comfy-nodes for certain node
 */
export const listComfyNodes = (
    nodeId: string,
    version: string,
    params?: ListComfyNodesParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ListComfyNodes200>(
      {url: `/nodes/${nodeId}/versions/${version}/comfy-nodes`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListComfyNodesQueryKey = (nodeId: string,
    version: string,
    params?: ListComfyNodesParams,) => {
    return [`/nodes/${nodeId}/versions/${version}/comfy-nodes`, ...(params ? [params]: [])] as const;
    }

    
export const getListComfyNodesQueryOptions = <TData = Awaited<ReturnType<typeof listComfyNodes>>, TError = void | ErrorResponse>(nodeId: string,
    version: string,
    params?: ListComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListComfyNodesQueryKey(nodeId,version,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listComfyNodes>>> = ({ signal }) => listComfyNodes(nodeId,version,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId && version), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListComfyNodesQueryResult = NonNullable<Awaited<ReturnType<typeof listComfyNodes>>>
export type ListComfyNodesQueryError = void | ErrorResponse


export function useListComfyNodes<TData = Awaited<ReturnType<typeof listComfyNodes>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    params: undefined |  ListComfyNodesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listComfyNodes>>,
          TError,
          Awaited<ReturnType<typeof listComfyNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListComfyNodes<TData = Awaited<ReturnType<typeof listComfyNodes>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    params?: ListComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listComfyNodes>>,
          TError,
          Awaited<ReturnType<typeof listComfyNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListComfyNodes<TData = Awaited<ReturnType<typeof listComfyNodes>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    params?: ListComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary list comfy-nodes for certain node
 */

export function useListComfyNodes<TData = Awaited<ReturnType<typeof listComfyNodes>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    params?: ListComfyNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listComfyNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListComfyNodesQueryOptions(nodeId,version,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary create comfy-nodes for certain node
 */
export const createComfyNodes = (
    nodeId: string,
    version: string,
    createComfyNodesBody: CreateComfyNodesBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/nodes/${nodeId}/versions/${version}/comfy-nodes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createComfyNodesBody, signal
    },
      options);
    }
  


export const getCreateComfyNodesMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComfyNodes>>, TError,{nodeId: string;version: string;data: CreateComfyNodesBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createComfyNodes>>, TError,{nodeId: string;version: string;data: CreateComfyNodesBody}, TContext> => {
    
const mutationKey = ['createComfyNodes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createComfyNodes>>, {nodeId: string;version: string;data: CreateComfyNodesBody}> = (props) => {
          const {nodeId,version,data} = props ?? {};

          return  createComfyNodes(nodeId,version,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateComfyNodesMutationResult = NonNullable<Awaited<ReturnType<typeof createComfyNodes>>>
    export type CreateComfyNodesMutationBody = CreateComfyNodesBody
    export type CreateComfyNodesMutationError = void | ErrorResponse

    /**
 * @summary create comfy-nodes for certain node
 */
export const useCreateComfyNodes = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComfyNodes>>, TError,{nodeId: string;version: string;data: CreateComfyNodesBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createComfyNodes>>,
        TError,
        {nodeId: string;version: string;data: CreateComfyNodesBody},
        TContext
      > => {

      const mutationOptions = getCreateComfyNodesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary get specify comfy-node based on its id
 */
export const getComfyNode = (
    nodeId: string,
    version: string,
    comfyNodeName: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ComfyNode>(
      {url: `/nodes/${nodeId}/versions/${version}/comfy-nodes/${comfyNodeName}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetComfyNodeQueryKey = (nodeId: string,
    version: string,
    comfyNodeName: string,) => {
    return [`/nodes/${nodeId}/versions/${version}/comfy-nodes/${comfyNodeName}`] as const;
    }

    
export const getGetComfyNodeQueryOptions = <TData = Awaited<ReturnType<typeof getComfyNode>>, TError = void | ErrorResponse>(nodeId: string,
    version: string,
    comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetComfyNodeQueryKey(nodeId,version,comfyNodeName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getComfyNode>>> = ({ signal }) => getComfyNode(nodeId,version,comfyNodeName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId && version && comfyNodeName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetComfyNodeQueryResult = NonNullable<Awaited<ReturnType<typeof getComfyNode>>>
export type GetComfyNodeQueryError = void | ErrorResponse


export function useGetComfyNode<TData = Awaited<ReturnType<typeof getComfyNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    comfyNodeName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComfyNode>>,
          TError,
          Awaited<ReturnType<typeof getComfyNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetComfyNode<TData = Awaited<ReturnType<typeof getComfyNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getComfyNode>>,
          TError,
          Awaited<ReturnType<typeof getComfyNode>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetComfyNode<TData = Awaited<ReturnType<typeof getComfyNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary get specify comfy-node based on its id
 */

export function useGetComfyNode<TData = Awaited<ReturnType<typeof getComfyNode>>, TError = void | ErrorResponse>(
 nodeId: string,
    version: string,
    comfyNodeName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComfyNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetComfyNodeQueryOptions(nodeId,version,comfyNodeName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Retrieve all publishers
 */
export const listPublishers = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Publisher[]>(
      {url: `/publishers`, method: 'GET', signal
    },
      options);
    }
  

export const getListPublishersQueryKey = () => {
    return [`/publishers`] as const;
    }

    
export const getListPublishersQueryOptions = <TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPublishersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPublishers>>> = ({ signal }) => listPublishers(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPublishersQueryResult = NonNullable<Awaited<ReturnType<typeof listPublishers>>>
export type ListPublishersQueryError = ErrorResponse


export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPublishers>>,
          TError,
          Awaited<ReturnType<typeof listPublishers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPublishers>>,
          TError,
          Awaited<ReturnType<typeof listPublishers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve all publishers
 */

export function useListPublishers<TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPublishersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new publisher
 */
export const createPublisher = (
    publisher: Publisher,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Publisher>(
      {url: `/publishers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: publisher, signal
    },
      options);
    }
  


export const getCreatePublisherMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext> => {
    
const mutationKey = ['createPublisher'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPublisher>>, {data: Publisher}> = (props) => {
          const {data} = props ?? {};

          return  createPublisher(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof createPublisher>>>
    export type CreatePublisherMutationBody = Publisher
    export type CreatePublisherMutationError = ErrorResponse | void

    /**
 * @summary Create a new publisher
 */
export const useCreatePublisher = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPublisher>>,
        TError,
        {data: Publisher},
        TContext
      > => {

      const mutationOptions = getCreatePublisherMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Checks if the publisher username is already taken.
 * @summary Validate if a publisher username is available
 */
export const validatePublisher = (
    params: ValidatePublisherParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ValidatePublisher200>(
      {url: `/publishers/validate`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getValidatePublisherQueryKey = (params: ValidatePublisherParams,) => {
    return [`/publishers/validate`, ...(params ? [params]: [])] as const;
    }

    
export const getValidatePublisherQueryOptions = <TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidatePublisherQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validatePublisher>>> = ({ signal }) => validatePublisher(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ValidatePublisherQueryResult = NonNullable<Awaited<ReturnType<typeof validatePublisher>>>
export type ValidatePublisherQueryError = ErrorResponse


export function useValidatePublisher<TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(
 params: ValidatePublisherParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validatePublisher>>,
          TError,
          Awaited<ReturnType<typeof validatePublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useValidatePublisher<TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(
 params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validatePublisher>>,
          TError,
          Awaited<ReturnType<typeof validatePublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useValidatePublisher<TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(
 params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Validate if a publisher username is available
 */

export function useValidatePublisher<TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(
 params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getValidatePublisherQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete a publisher
 */
export const deletePublisher = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeletePublisherMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext> => {
    
const mutationKey = ['deletePublisher'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePublisher>>, {publisherId: string}> = (props) => {
          const {publisherId} = props ?? {};

          return  deletePublisher(publisherId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof deletePublisher>>>
    
    export type DeletePublisherMutationError = ErrorResponse

    /**
 * @summary Delete a publisher
 */
export const useDeletePublisher = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePublisher>>,
        TError,
        {publisherId: string},
        TContext
      > => {

      const mutationOptions = getDeletePublisherMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Retrieve a publisher by ID
 */
export const getPublisher = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Publisher>(
      {url: `/publishers/${publisherId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPublisherQueryKey = (publisherId: string,) => {
    return [`/publishers/${publisherId}`] as const;
    }

    
export const getGetPublisherQueryOptions = <TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublisherQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublisher>>> = ({ signal }) => getPublisher(publisherId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof getPublisher>>>
export type GetPublisherQueryError = ErrorResponse


export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(
 publisherId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublisher>>,
          TError,
          Awaited<ReturnType<typeof getPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublisher>>,
          TError,
          Awaited<ReturnType<typeof getPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve a publisher by ID
 */

export function useGetPublisher<TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPublisherQueryOptions(publisherId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a publisher
 */
export const updatePublisher = (
    publisherId: string,
    publisher: Publisher,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Publisher>(
      {url: `/publishers/${publisherId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: publisher
    },
      options);
    }
  


export const getUpdatePublisherMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext> => {
    
const mutationKey = ['updatePublisher'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePublisher>>, {publisherId: string;data: Publisher}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  updatePublisher(publisherId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof updatePublisher>>>
    export type UpdatePublisherMutationBody = Publisher
    export type UpdatePublisherMutationError = ErrorResponse | void

    /**
 * @summary Update a publisher
 */
export const useUpdatePublisher = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePublisher>>,
        TError,
        {publisherId: string;data: Publisher},
        TContext
      > => {

      const mutationOptions = getUpdatePublisherMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Ban a publisher
 */
export const banPublisher = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/ban`, method: 'POST', signal
    },
      options);
    }
  


export const getBanPublisherMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof banPublisher>>, TError,{publisherId: string}, TContext> => {
    
const mutationKey = ['banPublisher'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof banPublisher>>, {publisherId: string}> = (props) => {
          const {publisherId} = props ?? {};

          return  banPublisher(publisherId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BanPublisherMutationResult = NonNullable<Awaited<ReturnType<typeof banPublisher>>>
    
    export type BanPublisherMutationError = void | ErrorResponse

    /**
 * @summary Ban a publisher
 */
export const useBanPublisher = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof banPublisher>>,
        TError,
        {publisherId: string},
        TContext
      > => {

      const mutationOptions = getBanPublisherMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Retrieve all nodes
 */
export const listNodesForPublisher = (
    publisherId: string,
    params?: ListNodesForPublisherParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Node[]>(
      {url: `/publishers/${publisherId}/nodes`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListNodesForPublisherQueryKey = (publisherId: string,
    params?: ListNodesForPublisherParams,) => {
    return [`/publishers/${publisherId}/nodes`, ...(params ? [params]: [])] as const;
    }

    
export const getListNodesForPublisherQueryOptions = <TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(publisherId: string,
    params?: ListNodesForPublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListNodesForPublisherQueryKey(publisherId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodesForPublisher>>> = ({ signal }) => listNodesForPublisher(publisherId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListNodesForPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof listNodesForPublisher>>>
export type ListNodesForPublisherQueryError = ErrorResponse


export function useListNodesForPublisher<TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(
 publisherId: string,
    params: undefined |  ListNodesForPublisherParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodesForPublisher>>,
          TError,
          Awaited<ReturnType<typeof listNodesForPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListNodesForPublisher<TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodesForPublisher>>,
          TError,
          Awaited<ReturnType<typeof listNodesForPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListNodesForPublisher<TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve all nodes
 */

export function useListNodesForPublisher<TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListNodesForPublisherQueryOptions(publisherId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new custom node
 */
export const createNode = (
    publisherId: string,
    node: Node,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Node>(
      {url: `/publishers/${publisherId}/nodes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: node, signal
    },
      options);
    }
  


export const getCreateNodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext> => {
    
const mutationKey = ['createNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNode>>, {publisherId: string;data: Node}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  createNode(publisherId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof createNode>>>
    export type CreateNodeMutationBody = Node
    export type CreateNodeMutationError = ErrorResponse | void

    /**
 * @summary Create a new custom node
 */
export const useCreateNode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createNode>>,
        TError,
        {publisherId: string;data: Node},
        TContext
      > => {

      const mutationOptions = getCreateNodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Retrieve all nodes
 */
export const listNodesForPublisherV2 = (
    publisherId: string,
    params?: ListNodesForPublisherV2Params,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ListNodesForPublisherV2200>(
      {url: `/publishers/${publisherId}/nodes/v2`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListNodesForPublisherV2QueryKey = (publisherId: string,
    params?: ListNodesForPublisherV2Params,) => {
    return [`/publishers/${publisherId}/nodes/v2`, ...(params ? [params]: [])] as const;
    }

    
export const getListNodesForPublisherV2QueryOptions = <TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError = ErrorResponse>(publisherId: string,
    params?: ListNodesForPublisherV2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListNodesForPublisherV2QueryKey(publisherId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodesForPublisherV2>>> = ({ signal }) => listNodesForPublisherV2(publisherId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListNodesForPublisherV2QueryResult = NonNullable<Awaited<ReturnType<typeof listNodesForPublisherV2>>>
export type ListNodesForPublisherV2QueryError = ErrorResponse


export function useListNodesForPublisherV2<TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError = ErrorResponse>(
 publisherId: string,
    params: undefined |  ListNodesForPublisherV2Params, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodesForPublisherV2>>,
          TError,
          Awaited<ReturnType<typeof listNodesForPublisherV2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListNodesForPublisherV2<TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherV2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNodesForPublisherV2>>,
          TError,
          Awaited<ReturnType<typeof listNodesForPublisherV2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListNodesForPublisherV2<TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherV2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve all nodes
 */

export function useListNodesForPublisherV2<TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherV2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisherV2>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListNodesForPublisherV2QueryOptions(publisherId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete a specific node
 */
export const deleteNode = (
    publisherId: string,
    nodeId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteNodeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext> => {
    
const mutationKey = ['deleteNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNode>>, {publisherId: string;nodeId: string}> = (props) => {
          const {publisherId,nodeId} = props ?? {};

          return  deleteNode(publisherId,nodeId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteNodeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNode>>>
    
    export type DeleteNodeMutationError = ErrorResponse

    /**
 * @summary Delete a specific node
 */
export const useDeleteNode = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteNode>>,
        TError,
        {publisherId: string;nodeId: string},
        TContext
      > => {

      const mutationOptions = getDeleteNodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Update a specific node
 */
export const updateNode = (
    publisherId: string,
    nodeId: string,
    node: Node,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Node>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: node
    },
      options);
    }
  


export const getUpdateNodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext> => {
    
const mutationKey = ['updateNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNode>>, {publisherId: string;nodeId: string;data: Node}> = (props) => {
          const {publisherId,nodeId,data} = props ?? {};

          return  updateNode(publisherId,nodeId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof updateNode>>>
    export type UpdateNodeMutationBody = Node
    export type UpdateNodeMutationError = ErrorResponse | void

    /**
 * @summary Update a specific node
 */
export const useUpdateNode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateNode>>,
        TError,
        {publisherId: string;nodeId: string;data: Node},
        TContext
      > => {

      const mutationOptions = getUpdateNodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Ban a publisher's Node
 */
export const banPublisherNode = (
    publisherId: string,
    nodeId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/ban`, method: 'POST', signal
    },
      options);
    }
  


export const getBanPublisherNodeMutationOptions = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisherNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof banPublisherNode>>, TError,{publisherId: string;nodeId: string}, TContext> => {
    
const mutationKey = ['banPublisherNode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof banPublisherNode>>, {publisherId: string;nodeId: string}> = (props) => {
          const {publisherId,nodeId} = props ?? {};

          return  banPublisherNode(publisherId,nodeId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BanPublisherNodeMutationResult = NonNullable<Awaited<ReturnType<typeof banPublisherNode>>>
    
    export type BanPublisherNodeMutationError = void | ErrorResponse

    /**
 * @summary Ban a publisher's Node
 */
export const useBanPublisherNode = <TError = void | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisherNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof banPublisherNode>>,
        TError,
        {publisherId: string;nodeId: string},
        TContext
      > => {

      const mutationOptions = getBanPublisherNodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Retrieve permissions the user has for a given publisher
 */
export const getPermissionOnPublisherNodes = (
    publisherId: string,
    nodeId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetPermissionOnPublisherNodes200>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/permissions`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPermissionOnPublisherNodesQueryKey = (publisherId: string,
    nodeId: string,) => {
    return [`/publishers/${publisherId}/nodes/${nodeId}/permissions`] as const;
    }

    
export const getGetPermissionOnPublisherNodesQueryOptions = <TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPermissionOnPublisherNodesQueryKey(publisherId,nodeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>> = ({ signal }) => getPermissionOnPublisherNodes(publisherId,nodeId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId && nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPermissionOnPublisherNodesQueryResult = NonNullable<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>>
export type GetPermissionOnPublisherNodesQueryError = ErrorResponse


export function useGetPermissionOnPublisherNodes<TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(
 publisherId: string,
    nodeId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
          TError,
          Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPermissionOnPublisherNodes<TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(
 publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
          TError,
          Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPermissionOnPublisherNodes<TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(
 publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve permissions the user has for a given publisher
 */

export function useGetPermissionOnPublisherNodes<TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(
 publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPermissionOnPublisherNodesQueryOptions(publisherId,nodeId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Publish a new version of a node
 */
export const publishNodeVersion = (
    publisherId: string,
    nodeId: string,
    publishNodeVersionBody: PublishNodeVersionBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PublishNodeVersion201>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/versions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: publishNodeVersionBody, signal
    },
      options);
    }
  


export const getPublishNodeVersionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext> => {
    
const mutationKey = ['publishNodeVersion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof publishNodeVersion>>, {publisherId: string;nodeId: string;data: PublishNodeVersionBody}> = (props) => {
          const {publisherId,nodeId,data} = props ?? {};

          return  publishNodeVersion(publisherId,nodeId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PublishNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof publishNodeVersion>>>
    export type PublishNodeVersionMutationBody = PublishNodeVersionBody
    export type PublishNodeVersionMutationError = ErrorResponse

    /**
 * @summary Publish a new version of a node
 */
export const usePublishNodeVersion = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof publishNodeVersion>>,
        TError,
        {publisherId: string;nodeId: string;data: PublishNodeVersionBody},
        TContext
      > => {

      const mutationOptions = getPublishNodeVersionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Unpublish (delete) a specific version of a node
 */
export const deleteNodeVersion = (
    publisherId: string,
    nodeId: string,
    versionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteNodeVersionMutationOptions = <TError = ErrorResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext> => {
    
const mutationKey = ['deleteNodeVersion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNodeVersion>>, {publisherId: string;nodeId: string;versionId: string}> = (props) => {
          const {publisherId,nodeId,versionId} = props ?? {};

          return  deleteNodeVersion(publisherId,nodeId,versionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNodeVersion>>>
    
    export type DeleteNodeVersionMutationError = ErrorResponse | Error

    /**
 * @summary Unpublish (delete) a specific version of a node
 */
export const useDeleteNodeVersion = <TError = ErrorResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteNodeVersion>>,
        TError,
        {publisherId: string;nodeId: string;versionId: string},
        TContext
      > => {

      const mutationOptions = getDeleteNodeVersionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update only the changelog and deprecated status of a specific version of a node.
 * @summary Update changelog and deprecation status of a node version
 */
export const updateNodeVersion = (
    publisherId: string,
    nodeId: string,
    versionId: string,
    nodeVersionUpdateRequest: NodeVersionUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<NodeVersion>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: nodeVersionUpdateRequest
    },
      options);
    }
  


export const getUpdateNodeVersionMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext> => {
    
const mutationKey = ['updateNodeVersion'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNodeVersion>>, {publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}> = (props) => {
          const {publisherId,nodeId,versionId,data} = props ?? {};

          return  updateNodeVersion(publisherId,nodeId,versionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof updateNodeVersion>>>
    export type UpdateNodeVersionMutationBody = NodeVersionUpdateRequest
    export type UpdateNodeVersionMutationError = ErrorResponse | void

    /**
 * @summary Update changelog and deprecation status of a node version
 */
export const useUpdateNodeVersion = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateNodeVersion>>,
        TError,
        {publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateNodeVersionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Retrieve permissions the user has for a given publisher
 */
export const getPermissionOnPublisher = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetPermissionOnPublisher200>(
      {url: `/publishers/${publisherId}/permissions`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPermissionOnPublisherQueryKey = (publisherId: string,) => {
    return [`/publishers/${publisherId}/permissions`] as const;
    }

    
export const getGetPermissionOnPublisherQueryOptions = <TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPermissionOnPublisherQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPermissionOnPublisher>>> = ({ signal }) => getPermissionOnPublisher(publisherId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPermissionOnPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof getPermissionOnPublisher>>>
export type GetPermissionOnPublisherQueryError = ErrorResponse


export function useGetPermissionOnPublisher<TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(
 publisherId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPermissionOnPublisher>>,
          TError,
          Awaited<ReturnType<typeof getPermissionOnPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPermissionOnPublisher<TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPermissionOnPublisher>>,
          TError,
          Awaited<ReturnType<typeof getPermissionOnPublisher>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPermissionOnPublisher<TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve permissions the user has for a given publisher
 */

export function useGetPermissionOnPublisher<TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPermissionOnPublisherQueryOptions(publisherId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Retrieve all personal access tokens for a publisher
 */
export const listPersonalAccessTokens = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonalAccessToken[]>(
      {url: `/publishers/${publisherId}/tokens`, method: 'GET', signal
    },
      options);
    }
  

export const getListPersonalAccessTokensQueryKey = (publisherId: string,) => {
    return [`/publishers/${publisherId}/tokens`] as const;
    }

    
export const getListPersonalAccessTokensQueryOptions = <TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPersonalAccessTokensQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPersonalAccessTokens>>> = ({ signal }) => listPersonalAccessTokens(publisherId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPersonalAccessTokensQueryResult = NonNullable<Awaited<ReturnType<typeof listPersonalAccessTokens>>>
export type ListPersonalAccessTokensQueryError = ErrorResponse


export function useListPersonalAccessTokens<TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(
 publisherId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPersonalAccessTokens>>,
          TError,
          Awaited<ReturnType<typeof listPersonalAccessTokens>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPersonalAccessTokens<TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPersonalAccessTokens>>,
          TError,
          Awaited<ReturnType<typeof listPersonalAccessTokens>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPersonalAccessTokens<TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve all personal access tokens for a publisher
 */

export function useListPersonalAccessTokens<TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPersonalAccessTokensQueryOptions(publisherId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new personal access token
 */
export const createPersonalAccessToken = (
    publisherId: string,
    personalAccessToken: PersonalAccessToken,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreatePersonalAccessToken201>(
      {url: `/publishers/${publisherId}/tokens`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: personalAccessToken, signal
    },
      options);
    }
  


export const getCreatePersonalAccessTokenMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext> => {
    
const mutationKey = ['createPersonalAccessToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPersonalAccessToken>>, {publisherId: string;data: PersonalAccessToken}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  createPersonalAccessToken(publisherId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePersonalAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof createPersonalAccessToken>>>
    export type CreatePersonalAccessTokenMutationBody = PersonalAccessToken
    export type CreatePersonalAccessTokenMutationError = ErrorResponse

    /**
 * @summary Create a new personal access token
 */
export const useCreatePersonalAccessToken = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPersonalAccessToken>>,
        TError,
        {publisherId: string;data: PersonalAccessToken},
        TContext
      > => {

      const mutationOptions = getCreatePersonalAccessTokenMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Delete a specific personal access token
 */
export const deletePersonalAccessToken = (
    publisherId: string,
    tokenId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/tokens/${tokenId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeletePersonalAccessTokenMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext> => {
    
const mutationKey = ['deletePersonalAccessToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePersonalAccessToken>>, {publisherId: string;tokenId: string}> = (props) => {
          const {publisherId,tokenId} = props ?? {};

          return  deletePersonalAccessToken(publisherId,tokenId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePersonalAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof deletePersonalAccessToken>>>
    
    export type DeletePersonalAccessTokenMutationError = ErrorResponse

    /**
 * @summary Delete a specific personal access token
 */
export const useDeletePersonalAccessToken = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePersonalAccessToken>>,
        TError,
        {publisherId: string;tokenId: string},
        TContext
      > => {

      const mutationOptions = getDeletePersonalAccessTokenMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Pull all pending node versions and conduct security scans.
 * @summary Security Scan
 */
export const securityScan = (
    params?: SecurityScanParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/security-scan`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSecurityScanQueryKey = (params?: SecurityScanParams,) => {
    return [`/security-scan`, ...(params ? [params]: [])] as const;
    }

    
export const getSecurityScanQueryOptions = <TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse | void>(params?: SecurityScanParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSecurityScanQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof securityScan>>> = ({ signal }) => securityScan(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SecurityScanQueryResult = NonNullable<Awaited<ReturnType<typeof securityScan>>>
export type SecurityScanQueryError = ErrorResponse | void


export function useSecurityScan<TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse | void>(
 params: undefined |  SecurityScanParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof securityScan>>,
          TError,
          Awaited<ReturnType<typeof securityScan>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSecurityScan<TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse | void>(
 params?: SecurityScanParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof securityScan>>,
          TError,
          Awaited<ReturnType<typeof securityScan>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSecurityScan<TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse | void>(
 params?: SecurityScanParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Security Scan
 */

export function useSecurityScan<TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse | void>(
 params?: SecurityScanParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSecurityScanQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Receive artifacts (output files) from the ComfyUI GitHub Action
 */
export const postUploadArtifact = (
    postUploadArtifactBody: PostUploadArtifactBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostUploadArtifact200>(
      {url: `/upload-artifact`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postUploadArtifactBody, signal
    },
      options);
    }
  


export const getPostUploadArtifactMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext> => {
    
const mutationKey = ['postUploadArtifact'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUploadArtifact>>, {data: PostUploadArtifactBody}> = (props) => {
          const {data} = props ?? {};

          return  postUploadArtifact(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUploadArtifactMutationResult = NonNullable<Awaited<ReturnType<typeof postUploadArtifact>>>
    export type PostUploadArtifactMutationBody = PostUploadArtifactBody
    export type PostUploadArtifactMutationError = void

    /**
 * @summary Receive artifacts (output files) from the ComfyUI GitHub Action
 */
export const usePostUploadArtifact = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postUploadArtifact>>,
        TError,
        {data: PostUploadArtifactBody},
        TContext
      > => {

      const mutationOptions = getPostUploadArtifactMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get information about the calling user.
 */
export const getUser = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<User>(
      {url: `/users`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserQueryKey = () => {
    return [`/users`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = void


export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get information about the calling user.
 */

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Retrieve all publishers for a given user
 */
export const listPublishersForUser = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Publisher[]>(
      {url: `/users/publishers/`, method: 'GET', signal
    },
      options);
    }
  

export const getListPublishersForUserQueryKey = () => {
    return [`/users/publishers/`] as const;
    }

    
export const getListPublishersForUserQueryOptions = <TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPublishersForUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPublishersForUser>>> = ({ signal }) => listPublishersForUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPublishersForUserQueryResult = NonNullable<Awaited<ReturnType<typeof listPublishersForUser>>>
export type ListPublishersForUserQueryError = ErrorResponse


export function useListPublishersForUser<TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPublishersForUser>>,
          TError,
          Awaited<ReturnType<typeof listPublishersForUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPublishersForUser<TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPublishersForUser>>,
          TError,
          Awaited<ReturnType<typeof listPublishersForUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPublishersForUser<TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve all publishers for a given user
 */

export function useListPublishersForUser<TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPublishersForUserQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List all node versions given some filters.
 */
export const listAllNodeVersions = (
    params?: ListAllNodeVersionsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ListAllNodeVersions200>(
      {url: `/versions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListAllNodeVersionsQueryKey = (params?: ListAllNodeVersionsParams,) => {
    return [`/versions`, ...(params ? [params]: [])] as const;
    }

    
export const getListAllNodeVersionsQueryOptions = <TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(params?: ListAllNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAllNodeVersionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllNodeVersions>>> = ({ signal }) => listAllNodeVersions(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListAllNodeVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof listAllNodeVersions>>>
export type ListAllNodeVersionsQueryError = ErrorResponse


export function useListAllNodeVersions<TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(
 params: undefined |  ListAllNodeVersionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllNodeVersions>>,
          TError,
          Awaited<ReturnType<typeof listAllNodeVersions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAllNodeVersions<TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(
 params?: ListAllNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAllNodeVersions>>,
          TError,
          Awaited<ReturnType<typeof listAllNodeVersions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListAllNodeVersions<TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(
 params?: ListAllNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all node versions given some filters.
 */

export function useListAllNodeVersions<TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(
 params?: ListAllNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListAllNodeVersionsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Retrieve a specific commit by ID
 */
export const getWorkflowResult = (
    workflowResultId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ActionJobResult>(
      {url: `/workflowresult/${workflowResultId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWorkflowResultQueryKey = (workflowResultId: string,) => {
    return [`/workflowresult/${workflowResultId}`] as const;
    }

    
export const getGetWorkflowResultQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowResult>>, TError = ErrorResponse>(workflowResultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowResultQueryKey(workflowResultId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowResult>>> = ({ signal }) => getWorkflowResult(workflowResultId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(workflowResultId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetWorkflowResultQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowResult>>>
export type GetWorkflowResultQueryError = ErrorResponse


export function useGetWorkflowResult<TData = Awaited<ReturnType<typeof getWorkflowResult>>, TError = ErrorResponse>(
 workflowResultId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowResult>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflowResult<TData = Awaited<ReturnType<typeof getWorkflowResult>>, TError = ErrorResponse>(
 workflowResultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWorkflowResult>>,
          TError,
          Awaited<ReturnType<typeof getWorkflowResult>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetWorkflowResult<TData = Awaited<ReturnType<typeof getWorkflowResult>>, TError = ErrorResponse>(
 workflowResultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve a specific commit by ID
 */

export function useGetWorkflowResult<TData = Awaited<ReturnType<typeof getWorkflowResult>>, TError = ErrorResponse>(
 workflowResultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowResult>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetWorkflowResultQueryOptions(workflowResultId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
