/**
 * Generated by orval v7.13.0 üç∫
 * Do not edit manually.
 * Comfy API
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";

import { customInstance } from "./mutator/axios-instance";
export interface APIKey {
    created_at?: string;
    description?: string;
    id?: string;
    key_prefix?: string;
    name?: string;
}

export type APIKeyWithPlaintextAllOf = {
    /** The full API key (only returned at creation) */
    plaintext_key?: string;
};

export type APIKeyWithPlaintext = APIKey & APIKeyWithPlaintextAllOf;

export interface ActionJobResult {
    /** Identifier of the job this result belongs to */
    action_job_id?: string;
    /** Identifier of the run this result belongs to */
    action_run_id?: string;
    /** The author of the commit */
    author?: string;
    /** The average VRAM used by the job */
    avg_vram?: number;
    /** Name of the relevant git branch */
    branch_name?: string;
    /** The comfy run flags. E.g. `--low-vram` */
    comfy_run_flags?: string;
    /** The hash of the commit */
    commit_hash?: string;
    /** The ID of the commit */
    commit_id?: string;
    /** The message of the commit */
    commit_message?: string;
    /** The Unix timestamp when the commit was made */
    commit_time?: number;
    /** CUDA version used */
    cuda_version?: string;
    /** The end time of the job as a Unix timestamp. */
    end_time?: number;
    /** The repository name */
    git_repo?: string;
    /** Unique identifier for the job result */
    id?: string;
    /** The user who triggered the job. */
    job_trigger_user?: string;
    machine_stats?: MachineStats;
    /** Operating system used */
    operating_system?: string;
    /** The peak VRAM used by the job */
    peak_vram?: number;
    /** The pull request number */
    pr_number?: string;
    /** PyTorch version used */
    python_version?: string;
    /** PyTorch version used */
    pytorch_version?: string;
    /** The start time of the job as a Unix timestamp. */
    start_time?: number;
    status?: WorkflowRunStatus;
    storage_file?: StorageFile;
    /** Name of the workflow */
    workflow_name?: string;
}

/**
 * data related to the event
 */
export type AuditLogParams = { [key: string]: unknown };

export interface AuditLog {
    /** The date and time the event was created */
    createdAt?: string;
    /** the id of the event */
    event_id?: string;
    /** the type of the event */
    event_type?: string;
    /** data related to the event */
    params?: AuditLogParams;
}

export interface BFLAsyncResponse {
    id: string;
    polling_url: string;
}

export interface BFLAsyncWebhookResponse {
    id: string;
    status: string;
    webhook_url: string;
}

export interface BFLCannyInputs {
    /** High threshold for Canny edge detection */
    canny_high_threshold?: number;
    /** Low threshold for Canny edge detection */
    canny_low_threshold?: number;
    /** Base64 encoded image to use as control input if no preprocessed image is provided */
    control_image?: string;
    /** Guidance strength for the image generation process */
    guidance?: number;
    /** Output format for the generated image. Can be 'jpeg' or 'png'. */
    output_format?: BFLOutputFormat;
    /** Optional pre-processed image that will bypass the control preprocessing step */
    preprocessed_image?: string;
    /** Text prompt for image generation */
    prompt: string;
    /** Whether to perform upsampling on the prompt */
    prompt_upsampling?: boolean;
    /**
     * Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
     * @minimum 0
     * @maximum 6
     */
    safety_tolerance?: number;
    /** Optional seed for reproducibility */
    seed?: number;
    /** Number of steps for the image generation process */
    steps?: number;
    /** Optional secret for webhook signature verification */
    webhook_secret?: string;
    /** URL to receive webhook notifications */
    webhook_url?: string;
}

export interface BFLDepthInputs {
    /** Base64 encoded image to use as control input */
    control_image?: string;
    /** Guidance strength for the image generation process */
    guidance?: number;
    /** Output format for the generated image. Can be 'jpeg' or 'png'. */
    output_format?: BFLOutputFormat;
    /** Optional pre-processed image that will bypass the control preprocessing step */
    preprocessed_image?: string;
    /** Text prompt for image generation */
    prompt: string;
    /** Whether to perform upsampling on the prompt */
    prompt_upsampling?: boolean;
    /**
     * Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
     * @minimum 0
     * @maximum 6
     */
    safety_tolerance?: number;
    /** Optional seed for reproducibility */
    seed?: number;
    /** Number of steps for the image generation process */
    steps?: number;
    /** Optional secret for webhook signature verification */
    webhook_secret?: string;
    /** URL to receive webhook notifications */
    webhook_url?: string;
}

export interface BFLFluxKontextMaxGenerateRequest {
    /**
     * The guidance scale for generation
     * @minimum 1
     * @maximum 20
     */
    guidance?: number;
    /** Base64 encoded image to be edited */
    input_image: string;
    /** The text prompt describing what to edit on the image */
    prompt: string;
    /**
     * Number of inference steps
     * @minimum 1
     * @maximum 50
     */
    steps?: number;
}

export interface BFLFluxKontextMaxGenerateResponse {
    /** Job ID for tracking */
    id: string;
    /** URL to poll for results */
    polling_url: string;
}

export interface BFLFluxKontextProGenerateRequest {
    /**
     * The guidance scale for generation
     * @minimum 1
     * @maximum 20
     */
    guidance?: number;
    /** Base64 encoded image to be edited */
    input_image: string;
    /** The text prompt describing what to edit on the image */
    prompt: string;
    /**
     * Number of inference steps
     * @minimum 1
     * @maximum 50
     */
    steps?: number;
}

export interface BFLFluxKontextProGenerateResponse {
    /** Job ID for tracking */
    id: string;
    /** URL to poll for results */
    polling_url: string;
}

/**
 * Output image format
 */
export type BFLFluxPro11GenerateRequestOutputFormat =
    (typeof BFLFluxPro11GenerateRequestOutputFormat)[keyof typeof BFLFluxPro11GenerateRequestOutputFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BFLFluxPro11GenerateRequestOutputFormat = {
    jpeg: "jpeg",
    png: "png",
} as const;

export interface BFLFluxPro11GenerateRequest {
    /** Height of the generated image */
    height: number;
    /** Optional image prompt */
    image_prompt?: string;
    /** Output image format */
    output_format?: BFLFluxPro11GenerateRequestOutputFormat;
    /** The main text prompt for image generation */
    prompt: string;
    /** Whether to use prompt upsampling */
    prompt_upsampling?: boolean;
    /** Safety tolerance level */
    safety_tolerance?: number;
    /** Random seed for reproducibility */
    seed?: number;
    /** Optional webhook secret for async processing */
    webhook_secret?: string;
    /** Optional webhook URL for async processing */
    webhook_url?: string;
    /** Width of the generated image */
    width: number;
}

export interface BFLFluxPro11GenerateResponse {
    /** Job ID for tracking */
    id: string;
    /** URL to poll for results */
    polling_url: string;
}

export interface BFLFluxProExpandInputs {
    /** Number of pixels to expand at the bottom of the image */
    bottom?: number;
    /** Guidance strength for the image generation process */
    guidance?: number;
    /** A Base64-encoded string representing the image you wish to expand. */
    image: string;
    /** Number of pixels to expand on the left side of the image */
    left?: number;
    /** Output format for the generated image. Can be 'jpeg' or 'png'. */
    output_format?: BFLOutputFormat;
    /** The description of the changes you want to make. This text guides the expansion process, allowing you to specify features, styles, or modifications for the expanded areas. */
    prompt?: string;
    /** Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation */
    prompt_upsampling?: boolean;
    /** Number of pixels to expand on the right side of the image */
    right?: number;
    /**
     * Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
     * @minimum 0
     * @maximum 6
     */
    safety_tolerance?: number;
    /** Optional seed for reproducibility */
    seed?: number;
    /** Number of steps for the image generation process */
    steps?: number;
    /** Number of pixels to expand at the top of the image */
    top?: number;
    /** Optional secret for webhook signature verification */
    webhook_secret?: string;
    /** URL to receive webhook notifications */
    webhook_url?: string;
}

export interface BFLFluxProFillInputs {
    /** Guidance strength for the image generation process */
    guidance?: number;
    /** A Base64-encoded string representing the image you wish to modify. Can contain alpha mask if desired. */
    image: string;
    /** A Base64-encoded string representing a mask for the areas you want to modify in the image. The mask should be the same dimensions as the image and in black and white. Black areas (0%) indicate no modification, while white areas (100%) specify areas for inpainting. Optional if you provide an alpha mask in the original image. Validation: The endpoint verifies that the dimensions of the mask match the original image. */
    mask?: string;
    /** Output format for the generated image. Can be 'jpeg' or 'png'. */
    output_format?: BFLOutputFormat;
    /** The description of the changes you want to make. This text guides the inpainting process, allowing you to specify features, styles, or modifications for the masked area. */
    prompt?: string;
    /** Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation */
    prompt_upsampling?: boolean;
    /**
     * Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
     * @minimum 0
     * @maximum 6
     */
    safety_tolerance?: number;
    /** Optional seed for reproducibility */
    seed?: number;
    /** Number of steps for the image generation process */
    steps?: number;
    /** Optional secret for webhook signature verification */
    webhook_secret?: string;
    /** URL to receive webhook notifications */
    webhook_url?: string;
}

/**
 * Request body for the BFL Flux Pro 1.1 Ultra image generation API.
 */
export interface BFLFluxProGenerateRequest {
    /**
     * The guidance scale for generation.
     * @minimum 1
     * @maximum 20
     */
    guidance_scale?: number;
    /**
     * The height of the image to generate.
     * @minimum 64
     * @maximum 2048
     */
    height: number;
    /** The negative prompt for image generation. */
    negative_prompt?: string;
    /**
     * The number of images to generate.
     * @minimum 1
     * @maximum 4
     */
    num_images?: number;
    /**
     * The number of inference steps.
     * @minimum 1
     * @maximum 100
     */
    num_inference_steps?: number;
    /** The text prompt for image generation. */
    prompt: string;
    /** The seed value for reproducibility. */
    seed?: number;
    /**
     * The width of the image to generate.
     * @minimum 64
     * @maximum 2048
     */
    width: number;
}

/**
 * Response from the BFL Flux Pro 1.1 Ultra image generation API.
 */
export interface BFLFluxProGenerateResponse {
    /** The unique identifier for the generation task. */
    id: string;
    /** URL to poll for the generation result. */
    polling_url: string;
}

export interface BFLHTTPValidationError {
    detail?: BFLValidationError[];
}

export type BFLOutputFormat =
    (typeof BFLOutputFormat)[keyof typeof BFLOutputFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BFLOutputFormat = {
    jpeg: "jpeg",
    png: "png",
} as const;

export type BFLValidationErrorLocItem = string | number;

export interface BFLValidationError {
    loc: BFLValidationErrorLocItem[];
    msg: string;
    type: string;
}

/**
 * Status of the retrieval operation
 */
export type BulkNodeVersionResultStatus =
    (typeof BulkNodeVersionResultStatus)[keyof typeof BulkNodeVersionResultStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BulkNodeVersionResultStatus = {
    success: "success",
    not_found: "not_found",
    error: "error",
} as const;

export interface BulkNodeVersionResult {
    /** Error message if retrieval failed (only present if status is error) */
    error_message?: string;
    identifier: NodeVersionIdentifier;
    node_version?: NodeVersion;
    /** Status of the retrieval operation */
    status: BulkNodeVersionResultStatus;
}

export interface BulkNodeVersionsRequest {
    /** List of node ID and version pairs to retrieve */
    node_versions: NodeVersionIdentifier[];
}

export interface BulkNodeVersionsResponse {
    /** List of retrieved node versions with their status */
    node_versions: BulkNodeVersionResult[];
}

/**
 * Only seedream-4.0 and seededit-3.0-i2i support this parameter.

Enter the Base64 encoding or an accessible URL of the image to edit. Among the models, bytedance-seedream-4.0 supports inputting a single image or multiple images (see the multi-image blending example), while bytedance-seededit-3.0-i2 only supports single-image input.

‚Ä¢ Image URL: Make sure that the image URL is accessible.
‚Ä¢ Base64 encoding: The format must be data:image/<image format>;base64,<Base64 encoding>. Note: <image format> must be in lowercase, e.g., data:image/png;base64,<base64_image>.

An input image must meet the following requirements:
‚Ä¢ Image format: jpeg, png
‚Ä¢ Aspect ratio (width/height): In the range [1/3, 3]
‚Ä¢ Width and height (px): > 14
‚Ä¢ Size: No more than 10 MB

 */
export type BytePlusImageGenerationRequestImage = string | string[];

export type BytePlusImageGenerationRequestModel =
    (typeof BytePlusImageGenerationRequestModel)[keyof typeof BytePlusImageGenerationRequestModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BytePlusImageGenerationRequestModel = {
    "seedream-3-0-t2i-250415": "seedream-3-0-t2i-250415",
    "seededit-3-0-i2i-250628": "seededit-3-0-i2i-250628",
    "seedream-4-0-250828": "seedream-4-0-250828",
} as const;

/**
 * Specifies the format of the generated image returned in the response
 */
export type BytePlusImageGenerationRequestResponseFormat =
    (typeof BytePlusImageGenerationRequestResponseFormat)[keyof typeof BytePlusImageGenerationRequestResponseFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BytePlusImageGenerationRequestResponseFormat = {
    url: "url",
    b64_json: "b64_json",
} as const;

/**
 * Only seedream-4.0 supports this parameter.
Configuration for the batch image generation feature. This parameter is only effective when sequential_image_generation is set to auto.

 */
export type BytePlusImageGenerationRequestSequentialImageGenerationOptions = {
    /**
     * Specifies the maximum number of images to generate in this request. Number of input reference images + Number of generated images ‚â§ 15.
     * @minimum 1
     * @maximum 15
     */
    max_images?: number;
};

export interface BytePlusImageGenerationRequest {
    /**
     * Controls how closely the output image aligns with the input prompt. Range [1, 10]. Higher values result in stronger prompt adherence. Default 2.5 for seedream-3-0-t2i-250415 and 5.5 for seededit-3-0-i2i-250628
     * @minimum 1
     * @maximum 10
     */
    guidance_scale?: number;
    /** Only seedream-4.0 and seededit-3.0-i2i support this parameter.

Enter the Base64 encoding or an accessible URL of the image to edit. Among the models, bytedance-seedream-4.0 supports inputting a single image or multiple images (see the multi-image blending example), while bytedance-seededit-3.0-i2 only supports single-image input.

‚Ä¢ Image URL: Make sure that the image URL is accessible.
‚Ä¢ Base64 encoding: The format must be data:image/<image format>;base64,<Base64 encoding>. Note: <image format> must be in lowercase, e.g., data:image/png;base64,<base64_image>.

An input image must meet the following requirements:
‚Ä¢ Image format: jpeg, png
‚Ä¢ Aspect ratio (width/height): In the range [1/3, 3]
‚Ä¢ Width and height (px): > 14
‚Ä¢ Size: No more than 10 MB
 */
    image?: BytePlusImageGenerationRequestImage;
    model: BytePlusImageGenerationRequestModel;
    /** Text description for image generation or transformation */
    prompt: string;
    /** Specifies the format of the generated image returned in the response */
    response_format?: BytePlusImageGenerationRequestResponseFormat;
    /** Random seed to control the stochasticity of image generation. Range: [-1, 2147483647]. If not specified, a seed will be automatically generated. To reproduce the same output, use the same seed value. */
    seed?: number;
    /** Controls whether to disable the batch generation feature. This parameter is only supported on seedream-4.0. Valid values:
auto: In automatic mode, the model automatically determines whether to return multiple images and how many images it will contain based on the user's prompt.
disabled: Disables batch generation feature. The model will only generate one image.
 */
    sequential_image_generation?: string;
    /** Only seedream-4.0 supports this parameter.
Configuration for the batch image generation feature. This parameter is only effective when sequential_image_generation is set to auto.
 */
    sequential_image_generation_options?: BytePlusImageGenerationRequestSequentialImageGenerationOptions;
    /** "seedream-3-0-t2i-250415": Specifies the dimensions (width x height in pixels) of the generated image. Must be between [512x512, 2048x2048]
"seededit-3-0-i2i-250628": The width and height pixels of the generated image. Currently only supports adaptive.
"seedream-4-0-250828": Set the specification for the generated image. Two methods are available but cannot be used together.
  Method 1 | Example: Specify the resolution of the generated image, and describe its aspect ratio, shape, or purpose in the prompt using natural language, let the model ultimately determine the final image width and height.
    Optional values: 1K, 2K, 4K
  Method 2 | Example: Specify the width and height of the generated image in pixels:
    Default value: 2048x2048
    The value range of total pixels: [1024x1024, 4096x4096] 
    The aspect ratio value range: [1/16, 16]
 */
    size?: string;
    /** Specifies whether to add a watermark to the generated image. false = No watermark, true = Adds watermark with 'AI generated' label */
    watermark?: boolean;
}

export type BytePlusImageGenerationResponseDataItem = {
    /** Base64-encoded image data (if response_format is "b64_json") */
    b64_json?: string;
    /** URL for image download (if response_format is "url") */
    url?: string;
};

/**
 * Error information (if any)
 */
export type BytePlusImageGenerationResponseError = {
    /** Error code */
    code?: string;
    /** Error message */
    message?: string;
};

export type BytePlusImageGenerationResponseUsage = {
    /** Number of images generated by the model */
    generated_images?: number;
    /** The number of tokens used for the picture generated by the model. */
    output_tokens?: number;
    /** The total number of tokens consumed by this request. */
    total_tokens?: number;
};

export interface BytePlusImageGenerationResponse {
    /** Unix timestamp (in seconds) indicating the time when the request was created */
    created?: number;
    /** Contains information about the generated image(s) */
    data?: BytePlusImageGenerationResponseDataItem[];
    /** Error information (if any) */
    error?: BytePlusImageGenerationResponseError;
    /** The model ID used for the request */
    model?: string;
    usage?: BytePlusImageGenerationResponseUsage;
}

export type BytePlusVideoGenerationContentImageUrl = {
    /** Image content for image-to-video generation (when type is "image")
Image URL: Make sure that the image URL is accessible.
Base64-encoded content: Format must be data:image/<format>;base64,<content>
 */
    url?: string;
};

/**
 * The type of the input content
 */
export type BytePlusVideoGenerationContentType =
    (typeof BytePlusVideoGenerationContentType)[keyof typeof BytePlusVideoGenerationContentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BytePlusVideoGenerationContentType = {
    text: "text",
    image_url: "image_url",
} as const;

export interface BytePlusVideoGenerationContent {
    image_url?: BytePlusVideoGenerationContentImageUrl;
    /**
   * The input text information for the model. Includes text prompt and optional parameters.

Text prompt (required): Description of the video to be generated using Chinese and English characters.

Parameters (optional): Add --[parameters] after the text prompt to control video specifications:
- --resolution (--rs): 480p, 720p, 1080p (default: 720p)
- --ratio (--rt): 21:9, 16:9, 4:3, 1:1, 3:4, 9:16, 9:21, adaptive (default: 16:9 or adaptive)
- --duration (--dur): 3-12 seconds (default: 5)
- --framepersecond (--fps): 24 (default: 24)
- --watermark (--wm): true/false (default: false)
- --seed (--seed): -1 to 2^32-1 (default: -1)
- --camerafixed (--cf): true/false (default: false)

Example: "A beautiful landscape --ratio 16:9 --resolution 720p --duration 5"

   * @maxLength 4096
   */
    text?: string;
    /** The type of the input content */
    type: BytePlusVideoGenerationContentType;
}

/**
 * The output after the video generation task is completed, which contains the download URL of the output video.
 */
export type BytePlusVideoGenerationQueryResponseContent = {
    /** The URL of the output video. For security purposes, the output video is cleared after 24 hours. */
    video_url?: string;
};

/**
 * The error information. If the task succeeds, null is returned. If the task fails, the error information is returned.
 * @nullable
 */
export type BytePlusVideoGenerationQueryResponseError = {
    /** The error code */
    code?: string;
    /** The error message */
    message?: string;
} | null;

/**
 * The state of the task
 */
export type BytePlusVideoGenerationQueryResponseStatus =
    (typeof BytePlusVideoGenerationQueryResponseStatus)[keyof typeof BytePlusVideoGenerationQueryResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BytePlusVideoGenerationQueryResponseStatus = {
    queued: "queued",
    running: "running",
    cancelled: "cancelled",
    succeeded: "succeeded",
    failed: "failed",
} as const;

/**
 * The token usage for the request
 */
export type BytePlusVideoGenerationQueryResponseUsage = {
    /** The number of tokens generated by the model */
    completion_tokens?: number;
    /** For the video generation model, the number of input tokens is not calculated and defaults to 0. Therefore, total_tokens = completion_tokens. */
    total_tokens?: number;
};

export interface BytePlusVideoGenerationQueryResponse {
    /** The output after the video generation task is completed, which contains the download URL of the output video. */
    content?: BytePlusVideoGenerationQueryResponseContent;
    /** The time when the task was created. The value is a UNIX timestamp in seconds. */
    created_at?: number;
    /**
     * The error information. If the task succeeds, null is returned. If the task fails, the error information is returned.
     * @nullable
     */
    error?: BytePlusVideoGenerationQueryResponseError;
    /** The ID of the video generation task */
    id?: string;
    /** The name and version of the model used by the task */
    model?: string;
    /** The state of the task */
    status?: BytePlusVideoGenerationQueryResponseStatus;
    /** The time when the task was last updated. The value is a UNIX timestamp in seconds. */
    updated_at?: number;
    /** The token usage for the request */
    usage?: BytePlusVideoGenerationQueryResponseUsage;
}

/**
 * The ID of the model to call. Available models include seedance-1-0-pro-250528, seedance-1-0-lite-t2v-250428, seedance-1-0-lite-i2v-250428
 */
export type BytePlusVideoGenerationRequestModel =
    (typeof BytePlusVideoGenerationRequestModel)[keyof typeof BytePlusVideoGenerationRequestModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BytePlusVideoGenerationRequestModel = {
    "seedance-1-0-pro-250528": "seedance-1-0-pro-250528",
    "seedance-1-0-lite-t2v-250428": "seedance-1-0-lite-t2v-250428",
    "seedance-1-0-lite-i2v-250428": "seedance-1-0-lite-i2v-250428",
} as const;

export interface BytePlusVideoGenerationRequest {
    /** Callback notification address for the result of this generation task */
    callback_url?: string;
    /**
     * The input content for the model to generate a video
     * @minItems 1
     */
    content: BytePlusVideoGenerationContent[];
    /** The ID of the model to call. Available models include seedance-1-0-pro-250528, seedance-1-0-lite-t2v-250428, seedance-1-0-lite-i2v-250428 */
    model: BytePlusVideoGenerationRequestModel;
}

export interface BytePlusVideoGenerationResponse {
    /** The ID of the video generation task */
    id: string;
}

export interface ClaimMyNodeRequest {
    /** GitHub token to verify if the user owns the repo of the node */
    GH_TOKEN: string;
}

export interface ComfyNode {
    /** UI category where the node is listed, used for grouping nodes. */
    category?: string;
    /** Unique identifier for the node */
    comfy_node_name?: string;
    /** Indicates if the node is deprecated. Deprecated nodes are hidden in the UI. */
    deprecated?: boolean;
    /** Brief description of the node's functionality or purpose. */
    description?: string;
    /** Indicates if the node is experimental, subject to changes or removal. */
    experimental?: boolean;
    /** Name of the entry-point function to execute the node. */
    function?: string;
    /** Defines input parameters */
    input_types?: string;
    /** Boolean values indicating if each output is a list. */
    output_is_list?: boolean[];
    /** Names of the outputs for clarity in workflows. */
    return_names?: string;
    /** Specifies the types of outputs produced by the node. */
    return_types?: string;
}

export interface ComfyNodeCloudBuildInfo {
    build_id?: string;
    location?: string;
    project_id?: string;
    project_number?: string;
}

export type ComputerToolCallAction = { [key: string]: unknown };

/**
 * The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.

 */
export type ComputerToolCallStatus =
    (typeof ComputerToolCallStatus)[keyof typeof ComputerToolCallStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ComputerToolCallStatus = {
    in_progress: "in_progress",
    completed: "completed",
    incomplete: "incomplete",
} as const;

/**
 * The type of the computer call. Always `computer_call`.
 */
export type ComputerToolCallType =
    (typeof ComputerToolCallType)[keyof typeof ComputerToolCallType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ComputerToolCallType = {
    computer_call: "computer_call",
} as const;

/**
 * A tool call to a computer use tool. See the 
[computer use guide](/docs/guides/tools-computer-use) for more information.

 */
export interface ComputerToolCall {
    action: ComputerToolCallAction;
    /** An identifier used when responding to the tool call with output.
     */
    call_id: string;
    /** The unique ID of the computer call. */
    id: string;
    /** The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.
 */
    status: ComputerToolCallStatus;
    /** The type of the computer call. Always `computer_call`. */
    type: ComputerToolCallType;
}

/**
 * The type of computer environment to control.
 */
export type ComputerUsePreviewToolEnvironment =
    (typeof ComputerUsePreviewToolEnvironment)[keyof typeof ComputerUsePreviewToolEnvironment];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ComputerUsePreviewToolEnvironment = {
    windows: "windows",
    mac: "mac",
    linux: "linux",
    ubuntu: "ubuntu",
    browser: "browser",
} as const;

/**
 * The type of the computer use tool. Always `computer_use_preview`.
 */
export type ComputerUsePreviewToolType =
    (typeof ComputerUsePreviewToolType)[keyof typeof ComputerUsePreviewToolType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ComputerUsePreviewToolType = {
    computer_use_preview: "computer_use_preview",
} as const;

/**
 * A tool that controls a virtual computer. Learn more about the [computer tool](https://platform.openai.com/docs/guides/tools-computer-use).
 */
export interface ComputerUsePreviewTool {
    /** The height of the computer display. */
    display_height: number;
    /** The width of the computer display. */
    display_width: number;
    /** The type of computer environment to control. */
    environment: ComputerUsePreviewToolEnvironment;
    /** The type of the computer use tool. Always `computer_use_preview`. */
    type: ComputerUsePreviewToolType;
}

export interface CreateAPIKeyRequest {
    description?: string;
    name: string;
}

export type CreateModelResponseProperties = ModelResponseProperties;

export interface Customer {
    /** The date and time the user was created */
    createdAt?: string;
    /** The email address for this user */
    email?: string;
    /** Whether the user has funds */
    has_fund?: boolean;
    /** The firebase UID of the user */
    id: string;
    /** Whether the user is an admin */
    is_admin?: boolean;
    /** The Metronome customer ID */
    metronome_id?: string;
    /** The name for this user */
    name?: string;
    /** The Stripe customer ID */
    stripe_id?: string;
    /** The date and time the user was last updated */
    updatedAt?: string;
}

export interface CustomerStorageResourceResponse {
    /** The signed URL to use for downloading the file from the specified path */
    download_url?: string;
    /** Whether an existing file with the same hash was found */
    existing_file?: boolean;
    /** When the signed URL will expire */
    expires_at?: string;
    /** The signed URL to use for uploading the file to the specified path */
    upload_url?: string;
}

/**
 * Text, image, or audio input to the model, used to generate a response.
Can also contain previous assistant responses.

 */
export type EasyInputMessageContent = string | InputMessageContentList;

/**
 * The role of the message input. One of `user`, `assistant`, `system`, or
`developer`.

 */
export type EasyInputMessageRole =
    (typeof EasyInputMessageRole)[keyof typeof EasyInputMessageRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EasyInputMessageRole = {
    user: "user",
    assistant: "assistant",
    system: "system",
    developer: "developer",
} as const;

/**
 * The type of the message input. Always `message`.

 */
export type EasyInputMessageType =
    (typeof EasyInputMessageType)[keyof typeof EasyInputMessageType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EasyInputMessageType = {
    message: "message",
} as const;

/**
 * A message input to the model with a role indicating instruction following
hierarchy. Instructions given with the `developer` or `system` role take
precedence over instructions given with the `user` role. Messages with the
`assistant` role are presumed to have been generated by the model in previous
interactions.

 */
export interface EasyInputMessage {
    /** Text, image, or audio input to the model, used to generate a response.
Can also contain previous assistant responses.
 */
    content: EasyInputMessageContent;
    /** The role of the message input. One of `user`, `assistant`, `system`, or
`developer`.
 */
    role: EasyInputMessageRole;
    /** The type of the message input. Always `message`.
     */
    type?: EasyInputMessageType;
}

export interface Error {
    /** Optional detailed information about the error or hints for resolving it. */
    details?: string[];
    /** A clear and concise description of the error. */
    message?: string;
}

export interface ErrorResponse {
    error: string;
    message: string;
}

/**
 * The type of tool
 */
export type FileSearchToolType =
    (typeof FileSearchToolType)[keyof typeof FileSearchToolType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FileSearchToolType = {
    file_search: "file_search",
} as const;

export interface FileSearchTool {
    /** The type of tool */
    type: FileSearchToolType;
    /** IDs of vector stores to search in */
    vector_store_ids: string[];
}

export type FileSearchToolCallResultsItem = {
    /** The unique ID of the file.
     */
    file_id?: string;
    /** The name of the file.
     */
    filename?: string;
    /** The relevance score of the file - a value between 0 and 1.
     */
    score?: number;
    /** The text that was retrieved from the file.
     */
    text?: string;
};

/**
 * The status of the file search tool call. One of `in_progress`, 
`searching`, `incomplete` or `failed`,

 */
export type FileSearchToolCallStatus =
    (typeof FileSearchToolCallStatus)[keyof typeof FileSearchToolCallStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FileSearchToolCallStatus = {
    in_progress: "in_progress",
    searching: "searching",
    completed: "completed",
    incomplete: "incomplete",
    failed: "failed",
} as const;

/**
 * The type of the file search tool call. Always `file_search_call`.

 */
export type FileSearchToolCallType =
    (typeof FileSearchToolCallType)[keyof typeof FileSearchToolCallType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FileSearchToolCallType = {
    file_search_call: "file_search_call",
} as const;

/**
 * The results of a file search tool call. See the 
[file search guide](/docs/guides/tools-file-search) for more information.

 */
export interface FileSearchToolCall {
    /** The unique ID of the file search tool call.
     */
    id: string;
    /** The queries used to search for files.
     */
    queries: string[];
    /** The results of the file search tool call.
     */
    results?: FileSearchToolCallResultsItem[];
    /** The status of the file search tool call. One of `in_progress`, 
`searching`, `incomplete` or `failed`,
 */
    status: FileSearchToolCallStatus;
    /** The type of the file search tool call. Always `file_search_call`.
     */
    type: FileSearchToolCallType;
}

/**
 * JSON Schema object describing the function parameters
 */
export type FunctionToolParameters = { [key: string]: unknown };

/**
 * The type of tool
 */
export type FunctionToolType =
    (typeof FunctionToolType)[keyof typeof FunctionToolType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FunctionToolType = {
    function: "function",
} as const;

export interface FunctionTool {
    /** Description of what the function does */
    description?: string;
    /** Name of the function */
    name: string;
    /** JSON Schema object describing the function parameters */
    parameters: FunctionToolParameters;
    /** The type of tool */
    type: FunctionToolType;
}

/**
 * The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.

 */
export type FunctionToolCallStatus =
    (typeof FunctionToolCallStatus)[keyof typeof FunctionToolCallStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FunctionToolCallStatus = {
    in_progress: "in_progress",
    completed: "completed",
    incomplete: "incomplete",
} as const;

/**
 * The type of the function tool call. Always `function_call`.

 */
export type FunctionToolCallType =
    (typeof FunctionToolCallType)[keyof typeof FunctionToolCallType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FunctionToolCallType = {
    function_call: "function_call",
} as const;

/**
 * A tool call to run a function. See the 
[function calling guide](/docs/guides/function-calling) for more information.

 */
export interface FunctionToolCall {
    /** A JSON string of the arguments to pass to the function.
     */
    arguments: string;
    /** The unique ID of the function tool call generated by the model.
     */
    call_id: string;
    /** The unique ID of the function tool call.
     */
    id?: string;
    /** The name of the function to run.
     */
    name: string;
    /** The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.
 */
    status?: FunctionToolCallStatus;
    /** The type of the function tool call. Always `function_call`.
     */
    type: FunctionToolCallType;
}

export interface GeminiCandidate {
    citationMetadata?: GeminiCitationMetadata;
    content?: GeminiContent;
    finishReason?: string;
    safetyRatings?: GeminiSafetyRating[];
}

export interface GeminiCitation {
    authors?: string[];
    endIndex?: number;
    license?: string;
    publicationDate?: string;
    startIndex?: number;
    title?: string;
    uri?: string;
}

export interface GeminiCitationMetadata {
    citations?: GeminiCitation[];
}

export type GeminiContentRole =
    (typeof GeminiContentRole)[keyof typeof GeminiContentRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GeminiContentRole = {
    user: "user",
    model: "model",
} as const;

/**
 * The content of the current conversation with the model. For single-turn queries, this is a single instance. For multi-turn queries, this is a repeated field that contains conversation history and the latest request.

 */
export interface GeminiContent {
    parts: GeminiPart[];
    role: GeminiContentRole;
}

/**
 * JSON schema for the function parameters
 */
export type GeminiFunctionDeclarationParameters = { [key: string]: unknown };

export interface GeminiFunctionDeclaration {
    description?: string;
    name: string;
    /** JSON schema for the function parameters */
    parameters: GeminiFunctionDeclarationParameters;
}

export interface GeminiGenerateContentRequest {
    contents: GeminiContent[];
    generationConfig?: GeminiGenerationConfig;
    safetySettings?: GeminiSafetySetting[];
    systemInstruction?: GeminiSystemInstructionContent;
    tools?: GeminiTool[];
    videoMetadata?: GeminiVideoMetadata;
}

export interface GeminiGenerateContentResponse {
    candidates?: GeminiCandidate[];
    promptFeedback?: GeminiPromptFeedback;
    usageMetadata?: GeminiUsageMetadata;
}

export type GeminiGenerationConfigResponseModalitiesItem =
    (typeof GeminiGenerationConfigResponseModalitiesItem)[keyof typeof GeminiGenerationConfigResponseModalitiesItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GeminiGenerationConfigResponseModalitiesItem = {
    TEXT: "TEXT",
    IMAGE: "IMAGE",
} as const;

export interface GeminiGenerationConfig {
    /**
   * Maximum number of tokens that can be generated in the response. A token is approximately 4 characters. 100 tokens correspond to roughly 60-80 words.

   * @minimum 16
   * @maximum 8192
   */
    maxOutputTokens?: number;
    responseModalities?: GeminiGenerationConfigResponseModalitiesItem[];
    /** When seed is fixed to a specific value, the model makes a best effort to provide the same response for repeated requests. Deterministic output isn't guaranteed. Also, changing the model or parameter settings, such as the temperature, can cause variations in the response even when you use the same seed value. By default, a random seed value is used. Available for the following models:, gemini-2.5-flash, gemini-2.5-pro, gemini-2.5-flash-preview-04-1, gemini-2.5-pro-preview-05-0, gemini-2.0-flash-lite-00, gemini-2.0-flash-001
     */
    seed?: number;
    stopSequences?: string[];
    /**
   * The temperature is used for sampling during response generation, which occurs when topP and topK are applied. Temperature controls the degree of randomness in token selection. Lower temperatures are good for prompts that require a less open-ended or creative response, while higher temperatures can lead to more diverse or creative results. A temperature of 0 means that the highest probability tokens are always selected. In this case, responses for a given prompt are mostly deterministic, but a small amount of variation is still possible. If the model returns a response that's too generic, too short, or the model gives a fallback response, try increasing the temperature

   * @minimum 0
   * @maximum 2
   */
    temperature?: number;
    /**
   * Top-K changes how the model selects tokens for output. A top-K of 1 means the next selected token is the most probable among all tokens in the model's vocabulary. A top-K of 3 means that the next token is selected from among the 3 most probable tokens by using temperature.

   * @minimum 1
   */
    topK?: number;
    /**
   * If specified, nucleus sampling is used.
Top-P changes how the model selects tokens for output. Tokens are selected from the most (see top-K) to least probable until the sum of their probabilities equals the top-P value. For example, if tokens A, B, and C have a probability of 0.3, 0.2, and 0.1 and the top-P value is 0.5, then the model will select either A or B as the next token by using temperature and excludes C as a candidate.
Specify a lower value for less random responses and a higher value for more random responses.

   * @minimum 0
   * @maximum 1
   */
    topP?: number;
}

/**
 * Inline data in raw bytes. For gemini-2.0-flash-lite and gemini-2.0-flash, you can specify up to 3000 images by using inlineData.

 */
export interface GeminiInlineData {
    /** The base64 encoding of the image, PDF, or video to include inline in the prompt. When including media inline, you must also specify the media type (mimeType) of the data. Size limit: 20MB
     */
    data?: string;
    mimeType?: GeminiMimeType;
}

/**
 * The media type of the file specified in the data or fileUri fields. Acceptable values include the following. For gemini-2.0-flash-lite and gemini-2.0-flash, the maximum length of an audio file is 8.4 hours and the maximum length of a video file (without audio) is one hour. For more information, see Gemini audio and video requirements. Text files must be UTF-8 encoded. The contents of the text file count toward the token limit. There is no limit on image resolution.
 */
export type GeminiMimeType =
    (typeof GeminiMimeType)[keyof typeof GeminiMimeType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GeminiMimeType = {
    "application/pdf": "application/pdf",
    "audio/mpeg": "audio/mpeg",
    "audio/mp3": "audio/mp3",
    "audio/wav": "audio/wav",
    "image/png": "image/png",
    "image/jpeg": "image/jpeg",
    "image/webp": "image/webp",
    "text/plain": "text/plain",
    "video/mov": "video/mov",
    "video/mpeg": "video/mpeg",
    "video/mp4": "video/mp4",
    "video/mpg": "video/mpg",
    "video/avi": "video/avi",
    "video/wmv": "video/wmv",
    "video/mpegps": "video/mpegps",
    "video/flv": "video/flv",
} as const;

/**
 * Represents a duration offset for video timeline positions.

 */
export interface GeminiOffset {
    /**
   * Signed fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values.

   * @minimum 0
   * @maximum 999999999
   */
    nanos?: number;
    /**
   * Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive.

   * @minimum -315576000000
   * @maximum 315576000000
   */
    seconds?: number;
}

export interface GeminiPart {
    inlineData?: GeminiInlineData;
    /** A text prompt or code snippet. */
    text?: string;
}

export interface GeminiPromptFeedback {
    blockReason?: string;
    blockReasonMessage?: string;
    safetyRatings?: GeminiSafetyRating[];
}

export type GeminiSafetyCategory =
    (typeof GeminiSafetyCategory)[keyof typeof GeminiSafetyCategory];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GeminiSafetyCategory = {
    HARM_CATEGORY_SEXUALLY_EXPLICIT: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
    HARM_CATEGORY_HATE_SPEECH: "HARM_CATEGORY_HATE_SPEECH",
    HARM_CATEGORY_HARASSMENT: "HARM_CATEGORY_HARASSMENT",
    HARM_CATEGORY_DANGEROUS_CONTENT: "HARM_CATEGORY_DANGEROUS_CONTENT",
} as const;

/**
 * The probability that the content violates the specified safety category
 */
export type GeminiSafetyRatingProbability =
    (typeof GeminiSafetyRatingProbability)[keyof typeof GeminiSafetyRatingProbability];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GeminiSafetyRatingProbability = {
    NEGLIGIBLE: "NEGLIGIBLE",
    LOW: "LOW",
    MEDIUM: "MEDIUM",
    HIGH: "HIGH",
    UNKNOWN: "UNKNOWN",
} as const;

export interface GeminiSafetyRating {
    category?: GeminiSafetyCategory;
    /** The probability that the content violates the specified safety category */
    probability?: GeminiSafetyRatingProbability;
}

/**
 * Per request settings for blocking unsafe content. Enforced on GenerateContentResponse.candidates.

 */
export interface GeminiSafetySetting {
    category: GeminiSafetyCategory;
    threshold: GeminiSafetyThreshold;
}

export type GeminiSafetyThreshold =
    (typeof GeminiSafetyThreshold)[keyof typeof GeminiSafetyThreshold];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GeminiSafetyThreshold = {
    OFF: "OFF",
    BLOCK_NONE: "BLOCK_NONE",
    BLOCK_LOW_AND_ABOVE: "BLOCK_LOW_AND_ABOVE",
    BLOCK_MEDIUM_AND_ABOVE: "BLOCK_MEDIUM_AND_ABOVE",
    BLOCK_ONLY_HIGH: "BLOCK_ONLY_HIGH",
} as const;

/**
 * The identity of the entity that creates the message. The following values are supported: user: This indicates that the message is sent by a real person, typically a user-generated message. model: This indicates that the message is generated by the model. The model value is used to insert messages from the model into the conversation during multi-turn conversations. For non-multi-turn conversations, this field can be left blank or unset.

 */
export type GeminiSystemInstructionContentRole =
    (typeof GeminiSystemInstructionContentRole)[keyof typeof GeminiSystemInstructionContentRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GeminiSystemInstructionContentRole = {
    user: "user",
    model: "model",
} as const;

/**
 * Available for gemini-2.0-flash and gemini-2.0-flash-lite. Instructions for the model to steer it toward better performance. For example, "Answer as concisely as possible" or "Don't use technical terms in your response". The text strings count toward the token limit. The role field of systemInstruction is ignored and doesn't affect the performance of the model. Note: Only text should be used in parts and content in each part should be in a separate paragraph.

 */
export interface GeminiSystemInstructionContent {
    /** A list of ordered parts that make up a single message. Different parts may have different IANA MIME types. For limits on the inputs, such as the maximum number of tokens or the number of images, see the model specifications on the Google models page.
     */
    parts: GeminiTextPart[];
    /** The identity of the entity that creates the message. The following values are supported: user: This indicates that the message is sent by a real person, typically a user-generated message. model: This indicates that the message is generated by the model. The model value is used to insert messages from the model into the conversation during multi-turn conversations. For non-multi-turn conversations, this field can be left blank or unset.
     */
    role: GeminiSystemInstructionContentRole;
}

export interface GeminiTextPart {
    /** A text prompt or code snippet. */
    text?: string;
}

/**
 * A piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the model. See Function calling.

 */
export interface GeminiTool {
    functionDeclarations?: GeminiFunctionDeclaration[];
}

export interface GeminiUsageMetadata {
    /** Output only. Number of tokens in the cached part in the input (the cached content). */
    cachedContentTokenCount?: number;
    /** Number of tokens in the response(s). */
    candidatesTokenCount?: number;
    /** Breakdown of candidate tokens by modality. */
    candidatesTokensDetails?: ModalityTokenCount[];
    /** Number of tokens in the request. When cachedContent is set, this is still the total effective prompt size meaning this includes the number of tokens in the cached content. */
    promptTokenCount?: number;
    /** Breakdown of prompt tokens by modality. */
    promptTokensDetails?: ModalityTokenCount[];
    /** Number of tokens present in thoughts output. */
    thoughtsTokenCount?: number;
    /** Number of tokens present in tool-use prompt(s). */
    toolUsePromptTokenCount?: number;
}

/**
 * For video input, the start and end offset of the video in Duration format. For example, to specify a 10 second clip starting at 1:00, set "startOffset": { "seconds": 60 } and "endOffset": { "seconds": 70 }. The metadata should only be specified while the video data is presented in inlineData or fileData.

 */
export interface GeminiVideoMetadata {
    endOffset?: GeminiOffset;
    startOffset?: GeminiOffset;
}

/**
 * A map of operating system to status pairs
 */
export type GitCommitSummaryStatusSummary = { [key: string]: string };

export interface GitCommitSummary {
    /** The author of the commit */
    author?: string;
    /** The branch where the commit was made */
    branch_name?: string;
    /** The hash of the commit */
    commit_hash?: string;
    /** The name of the commit */
    commit_name?: string;
    /** A map of operating system to status pairs */
    status_summary?: GitCommitSummaryStatusSummary;
    /** The timestamp when the commit was made */
    timestamp?: string;
}

/**
 * A GitHub enterprise
 */
export interface GithubEnterprise {
    /** URL to the enterprise avatar */
    avatar_url: string;
    /** When the enterprise was created */
    created_at: string;
    /**
     * The enterprise description
     * @nullable
     */
    description?: string | null;
    /** The HTML URL of the enterprise */
    html_url: string;
    /** The enterprise ID */
    id: number;
    /** The enterprise name */
    name: string;
    /** The enterprise node ID */
    node_id: string;
    /** The enterprise slug */
    slug: string;
    /** When the enterprise was last updated */
    updated_at: string;
    /**
     * The enterprise website URL
     * @nullable
     */
    website_url?: string | null;
}

/**
 * The installation permissions
 */
export type GithubInstallationPermissions = { [key: string]: unknown };

/**
 * Repository selection for the installation
 */
export type GithubInstallationRepositorySelection =
    (typeof GithubInstallationRepositorySelection)[keyof typeof GithubInstallationRepositorySelection];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GithubInstallationRepositorySelection = {
    selected: "selected",
    all: "all",
} as const;

/**
 * A GitHub App installation
 */
export interface GithubInstallation {
    /** The API URL for access tokens */
    access_tokens_url: string;
    account: GithubUser;
    /** The GitHub App ID */
    app_id: number;
    /** When the installation was created */
    created_at: string;
    /** The events the installation subscribes to */
    events: string[];
    /** The HTML URL of the installation */
    html_url: string;
    /** The installation ID */
    id: number;
    /** The installation permissions */
    permissions: GithubInstallationPermissions;
    /** The API URL for repositories */
    repositories_url: string;
    /** Repository selection for the installation */
    repository_selection: GithubInstallationRepositorySelection;
    /**
     * The single file name if applicable
     * @nullable
     */
    single_file_name?: string | null;
    /** The target ID */
    target_id: number;
    /** The target type */
    target_type: string;
    /** When the installation was last updated */
    updated_at: string;
}

/**
 * A GitHub organization
 */
export interface GithubOrganization {
    /** URL to the organization's avatar */
    avatar_url: string;
    /**
     * The organization description
     * @nullable
     */
    description?: string | null;
    /** The API URL of the organization's events */
    events_url: string;
    /** The API URL of the organization's hooks */
    hooks_url: string;
    /** The organization ID */
    id: number;
    /** The API URL of the organization's issues */
    issues_url: string;
    /** The organization's login name */
    login: string;
    /** The API URL of the organization's members */
    members_url: string;
    /** The organization node ID */
    node_id: string;
    /** The API URL of the organization's public members */
    public_members_url: string;
    /** The API URL of the organization's repositories */
    repos_url: string;
    /** The API URL of the organization */
    url: string;
}

/**
 * The state of the asset
 */
export type GithubReleaseAssetState =
    (typeof GithubReleaseAssetState)[keyof typeof GithubReleaseAssetState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GithubReleaseAssetState = {
    uploaded: "uploaded",
    open: "open",
} as const;

/**
 * A GitHub release asset
 */
export interface GithubReleaseAsset {
    /** The browser download URL */
    browser_download_url: string;
    /** The content type of the asset */
    content_type: string;
    /** When the asset was created */
    created_at: string;
    /** The number of downloads */
    download_count: number;
    /** The asset ID */
    id: number;
    /**
     * The label of the asset
     * @nullable
     */
    label?: string | null;
    /** The name of the asset */
    name: string;
    /** The asset node ID */
    node_id: string;
    /** The size of the asset in bytes */
    size: number;
    /** The state of the asset */
    state: GithubReleaseAssetState;
    /** When the asset was last updated */
    updated_at: string;
    uploader: GithubUser;
}

/**
 * The action performed on the release
 */
export type GithubReleaseWebhookAction =
    (typeof GithubReleaseWebhookAction)[keyof typeof GithubReleaseWebhookAction];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GithubReleaseWebhookAction = {
    published: "published",
    unpublished: "unpublished",
    created: "created",
    edited: "edited",
    deleted: "deleted",
    prereleased: "prereleased",
    released: "released",
} as const;

/**
 * The release object
 */
export type GithubReleaseWebhookRelease = {
    /** Array of release assets */
    assets: GithubReleaseAsset[];
    /** The URL to the release assets */
    assets_url?: string;
    author: GithubUser;
    /**
     * The release notes/body
     * @nullable
     */
    body?: string | null;
    /** When the release was created */
    created_at: string;
    /** Whether the release is a draft */
    draft: boolean;
    /** The HTML URL of the release */
    html_url: string;
    /** The ID of the release */
    id: number;
    /**
     * The name of the release
     * @nullable
     */
    name?: string | null;
    /** The node ID of the release */
    node_id: string;
    /** Whether the release is a prerelease */
    prerelease: boolean;
    /**
     * When the release was published
     * @nullable
     */
    published_at?: string | null;
    /** The tag name of the release */
    tag_name: string;
    /** URL to the tarball */
    tarball_url: string;
    /** The branch or commit the release was created from */
    target_commitish: string;
    /** The URL to upload release assets */
    upload_url?: string;
    /** The API URL of the release */
    url: string;
    /** URL to the zipball */
    zipball_url: string;
};

/**
 * GitHub release webhook payload based on official webhook documentation
 */
export interface GithubReleaseWebhook {
    /** The action performed on the release */
    action: GithubReleaseWebhookAction;
    enterprise?: GithubEnterprise;
    installation?: GithubInstallation;
    organization?: GithubOrganization;
    /** The release object */
    release: GithubReleaseWebhookRelease;
    repository: GithubRepository;
    sender: GithubUser;
}

/**
 * A GitHub repository
 */
export interface GithubRepository {
    /** The clone URL of the repository */
    clone_url: string;
    /** When the repository was created */
    created_at: string;
    /** The default branch of the repository */
    default_branch: string;
    /**
     * The repository description
     * @nullable
     */
    description?: string | null;
    /** Whether the repository is a fork */
    fork: boolean;
    /** The full name of the repository (owner/repo) */
    full_name: string;
    /** The git URL of the repository */
    git_url: string;
    /** The HTML URL of the repository */
    html_url: string;
    /** The repository ID */
    id: number;
    /** The name of the repository */
    name: string;
    /** The repository node ID */
    node_id: string;
    owner: GithubUser;
    /** Whether the repository is private */
    private: boolean;
    /** When the repository was last pushed to */
    pushed_at: string;
    /** The SSH URL of the repository */
    ssh_url: string;
    /** When the repository was last updated */
    updated_at: string;
    /** The API URL of the repository */
    url: string;
}

/**
 * The type of user
 */
export type GithubUserType =
    (typeof GithubUserType)[keyof typeof GithubUserType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GithubUserType = {
    Bot: "Bot",
    User: "User",
    Organization: "Organization",
} as const;

/**
 * A GitHub user
 */
export interface GithubUser {
    /** URL to the user's avatar */
    avatar_url: string;
    /**
     * The user's gravatar ID
     * @nullable
     */
    gravatar_id?: string | null;
    /** The HTML URL of the user */
    html_url: string;
    /** The user's ID */
    id: number;
    /** The user's login name */
    login: string;
    /** The user's node ID */
    node_id: string;
    /** Whether the user is a site admin */
    site_admin: boolean;
    /** The type of user */
    type: GithubUserType;
    /** The API URL of the user */
    url: string;
}

export type IdeogramColorPaletteOneOf = {
    /** Name of the preset color palette */
    name: string;
};

export type IdeogramColorPaletteOneOfTwoMembersItem = {
    /**
     * Hexadecimal color code
     * @pattern ^#[0-9A-Fa-f]{6}$
     */
    color?: string;
    /**
     * Optional weight for the color (0-1)
     * @minimum 0
     * @maximum 1
     */
    weight?: number;
};

export type IdeogramColorPaletteOneOfTwo = {
    /** Array of color definitions with optional weights */
    members: IdeogramColorPaletteOneOfTwoMembersItem[];
};

/**
 * A color palette specification that can either use a preset name or explicit color definitions with weights
 */
export type IdeogramColorPalette =
    | IdeogramColorPaletteOneOf
    | IdeogramColorPaletteOneOfTwo;

/**
 * Optional. Color palette object. Only for V_2, V_2_TURBO.
 */
export type IdeogramGenerateRequestImageRequestColorPalette = {
    [key: string]: unknown;
};

/**
 * The image generation request parameters.
 */
export type IdeogramGenerateRequestImageRequest = {
    /** Optional. The aspect ratio (e.g., 'ASPECT_16_9', 'ASPECT_1_1'). Cannot be used with resolution. Defaults to 'ASPECT_1_1' if unspecified. */
    aspect_ratio?: string;
    /** Optional. Color palette object. Only for V_2, V_2_TURBO. */
    color_palette?: IdeogramGenerateRequestImageRequestColorPalette;
    /** Optional. MagicPrompt usage ('AUTO', 'ON', 'OFF'). */
    magic_prompt_option?: string;
    /** The model used (e.g., 'V_2', 'V_2A_TURBO') */
    model: string;
    /** Optional. Description of what to exclude. Only for V_1, V_1_TURBO, V_2, V_2_TURBO. */
    negative_prompt?: string;
    /**
     * Optional. Number of images to generate (1-8). Defaults to 1.
     * @minimum 1
     * @maximum 8
     */
    num_images?: number;
    /** Required. The prompt to use to generate the image. */
    prompt: string;
    /** Optional. Resolution (e.g., 'RESOLUTION_1024_1024'). Only for model V_2. Cannot be used with aspect_ratio. */
    resolution?: string;
    /**
     * Optional. A number between 0 and 2147483647.
     * @minimum 0
     * @maximum 2147483647
     */
    seed?: number;
    /** Optional. Style type ('AUTO', 'GENERAL', 'REALISTIC', 'DESIGN', 'RENDER_3D', 'ANIME'). Only for models V_2 and above. */
    style_type?: string;
};

/**
 * Parameters for the Ideogram generation proxy request. Based on Ideogram's API.
 */
export interface IdeogramGenerateRequest {
    /** The image generation request parameters. */
    image_request: IdeogramGenerateRequestImageRequest;
}

export type IdeogramGenerateResponseDataItem = {
    /** Indicates whether the image is considered safe. */
    is_image_safe?: boolean;
    /** The prompt used to generate this image. */
    prompt?: string;
    /** The resolution of the generated image (e.g., '1024x1024'). */
    resolution?: string;
    /** The seed value used for this generation. */
    seed?: number;
    /** The style type used for generation (e.g., 'REALISTIC', 'ANIME'). */
    style_type?: string;
    /** URL to the generated image. */
    url?: string;
};

/**
 * Response from the Ideogram image generation API.
 */
export interface IdeogramGenerateResponse {
    /** Timestamp when the generation was created. */
    created?: string;
    /** Array of generated image information. */
    data?: IdeogramGenerateResponseDataItem[];
}

export type IdeogramStyleType =
    (typeof IdeogramStyleType)[keyof typeof IdeogramStyleType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IdeogramStyleType = {
    AUTO: "AUTO",
    GENERAL: "GENERAL",
    REALISTIC: "REALISTIC",
    DESIGN: "DESIGN",
    FICTION: "FICTION",
} as const;

export interface IdeogramV3EditRequest {
    /** Generations with character reference are subject to the character reference pricing. A set of images to use as character references (maximum total size 10MB across all character references), currently only supports 1 character reference image. The images should be in JPEG, PNG or WebP format. */
    character_reference_images?: Blob[];
    /** Optional masks for character reference images. When provided, must match the number of character_reference_images. Each mask should be a grayscale image of the same dimensions as the corresponding character reference image. The images should be in JPEG, PNG or WebP format. */
    character_reference_images_mask?: Blob[];
    color_palette?: IdeogramColorPalette;
    /** The image being edited (max size 10MB); only JPEG, WebP and PNG formats are supported at this time. */
    image?: Blob;
    /** Determine if MagicPrompt should be used in generating the request or not. */
    magic_prompt?: string;
    /** A black and white image of the same size as the image being edited (max size 10MB). Black regions in the mask should match up with the regions of the image that you would like to edit; only JPEG, WebP and PNG formats are supported at this time. */
    mask?: Blob;
    /** The number of images to generate. */
    num_images?: number;
    /** The prompt used to describe the edited result. */
    prompt: string;
    rendering_speed: RenderingSpeed;
    /** Random seed. Set for reproducible generation. */
    seed?: number;
    /** A list of 8 character hexadecimal codes representing the style of the image. Cannot be used in conjunction with style_reference_images or style_type. */
    style_codes?: string[];
    /** A set of images to use as style references (maximum total size 10MB across all style references). The images should be in JPEG, PNG or WebP format. */
    style_reference_images?: Blob[];
    style_type?: IdeogramStyleType;
}

export type IdeogramV3IdeogramResponseDataItem = {
    is_image_safe?: boolean;
    prompt?: string;
    resolution?: string;
    seed?: number;
    style_type?: string;
    url?: string;
};

export interface IdeogramV3IdeogramResponse {
    created?: string;
    data?: IdeogramV3IdeogramResponseDataItem[];
}

export type IdeogramV3ReframeRequestColorPalette = { [key: string]: unknown };

export interface IdeogramV3ReframeRequest {
    color_palette?: IdeogramV3ReframeRequestColorPalette;
    image?: Blob;
    /**
     * @minimum 1
     * @maximum 8
     */
    num_images?: number;
    rendering_speed?: RenderingSpeed;
    resolution: string;
    /**
     * @minimum 0
     * @maximum 2147483647
     */
    seed?: number;
    style_codes?: string[];
    style_reference_images?: Blob[];
}

export type IdeogramV3RemixRequestColorPalette = { [key: string]: unknown };

export type IdeogramV3RemixRequestMagicPrompt =
    (typeof IdeogramV3RemixRequestMagicPrompt)[keyof typeof IdeogramV3RemixRequestMagicPrompt];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IdeogramV3RemixRequestMagicPrompt = {
    AUTO: "AUTO",
    ON: "ON",
    OFF: "OFF",
} as const;

export interface IdeogramV3RemixRequest {
    aspect_ratio?: string;
    /** Generations with character reference are subject to the character reference pricing. A set of images to use as character references (maximum total size 10MB across all character references), currently only supports 1 character reference image. The images should be in JPEG, PNG or WebP format. */
    character_reference_images?: Blob[];
    /** Optional masks for character reference images. When provided, must match the number of character_reference_images. Each mask should be a grayscale image of the same dimensions as the corresponding character reference image. The images should be in JPEG, PNG or WebP format. */
    character_reference_images_mask?: Blob[];
    color_palette?: IdeogramV3RemixRequestColorPalette;
    image?: Blob;
    /**
     * @minimum 1
     * @maximum 100
     */
    image_weight?: number;
    magic_prompt?: IdeogramV3RemixRequestMagicPrompt;
    negative_prompt?: string;
    /**
     * @minimum 1
     * @maximum 8
     */
    num_images?: number;
    prompt: string;
    rendering_speed?: RenderingSpeed;
    resolution?: string;
    /**
     * @minimum 0
     * @maximum 2147483647
     */
    seed?: number;
    style_codes?: string[];
    style_reference_images?: Blob[];
    style_type?: IdeogramStyleType;
}

export type IdeogramV3ReplaceBackgroundRequestColorPalette = {
    [key: string]: unknown;
};

export type IdeogramV3ReplaceBackgroundRequestMagicPrompt =
    (typeof IdeogramV3ReplaceBackgroundRequestMagicPrompt)[keyof typeof IdeogramV3ReplaceBackgroundRequestMagicPrompt];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IdeogramV3ReplaceBackgroundRequestMagicPrompt = {
    AUTO: "AUTO",
    ON: "ON",
    OFF: "OFF",
} as const;

export interface IdeogramV3ReplaceBackgroundRequest {
    color_palette?: IdeogramV3ReplaceBackgroundRequestColorPalette;
    image?: Blob;
    magic_prompt?: IdeogramV3ReplaceBackgroundRequestMagicPrompt;
    /**
     * @minimum 1
     * @maximum 8
     */
    num_images?: number;
    prompt: string;
    rendering_speed?: RenderingSpeed;
    /**
     * @minimum 0
     * @maximum 2147483647
     */
    seed?: number;
    style_codes?: string[];
    style_reference_images?: Blob[];
}

export type IdeogramV3RequestColorPalette = {
    /** Name of the color palette */
    name: string;
};

/**
 * Whether to enable magic prompt enhancement
 */
export type IdeogramV3RequestMagicPrompt =
    (typeof IdeogramV3RequestMagicPrompt)[keyof typeof IdeogramV3RequestMagicPrompt];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IdeogramV3RequestMagicPrompt = {
    ON: "ON",
    OFF: "OFF",
} as const;

export interface IdeogramV3Request {
    /** Aspect ratio in format WxH */
    aspect_ratio?: string;
    /** Generations with character reference are subject to the character reference pricing. A set of images to use as character references (maximum total size 10MB across all character references), currently only supports 1 character reference image. The images should be in JPEG, PNG or WebP format. */
    character_reference_images?: Blob[];
    /** Optional masks for character reference images. When provided, must match the number of character_reference_images. Each mask should be a grayscale image of the same dimensions as the corresponding character reference image. The images should be in JPEG, PNG or WebP format. */
    character_reference_images_mask?: Blob[];
    color_palette?: IdeogramV3RequestColorPalette;
    /** Whether to enable magic prompt enhancement */
    magic_prompt?: IdeogramV3RequestMagicPrompt;
    /** Text prompt specifying what to avoid in the generation */
    negative_prompt?: string;
    /**
     * Number of images to generate
     * @minimum 1
     */
    num_images?: number;
    /** The text prompt for image generation */
    prompt: string;
    rendering_speed: RenderingSpeed;
    /** Image resolution in format WxH */
    resolution?: string;
    /** Seed value for reproducible generation */
    seed?: number;
    /** Array of style codes in hexadecimal format */
    style_codes?: string[];
    /** Array of reference image URLs or identifiers */
    style_reference_images?: Blob[];
    style_type?: IdeogramStyleType;
}

export interface ImagenGenerateImageRequest {
    instances: ImagenImageGenerationInstance[];
    parameters: ImagenImageGenerationParameters;
}

export interface ImagenGenerateImageResponse {
    predictions?: ImagenImagePrediction[];
}

export interface ImagenImageGenerationInstance {
    /** Text prompt for image generation */
    prompt: string;
}

export type ImagenImageGenerationParametersAspectRatio =
    (typeof ImagenImageGenerationParametersAspectRatio)[keyof typeof ImagenImageGenerationParametersAspectRatio];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImagenImageGenerationParametersAspectRatio = {
    "1:1": "1:1",
    "9:16": "9:16",
    "16:9": "16:9",
    "3:4": "3:4",
    "4:3": "4:3",
} as const;

export type ImagenImageGenerationParametersPersonGeneration =
    (typeof ImagenImageGenerationParametersPersonGeneration)[keyof typeof ImagenImageGenerationParametersPersonGeneration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImagenImageGenerationParametersPersonGeneration = {
    dont_allow: "dont_allow",
    allow_adult: "allow_adult",
    allow_all: "allow_all",
} as const;

export type ImagenImageGenerationParametersSafetySetting =
    (typeof ImagenImageGenerationParametersSafetySetting)[keyof typeof ImagenImageGenerationParametersSafetySetting];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImagenImageGenerationParametersSafetySetting = {
    block_most: "block_most",
    block_some: "block_some",
    block_few: "block_few",
    block_fewest: "block_fewest",
} as const;

export interface ImagenImageGenerationParameters {
    addWatermark?: boolean;
    aspectRatio?: ImagenImageGenerationParametersAspectRatio;
    enhancePrompt?: boolean;
    includeRaiReason?: boolean;
    includeSafetyAttributes?: boolean;
    outputOptions?: ImagenOutputOptions;
    personGeneration?: ImagenImageGenerationParametersPersonGeneration;
    safetySetting?: ImagenImageGenerationParametersSafetySetting;
    /**
     * @minimum 1
     * @maximum 4
     */
    sampleCount?: number;
    seed?: number;
    storageUri?: string;
}

export interface ImagenImagePrediction {
    /** Base64-encoded image content */
    bytesBase64Encoded?: string;
    /** MIME type of the generated image */
    mimeType?: string;
    /** Enhanced or rewritten prompt used to generate this image */
    prompt?: string;
}

export type ImagenOutputOptionsMimeType =
    (typeof ImagenOutputOptionsMimeType)[keyof typeof ImagenOutputOptionsMimeType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImagenOutputOptionsMimeType = {
    "image/png": "image/png",
    "image/jpeg": "image/jpeg",
} as const;

export interface ImagenOutputOptions {
    /**
     * @minimum 0
     * @maximum 100
     */
    compressionQuality?: number;
    mimeType?: ImagenOutputOptionsMimeType;
}

/**
 * Specify additional output data to include in the model response. Currently
supported values are:
- `file_search_call.results`: Include the search results of
  the file search tool call.
- `message.input_image.image_url`: Include image urls from the input message.
- `computer_call_output.output.image_url`: Include image urls from the computer call output.

 */
export type Includable = (typeof Includable)[keyof typeof Includable];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Includable = {
    file_search_callresults: "file_search_call.results",
    messageinput_imageimage_url: "message.input_image.image_url",
    computer_call_outputoutputimage_url:
        "computer_call_output.output.image_url",
} as const;

export type InputContent =
    | InputTextContent
    | InputImageContent
    | InputFileContent;

/**
 * The type of the input item. Always `input_file`.
 */
export type InputFileContentType =
    (typeof InputFileContentType)[keyof typeof InputFileContentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InputFileContentType = {
    input_file: "input_file",
} as const;

/**
 * A file input to the model.
 */
export interface InputFileContent {
    /** The content of the file to be sent to the model.
     */
    file_data?: string;
    /** The ID of the file to be sent to the model. */
    file_id?: string;
    /** The name of the file to be sent to the model. */
    filename?: string;
    /** The type of the input item. Always `input_file`. */
    type: InputFileContentType;
}

/**
 * The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`.
 */
export type InputImageContentDetail =
    (typeof InputImageContentDetail)[keyof typeof InputImageContentDetail];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InputImageContentDetail = {
    low: "low",
    high: "high",
    auto: "auto",
} as const;

/**
 * The type of the input item. Always `input_image`.
 */
export type InputImageContentType =
    (typeof InputImageContentType)[keyof typeof InputImageContentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InputImageContentType = {
    input_image: "input_image",
} as const;

/**
 * An image input to the model. Learn about [image inputs](/docs/guides/vision).
 */
export interface InputImageContent {
    /** The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`. */
    detail: InputImageContentDetail;
    /** The ID of the file to be sent to the model. */
    file_id?: string;
    /** The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL. */
    image_url?: string;
    /** The type of the input item. Always `input_image`. */
    type: InputImageContentType;
}

export type InputItem = EasyInputMessage | Item;

export type InputMessageRole =
    (typeof InputMessageRole)[keyof typeof InputMessageRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InputMessageRole = {
    user: "user",
    system: "system",
    developer: "developer",
} as const;

export type InputMessageStatus =
    (typeof InputMessageStatus)[keyof typeof InputMessageStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InputMessageStatus = {
    in_progress: "in_progress",
    completed: "completed",
    incomplete: "incomplete",
} as const;

export type InputMessageType =
    (typeof InputMessageType)[keyof typeof InputMessageType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InputMessageType = {
    message: "message",
} as const;

export interface InputMessage {
    content?: InputMessageContentList;
    role?: InputMessageRole;
    status?: InputMessageStatus;
    type?: InputMessageType;
}

/**
 * A list of one or many input items to the model, containing different content 
types.

 */
export type InputMessageContentList = InputContent[];

/**
 * The type of the input item. Always `input_text`.
 */
export type InputTextContentType =
    (typeof InputTextContentType)[keyof typeof InputTextContentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InputTextContentType = {
    input_text: "input_text",
} as const;

/**
 * A text input to the model.
 */
export interface InputTextContent {
    /** The text input to the model. */
    text: string;
    /** The type of the input item. Always `input_text`. */
    type: InputTextContentType;
}

/**
 * Content item used to generate a response.

 */
export type Item =
    | InputMessage
    | OutputMessage
    | FileSearchToolCall
    | ComputerToolCall
    | WebSearchToolCall
    | FunctionToolCall
    | ReasoningItem;

/**
 * Method of Transmitting Audio Files for Lip-Sync. Required when mode is audio2video.
 */
export type KlingAudioUploadType =
    (typeof KlingAudioUploadType)[keyof typeof KlingAudioUploadType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingAudioUploadType = {
    file: "file",
    url: "url",
} as const;

export interface KlingCameraConfig {
    /**
     * Controls camera's movement along horizontal axis (x-axis). Negative indicates left, positive indicates right.
     * @minimum -10
     * @maximum 10
     */
    horizontal?: number;
    /**
     * Controls camera's rotation in vertical plane (x-axis). Negative indicates downward rotation, positive indicates upward rotation.
     * @minimum -10
     * @maximum 10
     */
    pan?: number;
    /**
     * Controls camera's rolling amount (z-axis). Negative indicates counterclockwise, positive indicates clockwise.
     * @minimum -10
     * @maximum 10
     */
    roll?: number;
    /**
     * Controls camera's rotation in horizontal plane (y-axis). Negative indicates left rotation, positive indicates right rotation.
     * @minimum -10
     * @maximum 10
     */
    tilt?: number;
    /**
     * Controls camera's movement along vertical axis (y-axis). Negative indicates downward, positive indicates upward.
     * @minimum -10
     * @maximum 10
     */
    vertical?: number;
    /**
     * Controls change in camera's focal length. Negative indicates narrower field of view, positive indicates wider field of view.
     * @minimum -10
     * @maximum 10
     */
    zoom?: number;
}

export interface KlingCameraControl {
    config?: KlingCameraConfig;
    type?: KlingCameraControlType;
}

/**
 * Predefined camera movements type. simple: Customizable camera movement. down_back: Camera descends and moves backward. forward_up: Camera moves forward and tilts up. right_turn_forward: Rotate right and move forward. left_turn_forward: Rotate left and move forward.
 */
export type KlingCameraControlType =
    (typeof KlingCameraControlType)[keyof typeof KlingCameraControlType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingCameraControlType = {
    simple: "simple",
    down_back: "down_back",
    forward_up: "forward_up",
    right_turn_forward: "right_turn_forward",
    left_turn_forward: "left_turn_forward",
} as const;

/**
 * Model Name. Can be kling-v1, kling-v1-5, or kling-v1-6.
 */
export type KlingCharacterEffectModelName =
    (typeof KlingCharacterEffectModelName)[keyof typeof KlingCharacterEffectModelName];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingCharacterEffectModelName = {
    "kling-v1": "kling-v1",
    "kling-v1-5": "kling-v1-5",
    "kling-v1-6": "kling-v1-6",
} as const;

export interface KlingDualCharacterEffectInput {
    duration: KlingVideoGenDuration;
    images: KlingDualCharacterImages;
    mode?: KlingVideoGenMode;
    model_name?: KlingCharacterEffectModelName;
}

/**
 * Scene Name. Dual-character Effects (hug, kiss, heart_gesture).
 */
export type KlingDualCharacterEffectsScene =
    (typeof KlingDualCharacterEffectsScene)[keyof typeof KlingDualCharacterEffectsScene];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingDualCharacterEffectsScene = {
    hug: "hug",
    kiss: "kiss",
    heart_gesture: "heart_gesture",
} as const;

/**
 * @minItems 2
 * @maxItems 2
 */
export type KlingDualCharacterImages = string[];

export interface KlingErrorResponse {
    /** - 1000: Authentication failed
- 1001: Authorization is empty
- 1002: Authorization is invalid
- 1003: Authorization is not yet valid
- 1004: Authorization has expired
- 1100: Account exception
- 1101: Account in arrears (postpaid scenario)
- 1102: Resource pack depleted or expired (prepaid scenario)
- 1103: Unauthorized access to requested resource
- 1200: Invalid request parameters
- 1201: Invalid parameters
- 1202: Invalid request method
- 1203: Requested resource does not exist
- 1300: Trigger platform strategy
- 1301: Trigger content security policy
- 1302: API request too frequent
- 1303: Concurrency/QPS exceeds limit
- 1304: Trigger IP whitelist policy
- 5000: Internal server error
- 5001: Service temporarily unavailable
- 5002: Server internal timeout
 */
    code: number;
    /** Human-readable error message */
    message: string;
    /** Request ID for tracking and troubleshooting */
    request_id: string;
}

export type KlingImage2VideoRequestDynamicMasksItemTrajectoriesItem = {
    /** The horizontal coordinate of trajectory point. Based on bottom-left corner of image as origin (0,0). */
    x?: number;
    /** The vertical coordinate of trajectory point. Based on bottom-left corner of image as origin (0,0). */
    y?: number;
};

export type KlingImage2VideoRequestDynamicMasksItem = {
    /** Dynamic Brush Application Area (Mask image created by users using the motion brush). The aspect ratio must match the input image. */
    mask?: string;
    trajectories?: KlingImage2VideoRequestDynamicMasksItemTrajectoriesItem[];
};

export interface KlingImage2VideoRequest {
    aspect_ratio?: KlingVideoGenAspectRatio;
    /** The callback notification address. Server will notify when the task status changes. */
    callback_url?: string;
    camera_control?: KlingCameraControl;
    cfg_scale?: KlingVideoGenCfgScale;
    duration?: KlingVideoGenDuration;
    /** Dynamic Brush Configuration List (up to 6 groups). For 5-second videos, trajectory length must not exceed 77 coordinates. */
    dynamic_masks?: KlingImage2VideoRequestDynamicMasksItem[];
    /** Customized Task ID. Must be unique within a single user account. */
    external_task_id?: string;
    /** Reference Image - URL or Base64 encoded string, cannot exceed 10MB, resolution not less than 300*300px, aspect ratio between 1:2.5 ~ 2.5:1. Base64 should not include data:image prefix. */
    image?: string;
    /** Reference Image - End frame control. URL or Base64 encoded string, cannot exceed 10MB, resolution not less than 300*300px. Base64 should not include data:image prefix. */
    image_tail?: string;
    mode?: KlingVideoGenMode;
    model_name?: KlingVideoGenModelName;
    /**
     * Negative text prompt
     * @maxLength 2500
     */
    negative_prompt?: string;
    /**
     * Positive text prompt
     * @maxLength 2500
     */
    prompt?: string;
    /** Static Brush Application Area (Mask image created by users using the motion brush). The aspect ratio must match the input image. */
    static_mask?: string;
}

export type KlingImage2VideoResponseDataTaskInfo = {
    external_task_id?: string;
};

export type KlingImage2VideoResponseDataTaskResult = {
    videos?: KlingVideoResult[];
};

export type KlingImage2VideoResponseData = {
    /** Task creation time */
    created_at?: number;
    /** Task ID */
    task_id?: string;
    task_info?: KlingImage2VideoResponseDataTaskInfo;
    task_result?: KlingImage2VideoResponseDataTaskResult;
    task_status?: KlingTaskStatus;
    /** Task update time */
    updated_at?: number;
};

export interface KlingImage2VideoResponse {
    /** Error code */
    code?: number;
    data?: KlingImage2VideoResponseData;
    /** Error message */
    message?: string;
    /** Request ID */
    request_id?: string;
}

/**
 * Aspect ratio of the generated images
 */
export type KlingImageGenAspectRatio =
    (typeof KlingImageGenAspectRatio)[keyof typeof KlingImageGenAspectRatio];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingImageGenAspectRatio = {
    "16:9": "16:9",
    "9:16": "9:16",
    "1:1": "1:1",
    "4:3": "4:3",
    "3:4": "3:4",
    "3:2": "3:2",
    "2:3": "2:3",
    "21:9": "21:9",
} as const;

/**
 * Image reference type
 */
export type KlingImageGenImageReferenceType =
    (typeof KlingImageGenImageReferenceType)[keyof typeof KlingImageGenImageReferenceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingImageGenImageReferenceType = {
    subject: "subject",
    face: "face",
} as const;

/**
 * Model Name
 */
export type KlingImageGenModelName =
    (typeof KlingImageGenModelName)[keyof typeof KlingImageGenModelName];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingImageGenModelName = {
    "kling-v1": "kling-v1",
    "kling-v1-5": "kling-v1-5",
    "kling-v2": "kling-v2",
} as const;

export interface KlingImageGenerationsRequest {
    aspect_ratio?: KlingImageGenAspectRatio;
    /** The callback notification address */
    callback_url?: string;
    /**
     * Subject reference similarity
     * @minimum 0
     * @maximum 1
     */
    human_fidelity?: number;
    /** Reference Image - Base64 encoded string or image URL */
    image?: string;
    /**
     * Reference intensity for user-uploaded images
     * @minimum 0
     * @maximum 1
     */
    image_fidelity?: number;
    image_reference?: KlingImageGenImageReferenceType;
    model_name?: KlingImageGenModelName;
    /**
     * Number of generated images
     * @minimum 1
     * @maximum 9
     */
    n?: number;
    /**
     * Negative text prompt
     * @maxLength 200
     */
    negative_prompt?: string;
    /**
     * Positive text prompt
     * @maxLength 500
     */
    prompt: string;
}

export type KlingImageGenerationsResponseDataTaskResult = {
    images?: KlingImageResult[];
};

export type KlingImageGenerationsResponseData = {
    /** Task creation time */
    created_at?: number;
    /** Task ID */
    task_id?: string;
    task_result?: KlingImageGenerationsResponseDataTaskResult;
    task_status?: KlingTaskStatus;
    /** Task status information */
    task_status_msg?: string;
    /** Task update time */
    updated_at?: number;
};

export interface KlingImageGenerationsResponse {
    /** Error code */
    code?: number;
    data?: KlingImageGenerationsResponseData;
    /** Error message */
    message?: string;
    /** Request ID */
    request_id?: string;
}

export interface KlingImageResult {
    /** Image Number (0-9) */
    index?: number;
    /** URL for generated image */
    url?: string;
}

export interface KlingLipSyncInputObject {
    /** Local Path of Audio File. Supported formats: .mp3/.wav/.m4a/.aac, maximum file size of 5MB. Base64 code. */
    audio_file?: string;
    audio_type?: KlingAudioUploadType;
    /** Audio File Download URL. Supported formats: .mp3/.wav/.m4a/.aac, maximum file size of 5MB. */
    audio_url?: string;
    mode: KlingLipSyncMode;
    /** Text Content for Lip-Sync Video Generation. Required when mode is text2video. Maximum length is 120 characters. */
    text?: string;
    /** The ID of the video generated by Kling AI. Only supports 5-second and 10-second videos generated within the last 30 days. */
    video_id?: string;
    /** Get link for uploaded video. Video files support .mp4/.mov, file size does not exceed 100MB, video length between 2-10s. */
    video_url?: string;
    /** Voice ID. Required when mode is text2video. The system offers a variety of voice options to choose from. */
    voice_id?: string;
    voice_language?: KlingLipSyncVoiceLanguage;
    /**
     * Speech Rate. Valid range: 0.8~2.0, accurate to one decimal place.
     * @minimum 0.8
     * @maximum 2
     */
    voice_speed?: number;
}

/**
 * Video Generation Mode. text2video: Text-to-video generation mode; audio2video: Audio-to-video generation mode
 */
export type KlingLipSyncMode =
    (typeof KlingLipSyncMode)[keyof typeof KlingLipSyncMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingLipSyncMode = {
    text2video: "text2video",
    audio2video: "audio2video",
} as const;

export interface KlingLipSyncRequest {
    /** The callback notification address. Server will notify when the task status changes. */
    callback_url?: string;
    input: KlingLipSyncInputObject;
}

export type KlingLipSyncResponseDataTaskInfo = {
    external_task_id?: string;
};

export type KlingLipSyncResponseDataTaskResult = {
    videos?: KlingVideoResult[];
};

export type KlingLipSyncResponseData = {
    /** Task creation time */
    created_at?: number;
    /** Task ID */
    task_id?: string;
    task_info?: KlingLipSyncResponseDataTaskInfo;
    task_result?: KlingLipSyncResponseDataTaskResult;
    task_status?: KlingTaskStatus;
    /** Task update time */
    updated_at?: number;
};

export interface KlingLipSyncResponse {
    /** Error code */
    code?: number;
    data?: KlingLipSyncResponseData;
    /** Error message */
    message?: string;
    /** Request ID */
    request_id?: string;
}

/**
 * The voice language corresponds to the Voice ID.
 */
export type KlingLipSyncVoiceLanguage =
    (typeof KlingLipSyncVoiceLanguage)[keyof typeof KlingLipSyncVoiceLanguage];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingLipSyncVoiceLanguage = {
    zh: "zh",
    en: "en",
} as const;

/**
 * Resource package type (decreasing_total=decreasing total, constant_period=constant periodicity)
 */
export type KlingResourcePackageResponseDataResourcePackSubscribeInfosItemResourcePackType =
    (typeof KlingResourcePackageResponseDataResourcePackSubscribeInfosItemResourcePackType)[keyof typeof KlingResourcePackageResponseDataResourcePackSubscribeInfosItemResourcePackType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingResourcePackageResponseDataResourcePackSubscribeInfosItemResourcePackType =
    {
        decreasing_total: "decreasing_total",
        constant_period: "constant_period",
    } as const;

/**
 * Resource Package Status
 */
export type KlingResourcePackageResponseDataResourcePackSubscribeInfosItemStatus =
    (typeof KlingResourcePackageResponseDataResourcePackSubscribeInfosItemStatus)[keyof typeof KlingResourcePackageResponseDataResourcePackSubscribeInfosItemStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingResourcePackageResponseDataResourcePackSubscribeInfosItemStatus =
    {
        toBeOnline: "toBeOnline",
        online: "online",
        expired: "expired",
        runOut: "runOut",
    } as const;

export type KlingResourcePackageResponseDataResourcePackSubscribeInfosItem = {
    /** Effective time, Unix timestamp in ms */
    effective_time?: number;
    /** Expiration time, Unix timestamp in ms */
    invalid_time?: number;
    /** Purchase time, Unix timestamp in ms */
    purchase_time?: number;
    /** Remaining quantity (updated with a 12-hour delay) */
    remaining_quantity?: number;
    /** Resource package ID */
    resource_pack_id?: string;
    /** Resource package name */
    resource_pack_name?: string;
    /** Resource package type (decreasing_total=decreasing total, constant_period=constant periodicity) */
    resource_pack_type?: KlingResourcePackageResponseDataResourcePackSubscribeInfosItemResourcePackType;
    /** Resource Package Status */
    status?: KlingResourcePackageResponseDataResourcePackSubscribeInfosItemStatus;
    /** Total quantity */
    total_quantity?: number;
};

export type KlingResourcePackageResponseData = {
    /** Error code; 0 indicates success */
    code?: number;
    /** Error information */
    msg?: string;
    /** Resource package list */
    resource_pack_subscribe_infos?: KlingResourcePackageResponseDataResourcePackSubscribeInfosItem[];
};

export interface KlingResourcePackageResponse {
    /** Error code; 0 indicates success */
    code?: number;
    data?: KlingResourcePackageResponseData;
    /** Error information */
    message?: string;
    /** Request ID, generated by the system, used to track requests and troubleshoot problems */
    request_id?: string;
}

/**
 * Video Length in seconds. Only 5-second videos are supported.
 */
export type KlingSingleImageEffectDuration =
    (typeof KlingSingleImageEffectDuration)[keyof typeof KlingSingleImageEffectDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingSingleImageEffectDuration = {
    NUMBER_5: "5",
} as const;

export interface KlingSingleImageEffectInput {
    duration: KlingSingleImageEffectDuration;
    /** Reference Image. URL or Base64 encoded string (without data:image prefix). File size cannot exceed 10MB, resolution not less than 300*300px, aspect ratio between 1:2.5 ~ 2.5:1. */
    image: string;
    model_name: KlingSingleImageEffectModelName;
}

/**
 * Model Name. Only kling-v1-6 is supported for single image effects.
 */
export type KlingSingleImageEffectModelName =
    (typeof KlingSingleImageEffectModelName)[keyof typeof KlingSingleImageEffectModelName];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingSingleImageEffectModelName = {
    "kling-v1-6": "kling-v1-6",
} as const;

/**
 * Scene Name. Single Image Effects (bloombloom, dizzydizzy, fuzzyfuzzy, squish, expansion).
 */
export type KlingSingleImageEffectsScene =
    (typeof KlingSingleImageEffectsScene)[keyof typeof KlingSingleImageEffectsScene];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingSingleImageEffectsScene = {
    bloombloom: "bloombloom",
    dizzydizzy: "dizzydizzy",
    fuzzyfuzzy: "fuzzyfuzzy",
    squish: "squish",
    expansion: "expansion",
} as const;

/**
 * Task Status
 */
export type KlingTaskStatus =
    (typeof KlingTaskStatus)[keyof typeof KlingTaskStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingTaskStatus = {
    submitted: "submitted",
    processing: "processing",
    succeed: "succeed",
    failed: "failed",
} as const;

export interface KlingText2VideoRequest {
    aspect_ratio?: KlingVideoGenAspectRatio;
    /** The callback notification address */
    callback_url?: string;
    camera_control?: KlingCameraControl;
    cfg_scale?: KlingVideoGenCfgScale;
    duration?: KlingVideoGenDuration;
    /** Customized Task ID */
    external_task_id?: string;
    mode?: KlingVideoGenMode;
    model_name?: KlingTextToVideoModelName;
    /**
     * Negative text prompt
     * @maxLength 2500
     */
    negative_prompt?: string;
    /**
     * Positive text prompt
     * @maxLength 2500
     */
    prompt?: string;
}

export type KlingText2VideoResponseDataTaskInfo = {
    external_task_id?: string;
};

export type KlingText2VideoResponseDataTaskResult = {
    videos?: KlingVideoResult[];
};

export type KlingText2VideoResponseData = {
    /** Task creation time */
    created_at?: number;
    /** Task ID */
    task_id?: string;
    task_info?: KlingText2VideoResponseDataTaskInfo;
    task_result?: KlingText2VideoResponseDataTaskResult;
    task_status?: KlingTaskStatus;
    /** Task update time */
    updated_at?: number;
};

export interface KlingText2VideoResponse {
    /** Error code */
    code?: number;
    data?: KlingText2VideoResponseData;
    /** Error message */
    message?: string;
    /** Request ID */
    request_id?: string;
}

/**
 * Model Name
 */
export type KlingTextToVideoModelName =
    (typeof KlingTextToVideoModelName)[keyof typeof KlingTextToVideoModelName];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingTextToVideoModelName = {
    "kling-v1": "kling-v1",
    "kling-v1-5": "kling-v1-5",
    "kling-v1-6": "kling-v1-6",
    "kling-v2-master": "kling-v2-master",
    "kling-v2-1-master": "kling-v2-1-master",
} as const;

export type KlingVideoEffectsInput =
    | KlingSingleImageEffectInput
    | KlingDualCharacterEffectInput;

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingVideoEffectsRequestEffectScene = {
    ...KlingDualCharacterEffectsScene,
    ...KlingSingleImageEffectsScene,
} as const;
export interface KlingVideoEffectsRequest {
    /** The callback notification address for the result of this task. */
    callback_url?: string;
    effect_scene: (typeof KlingVideoEffectsRequestEffectScene)[keyof typeof KlingVideoEffectsRequestEffectScene];
    /** Customized Task ID. Must be unique within a single user account. */
    external_task_id?: string;
    input: KlingVideoEffectsInput;
}

export type KlingVideoEffectsResponseDataTaskInfo = {
    external_task_id?: string;
};

export type KlingVideoEffectsResponseDataTaskResult = {
    videos?: KlingVideoResult[];
};

export type KlingVideoEffectsResponseData = {
    /** Task creation time */
    created_at?: number;
    /** Task ID */
    task_id?: string;
    task_info?: KlingVideoEffectsResponseDataTaskInfo;
    task_result?: KlingVideoEffectsResponseDataTaskResult;
    task_status?: KlingTaskStatus;
    /** Task update time */
    updated_at?: number;
};

export interface KlingVideoEffectsResponse {
    /** Error code */
    code?: number;
    data?: KlingVideoEffectsResponseData;
    /** Error message */
    message?: string;
    /** Request ID */
    request_id?: string;
}

export interface KlingVideoExtendRequest {
    /** The callback notification address. Server will notify when the task status changes. */
    callback_url?: string;
    cfg_scale?: KlingVideoGenCfgScale;
    /**
     * Negative text prompt for elements to avoid in the extended video
     * @maxLength 2500
     */
    negative_prompt?: string;
    /**
     * Positive text prompt for guiding the video extension
     * @maxLength 2500
     */
    prompt?: string;
    /** The ID of the video to be extended. Supports videos generated by text-to-video, image-to-video, and previous video extension operations. Cannot exceed 3 minutes total duration after extension. */
    video_id?: string;
}

export type KlingVideoExtendResponseDataTaskInfo = {
    external_task_id?: string;
};

export type KlingVideoExtendResponseDataTaskResult = {
    videos?: KlingVideoResult[];
};

export type KlingVideoExtendResponseData = {
    /** Task creation time */
    created_at?: number;
    /** Task ID */
    task_id?: string;
    task_info?: KlingVideoExtendResponseDataTaskInfo;
    task_result?: KlingVideoExtendResponseDataTaskResult;
    task_status?: KlingTaskStatus;
    /** Task update time */
    updated_at?: number;
};

export interface KlingVideoExtendResponse {
    /** Error code */
    code?: number;
    data?: KlingVideoExtendResponseData;
    /** Error message */
    message?: string;
    /** Request ID */
    request_id?: string;
}

/**
 * Video aspect ratio
 */
export type KlingVideoGenAspectRatio =
    (typeof KlingVideoGenAspectRatio)[keyof typeof KlingVideoGenAspectRatio];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingVideoGenAspectRatio = {
    "16:9": "16:9",
    "9:16": "9:16",
    "1:1": "1:1",
} as const;

/**
 * Flexibility in video generation. The higher the value, the lower the model's degree of flexibility, and the stronger the relevance to the user's prompt.
 * @minimum 0
 * @maximum 1
 */
export type KlingVideoGenCfgScale = number;

/**
 * Video length in seconds
 */
export type KlingVideoGenDuration =
    (typeof KlingVideoGenDuration)[keyof typeof KlingVideoGenDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingVideoGenDuration = {
    NUMBER_5: "5",
    NUMBER_10: "10",
} as const;

/**
 * Video generation mode. std: Standard Mode, which is cost-effective. pro: Professional Mode, generates videos with longer duration but higher quality output.
 */
export type KlingVideoGenMode =
    (typeof KlingVideoGenMode)[keyof typeof KlingVideoGenMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingVideoGenMode = {
    std: "std",
    pro: "pro",
} as const;

/**
 * Model Name
 */
export type KlingVideoGenModelName =
    (typeof KlingVideoGenModelName)[keyof typeof KlingVideoGenModelName];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingVideoGenModelName = {
    "kling-v1": "kling-v1",
    "kling-v1-5": "kling-v1-5",
    "kling-v1-6": "kling-v1-6",
    "kling-v2-master": "kling-v2-master",
    "kling-v2-1": "kling-v2-1",
    "kling-v2-1-master": "kling-v2-1-master",
} as const;

export interface KlingVideoResult {
    /** Total video duration */
    duration?: string;
    /** Generated video ID */
    id?: string;
    /** URL for generated video */
    url?: string;
}

/**
 * Model Name
 */
export type KlingVirtualTryOnModelName =
    (typeof KlingVirtualTryOnModelName)[keyof typeof KlingVirtualTryOnModelName];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const KlingVirtualTryOnModelName = {
    "kolors-virtual-try-on-v1": "kolors-virtual-try-on-v1",
    "kolors-virtual-try-on-v1-5": "kolors-virtual-try-on-v1-5",
} as const;

export interface KlingVirtualTryOnRequest {
    /** The callback notification address */
    callback_url?: string;
    /** Reference clothing image - Base64 encoded string or image URL */
    cloth_image?: string;
    /** Reference human image - Base64 encoded string or image URL */
    human_image: string;
    model_name?: KlingVirtualTryOnModelName;
}

export type KlingVirtualTryOnResponseDataTaskResult = {
    images?: KlingImageResult[];
};

export type KlingVirtualTryOnResponseData = {
    /** Task creation time */
    created_at?: number;
    /** Task ID */
    task_id?: string;
    task_result?: KlingVirtualTryOnResponseDataTaskResult;
    task_status?: KlingTaskStatus;
    /** Task status information */
    task_status_msg?: string;
    /** Task update time */
    updated_at?: number;
};

export interface KlingVirtualTryOnResponse {
    /** Error code */
    code?: number;
    data?: KlingVirtualTryOnResponseData;
    /** Error message */
    message?: string;
    /** Request ID */
    request_id?: string;
}

/**
 * The aspect ratio of the generation
 */
export type LumaAspectRatio =
    (typeof LumaAspectRatio)[keyof typeof LumaAspectRatio];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LumaAspectRatio = {
    "1:1": "1:1",
    "16:9": "16:9",
    "9:16": "9:16",
    "4:3": "4:3",
    "3:4": "3:4",
    "21:9": "21:9",
    "9:21": "9:21",
} as const;

/**
 * The assets of the generation
 */
export interface LumaAssets {
    /** The URL of the image */
    image?: string;
    /** The URL of the progress video */
    progress_video?: string;
    /** The URL of the video */
    video?: string;
}

export type LumaAudioGenerationRequestGenerationType =
    (typeof LumaAudioGenerationRequestGenerationType)[keyof typeof LumaAudioGenerationRequestGenerationType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LumaAudioGenerationRequestGenerationType = {
    add_audio: "add_audio",
} as const;

/**
 * The audio generation request object
 */
export interface LumaAudioGenerationRequest {
    /** The callback URL for the audio */
    callback_url?: string;
    generation_type?: LumaAudioGenerationRequestGenerationType;
    /** The negative prompt of the audio */
    negative_prompt?: string;
    /** The prompt of the audio */
    prompt?: string;
}

/**
 * The error object
 */
export interface LumaError {
    /** The error message */
    detail?: string;
}

/**
 * The request of the generation
 */
export type LumaGenerationRequestProperty =
    | LumaGenerationRequest
    | LumaImageGenerationRequest
    | LumaUpscaleVideoGenerationRequest
    | LumaAudioGenerationRequest;

/**
 * The generation response object
 */
export interface LumaGeneration {
    assets?: LumaAssets;
    /** The date and time when the generation was created */
    created_at?: string;
    /** The reason for the state of the generation */
    failure_reason?: string;
    generation_type?: LumaGenerationType;
    /** The ID of the generation */
    id?: string;
    /** The model used for the generation */
    model?: string;
    /** The request of the generation */
    request?: LumaGenerationRequestProperty;
    state?: LumaState;
}

export type LumaGenerationReferenceType =
    (typeof LumaGenerationReferenceType)[keyof typeof LumaGenerationReferenceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LumaGenerationReferenceType = {
    generation: "generation",
} as const;

/**
 * The generation reference object
 */
export interface LumaGenerationReference {
    /** The ID of the generation */
    id: string;
    type: LumaGenerationReferenceType;
}

export type LumaGenerationRequestGenerationType =
    (typeof LumaGenerationRequestGenerationType)[keyof typeof LumaGenerationRequestGenerationType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LumaGenerationRequestGenerationType = {
    video: "video",
} as const;

/**
 * The generation request object
 */
export interface LumaGenerationRequest {
    aspect_ratio: LumaAspectRatio;
    /** The callback URL of the generation, a POST request with Generation object will be sent to the callback URL when the generation is dreaming, completed, or failed */
    callback_url?: string;
    duration: LumaVideoModelOutputDuration;
    generation_type?: LumaGenerationRequestGenerationType;
    keyframes?: LumaKeyframes;
    /** Whether to loop the video */
    loop?: boolean;
    model: LumaVideoModel;
    /** The prompt of the generation */
    prompt: string;
    resolution: LumaVideoModelOutputResolution;
}

export type LumaGenerationType =
    (typeof LumaGenerationType)[keyof typeof LumaGenerationType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LumaGenerationType = {
    video: "video",
    image: "image",
} as const;

export type LumaImageGenerationRequestCharacterRef = {
    identity0?: LumaImageIdentity;
};

export type LumaImageGenerationRequestGenerationType =
    (typeof LumaImageGenerationRequestGenerationType)[keyof typeof LumaImageGenerationRequestGenerationType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LumaImageGenerationRequestGenerationType = {
    image: "image",
} as const;

/**
 * The image generation request object
 */
export interface LumaImageGenerationRequest {
    aspect_ratio?: LumaAspectRatio;
    /** The callback URL for the generation */
    callback_url?: string;
    character_ref?: LumaImageGenerationRequestCharacterRef;
    generation_type?: LumaImageGenerationRequestGenerationType;
    image_ref?: LumaImageRef[];
    model?: LumaImageModel;
    modify_image_ref?: LumaModifyImageRef;
    /** The prompt of the generation */
    prompt?: string;
    style_ref?: LumaImageRef[];
}

/**
 * The image identity object
 */
export interface LumaImageIdentity {
    /** The URLs of the image identity */
    images?: string[];
}

/**
 * The image model used for the generation
 */
export type LumaImageModel =
    (typeof LumaImageModel)[keyof typeof LumaImageModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LumaImageModel = {
    "photon-1": "photon-1",
    "photon-flash-1": "photon-flash-1",
} as const;

/**
 * The image reference object
 */
export interface LumaImageRef {
    /** The URL of the image reference */
    url?: string;
    /** The weight of the image reference */
    weight?: number;
}

export type LumaImageReferenceType =
    (typeof LumaImageReferenceType)[keyof typeof LumaImageReferenceType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LumaImageReferenceType = {
    image: "image",
} as const;

/**
 * The image object
 */
export interface LumaImageReference {
    type: LumaImageReferenceType;
    /** The URL of the image */
    url: string;
}

/**
 * A keyframe can be either a Generation reference, an Image, or a Video
 */
export type LumaKeyframe = LumaGenerationReference | LumaImageReference;

/**
 * The keyframes of the generation
 */
export interface LumaKeyframes {
    frame0?: LumaKeyframe;
    frame1?: LumaKeyframe;
}

/**
 * The modify image reference object
 */
export interface LumaModifyImageRef {
    /** The URL of the image reference */
    url?: string;
    /** The weight of the modify image reference */
    weight?: number;
}

/**
 * The state of the generation
 */
export type LumaState = (typeof LumaState)[keyof typeof LumaState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LumaState = {
    queued: "queued",
    dreaming: "dreaming",
    completed: "completed",
    failed: "failed",
} as const;

export type LumaUpscaleVideoGenerationRequestGenerationType =
    (typeof LumaUpscaleVideoGenerationRequestGenerationType)[keyof typeof LumaUpscaleVideoGenerationRequestGenerationType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LumaUpscaleVideoGenerationRequestGenerationType = {
    upscale_video: "upscale_video",
} as const;

/**
 * The upscale generation request object
 */
export interface LumaUpscaleVideoGenerationRequest {
    /** The callback URL for the upscale */
    callback_url?: string;
    generation_type?: LumaUpscaleVideoGenerationRequestGenerationType;
    resolution?: LumaVideoModelOutputResolution;
}

/**
 * The video model used for the generation
 */
export type LumaVideoModel =
    (typeof LumaVideoModel)[keyof typeof LumaVideoModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LumaVideoModel = {
    "ray-2": "ray-2",
    "ray-flash-2": "ray-flash-2",
    "ray-1-6": "ray-1-6",
} as const;

export type LumaVideoModelOutputDuration = "5s" | "9s" | string;

export type LumaVideoModelOutputResolution =
    | "540p"
    | "720p"
    | "1080p"
    | "4k"
    | string;

/**
 * Time series of VRAM usage.
 */
export type MachineStatsVramTimeSeries = { [key: string]: unknown };

export interface MachineStats {
    /** Total CPU on the machine. */
    cpu_capacity?: string;
    /** Total disk capacity on the machine. */
    disk_capacity?: string;
    /** The GPU type. eg. NVIDIA Tesla K80 */
    gpu_type?: string;
    /** Initial CPU available before the job starts. */
    initial_cpu?: string;
    /** Initial disk available before the job starts. */
    initial_disk?: string;
    /** Initial RAM available before the job starts. */
    initial_ram?: string;
    /** Name of the machine. */
    machine_name?: string;
    /** Total memory on the machine. */
    memory_capacity?: string;
    /** The operating system version. eg. Ubuntu Linux 20.04 */
    os_version?: string;
    /** The pip freeze output */
    pip_freeze?: string;
    /** Time series of VRAM usage. */
    vram_time_series?: MachineStatsVramTimeSeries;
}

/**
 * Common response structure used by Minimax APIs
 */
export interface MinimaxBaseResponse {
    /** Status code. 0 indicates success, other values indicate errors. */
    status_code: number;
    /** Specific error details or success message. */
    status_msg: string;
}

export type MinimaxFileRetrieveResponseFile = {
    /** File size in bytes */
    bytes?: number;
    /** Unix timestamp when the file was created, in seconds */
    created_at?: number;
    /** The URL to download the video */
    download_url?: string;
    /** Unique identifier for the file */
    file_id?: number;
    /** The name of the file */
    filename?: string;
    /** The purpose of using the file */
    purpose?: string;
};

/**
 * Response from retrieving a Minimax file download URL.
 */
export interface MinimaxFileRetrieveResponse {
    base_resp: MinimaxBaseResponse;
    file: MinimaxFileRetrieveResponseFile;
}

/**
 * Task status: 'Queueing' (in queue), 'Preparing' (task is preparing), 'Processing' (generating), 'Success' (task completed successfully), or 'Fail' (task failed).
 */
export type MinimaxTaskResultResponseStatus =
    (typeof MinimaxTaskResultResponseStatus)[keyof typeof MinimaxTaskResultResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MinimaxTaskResultResponseStatus = {
    Queueing: "Queueing",
    Preparing: "Preparing",
    Processing: "Processing",
    Success: "Success",
    Fail: "Fail",
} as const;

/**
 * Response from querying a Minimax video generation task status.
 */
export interface MinimaxTaskResultResponse {
    base_resp: MinimaxBaseResponse;
    /** After the task status changes to Success, this field returns the file ID corresponding to the generated video. */
    file_id?: string;
    /** Task status: 'Queueing' (in queue), 'Preparing' (task is preparing), 'Processing' (generating), 'Success' (task completed successfully), or 'Fail' (task failed). */
    status: MinimaxTaskResultResponseStatus;
    /** The task ID being queried. */
    task_id: string;
}

/**
 * Video length in seconds. Only available for MiniMax-Hailuo-02
 */
export type MinimaxVideoGenerationRequestDuration =
    (typeof MinimaxVideoGenerationRequestDuration)[keyof typeof MinimaxVideoGenerationRequestDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MinimaxVideoGenerationRequestDuration = {
    NUMBER_6: 6,
    NUMBER_10: 10,
} as const;

/**
 * Required. ID of model. Options: MiniMax-Hailuo-02, T2V-01-Director, I2V-01-Director, S2V-01, I2V-01, I2V-01-live, T2V-01
 */
export type MinimaxVideoGenerationRequestModel =
    (typeof MinimaxVideoGenerationRequestModel)[keyof typeof MinimaxVideoGenerationRequestModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MinimaxVideoGenerationRequestModel = {
    "MiniMax-Hailuo-02": "MiniMax-Hailuo-02",
    "T2V-01-Director": "T2V-01-Director",
    "I2V-01-Director": "I2V-01-Director",
    "S2V-01": "S2V-01",
    "I2V-01": "I2V-01",
    "I2V-01-live": "I2V-01-live",
    "T2V-01": "T2V-01",
} as const;

/**
 * Video resolution. Only available for MiniMax-Hailuo-02.
 */
export type MinimaxVideoGenerationRequestResolution =
    (typeof MinimaxVideoGenerationRequestResolution)[keyof typeof MinimaxVideoGenerationRequestResolution];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MinimaxVideoGenerationRequestResolution = {
    "768P": "768P",
    "1080P": "1080P",
} as const;

export type MinimaxVideoGenerationRequestSubjectReferenceItem = {
    /** URL or base64 encoding of the subject reference image. */
    image?: string;
    /** URL or base64 encoding of the mask for the subject reference image. */
    mask?: string;
};

/**
 * Parameters for the Minimax video generation proxy request.
 */
export interface MinimaxVideoGenerationRequest {
    /** Optional. URL to receive real-time status updates about the video generation task. */
    callback_url?: string;
    /** Video length in seconds. Only available for MiniMax-Hailuo-02 */
    duration?: MinimaxVideoGenerationRequestDuration;
    /** URL or base64 encoding of the first frame image. Required when model is I2V-01, I2V-01-Director, or I2V-01-live. */
    first_frame_image?: string;
    /** Required. ID of model. Options: MiniMax-Hailuo-02, T2V-01-Director, I2V-01-Director, S2V-01, I2V-01, I2V-01-live, T2V-01 */
    model: MinimaxVideoGenerationRequestModel;
    /**
     * Description of the video. Should be less than 2000 characters. Supports camera movement instructions in [brackets].
     * @maxLength 2000
     */
    prompt?: string;
    /** If true (default), the model will automatically optimize the prompt. Set to false for more precise control. */
    prompt_optimizer?: boolean;
    /** Video resolution. Only available for MiniMax-Hailuo-02. */
    resolution?: MinimaxVideoGenerationRequestResolution;
    /** Only available when model is S2V-01. The model will generate a video based on the subject uploaded through this parameter. */
    subject_reference?: MinimaxVideoGenerationRequestSubjectReferenceItem[];
}

/**
 * Response from the Minimax video generation API.
 */
export interface MinimaxVideoGenerationResponse {
    base_resp: MinimaxBaseResponse;
    /** The task ID for the asynchronous video generation task. */
    task_id: string;
}

/**
 * Type of input or output content modality.
 */
export type Modality = (typeof Modality)[keyof typeof Modality];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Modality = {
    MODALITY_UNSPECIFIED: "MODALITY_UNSPECIFIED",
    TEXT: "TEXT",
    IMAGE: "IMAGE",
    VIDEO: "VIDEO",
    AUDIO: "AUDIO",
    DOCUMENT: "DOCUMENT",
} as const;

export interface ModalityTokenCount {
    modality?: Modality;
    /** Number of tokens for the given modality. */
    tokenCount?: number;
}

/**
 * How to handle truncation of the response
 */
export type ModelResponsePropertiesTruncation =
    (typeof ModelResponsePropertiesTruncation)[keyof typeof ModelResponsePropertiesTruncation];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelResponsePropertiesTruncation = {
    disabled: "disabled",
    auto: "auto",
} as const;

/**
 * Common properties for model responses
 */
export interface ModelResponseProperties {
    /** Instructions for the model on how to generate the response */
    instructions?: string;
    /** Maximum number of tokens to generate */
    max_output_tokens?: number;
    /** The model used to generate the response */
    model?: string;
    /**
     * Controls randomness in the response
     * @minimum 0
     * @maximum 2
     */
    temperature?: number;
    /**
     * Controls diversity of the response via nucleus sampling
     * @minimum 0
     * @maximum 1
     */
    top_p?: number;
    /** How to handle truncation of the response */
    truncation?: ModelResponsePropertiesTruncation;
}

export type MoonvalleyImageToVideoRequestAllOfKeyframes = {
    [key: string]: {
        image_url?: string;
    };
};

export type MoonvalleyImageToVideoRequestAllOf = {
    keyframes?: MoonvalleyImageToVideoRequestAllOfKeyframes;
};

export type MoonvalleyImageToVideoRequest = MoonvalleyTextToVideoRequest &
    MoonvalleyImageToVideoRequestAllOf;

export type MoonvalleyPromptResponseError = { [key: string]: unknown };

export type MoonvalleyPromptResponseFrameConditioning = {
    [key: string]: unknown;
};

export type MoonvalleyPromptResponseInferenceParams = {
    [key: string]: unknown;
};

export type MoonvalleyPromptResponseMeta = { [key: string]: unknown };

export type MoonvalleyPromptResponseModelParams = { [key: string]: unknown };

export interface MoonvalleyPromptResponse {
    error?: MoonvalleyPromptResponseError;
    frame_conditioning?: MoonvalleyPromptResponseFrameConditioning;
    id?: string;
    inference_params?: MoonvalleyPromptResponseInferenceParams;
    meta?: MoonvalleyPromptResponseMeta;
    model_params?: MoonvalleyPromptResponseModelParams;
    output_url?: string;
    prompt_text?: string;
    status?: string;
}

export type MoonvalleyResizeVideoRequestAllOf = {
    /**
     * @minItems 2
     * @maxItems 2
     */
    frame_position?: number[];
    /**
     * @minItems 2
     * @maxItems 2
     */
    frame_resolution?: number[];
    /**
     * @minItems 2
     * @maxItems 2
     */
    scale?: number[];
};

export type MoonvalleyResizeVideoRequest = MoonvalleyVideoToVideoRequest &
    MoonvalleyResizeVideoRequestAllOf;

export interface MoonvalleyTextToImageRequest {
    image_url?: string;
    inference_params?: MoonvalleyTextToVideoInferenceParams;
    prompt_text?: string;
    webhook_url?: string;
}

export interface MoonvalleyTextToVideoInferenceParams {
    /** Guidance scale for generation control */
    guidance_scale?: number;
    /** Height of the generated video in pixels */
    height?: number;
    /** Negative prompt text */
    negative_prompt?: string;
    /** Random seed for generation (default: random) */
    seed?: number;
    /** Number of denoising steps */
    steps?: number;
    /** Whether to use negative prompts */
    use_negative_prompts?: boolean;
    /** Width of the generated video in pixels */
    width?: number;
}

export interface MoonvalleyTextToVideoRequest {
    image_url?: string;
    inference_params?: MoonvalleyTextToVideoInferenceParams;
    prompt_text?: string;
    webhook_url?: string;
}

export interface MoonvalleyUploadFileRequest {
    file?: Blob;
}

export interface MoonvalleyUploadFileResponse {
    access_url?: string;
}

export type MoonvalleyVideoToVideoInferenceParamsControlParams = {
    /** Intensity of motion control */
    motion_intensity?: number;
};

export interface MoonvalleyVideoToVideoInferenceParams {
    control_params?: MoonvalleyVideoToVideoInferenceParamsControlParams;
    /** Guidance scale for generation control */
    guidance_scale?: number;
    /** Negative prompt text */
    negative_prompt?: string;
    /** Random seed for generation (default: random) */
    seed?: number;
    /** Number of denoising steps */
    steps?: number;
    /** Whether to use negative prompts */
    use_negative_prompts?: boolean;
}

/**
 * Supported types for video control
 */
export type MoonvalleyVideoToVideoRequestControlType =
    (typeof MoonvalleyVideoToVideoRequestControlType)[keyof typeof MoonvalleyVideoToVideoRequestControlType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MoonvalleyVideoToVideoRequestControlType = {
    motion_control: "motion_control",
    pose_control: "pose_control",
} as const;

export interface MoonvalleyVideoToVideoRequest {
    /** Supported types for video control */
    control_type: MoonvalleyVideoToVideoRequestControlType;
    /** Url to control image */
    image_url?: string;
    inference_params?: MoonvalleyVideoToVideoInferenceParams;
    /** Describes the video to generate */
    prompt_text: string;
    /** Url to control video */
    video_url: string;
    /** Optional webhook URL for notifications */
    webhook_url?: string;
}

/**
 * Translations of node metadata in different languages.
 */
export type NodeTranslations = { [key: string]: { [key: string]: unknown } };

export interface Node {
    author?: string;
    /** URL to the node's banner. */
    banner_url?: string;
    /** The category of the node. */
    category?: string;
    /** The date and time when the node was created */
    created_at?: string;
    description?: string;
    /** The number of downloads of the node. */
    downloads?: number;
    /** Number of stars on the GitHub repository. */
    github_stars?: number;
    /** URL to the node's icon. */
    icon?: string;
    /** The unique identifier of the node. */
    id?: string;
    latest_version?: NodeVersion;
    /** The path to the LICENSE file in the node's repository. */
    license?: string;
    /** The display name of the node. */
    name?: string;
    /** A list of Comfy node names that are preempted by this node. */
    preempted_comfy_node_names?: string[];
    publisher?: Publisher;
    /** The average rating of the node. */
    rating?: number;
    /** URL to the node's repository. */
    repository?: string;
    /** A numerical value representing the node's search ranking, used for sorting search results. */
    search_ranking?: number;
    status?: NodeStatus;
    /** The status detail of the node. */
    status_detail?: string;
    /** List of accelerators (e.g. CUDA, DirectML, ROCm) that this node supports */
    supported_accelerators?: string[];
    /** Supported versions of ComfyUI frontend */
    supported_comfyui_frontend_version?: string;
    /** Supported versions of ComfyUI */
    supported_comfyui_version?: string;
    /** List of operating systems that this node supports */
    supported_os?: string[];
    tags?: string[];
    /** Translations of node metadata in different languages. */
    translations?: NodeTranslations;
}

export type NodeStatus = (typeof NodeStatus)[keyof typeof NodeStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NodeStatus = {
    NodeStatusActive: "NodeStatusActive",
    NodeStatusDeleted: "NodeStatusDeleted",
    NodeStatusBanned: "NodeStatusBanned",
} as const;

export interface NodeVersion {
    /** Summary of changes made in this version */
    changelog?: string;
    /** The status of comfy node extraction process. */
    comfy_node_extract_status?: string;
    /** The date and time the version was created. */
    createdAt?: string;
    /** A list of pip dependencies required by the node. */
    dependencies?: string[];
    /** Indicates if this version is deprecated. */
    deprecated?: boolean;
    /** [Output Only] URL to download this version of the node */
    downloadUrl?: string;
    id?: string;
    /** The unique identifier of the node. */
    node_id?: string;
    status?: NodeVersionStatus;
    /** The reason for the status change. */
    status_reason?: string;
    /** List of accelerators (e.g. CUDA, DirectML, ROCm) that this node supports */
    supported_accelerators?: string[];
    /** Supported versions of ComfyUI frontend */
    supported_comfyui_frontend_version?: string;
    /** Supported versions of ComfyUI */
    supported_comfyui_version?: string;
    /** List of operating systems that this node supports */
    supported_os?: string[];
    /** The version identifier, following semantic versioning. Must be unique for the node. */
    version?: string;
}

export interface NodeVersionIdentifier {
    /** The unique identifier of the node */
    node_id: string;
    /** The version of the node */
    version: string;
}

export type NodeVersionStatus =
    (typeof NodeVersionStatus)[keyof typeof NodeVersionStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NodeVersionStatus = {
    NodeVersionStatusActive: "NodeVersionStatusActive",
    NodeVersionStatusDeleted: "NodeVersionStatusDeleted",
    NodeVersionStatusBanned: "NodeVersionStatusBanned",
    NodeVersionStatusPending: "NodeVersionStatusPending",
    NodeVersionStatusFlagged: "NodeVersionStatusFlagged",
} as const;

export interface NodeVersionUpdateRequest {
    /** The changelog describing the version changes. */
    changelog?: string;
    /** Whether the version is deprecated. */
    deprecated?: boolean;
}

/**
 * Text, image, or file inputs to the model, used to generate a response.

Learn more:
- [Text inputs and outputs](/docs/guides/text)
- [Image inputs](/docs/guides/images)
- [File inputs](/docs/guides/pdf-files)
- [Conversation state](/docs/guides/conversation-state)
- [Function calling](/docs/guides/function-calling)

 */
export type OpenAICreateResponseAllOfInput = string | InputItem[];

export type OpenAICreateResponseAllOf = {
    /**
   * Specify additional output data to include in the model response. Currently
supported values are:
- `file_search_call.results`: Include the search results of
  the file search tool call.
- `message.input_image.image_url`: Include image urls from the input message.
- `computer_call_output.output.image_url`: Include image urls from the computer call output.

   * @nullable
   */
    include?: Includable[] | null;
    /** Text, image, or file inputs to the model, used to generate a response.

Learn more:
- [Text inputs and outputs](/docs/guides/text)
- [Image inputs](/docs/guides/images)
- [File inputs](/docs/guides/pdf-files)
- [Conversation state](/docs/guides/conversation-state)
- [Function calling](/docs/guides/function-calling)
 */
    input: OpenAICreateResponseAllOfInput;
    /**
   * Whether to allow the model to run tool calls in parallel.

   * @nullable
   */
    parallel_tool_calls?: boolean | null;
    /**
   * Whether to store the generated model response for later retrieval via
API.

   * @nullable
   */
    store?: boolean | null;
    /**
   * If set to true, the model response data will be streamed to the client
as it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).
See the [Streaming section below](/docs/api-reference/responses-streaming)
for more information.

   * @nullable
   */
    stream?: boolean | null;
    usage?: ResponseUsage;
};

export type OpenAICreateResponse = CreateModelResponseProperties &
    ResponseProperties &
    OpenAICreateResponseAllOf &
    Required<
        Pick<
            CreateModelResponseProperties &
                ResponseProperties &
                OpenAICreateResponseAllOf,
            "model"
        >
    >;

/**
 * Content moderation setting
 */
export type OpenAIImageEditRequestModeration =
    (typeof OpenAIImageEditRequestModeration)[keyof typeof OpenAIImageEditRequestModeration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIImageEditRequestModeration = {
    low: "low",
    auto: "auto",
} as const;

/**
 * Format of the output image
 */
export type OpenAIImageEditRequestOutputFormat =
    (typeof OpenAIImageEditRequestOutputFormat)[keyof typeof OpenAIImageEditRequestOutputFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIImageEditRequestOutputFormat = {
    png: "png",
    webp: "webp",
    jpeg: "jpeg",
} as const;

export interface OpenAIImageEditRequest {
    /** Background transparency */
    background?: string;
    /** The model to use for image editing */
    model: string;
    /** Content moderation setting */
    moderation?: OpenAIImageEditRequestModeration;
    /** The number of images to generate */
    n?: number;
    /** Compression level for JPEG or WebP (0-100) */
    output_compression?: number;
    /** Format of the output image */
    output_format?: OpenAIImageEditRequestOutputFormat;
    /** A text description of the desired edit */
    prompt: string;
    /** The quality of the edited image */
    quality?: string;
    /** Size of the output image */
    size?: string;
    /** A unique identifier for end-user monitoring */
    user?: string;
}

/**
 * Background transparency
 */
export type OpenAIImageGenerationRequestBackground =
    (typeof OpenAIImageGenerationRequestBackground)[keyof typeof OpenAIImageGenerationRequestBackground];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIImageGenerationRequestBackground = {
    transparent: "transparent",
    opaque: "opaque",
} as const;

/**
 * Content moderation setting
 */
export type OpenAIImageGenerationRequestModeration =
    (typeof OpenAIImageGenerationRequestModeration)[keyof typeof OpenAIImageGenerationRequestModeration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIImageGenerationRequestModeration = {
    low: "low",
    auto: "auto",
} as const;

/**
 * Format of the output image
 */
export type OpenAIImageGenerationRequestOutputFormat =
    (typeof OpenAIImageGenerationRequestOutputFormat)[keyof typeof OpenAIImageGenerationRequestOutputFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIImageGenerationRequestOutputFormat = {
    png: "png",
    webp: "webp",
    jpeg: "jpeg",
} as const;

/**
 * The quality of the generated image
 */
export type OpenAIImageGenerationRequestQuality =
    (typeof OpenAIImageGenerationRequestQuality)[keyof typeof OpenAIImageGenerationRequestQuality];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIImageGenerationRequestQuality = {
    low: "low",
    medium: "medium",
    high: "high",
    standard: "standard",
    hd: "hd",
} as const;

/**
 * Response format of image data
 */
export type OpenAIImageGenerationRequestResponseFormat =
    (typeof OpenAIImageGenerationRequestResponseFormat)[keyof typeof OpenAIImageGenerationRequestResponseFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIImageGenerationRequestResponseFormat = {
    url: "url",
    b64_json: "b64_json",
} as const;

/**
 * Style of the image (only for dall-e-3)
 */
export type OpenAIImageGenerationRequestStyle =
    (typeof OpenAIImageGenerationRequestStyle)[keyof typeof OpenAIImageGenerationRequestStyle];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIImageGenerationRequestStyle = {
    vivid: "vivid",
    natural: "natural",
} as const;

export interface OpenAIImageGenerationRequest {
    /** Background transparency */
    background?: OpenAIImageGenerationRequestBackground;
    /** The model to use for image generation */
    model?: string;
    /** Content moderation setting */
    moderation?: OpenAIImageGenerationRequestModeration;
    /** The number of images to generate (1-10). Only 1 supported for dall-e-3. */
    n?: number;
    /** Compression level for JPEG or WebP (0-100) */
    output_compression?: number;
    /** Format of the output image */
    output_format?: OpenAIImageGenerationRequestOutputFormat;
    /** A text description of the desired image */
    prompt: string;
    /** The quality of the generated image */
    quality?: OpenAIImageGenerationRequestQuality;
    /** Response format of image data */
    response_format?: OpenAIImageGenerationRequestResponseFormat;
    /** Size of the image (e.g., 1024x1024, 1536x1024, auto) */
    size?: string;
    /** Style of the image (only for dall-e-3) */
    style?: OpenAIImageGenerationRequestStyle;
    /** A unique identifier for end-user monitoring */
    user?: string;
}

export type OpenAIImageGenerationResponseDataItem = {
    /** Base64 encoded image data */
    b64_json?: string;
    /** Revised prompt */
    revised_prompt?: string;
    /** URL of the image */
    url?: string;
};

export type OpenAIImageGenerationResponseUsageInputTokensDetails = {
    image_tokens?: number;
    text_tokens?: number;
};

export type OpenAIImageGenerationResponseUsage = {
    input_tokens?: number;
    input_tokens_details?: OpenAIImageGenerationResponseUsageInputTokensDetails;
    output_tokens?: number;
    total_tokens?: number;
};

export interface OpenAIImageGenerationResponse {
    data?: OpenAIImageGenerationResponseDataItem[];
    usage?: OpenAIImageGenerationResponseUsage;
}

export type OpenAIModels = (typeof OpenAIModels)[keyof typeof OpenAIModels];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIModels = {
    "gpt-4": "gpt-4",
    "gpt-4-0314": "gpt-4-0314",
    "gpt-4-0613": "gpt-4-0613",
    "gpt-4-32k": "gpt-4-32k",
    "gpt-4-32k-0314": "gpt-4-32k-0314",
    "gpt-4-32k-0613": "gpt-4-32k-0613",
    "gpt-4-0125-preview": "gpt-4-0125-preview",
    "gpt-4-turbo": "gpt-4-turbo",
    "gpt-4-turbo-2024-04-09": "gpt-4-turbo-2024-04-09",
    "gpt-4-turbo-preview": "gpt-4-turbo-preview",
    "gpt-4-1106-preview": "gpt-4-1106-preview",
    "gpt-4-vision-preview": "gpt-4-vision-preview",
    "gpt-35-turbo": "gpt-3.5-turbo",
    "gpt-35-turbo-16k": "gpt-3.5-turbo-16k",
    "gpt-35-turbo-0301": "gpt-3.5-turbo-0301",
    "gpt-35-turbo-0613": "gpt-3.5-turbo-0613",
    "gpt-35-turbo-1106": "gpt-3.5-turbo-1106",
    "gpt-35-turbo-0125": "gpt-3.5-turbo-0125",
    "gpt-35-turbo-16k-0613": "gpt-3.5-turbo-16k-0613",
    "gpt-41": "gpt-4.1",
    "gpt-41-mini": "gpt-4.1-mini",
    "gpt-41-nano": "gpt-4.1-nano",
    "gpt-41-2025-04-14": "gpt-4.1-2025-04-14",
    "gpt-41-mini-2025-04-14": "gpt-4.1-mini-2025-04-14",
    "gpt-41-nano-2025-04-14": "gpt-4.1-nano-2025-04-14",
    o1: "o1",
    "o1-mini": "o1-mini",
    "o1-preview": "o1-preview",
    "o1-pro": "o1-pro",
    "o1-2024-12-17": "o1-2024-12-17",
    "o1-preview-2024-09-12": "o1-preview-2024-09-12",
    "o1-mini-2024-09-12": "o1-mini-2024-09-12",
    "o1-pro-2025-03-19": "o1-pro-2025-03-19",
    o3: "o3",
    "o3-mini": "o3-mini",
    "o3-2025-04-16": "o3-2025-04-16",
    "o3-mini-2025-01-31": "o3-mini-2025-01-31",
    "o4-mini": "o4-mini",
    "o4-mini-2025-04-16": "o4-mini-2025-04-16",
    "gpt-4o": "gpt-4o",
    "gpt-4o-mini": "gpt-4o-mini",
    "gpt-4o-2024-11-20": "gpt-4o-2024-11-20",
    "gpt-4o-2024-08-06": "gpt-4o-2024-08-06",
    "gpt-4o-2024-05-13": "gpt-4o-2024-05-13",
    "gpt-4o-mini-2024-07-18": "gpt-4o-mini-2024-07-18",
    "gpt-4o-audio-preview": "gpt-4o-audio-preview",
    "gpt-4o-audio-preview-2024-10-01": "gpt-4o-audio-preview-2024-10-01",
    "gpt-4o-audio-preview-2024-12-17": "gpt-4o-audio-preview-2024-12-17",
    "gpt-4o-mini-audio-preview": "gpt-4o-mini-audio-preview",
    "gpt-4o-mini-audio-preview-2024-12-17":
        "gpt-4o-mini-audio-preview-2024-12-17",
    "gpt-4o-search-preview": "gpt-4o-search-preview",
    "gpt-4o-mini-search-preview": "gpt-4o-mini-search-preview",
    "gpt-4o-search-preview-2025-03-11": "gpt-4o-search-preview-2025-03-11",
    "gpt-4o-mini-search-preview-2025-03-11":
        "gpt-4o-mini-search-preview-2025-03-11",
    "computer-use-preview": "computer-use-preview",
    "computer-use-preview-2025-03-11": "computer-use-preview-2025-03-11",
    "gpt-5": "gpt-5",
    "gpt-5-mini": "gpt-5-mini",
    "gpt-5-nano": "gpt-5-nano",
    "chatgpt-4o-latest": "chatgpt-4o-latest",
} as const;

/**
 * The reason why the response is incomplete.
 */
export type OpenAIResponseAllOfIncompleteDetailsReason =
    (typeof OpenAIResponseAllOfIncompleteDetailsReason)[keyof typeof OpenAIResponseAllOfIncompleteDetailsReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIResponseAllOfIncompleteDetailsReason = {
    max_output_tokens: "max_output_tokens",
    content_filter: "content_filter",
} as const;

/**
 * Details about why the response is incomplete.

 * @nullable
 */
export type OpenAIResponseAllOfIncompleteDetails = {
    /** The reason why the response is incomplete. */
    reason?: OpenAIResponseAllOfIncompleteDetailsReason;
} | null;

/**
 * The object type of this resource - always set to `response`.
 */
export type OpenAIResponseAllOfObject =
    (typeof OpenAIResponseAllOfObject)[keyof typeof OpenAIResponseAllOfObject];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIResponseAllOfObject = {
    response: "response",
} as const;

/**
 * The status of the response generation. One of `completed`, `failed`, `in_progress`, or `incomplete`.
 */
export type OpenAIResponseAllOfStatus =
    (typeof OpenAIResponseAllOfStatus)[keyof typeof OpenAIResponseAllOfStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OpenAIResponseAllOfStatus = {
    completed: "completed",
    failed: "failed",
    in_progress: "in_progress",
    incomplete: "incomplete",
} as const;

export type OpenAIResponseAllOf = {
    /** Unix timestamp (in seconds) of when this Response was created. */
    created_at?: number;
    error?: ResponseError;
    /** Unique identifier for this Response. */
    id?: string;
    /**
   * Details about why the response is incomplete.

   * @nullable
   */
    incomplete_details?: OpenAIResponseAllOfIncompleteDetails;
    /** The object type of this resource - always set to `response`. */
    object?: OpenAIResponseAllOfObject;
    /** An array of content items generated by the model.

- The length and order of items in the `output` array is dependent
  on the model's response.
- Rather than accessing the first item in the `output` array and 
  assuming it's an `assistant` message with the content generated by
  the model, you might consider using the `output_text` property where
  supported in SDKs.
 */
    output?: OutputItem[];
    /**
   * SDK-only convenience property that contains the aggregated text output 
from all `output_text` items in the `output` array, if any are present. 
Supported in the Python and JavaScript SDKs.

   * @nullable
   */
    output_text?: string | null;
    /** Whether to allow the model to run tool calls in parallel.
     */
    parallel_tool_calls?: boolean;
    /** The status of the response generation. One of `completed`, `failed`, `in_progress`, or `incomplete`. */
    status?: OpenAIResponseAllOfStatus;
    usage?: ResponseUsage;
};

/**
 * A response from the model
 */
export type OpenAIResponse = ModelResponseProperties &
    ResponseProperties &
    OpenAIResponseAllOf;

/**
 * Events that can be emitted during response streaming
 */
export type OpenAIResponseStreamEvent =
    | ResponseCreatedEvent
    | ResponseInProgressEvent
    | ResponseCompletedEvent
    | ResponseFailedEvent
    | ResponseIncompleteEvent
    | ResponseOutputItemAddedEvent
    | ResponseOutputItemDoneEvent
    | ResponseContentPartAddedEvent
    | ResponseContentPartDoneEvent
    | ResponseErrorEvent;

/**
 * The type of output content
 */
export type OutputAudioContentType =
    (typeof OutputAudioContentType)[keyof typeof OutputAudioContentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OutputAudioContentType = {
    output_audio: "output_audio",
} as const;

export interface OutputAudioContent {
    /** Base64-encoded audio data */
    data: string;
    /** Transcript of the audio */
    transcript: string;
    /** The type of output content */
    type: OutputAudioContentType;
}

export type OutputContent = OutputTextContent | OutputAudioContent;

export type OutputItem =
    | OutputMessage
    | FileSearchToolCall
    | FunctionToolCall
    | WebSearchToolCall
    | ComputerToolCall
    | ReasoningItem;

/**
 * The role of the message
 */
export type OutputMessageRole =
    (typeof OutputMessageRole)[keyof typeof OutputMessageRole];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OutputMessageRole = {
    assistant: "assistant",
} as const;

/**
 * The type of output item
 */
export type OutputMessageType =
    (typeof OutputMessageType)[keyof typeof OutputMessageType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OutputMessageType = {
    message: "message",
} as const;

export interface OutputMessage {
    /** The content of the message */
    content: OutputContent[];
    /** The role of the message */
    role: OutputMessageRole;
    /** The type of output item */
    type: OutputMessageType;
}

/**
 * The type of output content
 */
export type OutputTextContentType =
    (typeof OutputTextContentType)[keyof typeof OutputTextContentType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OutputTextContentType = {
    output_text: "output_text",
} as const;

export interface OutputTextContent {
    /** The text content */
    text: string;
    /** The type of output content */
    type: OutputTextContentType;
}

export interface PersonalAccessToken {
    /** [Output Only]The date and time the token was created. */
    createdAt?: string;
    /** Optional. A more detailed description of the token's intended use. */
    description?: string;
    /** Unique identifier for the GitCommit */
    id?: string;
    /** Required. The name of the token. Can be a simple description. */
    name?: string;
    /** [Output Only]. The personal access token. Only returned during creation. */
    token?: string;
}

export type PikaBodyGenerate22C2vGenerate22PikascenesPostIngredientsMode =
    (typeof PikaBodyGenerate22C2vGenerate22PikascenesPostIngredientsMode)[keyof typeof PikaBodyGenerate22C2vGenerate22PikascenesPostIngredientsMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PikaBodyGenerate22C2vGenerate22PikascenesPostIngredientsMode = {
    creative: "creative",
    precise: "precise",
} as const;

export interface PikaBodyGenerate22C2vGenerate22PikascenesPost {
    /** Aspect ratio (width / height) */
    aspectRatio?: number;
    duration?: number;
    images?: Blob[];
    ingredientsMode: PikaBodyGenerate22C2vGenerate22PikascenesPostIngredientsMode;
    negativePrompt?: string;
    promptText?: string;
    resolution?: string;
    seed?: number;
}

export interface PikaBodyGenerate22I2vGenerate22I2vPost {
    duration?: PikaDurationEnum;
    /** @nullable */
    image?: Blob | null;
    /** @nullable */
    negativePrompt?: string | null;
    /** @nullable */
    promptText?: string | null;
    resolution?: PikaResolutionEnum;
    /** @nullable */
    seed?: number | null;
}

export interface PikaBodyGenerate22KeyframeGenerate22PikaframesPost {
    /**
     * @minimum 5
     * @maximum 10
     */
    duration?: number;
    /** Array of keyframe images */
    keyFrames?: Blob[];
    negativePrompt?: string;
    promptText: string;
    resolution?: PikaResolutionEnum;
    seed?: number;
}

export interface PikaBodyGenerate22T2vGenerate22T2vPost {
    /**
     * Aspect ratio (width / height)
     * @minimum 0.4
     * @maximum 2.5
     */
    aspectRatio?: number;
    duration?: PikaDurationEnum;
    /** @nullable */
    negativePrompt?: string | null;
    promptText: string;
    resolution?: PikaResolutionEnum;
    /** @nullable */
    seed?: number | null;
}

export interface PikaBodyGeneratePikadditionsGeneratePikadditionsPost {
    image?: Blob;
    negativePrompt?: string;
    promptText?: string;
    seed?: number;
    video?: Blob;
}

export interface PikaBodyGeneratePikaffectsGeneratePikaffectsPost {
    image?: Blob;
    negativePrompt?: string;
    pikaffect?: Pikaffect;
    promptText?: string;
    seed?: number;
}

export interface PikaBodyGeneratePikaswapsGeneratePikaswapsPost {
    image?: Blob;
    /** A mask image that specifies the region to modify, where the mask is white and the background is black */
    modifyRegionMask?: Blob;
    /** Plaintext description of the object / region to modify */
    modifyRegionRoi?: string;
    negativePrompt?: string;
    promptText?: string;
    seed?: number;
    video?: Blob;
}

export type PikaDurationEnum =
    (typeof PikaDurationEnum)[keyof typeof PikaDurationEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PikaDurationEnum = {
    NUMBER_5: 5,
    NUMBER_10: 10,
} as const;

export interface PikaGenerateResponse {
    video_id: string;
}

export interface PikaHTTPValidationError {
    detail?: PikaValidationError[];
}

export type PikaResolutionEnum =
    (typeof PikaResolutionEnum)[keyof typeof PikaResolutionEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PikaResolutionEnum = {
    "1080p": "1080p",
    "720p": "720p",
} as const;

export type PikaStatusEnum =
    (typeof PikaStatusEnum)[keyof typeof PikaStatusEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PikaStatusEnum = {
    queued: "queued",
    started: "started",
    finished: "finished",
} as const;

export type PikaValidationErrorLocItem = string | number;

export interface PikaValidationError {
    loc: PikaValidationErrorLocItem[];
    msg: string;
    type: string;
}

export interface PikaVideoResponse {
    id: string;
    /** @nullable */
    progress?: number | null;
    status: PikaStatusEnum;
    /** @nullable */
    url?: string | null;
}

export type Pikaffect = (typeof Pikaffect)[keyof typeof Pikaffect];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Pikaffect = {
    "Cake-ify": "Cake-ify",
    Crumble: "Crumble",
    Crush: "Crush",
    Decapitate: "Decapitate",
    Deflate: "Deflate",
    Dissolve: "Dissolve",
    Explode: "Explode",
    "Eye-pop": "Eye-pop",
    Inflate: "Inflate",
    Levitate: "Levitate",
    Melt: "Melt",
    Peel: "Peel",
    Poke: "Poke",
    Squish: "Squish",
    "Ta-da": "Ta-da",
    Tear: "Tear",
} as const;

export type PixverseImageUploadResponseResp = {
    img_id?: number;
};

export interface PixverseImageUploadResponse {
    ErrCode?: number;
    ErrMsg?: string;
    Resp?: PixverseImageUploadResponseResp;
}

export type PixverseImageVideoRequestDuration =
    (typeof PixverseImageVideoRequestDuration)[keyof typeof PixverseImageVideoRequestDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseImageVideoRequestDuration = {
    NUMBER_5: 5,
    NUMBER_8: 8,
} as const;

export type PixverseImageVideoRequestModel =
    (typeof PixverseImageVideoRequestModel)[keyof typeof PixverseImageVideoRequestModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseImageVideoRequestModel = {
    v35: "v3.5",
} as const;

export type PixverseImageVideoRequestMotionMode =
    (typeof PixverseImageVideoRequestMotionMode)[keyof typeof PixverseImageVideoRequestMotionMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseImageVideoRequestMotionMode = {
    normal: "normal",
    fast: "fast",
} as const;

export type PixverseImageVideoRequestQuality =
    (typeof PixverseImageVideoRequestQuality)[keyof typeof PixverseImageVideoRequestQuality];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseImageVideoRequestQuality = {
    "360p": "360p",
    "540p": "540p",
    "720p": "720p",
    "1080p": "1080p",
} as const;

export type PixverseImageVideoRequestStyle =
    (typeof PixverseImageVideoRequestStyle)[keyof typeof PixverseImageVideoRequestStyle];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseImageVideoRequestStyle = {
    anime: "anime",
    "3d_animation": "3d_animation",
    clay: "clay",
    comic: "comic",
    cyberpunk: "cyberpunk",
} as const;

export interface PixverseImageVideoRequest {
    duration: PixverseImageVideoRequestDuration;
    img_id: number;
    model: PixverseImageVideoRequestModel;
    motion_mode?: PixverseImageVideoRequestMotionMode;
    prompt: string;
    quality: PixverseImageVideoRequestQuality;
    seed?: number;
    style?: PixverseImageVideoRequestStyle;
    template_id?: number;
    water_mark?: boolean;
}

export type PixverseTextVideoRequestAspectRatio =
    (typeof PixverseTextVideoRequestAspectRatio)[keyof typeof PixverseTextVideoRequestAspectRatio];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseTextVideoRequestAspectRatio = {
    "16:9": "16:9",
    "4:3": "4:3",
    "1:1": "1:1",
    "3:4": "3:4",
    "9:16": "9:16",
} as const;

export type PixverseTextVideoRequestDuration =
    (typeof PixverseTextVideoRequestDuration)[keyof typeof PixverseTextVideoRequestDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseTextVideoRequestDuration = {
    NUMBER_5: 5,
    NUMBER_8: 8,
} as const;

export type PixverseTextVideoRequestModel =
    (typeof PixverseTextVideoRequestModel)[keyof typeof PixverseTextVideoRequestModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseTextVideoRequestModel = {
    v35: "v3.5",
} as const;

export type PixverseTextVideoRequestMotionMode =
    (typeof PixverseTextVideoRequestMotionMode)[keyof typeof PixverseTextVideoRequestMotionMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseTextVideoRequestMotionMode = {
    normal: "normal",
    fast: "fast",
} as const;

export type PixverseTextVideoRequestQuality =
    (typeof PixverseTextVideoRequestQuality)[keyof typeof PixverseTextVideoRequestQuality];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseTextVideoRequestQuality = {
    "360p": "360p",
    "540p": "540p",
    "720p": "720p",
    "1080p": "1080p",
} as const;

export type PixverseTextVideoRequestStyle =
    (typeof PixverseTextVideoRequestStyle)[keyof typeof PixverseTextVideoRequestStyle];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseTextVideoRequestStyle = {
    anime: "anime",
    "3d_animation": "3d_animation",
    clay: "clay",
    comic: "comic",
    cyberpunk: "cyberpunk",
} as const;

export interface PixverseTextVideoRequest {
    aspect_ratio: PixverseTextVideoRequestAspectRatio;
    duration: PixverseTextVideoRequestDuration;
    model: PixverseTextVideoRequestModel;
    motion_mode?: PixverseTextVideoRequestMotionMode;
    negative_prompt?: string;
    prompt: string;
    quality: PixverseTextVideoRequestQuality;
    seed?: number;
    style?: PixverseTextVideoRequestStyle;
    template_id?: number;
    water_mark?: boolean;
}

export type PixverseTransitionVideoRequestDuration =
    (typeof PixverseTransitionVideoRequestDuration)[keyof typeof PixverseTransitionVideoRequestDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseTransitionVideoRequestDuration = {
    NUMBER_5: 5,
    NUMBER_8: 8,
} as const;

export type PixverseTransitionVideoRequestModel =
    (typeof PixverseTransitionVideoRequestModel)[keyof typeof PixverseTransitionVideoRequestModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseTransitionVideoRequestModel = {
    v35: "v3.5",
} as const;

export type PixverseTransitionVideoRequestMotionMode =
    (typeof PixverseTransitionVideoRequestMotionMode)[keyof typeof PixverseTransitionVideoRequestMotionMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseTransitionVideoRequestMotionMode = {
    normal: "normal",
    fast: "fast",
} as const;

export type PixverseTransitionVideoRequestQuality =
    (typeof PixverseTransitionVideoRequestQuality)[keyof typeof PixverseTransitionVideoRequestQuality];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseTransitionVideoRequestQuality = {
    "360p": "360p",
    "540p": "540p",
    "720p": "720p",
    "1080p": "1080p",
} as const;

export type PixverseTransitionVideoRequestStyle =
    (typeof PixverseTransitionVideoRequestStyle)[keyof typeof PixverseTransitionVideoRequestStyle];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseTransitionVideoRequestStyle = {
    anime: "anime",
    "3d_animation": "3d_animation",
    clay: "clay",
    comic: "comic",
    cyberpunk: "cyberpunk",
} as const;

export interface PixverseTransitionVideoRequest {
    duration: PixverseTransitionVideoRequestDuration;
    first_frame_img: number;
    last_frame_img: number;
    model: PixverseTransitionVideoRequestModel;
    motion_mode: PixverseTransitionVideoRequestMotionMode;
    prompt: string;
    quality: PixverseTransitionVideoRequestQuality;
    seed: number;
    style?: PixverseTransitionVideoRequestStyle;
    template_id?: number;
    water_mark?: boolean;
}

export type PixverseVideoResponseResp = {
    video_id?: number;
};

export interface PixverseVideoResponse {
    ErrCode?: number;
    ErrMsg?: string;
    Resp?: PixverseVideoResponseResp;
}

/**
 * Video generation status codes:
* 1 - Generation successful
* 5 - Generating
* 6 - Deleted
* 7 - Contents moderation failed
* 8 - Generation failed

 */
export type PixverseVideoResultResponseRespStatus =
    (typeof PixverseVideoResultResponseRespStatus)[keyof typeof PixverseVideoResultResponseRespStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PixverseVideoResultResponseRespStatus = {
    NUMBER_1: 1,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
} as const;

export type PixverseVideoResultResponseResp = {
    create_time?: string;
    id?: number;
    modify_time?: string;
    negative_prompt?: string;
    outputHeight?: number;
    outputWidth?: number;
    prompt?: string;
    resolution_ratio?: number;
    seed?: number;
    size?: number;
    /** Video generation status codes:
     * 1 - Generation successful
     * 5 - Generating
     * 6 - Deleted
     * 7 - Contents moderation failed
     * 8 - Generation failed
     */
    status?: PixverseVideoResultResponseRespStatus;
    style?: string;
    url?: string;
};

export interface PixverseVideoResultResponse {
    ErrCode?: number;
    ErrMsg?: string;
    Resp?: PixverseVideoResultResponseResp;
}

export interface Publisher {
    /** The date and time the publisher was created. */
    createdAt?: string;
    description?: string;
    /** The unique identifier for the publisher. It's akin to a username. Should be lowercase. */
    id?: string;
    /** URL to the publisher's logo. */
    logo?: string;
    /** A list of members in the publisher. */
    members?: PublisherMember[];
    name?: string;
    source_code_repo?: string;
    status?: PublisherStatus;
    support?: string;
    website?: string;
}

export interface PublisherMember {
    /** The unique identifier for the publisher member. */
    id?: string;
    /** The role of the user in the publisher. */
    role?: string;
    user?: PublisherUser;
}

export type PublisherStatus =
    (typeof PublisherStatus)[keyof typeof PublisherStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PublisherStatus = {
    PublisherStatusActive: "PublisherStatusActive",
    PublisherStatusBanned: "PublisherStatusBanned",
} as const;

export interface PublisherUser {
    /** The email address for this user. */
    email?: string;
    /** The unique id for this user. */
    id?: string;
    /** The name for this user. */
    name?: string;
}

/**
 * RGB color values
 */
export interface RGBColor {
    /**
     * @minItems 3
     * @maxItems 3
     */
    rgb: number[];
}

/**
 * **Deprecated:** use `summary` instead.

A summary of the reasoning performed by the model. This can be
useful for debugging and understanding the model's reasoning process.
One of `auto`, `concise`, or `detailed`.

 * @deprecated
 */
export type ReasoningGenerateSummary =
    (typeof ReasoningGenerateSummary)[keyof typeof ReasoningGenerateSummary];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReasoningGenerateSummary = {
    auto: "auto",
    concise: "concise",
    detailed: "detailed",
} as const;

/**
 * A summary of the reasoning performed by the model. This can be
useful for debugging and understanding the model's reasoning process.
One of `auto`, `concise`, or `detailed`.

 */
export type ReasoningSummary =
    (typeof ReasoningSummary)[keyof typeof ReasoningSummary];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReasoningSummary = {
    auto: "auto",
    concise: "concise",
    detailed: "detailed",
} as const;

/**
 * **o-series models only**

Configuration options for 
[reasoning models](https://platform.openai.com/docs/guides/reasoning).

 */
export interface Reasoning {
    effort?: ReasoningEffort;
    /**
   * **Deprecated:** use `summary` instead.

A summary of the reasoning performed by the model. This can be
useful for debugging and understanding the model's reasoning process.
One of `auto`, `concise`, or `detailed`.

   * @deprecated
   */
    generate_summary?: ReasoningGenerateSummary;
    /** A summary of the reasoning performed by the model. This can be
useful for debugging and understanding the model's reasoning process.
One of `auto`, `concise`, or `detailed`.
 */
    summary?: ReasoningSummary;
}

/**
 * **o-series models only** 

Constrains effort on reasoning for 
[reasoning models](https://platform.openai.com/docs/guides/reasoning).
Currently supported values are `low`, `medium`, and `high`. Reducing
reasoning effort can result in faster responses and fewer tokens used
on reasoning in a response.

 */
export type ReasoningEffort =
    (typeof ReasoningEffort)[keyof typeof ReasoningEffort];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReasoningEffort = {
    low: "low",
    medium: "medium",
    high: "high",
} as const;

/**
 * The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.

 */
export type ReasoningItemStatus =
    (typeof ReasoningItemStatus)[keyof typeof ReasoningItemStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReasoningItemStatus = {
    in_progress: "in_progress",
    completed: "completed",
    incomplete: "incomplete",
} as const;

/**
 * The type of the object. Always `summary_text`.

 */
export type ReasoningItemSummaryItemType =
    (typeof ReasoningItemSummaryItemType)[keyof typeof ReasoningItemSummaryItemType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReasoningItemSummaryItemType = {
    summary_text: "summary_text",
} as const;

export type ReasoningItemSummaryItem = {
    /** A short summary of the reasoning used by the model when generating
the response.
 */
    text: string;
    /** The type of the object. Always `summary_text`.
     */
    type: ReasoningItemSummaryItemType;
};

/**
 * The type of the object. Always `reasoning`.

 */
export type ReasoningItemType =
    (typeof ReasoningItemType)[keyof typeof ReasoningItemType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReasoningItemType = {
    reasoning: "reasoning",
} as const;

/**
 * A description of the chain of thought used by a reasoning model while generating
a response.

 */
export interface ReasoningItem {
    /** The unique identifier of the reasoning content.
     */
    id: string;
    /** The status of the item. One of `in_progress`, `completed`, or
`incomplete`. Populated when items are returned via API.
 */
    status?: ReasoningItemStatus;
    /** Reasoning text contents.
     */
    summary: ReasoningItemSummaryItem[];
    /** The type of the object. Always `reasoning`.
     */
    type: ReasoningItemType;
}

export interface RecraftGenerateImageResponse {
    created: number;
    credits: number;
    data: RecraftImage[];
}

export interface RecraftImage {
    b64_json?: string;
    features?: RecraftImageFeatures;
    image_id: string;
    revised_prompt?: string;
    url?: string;
}

export interface RecraftImageColor {
    rgb?: number[];
    std?: number[];
    weight?: number;
}

export interface RecraftImageFeatures {
    nsfw_score?: number;
}

export type RecraftImageFormat =
    (typeof RecraftImageFormat)[keyof typeof RecraftImageFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecraftImageFormat = {
    webp: "webp",
    png: "png",
} as const;

/**
 * The controls for the generated image
 */
export type RecraftImageGenerationRequestControls = {
    /**
     * Defines artistic tone of your image. At a simple level, the person looks straight at the camera in a static and clean style. Dynamic and eccentric levels introduce movement and creativity.
     * @minimum 0
     * @maximum 5
     * @nullable
     */
    artistic_level?: number | null;
    background_color?: RGBColor;
    /** An array of preferable colors */
    colors?: RGBColor[];
    /** Do not embed text layouts */
    no_text?: boolean;
};

/**
 * Parameters for the Recraft image generation proxy request.
 */
export interface RecraftImageGenerationRequest {
    /** The controls for the generated image */
    controls?: RecraftImageGenerationRequestControls;
    /** The model to use for generation (e.g., "recraftv3") */
    model: string;
    /**
     * The number of images to generate
     * @minimum 1
     * @maximum 4
     */
    n: number;
    /** The text prompt describing the image to generate */
    prompt: string;
    /** The size of the generated image (e.g., "1024x1024") */
    size: string;
    /** The style to apply to the generated image (e.g., "digital_illustration") */
    style?: string;
    /** The style ID to apply to the generated image (e.g., "123e4567-e89b-12d3-a456-426614174000"). If style_id is provided, style should not be provided. */
    style_id?: string;
}

export type RecraftImageGenerationResponseDataItem = {
    /** Unique identifier for the generated image */
    image_id?: string;
    /** URL to access the generated image */
    url?: string;
};

/**
 * Response from the Recraft image generation API.
 */
export interface RecraftImageGenerationResponse {
    /** Unix timestamp when the generation was created */
    created: number;
    /** Number of credits used for the generation */
    credits: number;
    /** Array of generated image information */
    data: RecraftImageGenerationResponseDataItem[];
}

export type RecraftImageStyle =
    (typeof RecraftImageStyle)[keyof typeof RecraftImageStyle];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecraftImageStyle = {
    digital_illustration: "digital_illustration",
    icon: "icon",
    realistic_image: "realistic_image",
    vector_illustration: "vector_illustration",
} as const;

export type RecraftImageSubStyle =
    (typeof RecraftImageSubStyle)[keyof typeof RecraftImageSubStyle];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecraftImageSubStyle = {
    "2d_art_poster": "2d_art_poster",
    "3d": "3d",
    "80s": "80s",
    glow: "glow",
    grain: "grain",
    hand_drawn: "hand_drawn",
    infantile_sketch: "infantile_sketch",
    kawaii: "kawaii",
    pixel_art: "pixel_art",
    psychedelic: "psychedelic",
    seamless: "seamless",
    voxel: "voxel",
    watercolor: "watercolor",
    broken_line: "broken_line",
    colored_outline: "colored_outline",
    colored_shapes: "colored_shapes",
    colored_shapes_gradient: "colored_shapes_gradient",
    doodle_fill: "doodle_fill",
    doodle_offset_fill: "doodle_offset_fill",
    offset_fill: "offset_fill",
    outline: "outline",
    outline_gradient: "outline_gradient",
    uneven_fill: "uneven_fill",
    "70s": "70s",
    cartoon: "cartoon",
    doodle_line_art: "doodle_line_art",
    engraving: "engraving",
    flat_2: "flat_2",
    line_art: "line_art",
    linocut: "linocut",
    b_and_w: "b_and_w",
    enterprise: "enterprise",
    hard_flash: "hard_flash",
    hdr: "hdr",
    motion_blur: "motion_blur",
    natural_light: "natural_light",
    studio_portrait: "studio_portrait",
    line_circuit: "line_circuit",
    "2d_art_poster_2": "2d_art_poster_2",
    engraving_color: "engraving_color",
    flat_air_art: "flat_air_art",
    hand_drawn_outline: "hand_drawn_outline",
    handmade_3d: "handmade_3d",
    stickers_drawings: "stickers_drawings",
    plastic: "plastic",
    pictogram: "pictogram",
} as const;

export interface RecraftImageToImageRequest {
    block_nsfw?: boolean;
    calculate_features?: boolean;
    controls?: RecraftUserControls;
    image: Blob;
    image_format?: RecraftImageFormat;
    model?: RecraftTransformModel;
    n?: number;
    negative_prompt?: string;
    prompt: string;
    response_format?: RecraftResponseFormat;
    strength: number;
    style?: RecraftImageStyle;
    style_id?: string;
    substyle?: RecraftImageSubStyle;
    text_layout?: RecraftTextLayout;
}

export interface RecraftProcessImageRequest {
    image: Blob;
    image_format?: RecraftImageFormat;
    response_format?: RecraftResponseFormat;
}

export interface RecraftProcessImageResponse {
    created: number;
    credits: number;
    image: RecraftImage;
}

export type RecraftResponseFormat =
    (typeof RecraftResponseFormat)[keyof typeof RecraftResponseFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecraftResponseFormat = {
    url: "url",
    b64_json: "b64_json",
} as const;

export type RecraftTextLayout = RecraftTextLayoutItem[];

export interface RecraftTextLayoutItem {
    bbox: number[][];
    text: string;
}

export interface RecraftTransformImageWithMaskRequest {
    block_nsfw?: boolean;
    calculate_features?: boolean;
    image: Blob;
    image_format?: RecraftImageFormat;
    mask: Blob;
    model?: RecraftTransformModel;
    n?: number;
    negative_prompt?: string;
    prompt: string;
    response_format?: RecraftResponseFormat;
    style?: RecraftImageStyle;
    style_id?: string;
    substyle?: RecraftImageSubStyle;
    text_layout?: RecraftTextLayout;
}

export type RecraftTransformModel =
    (typeof RecraftTransformModel)[keyof typeof RecraftTransformModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecraftTransformModel = {
    refm1: "refm1",
    recraft20b: "recraft20b",
    recraftv2: "recraftv2",
    recraftv3: "recraftv3",
    flux1_1pro: "flux1_1pro",
    flux1dev: "flux1dev",
    imagen3: "imagen3",
    hidream_i1_dev: "hidream_i1_dev",
} as const;

export interface RecraftUserControls {
    artistic_level?: number;
    background_color?: RecraftImageColor;
    colors?: RecraftImageColor[];
    no_text?: boolean;
}

/**
 * The attention level for this release
 */
export type ReleaseNoteAttention =
    (typeof ReleaseNoteAttention)[keyof typeof ReleaseNoteAttention];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReleaseNoteAttention = {
    low: "low",
    medium: "medium",
    high: "high",
} as const;

/**
 * The project this release note belongs to
 */
export type ReleaseNoteProject =
    (typeof ReleaseNoteProject)[keyof typeof ReleaseNoteProject];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReleaseNoteProject = {
    comfyui: "comfyui",
    comfyui_frontend: "comfyui_frontend",
    desktop: "desktop",
} as const;

export interface ReleaseNote {
    /** The attention level for this release */
    attention: ReleaseNoteAttention;
    /** The content of the release note in markdown format */
    content: string;
    /** Unique identifier for the release note */
    id: number;
    /** The project this release note belongs to */
    project: ReleaseNoteProject;
    /** When the release note was published */
    published_at: string;
    /** The version of the release */
    version: string;
}

/**
 * The rendering speed setting that controls the trade-off between generation speed and quality
 */
export type RenderingSpeed =
    (typeof RenderingSpeed)[keyof typeof RenderingSpeed];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RenderingSpeed = {
    DEFAULT: "DEFAULT",
    TURBO: "TURBO",
    QUALITY: "QUALITY",
} as const;

/**
 * The type of the event. Always `response.completed`.
 */
export type ResponseCompletedEventType =
    (typeof ResponseCompletedEventType)[keyof typeof ResponseCompletedEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseCompletedEventType = {
    responsecompleted: "response.completed",
} as const;

/**
 * Emitted when the model response is complete.
 */
export interface ResponseCompletedEvent {
    response: OpenAIResponse;
    /** The type of the event. Always `response.completed`. */
    type: ResponseCompletedEventType;
}

/**
 * The type of the event. Always `response.content_part.added`.
 */
export type ResponseContentPartAddedEventType =
    (typeof ResponseContentPartAddedEventType)[keyof typeof ResponseContentPartAddedEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseContentPartAddedEventType = {
    responsecontent_partadded: "response.content_part.added",
} as const;

/**
 * Emitted when a new content part is added.
 */
export interface ResponseContentPartAddedEvent {
    /** The index of the content part that was added. */
    content_index: number;
    /** The ID of the output item that the content part was added to. */
    item_id: string;
    /** The index of the output item that the content part was added to. */
    output_index: number;
    part: OutputContent;
    /** The type of the event. Always `response.content_part.added`. */
    type: ResponseContentPartAddedEventType;
}

/**
 * The type of the event. Always `response.content_part.done`.
 */
export type ResponseContentPartDoneEventType =
    (typeof ResponseContentPartDoneEventType)[keyof typeof ResponseContentPartDoneEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseContentPartDoneEventType = {
    responsecontent_partdone: "response.content_part.done",
} as const;

/**
 * Emitted when a content part is done.
 */
export interface ResponseContentPartDoneEvent {
    /** The index of the content part that is done. */
    content_index: number;
    /** The ID of the output item that the content part was added to. */
    item_id: string;
    /** The index of the output item that the content part was added to. */
    output_index: number;
    part: OutputContent;
    /** The type of the event. Always `response.content_part.done`. */
    type: ResponseContentPartDoneEventType;
}

/**
 * The type of the event. Always `response.created`.
 */
export type ResponseCreatedEventType =
    (typeof ResponseCreatedEventType)[keyof typeof ResponseCreatedEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseCreatedEventType = {
    responsecreated: "response.created",
} as const;

/**
 * An event that is emitted when a response is created.
 */
export interface ResponseCreatedEvent {
    response: OpenAIResponse;
    /** The type of the event. Always `response.created`. */
    type: ResponseCreatedEventType;
}

/**
 * An error object returned when the model fails to generate a Response.
 */
export interface ResponseError {
    code: ResponseErrorCode;
    /** A human-readable description of the error. */
    message: string;
}

/**
 * The error code for the response.
 */
export type ResponseErrorCode =
    (typeof ResponseErrorCode)[keyof typeof ResponseErrorCode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseErrorCode = {
    server_error: "server_error",
    rate_limit_exceeded: "rate_limit_exceeded",
    invalid_prompt: "invalid_prompt",
    vector_store_timeout: "vector_store_timeout",
    invalid_image: "invalid_image",
    invalid_image_format: "invalid_image_format",
    invalid_base64_image: "invalid_base64_image",
    invalid_image_url: "invalid_image_url",
    image_too_large: "image_too_large",
    image_too_small: "image_too_small",
    image_parse_error: "image_parse_error",
    image_content_policy_violation: "image_content_policy_violation",
    invalid_image_mode: "invalid_image_mode",
    image_file_too_large: "image_file_too_large",
    unsupported_image_media_type: "unsupported_image_media_type",
    empty_image_file: "empty_image_file",
    failed_to_download_image: "failed_to_download_image",
    image_file_not_found: "image_file_not_found",
} as const;

/**
 * The type of the event. Always `error`.

 */
export type ResponseErrorEventType =
    (typeof ResponseErrorEventType)[keyof typeof ResponseErrorEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseErrorEventType = {
    error: "error",
} as const;

/**
 * Emitted when an error occurs.
 */
export interface ResponseErrorEvent {
    /** The error code.
     */
    code: string;
    /** The error message.
     */
    message: string;
    /** The error parameter.
     */
    param: string;
    /** The type of the event. Always `error`.
     */
    type: ResponseErrorEventType;
}

/**
 * The type of the event. Always `response.failed`.

 */
export type ResponseFailedEventType =
    (typeof ResponseFailedEventType)[keyof typeof ResponseFailedEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseFailedEventType = {
    responsefailed: "response.failed",
} as const;

/**
 * An event that is emitted when a response fails.

 */
export interface ResponseFailedEvent {
    response: OpenAIResponse;
    /** The type of the event. Always `response.failed`.
     */
    type: ResponseFailedEventType;
}

/**
 * The type of response format being defined. Always `json_object`.
 */
export type ResponseFormatJsonObjectType =
    (typeof ResponseFormatJsonObjectType)[keyof typeof ResponseFormatJsonObjectType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseFormatJsonObjectType = {
    json_object: "json_object",
} as const;

/**
 * JSON object response format. An older method of generating JSON responses.
Using `json_schema` is recommended for models that support it. Note that the
model will not generate JSON without a system or user message instructing it
to do so.

 */
export interface ResponseFormatJsonObject {
    /** The type of response format being defined. Always `json_object`. */
    type: ResponseFormatJsonObjectType;
}

/**
 * The schema for the response format, described as a JSON Schema object.
Learn how to build JSON schemas [here](https://json-schema.org/).

 */
export interface ResponseFormatJsonSchemaSchema {
    [key: string]: unknown;
}

/**
 * The type of response format being defined. Always `text`.
 */
export type ResponseFormatTextType =
    (typeof ResponseFormatTextType)[keyof typeof ResponseFormatTextType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseFormatTextType = {
    text: "text",
} as const;

/**
 * Default response format. Used to generate text responses.

 */
export interface ResponseFormatText {
    /** The type of response format being defined. Always `text`. */
    type: ResponseFormatTextType;
}

/**
 * The type of the event. Always `response.in_progress`.

 */
export type ResponseInProgressEventType =
    (typeof ResponseInProgressEventType)[keyof typeof ResponseInProgressEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseInProgressEventType = {
    responsein_progress: "response.in_progress",
} as const;

/**
 * Emitted when the response is in progress.
 */
export interface ResponseInProgressEvent {
    response: OpenAIResponse;
    /** The type of the event. Always `response.in_progress`.
     */
    type: ResponseInProgressEventType;
}

/**
 * The type of the event. Always `response.incomplete`.

 */
export type ResponseIncompleteEventType =
    (typeof ResponseIncompleteEventType)[keyof typeof ResponseIncompleteEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseIncompleteEventType = {
    responseincomplete: "response.incomplete",
} as const;

/**
 * An event that is emitted when a response finishes as incomplete.

 */
export interface ResponseIncompleteEvent {
    response: OpenAIResponse;
    /** The type of the event. Always `response.incomplete`.
     */
    type: ResponseIncompleteEventType;
}

/**
 * The type of the event. Always `response.output_item.added`.

 */
export type ResponseOutputItemAddedEventType =
    (typeof ResponseOutputItemAddedEventType)[keyof typeof ResponseOutputItemAddedEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseOutputItemAddedEventType = {
    responseoutput_itemadded: "response.output_item.added",
} as const;

/**
 * Emitted when a new output item is added.
 */
export interface ResponseOutputItemAddedEvent {
    item: OutputItem;
    /** The index of the output item that was added.
     */
    output_index: number;
    /** The type of the event. Always `response.output_item.added`.
     */
    type: ResponseOutputItemAddedEventType;
}

/**
 * The type of the event. Always `response.output_item.done`.

 */
export type ResponseOutputItemDoneEventType =
    (typeof ResponseOutputItemDoneEventType)[keyof typeof ResponseOutputItemDoneEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseOutputItemDoneEventType = {
    responseoutput_itemdone: "response.output_item.done",
} as const;

/**
 * Emitted when an output item is marked done.
 */
export interface ResponseOutputItemDoneEvent {
    item: OutputItem;
    /** The index of the output item that was marked done.
     */
    output_index: number;
    /** The type of the event. Always `response.output_item.done`.
     */
    type: ResponseOutputItemDoneEventType;
}

export type ResponsePropertiesText = {
    format?: TextResponseFormatConfiguration;
};

/**
 * How the model should select which tool (or tools) to use when generating
a response. See the `tools` parameter to see how to specify which tools
the model can call.

 */
export type ResponsePropertiesToolChoice =
    | ToolChoiceOptions
    | ToolChoiceTypes
    | ToolChoiceFunction;

/**
 * The truncation strategy to use for the model response.
- `auto`: If the context of this response and previous ones exceeds
  the model's context window size, the model will truncate the 
  response to fit the context window by dropping input items in the
  middle of the conversation. 
- `disabled` (default): If a model response will exceed the context window 
  size for a model, the request will fail with a 400 error.

 */
export type ResponsePropertiesTruncation =
    (typeof ResponsePropertiesTruncation)[keyof typeof ResponsePropertiesTruncation];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponsePropertiesTruncation = {
    auto: "auto",
    disabled: "disabled",
} as const;

export interface ResponseProperties {
    /** Inserts a system (or developer) message as the first item in the model's context.

When using along with `previous_response_id`, the instructions from a previous
response will not be carried over to the next response. This makes it simple
to swap out system (or developer) messages in new responses.
 */
    instructions?: string;
    /** An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).
     */
    max_output_tokens?: number;
    model?: OpenAIModels;
    /** The unique ID of the previous response to the model. Use this to
create multi-turn conversations. Learn more about 
[conversation state](/docs/guides/conversation-state).
 */
    previous_response_id?: string;
    reasoning?: Reasoning;
    text?: ResponsePropertiesText;
    /** How the model should select which tool (or tools) to use when generating
a response. See the `tools` parameter to see how to specify which tools
the model can call.
 */
    tool_choice?: ResponsePropertiesToolChoice;
    tools?: Tool[];
    /** The truncation strategy to use for the model response.
- `auto`: If the context of this response and previous ones exceeds
  the model's context window size, the model will truncate the 
  response to fit the context window by dropping input items in the
  middle of the conversation. 
- `disabled` (default): If a model response will exceed the context window 
  size for a model, the request will fail with a 400 error.
 */
    truncation?: ResponsePropertiesTruncation;
}

/**
 * A detailed breakdown of the input tokens.
 */
export type ResponseUsageInputTokensDetails = {
    /** The number of tokens that were retrieved from the cache. 
[More on prompt caching](/docs/guides/prompt-caching).
 */
    cached_tokens: number;
};

/**
 * A detailed breakdown of the output tokens.
 */
export type ResponseUsageOutputTokensDetails = {
    /** The number of reasoning tokens. */
    reasoning_tokens: number;
};

/**
 * Represents token usage details including input tokens, output tokens,
a breakdown of output tokens, and the total tokens used.

 */
export interface ResponseUsage {
    /** The number of input tokens. */
    input_tokens: number;
    /** A detailed breakdown of the input tokens. */
    input_tokens_details: ResponseUsageInputTokensDetails;
    /** The number of output tokens. */
    output_tokens: number;
    /** A detailed breakdown of the output tokens. */
    output_tokens_details: ResponseUsageOutputTokensDetails;
    /** The total number of tokens used. */
    total_tokens: number;
}

export interface Rodin3DCheckStatusRequest {
    /** subscription from generate endpoint */
    subscription_key: string;
}

export interface Rodin3DCheckStatusResponse {
    /** Details for the generation status. */
    jobs?: RodinCheckStatusJobItem[];
}

export interface Rodin3DDownloadRequest {
    /** Task UUID */
    task_uuid: string;
}

export interface Rodin3DDownloadResponse {
    list?: RodinResourceItem[];
}

export interface Rodin3DGenerateRequest {
    /** The reference images to generate 3D Assets. */
    images: string;
    material?: RodinMaterialType;
    mesh_mode?: RodinMeshModeType;
    quality?: RodinQualityType;
    /** Seed. */
    seed?: number;
    tier?: RodinTierType;
}

export interface Rodin3DGenerateResponse {
    jobs?: RodinGenerateJobsData;
    /** message */
    message?: string;
    /** prompt */
    prompt?: string;
    /** Time */
    submit_time?: string;
    /** Task UUID */
    uuid?: string;
}

export interface RodinCheckStatusJobItem {
    status?: RodinStatusOptions;
    /** sub uuid */
    uuid?: string;
}

export interface RodinGenerateJobsData {
    /** Subscription Key. */
    subscription_key?: string;
    /** subjobs uuid. */
    uuids?: string[];
}

/**
 * Rodin Material para options
 */
export type RodinMaterialType =
    (typeof RodinMaterialType)[keyof typeof RodinMaterialType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RodinMaterialType = {
    PBR: "PBR",
    Shaded: "Shaded",
} as const;

/**
 * Rodin Mesh_Mode para options
 */
export type RodinMeshModeType =
    (typeof RodinMeshModeType)[keyof typeof RodinMeshModeType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RodinMeshModeType = {
    Quad: "Quad",
    Raw: "Raw",
} as const;

/**
 * Rodin Quality para options
 */
export type RodinQualityType =
    (typeof RodinQualityType)[keyof typeof RodinQualityType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RodinQualityType = {
    "extra-low": "extra-low",
    low: "low",
    medium: "medium",
    high: "high",
} as const;

export interface RodinResourceItem {
    /** File name */
    name?: string;
    /** Download url */
    url?: string;
}

export type RodinStatusOptions =
    (typeof RodinStatusOptions)[keyof typeof RodinStatusOptions];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RodinStatusOptions = {
    Done: "Done",
    Failed: "Failed",
    Generating: "Generating",
    Waiting: "Waiting",
} as const;

/**
 * Rodin Tier para options
 */
export type RodinTierType = (typeof RodinTierType)[keyof typeof RodinTierType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RodinTierType = {
    Regular: "Regular",
    Sketch: "Sketch",
    Detail: "Detail",
    Smooth: "Smooth",
} as const;

export type RunwayAspectRatioEnum =
    (typeof RunwayAspectRatioEnum)[keyof typeof RunwayAspectRatioEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunwayAspectRatioEnum = {
    "1280:720": "1280:720",
    "720:1280": "720:1280",
    "1104:832": "1104:832",
    "832:1104": "832:1104",
    "960:960": "960:960",
    "1584:672": "1584:672",
    "1280:768": "1280:768",
    "768:1280": "768:1280",
} as const;

export type RunwayDurationEnum =
    (typeof RunwayDurationEnum)[keyof typeof RunwayDurationEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunwayDurationEnum = {
    NUMBER_5: 5,
    NUMBER_10: 10,
} as const;

export interface RunwayImageToVideoRequest {
    duration: RunwayDurationEnum;
    model: RunwayModelEnum;
    promptImage: RunwayPromptImageObject;
    /**
     * Text prompt for the generation
     * @maxLength 1000
     */
    promptText?: string;
    ratio: RunwayAspectRatioEnum;
    /**
     * Random seed for generation
     * @minimum 0
     * @maximum 4294967295
     */
    seed: number;
}

export interface RunwayImageToVideoResponse {
    /** Task ID */
    id?: string;
}

/**
 * Available Runway models for generation.
 */
export type RunwayModelEnum =
    (typeof RunwayModelEnum)[keyof typeof RunwayModelEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunwayModelEnum = {
    gen4_turbo: "gen4_turbo",
    gen3a_turbo: "gen3a_turbo",
} as const;

/**
 * The position of the image in the output video. 'last' is currently supported for gen3a_turbo only.
 */
export type RunwayPromptImageDetailedObjectPosition =
    (typeof RunwayPromptImageDetailedObjectPosition)[keyof typeof RunwayPromptImageDetailedObjectPosition];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunwayPromptImageDetailedObjectPosition = {
    first: "first",
    last: "last",
} as const;

/**
 * Represents an image with its position in the video sequence.
 */
export interface RunwayPromptImageDetailedObject {
    /** The position of the image in the output video. 'last' is currently supported for gen3a_turbo only. */
    position: RunwayPromptImageDetailedObjectPosition;
    /** A HTTPS URL or data URI containing an encoded image. */
    uri: string;
}

/**
 * Image(s) to use for the video generation. Can be a single URI or an array of image objects with positions.
 */
export type RunwayPromptImageObject =
    | string
    | RunwayPromptImageDetailedObject[];

/**
 * Possible statuses for a Runway task.
 */
export type RunwayTaskStatusEnum =
    (typeof RunwayTaskStatusEnum)[keyof typeof RunwayTaskStatusEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunwayTaskStatusEnum = {
    SUCCEEDED: "SUCCEEDED",
    RUNNING: "RUNNING",
    FAILED: "FAILED",
    PENDING: "PENDING",
    CANCELLED: "CANCELLED",
    THROTTLED: "THROTTLED",
} as const;

export interface RunwayTaskStatusResponse {
    /** Task creation timestamp */
    createdAt: string;
    /** Task ID */
    id: string;
    /** Array of output video URLs */
    output?: string[];
    /**
     * Float value between 0 and 1 representing the progress of the task. Only available if status is RUNNING.
     * @minimum 0
     * @maximum 1
     */
    progress?: number;
    status: RunwayTaskStatusEnum;
}

export type RunwayTextToImageAspectRatioEnum =
    (typeof RunwayTextToImageAspectRatioEnum)[keyof typeof RunwayTextToImageAspectRatioEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunwayTextToImageAspectRatioEnum = {
    "1920:1080": "1920:1080",
    "1080:1920": "1080:1920",
    "1024:1024": "1024:1024",
    "1360:768": "1360:768",
    "1080:1080": "1080:1080",
    "1168:880": "1168:880",
    "1440:1080": "1440:1080",
    "1080:1440": "1080:1440",
    "1808:768": "1808:768",
    "2112:912": "2112:912",
} as const;

/**
 * Model to use for generation
 */
export type RunwayTextToImageRequestModel =
    (typeof RunwayTextToImageRequestModel)[keyof typeof RunwayTextToImageRequestModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RunwayTextToImageRequestModel = {
    gen4_image: "gen4_image",
} as const;

export type RunwayTextToImageRequestReferenceImagesItem = {
    /** A HTTPS URL or data URI containing an encoded image */
    uri?: string;
};

export interface RunwayTextToImageRequest {
    /** Model to use for generation */
    model: RunwayTextToImageRequestModel;
    /**
     * Text prompt for the image generation
     * @maxLength 1000
     */
    promptText: string;
    ratio: RunwayTextToImageAspectRatioEnum;
    /** Array of reference images to guide the generation */
    referenceImages?: RunwayTextToImageRequestReferenceImagesItem[];
}

export interface RunwayTextToImageResponse {
    /** Task ID */
    id?: string;
}

/**
 * Our content moderation system has flagged some part of your request and subsequently denied it.  You were not charged for this request.  While this may at times be frustrating, it is necessary to maintain the integrity of our platform and ensure a safe experience for all users. If you would like to provide feedback, please use the [Support Form](https://kb.stability.ai/knowledge-base/kb-tickets/new).
 * @minLength 1
 */
export type StabilityContentModerationResponseName =
    (typeof StabilityContentModerationResponseName)[keyof typeof StabilityContentModerationResponseName];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityContentModerationResponseName = {
    content_moderation: "content_moderation",
} as const;

/**
 * Your request was flagged by our content moderation system.
 */
export interface StabilityContentModerationResponse {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
     * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
     * @minLength 1
     */
    id: string;
    /**
     * Our content moderation system has flagged some part of your request and subsequently denied it.  You were not charged for this request.  While this may at times be frustrating, it is necessary to maintain the integrity of our platform and ensure a safe experience for all users. If you would like to provide feedback, please use the [Support Form](https://kb.stability.ai/knowledge-base/kb-tickets/new).
     * @minLength 1
     */
    name: StabilityContentModerationResponseName;
}

/**
 * Controls the likelihood of creating additional details not heavily conditioned by the init image.
 * @minimum 0.2
 * @maximum 0.5
 */
export type StabilityCreativity = number;

export interface StabilityError {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.

   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

/**
 * The `id` of a generation, typically used for async generations, that can be used to check the status of the generation or retrieve the result.
 * @minLength 64
 * @maxLength 64
 */
export type StabilityGenerationID = string;

export type StabilityGetResultResponse202Status =
    (typeof StabilityGetResultResponse202Status)[keyof typeof StabilityGetResultResponse202Status];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityGetResultResponse202Status = {
    "in-progress": "in-progress",
} as const;

export interface StabilityGetResultResponse202 {
    /** The ID of the generation result. */
    id?: string;
    status?: StabilityGetResultResponse202Status;
}

/**
 * Controls the aspect ratio of the generated image. Defaults to 1:1.

> **Important:** This parameter is only valid for **text-to-image** requests.
 */
export type StabilityImageGenerationSD3RequestAspectRatio =
    (typeof StabilityImageGenerationSD3RequestAspectRatio)[keyof typeof StabilityImageGenerationSD3RequestAspectRatio];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenerationSD3RequestAspectRatio = {
    "21:9": "21:9",
    "16:9": "16:9",
    "3:2": "3:2",
    "5:4": "5:4",
    "1:1": "1:1",
    "4:5": "4:5",
    "2:3": "2:3",
    "9:16": "9:16",
    "9:21": "9:21",
} as const;

/**
 * Controls whether this is a text-to-image or image-to-image generation, which affects which parameters are required:
- **text-to-image** requires only the `prompt` parameter
- **image-to-image** requires the `prompt`, `image`, and `strength` parameters
 */
export type StabilityImageGenerationSD3RequestMode =
    (typeof StabilityImageGenerationSD3RequestMode)[keyof typeof StabilityImageGenerationSD3RequestMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenerationSD3RequestMode = {
    "text-to-image": "text-to-image",
    "image-to-image": "image-to-image",
} as const;

/**
 * The model to use for generation.

- `sd3.5-large` requires 6.5 credits per generation
- `sd3.5-large-turbo` requires 4 credits per generation
- `sd3.5-medium` requires 3.5 credits per generation
- As of the April 17, 2025, `sd3-large`, `sd3-large-turbo` and `sd3-medium`



  are re-routed to their `sd3.5-[model version]` equivalent, at the same price.
 */
export type StabilityImageGenerationSD3RequestModel =
    (typeof StabilityImageGenerationSD3RequestModel)[keyof typeof StabilityImageGenerationSD3RequestModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenerationSD3RequestModel = {
    "sd35-large": "sd3.5-large",
    "sd35-large-turbo": "sd3.5-large-turbo",
    "sd35-medium": "sd3.5-medium",
} as const;

/**
 * Dictates the `content-type` of the generated image.
 */
export type StabilityImageGenerationSD3RequestOutputFormat =
    (typeof StabilityImageGenerationSD3RequestOutputFormat)[keyof typeof StabilityImageGenerationSD3RequestOutputFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenerationSD3RequestOutputFormat = {
    png: "png",
    jpeg: "jpeg",
} as const;

/**
 * Guides the image model towards a particular style.
 */
export type StabilityImageGenerationSD3RequestStylePreset =
    (typeof StabilityImageGenerationSD3RequestStylePreset)[keyof typeof StabilityImageGenerationSD3RequestStylePreset];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenerationSD3RequestStylePreset = {
    enhance: "enhance",
    anime: "anime",
    photographic: "photographic",
    "digital-art": "digital-art",
    "comic-book": "comic-book",
    "fantasy-art": "fantasy-art",
    "line-art": "line-art",
    "analog-film": "analog-film",
    "neon-punk": "neon-punk",
    isometric: "isometric",
    "low-poly": "low-poly",
    origami: "origami",
    "modeling-compound": "modeling-compound",
    cinematic: "cinematic",
    "3d-model": "3d-model",
    "pixel-art": "pixel-art",
    "tile-texture": "tile-texture",
} as const;

export interface StabilityImageGenerationSD3Request {
    /** Controls the aspect ratio of the generated image. Defaults to 1:1.

> **Important:** This parameter is only valid for **text-to-image** requests. */
    aspect_ratio?: StabilityImageGenerationSD3RequestAspectRatio;
    /**
     * How strictly the diffusion process adheres to the prompt text (higher values keep your image closer to your prompt). The _Large_ and _Medium_ models use a default of `4`. The _Turbo_ model uses a default of `1`.
     * @minimum 1
     * @maximum 10
     */
    cfg_scale?: number;
    /** The image to use as the starting point for the generation.

Supported formats:



  - jpeg
  - png
  - webp

Supported dimensions:



  - Every side must be at least 64 pixels

> **Important:** This parameter is only valid for **image-to-image** requests. */
    image?: Blob;
    /** Controls whether this is a text-to-image or image-to-image generation, which affects which parameters are required:
- **text-to-image** requires only the `prompt` parameter
- **image-to-image** requires the `prompt`, `image`, and `strength` parameters */
    mode?: StabilityImageGenerationSD3RequestMode;
    /** The model to use for generation.

- `sd3.5-large` requires 6.5 credits per generation
- `sd3.5-large-turbo` requires 4 credits per generation
- `sd3.5-medium` requires 3.5 credits per generation
- As of the April 17, 2025, `sd3-large`, `sd3-large-turbo` and `sd3-medium`



  are re-routed to their `sd3.5-[model version]` equivalent, at the same price. */
    model?: StabilityImageGenerationSD3RequestModel;
    /**
   * Keywords of what you **do not** wish to see in the output image.
This is an advanced feature.
   * @maxLength 10000
   */
    negative_prompt?: string;
    /** Dictates the `content-type` of the generated image. */
    output_format?: StabilityImageGenerationSD3RequestOutputFormat;
    /**
   * What you wish to see in the output image. A strong, descriptive prompt that clearly defines
elements, colors, and subjects will lead to better results.
   * @minLength 1
   * @maxLength 10000
   */
    prompt: string;
    /**
     * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
    /**
   * Sometimes referred to as _denoising_, this parameter controls how much influence the
`image` parameter has on the generated image.  A value of 0 would yield an image that
is identical to the input.  A value of 1 would be as if you passed in no image at all.

> **Important:** This parameter is only valid for **image-to-image** requests.
   * @minimum 0
   * @maximum 1
   */
    strength?: number;
    /** Guides the image model towards a particular style. */
    style_preset?: StabilityImageGenerationSD3RequestStylePreset;
}

/**
 * The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result.
 */
export type StabilityImageGenrationSD3Response200FinishReason =
    (typeof StabilityImageGenrationSD3Response200FinishReason)[keyof typeof StabilityImageGenrationSD3Response200FinishReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationSD3Response200FinishReason = {
    SUCCESS: "SUCCESS",
    CONTENT_FILTERED: "CONTENT_FILTERED",
} as const;

export interface StabilityImageGenrationSD3Response200 {
    /** The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result. */
    finish_reason: StabilityImageGenrationSD3Response200FinishReason;
    /** The generated image, encoded to base64. */
    image: string;
    /**
     * The seed used as random noise for this generation.
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
}

export interface StabilityImageGenrationSD3Response400 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationSD3Response413 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationSD3Response422 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationSD3Response429 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationSD3Response500 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

/**
 * Dictates the `content-type` of the generated image.
 */
export type StabilityImageGenrationUpscaleConservativeRequestOutputFormat =
    (typeof StabilityImageGenrationUpscaleConservativeRequestOutputFormat)[keyof typeof StabilityImageGenrationUpscaleConservativeRequestOutputFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUpscaleConservativeRequestOutputFormat = {
    jpeg: "jpeg",
    png: "png",
    webp: "webp",
} as const;

export interface StabilityImageGenrationUpscaleConservativeRequest {
    creativity?: StabilityCreativity;
    /** The image you wish to upscale.

Supported Formats:
- jpeg
- png
- webp

Validation Rules:
- Every side must be at least 64 pixels
- Total pixel count must be between 4,096 and 9,437,184 pixels
- The aspect ratio must be between 1:2.5 and 2.5:1 */
    image: Blob;
    /**
   * A blurb of text describing what you **do not** wish to see in the output image.
This is an advanced feature.
   * @maxLength 10000
   */
    negative_prompt?: string;
    /** Dictates the `content-type` of the generated image. */
    output_format?: StabilityImageGenrationUpscaleConservativeRequestOutputFormat;
    /**
   * What you wish to see in the output image. A strong, descriptive prompt that clearly defines
elements, colors, and subjects will lead to better results.

To control the weight of a given word use the format `(word:weight)`,
where `word` is the word you'd like to control the weight of and `weight`
is a value between 0 and 1. For example: `The sky was a crisp (blue:0.3) and (green:0.8)`
would convey a sky that was blue and green, but more green than blue.
   * @minLength 1
   * @maxLength 10000
   */
    prompt: string;
    /**
     * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
}

/**
 * The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result.
 */
export type StabilityImageGenrationUpscaleConservativeResponse200FinishReason =
    (typeof StabilityImageGenrationUpscaleConservativeResponse200FinishReason)[keyof typeof StabilityImageGenrationUpscaleConservativeResponse200FinishReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUpscaleConservativeResponse200FinishReason =
    {
        SUCCESS: "SUCCESS",
        CONTENT_FILTERED: "CONTENT_FILTERED",
    } as const;

export interface StabilityImageGenrationUpscaleConservativeResponse200 {
    /** The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result. */
    finish_reason: StabilityImageGenrationUpscaleConservativeResponse200FinishReason;
    /** The generated image, encoded to base64. */
    image: string;
    /**
     * The seed used as random noise for this generation.
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
}

export interface StabilityImageGenrationUpscaleConservativeResponse400 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleConservativeResponse413 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleConservativeResponse422 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleConservativeResponse429 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleConservativeResponse500 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

/**
 * Dictates the `content-type` of the generated image.
 */
export type StabilityImageGenrationUpscaleCreativeRequestOutputFormat =
    (typeof StabilityImageGenrationUpscaleCreativeRequestOutputFormat)[keyof typeof StabilityImageGenrationUpscaleCreativeRequestOutputFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUpscaleCreativeRequestOutputFormat = {
    jpeg: "jpeg",
    png: "png",
    webp: "webp",
} as const;

/**
 * Guides the image model towards a particular style.
 */
export type StabilityImageGenrationUpscaleCreativeRequestStylePreset =
    (typeof StabilityImageGenrationUpscaleCreativeRequestStylePreset)[keyof typeof StabilityImageGenrationUpscaleCreativeRequestStylePreset];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUpscaleCreativeRequestStylePreset = {
    enhance: "enhance",
    anime: "anime",
    photographic: "photographic",
    "digital-art": "digital-art",
    "comic-book": "comic-book",
    "fantasy-art": "fantasy-art",
    "line-art": "line-art",
    "analog-film": "analog-film",
    "neon-punk": "neon-punk",
    isometric: "isometric",
    "low-poly": "low-poly",
    origami: "origami",
    "modeling-compound": "modeling-compound",
    cinematic: "cinematic",
    "3d-model": "3d-model",
    "pixel-art": "pixel-art",
    "tile-texture": "tile-texture",
} as const;

export interface StabilityImageGenrationUpscaleCreativeRequest {
    /**
   * Indicates how creative the model should be when upscaling an image.
Higher values will result in more details being added to the image during upscaling.
   * @minimum 0.1
   * @maximum 0.5
   */
    creativity?: number;
    /** The image you wish to upscale.

Supported Formats:
- jpeg
- png
- webp

Validation Rules:
- Every side must be at least 64 pixels
- Total pixel count must be between 4,096 and 1,048,576 pixels */
    image: Blob;
    /**
   * A blurb of text describing what you **do not** wish to see in the output image.
This is an advanced feature.
   * @maxLength 10000
   */
    negative_prompt?: string;
    /** Dictates the `content-type` of the generated image. */
    output_format?: StabilityImageGenrationUpscaleCreativeRequestOutputFormat;
    /**
   * What you wish to see in the output image. A strong, descriptive prompt that clearly defines
elements, colors, and subjects will lead to better results.

To control the weight of a given word use the format `(word:weight)`,
where `word` is the word you'd like to control the weight of and `weight`
is a value between 0 and 1. For example: `The sky was a crisp (blue:0.3) and (green:0.8)`
would convey a sky that was blue and green, but more green than blue.
   * @minLength 1
   * @maxLength 10000
   */
    prompt: string;
    /**
     * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
    /** Guides the image model towards a particular style. */
    style_preset?: StabilityImageGenrationUpscaleCreativeRequestStylePreset;
}

export interface StabilityImageGenrationUpscaleCreativeResponse200 {
    id: StabilityGenerationID;
}

export interface StabilityImageGenrationUpscaleCreativeResponse400 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleCreativeResponse413 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleCreativeResponse422 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleCreativeResponse429 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleCreativeResponse500 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

/**
 * Dictates the `content-type` of the generated image.
 */
export type StabilityImageGenrationUpscaleFastRequestOutputFormat =
    (typeof StabilityImageGenrationUpscaleFastRequestOutputFormat)[keyof typeof StabilityImageGenrationUpscaleFastRequestOutputFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUpscaleFastRequestOutputFormat = {
    jpeg: "jpeg",
    png: "png",
    webp: "webp",
} as const;

export interface StabilityImageGenrationUpscaleFastRequest {
    /** The image you wish to upscale.

Supported Formats:
- jpeg
- png
- webp

Validation Rules:
- Width must be between 32 and 1,536 pixels
- Height must be between 32 and 1,536 pixels
- Total pixel count must be between 1,024 and 1,048,576 pixels */
    image: Blob;
    /** Dictates the `content-type` of the generated image. */
    output_format?: StabilityImageGenrationUpscaleFastRequestOutputFormat;
}

/**
 * The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result.
 */
export type StabilityImageGenrationUpscaleFastResponse200FinishReason =
    (typeof StabilityImageGenrationUpscaleFastResponse200FinishReason)[keyof typeof StabilityImageGenrationUpscaleFastResponse200FinishReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUpscaleFastResponse200FinishReason = {
    SUCCESS: "SUCCESS",
    CONTENT_FILTERED: "CONTENT_FILTERED",
} as const;

export interface StabilityImageGenrationUpscaleFastResponse200 {
    /** The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
policy and has been blurred as a result. */
    finish_reason: StabilityImageGenrationUpscaleFastResponse200FinishReason;
    /** The generated image, encoded to base64. */
    image: string;
    /**
     * The seed used as random noise for this generation.
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
}

export interface StabilityImageGenrationUpscaleFastResponse400 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleFastResponse413 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleFastResponse422 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleFastResponse429 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

export interface StabilityImageGenrationUpscaleFastResponse500 {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
   * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
you file, as it will greatly assist us in diagnosing the root cause of the problem.
   * @minLength 1
   */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
}

/**
 * The name of your application, used to help us communicate app-specific debugging or moderation issues to you.
 * @maxLength 256
 */
export type StabilityStabilityClientID = string;

/**
 * A unique identifier for your end user. Used to help us communicate user-specific debugging or moderation issues to you. Feel free to obfuscate this value to protect user privacy.
 * @maxLength 256
 */
export type StabilityStabilityClientUserID = string;

/**
 * The version of your application, used to help us communicate version-specific debugging or moderation issues to you.
 * @maxLength 256
 */
export type StabilityStabilityClientVersion = string;

/**
 * Reason for completion
 */
export type StableAudio25AudioResponseFinishReason =
    (typeof StableAudio25AudioResponseFinishReason)[keyof typeof StableAudio25AudioResponseFinishReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StableAudio25AudioResponseFinishReason = {
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    CONTENT_FILTERED: "CONTENT_FILTERED",
} as const;

/**
 * Response from Stable Audio 2.5 audio generation
 */
export interface StableAudio25AudioResponse {
    /** Base64-encoded audio data */
    audio?: string;
    /** Reason for completion */
    finish_reason?: StableAudio25AudioResponseFinishReason;
    /** Unique identifier for the generation request */
    id?: string;
}

/**
 * Request parameters for Stable Audio audio-to-audio transformation
 */
export interface StableAudio25AudioToAudioRequest {
    /** The audio to be used as the starting point for the generation. Supported formats - mp3, wav. Audio must be between 6 and 190 seconds long. */
    audio: Blob;
    /**
     * How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt). Defaults to 7 for stable-audio-2 and 1 for stable-audio-2.5.
     * @minimum 1
     * @maximum 25
     */
    cfg_scale?: number;
    /**
     * Controls the duration in seconds of the generated audio.
     * @minimum 1
     * @maximum 190
     */
    duration?: number;
    model: StableAudio25Model;
    output_format?: StableAudio25OutputFormat;
    /**
     * What you wish the output audio to be. A strong, descriptive prompt that clearly defines instruments, moods, styles, and genre will lead to better results.
     * @maxLength 10000
     */
    prompt: string;
    /**
     * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass 0 to use a random seed.)
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
    /**
     * Controls the number of sampling steps. For stable-audio-2.5 accepts steps between 4 and 8 (defaults to 8).
     * @minimum 4
     * @maximum 8
     */
    steps?: number;
    /**
     * Controls how much influence the audio parameter has on the generated audio. A value of 0 would yield audio that is identical to the input. A value of 1 would be as if you passed in no audio at all. Minimum value for stable-audio-2.5 is 0.01.
     * @minimum 0
     * @maximum 1
     */
    strength?: number;
}

/**
 * Request parameters for Stable Audio 2.5 audio inpainting
 */
export interface StableAudio25InpaintRequest {
    /** The audio to be used as the starting point for the generation. Supported formats - mp3, wav. Audio must be between 6 and 190 seconds long. */
    audio: Blob;
    /**
     * Controls the duration in seconds of the generated audio.
     * @minimum 1
     * @maximum 190
     */
    duration?: number;
    /**
     * End time in seconds for the audio segment to be inpainted.
     * @minimum 0
     * @maximum 190
     */
    mask_end?: number;
    /**
     * Start time in seconds for the audio segment to be inpainted.
     * @minimum 0
     * @maximum 190
     */
    mask_start?: number;
    output_format?: StableAudio25OutputFormat;
    /**
     * What you wish the output audio to be. A strong, descriptive prompt that clearly defines instruments, moods, styles, and genre will lead to better results.
     * @maxLength 10000
     */
    prompt: string;
    /**
     * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass 0 to use a random seed.)
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
    /**
     * Controls the number of sampling steps.
     * @minimum 4
     * @maximum 8
     */
    steps?: number;
}

/**
 * The model to use for generation
 */
export type StableAudio25Model =
    (typeof StableAudio25Model)[keyof typeof StableAudio25Model];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StableAudio25Model = {
    "stable-audio-25": "stable-audio-2.5",
} as const;

/**
 * Dictates the content-type of the generated audio
 */
export type StableAudio25OutputFormat =
    (typeof StableAudio25OutputFormat)[keyof typeof StableAudio25OutputFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StableAudio25OutputFormat = {
    mp3: "mp3",
    wav: "wav",
} as const;

/**
 * Request parameters for Stable Audio 2.5 text-to-audio generation
 */
export interface StableAudio25TextToAudioRequest {
    /**
     * How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt). Defaults to 1 for stable-audio-2.5.
     * @minimum 1
     * @maximum 25
     */
    cfg_scale?: number;
    /**
     * Controls the duration in seconds of the generated audio.
     * @minimum 1
     * @maximum 190
     */
    duration?: number;
    model: StableAudio25Model;
    output_format?: StableAudio25OutputFormat;
    /**
     * What you wish the output audio to be. A strong, descriptive prompt that clearly defines instruments, moods, styles, and genre will lead to better results.
     * @maxLength 10000
     */
    prompt: string;
    /**
     * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass 0 to use a random seed.)
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
    /**
     * Controls the number of sampling steps. For stable-audio-2.5 accepts steps between 4 and 8 (defaults to 8).
     * @minimum 4
     * @maximum 8
     */
    steps?: number;
}

export interface StorageFile {
    /** Path to the file in storage */
    file_path?: string;
    /** Unique identifier for the storage file */
    id?: string;
    /** Public URL */
    public_url?: string;
}

export interface StripeAddress {
    /** @nullable */
    city?: string | null;
    /** @nullable */
    country?: string | null;
    /** @nullable */
    line1?: string | null;
    /** @nullable */
    line2?: string | null;
    /** @nullable */
    postal_code?: string | null;
    /** @nullable */
    state?: string | null;
}

export type StripeAmountDetailsTip = { [key: string]: unknown };

export interface StripeAmountDetails {
    tip?: StripeAmountDetailsTip;
}

/**
 * @nullable
 */
export type StripeBillingDetailsTaxId = unknown | null;

export interface StripeBillingDetails {
    address?: StripeAddress;
    /** @nullable */
    email?: string | null;
    /** @nullable */
    name?: string | null;
    /** @nullable */
    phone?: string | null;
    /** @nullable */
    tax_id?: StripeBillingDetailsTaxId;
}

/**
 * @nullable
 */
export type StripeCardDetailsAuthorizationCode = unknown | null;

/**
 * @nullable
 */
export type StripeCardDetailsChecksAddressLine1Check = unknown | null;

/**
 * @nullable
 */
export type StripeCardDetailsChecksAddressPostalCodeCheck = unknown | null;

export type StripeCardDetailsChecks = {
    /** @nullable */
    address_line1_check?: StripeCardDetailsChecksAddressLine1Check;
    /** @nullable */
    address_postal_code_check?: StripeCardDetailsChecksAddressPostalCodeCheck;
    cvc_check?: string;
};

export type StripeCardDetailsExtendedAuthorization = {
    status?: string;
};

export type StripeCardDetailsIncrementalAuthorization = {
    status?: string;
};

/**
 * @nullable
 */
export type StripeCardDetailsInstallments = unknown | null;

/**
 * @nullable
 */
export type StripeCardDetailsMandate = unknown | null;

export type StripeCardDetailsMulticapture = {
    status?: string;
};

export type StripeCardDetailsNetworkToken = {
    used?: boolean;
};

export type StripeCardDetailsOvercapture = {
    maximum_amount_capturable?: number;
    status?: string;
};

/**
 * @nullable
 */
export type StripeCardDetailsThreeDSecure = unknown | null;

/**
 * @nullable
 */
export type StripeCardDetailsWallet = unknown | null;

export interface StripeCardDetails {
    amount_authorized?: number;
    /** @nullable */
    authorization_code?: StripeCardDetailsAuthorizationCode;
    brand?: string;
    checks?: StripeCardDetailsChecks;
    country?: string;
    exp_month?: number;
    exp_year?: number;
    extended_authorization?: StripeCardDetailsExtendedAuthorization;
    fingerprint?: string;
    funding?: string;
    incremental_authorization?: StripeCardDetailsIncrementalAuthorization;
    /** @nullable */
    installments?: StripeCardDetailsInstallments;
    last4?: string;
    /** @nullable */
    mandate?: StripeCardDetailsMandate;
    multicapture?: StripeCardDetailsMulticapture;
    network?: string;
    network_token?: StripeCardDetailsNetworkToken;
    network_transaction_id?: string;
    overcapture?: StripeCardDetailsOvercapture;
    regulated_status?: string;
    /** @nullable */
    three_d_secure?: StripeCardDetailsThreeDSecure;
    /** @nullable */
    wallet?: StripeCardDetailsWallet;
}

/**
 * @nullable
 */
export type StripeChargeDestination = unknown | null;

/**
 * @nullable
 */
export type StripeChargeDispute = unknown | null;

/**
 * @nullable
 */
export type StripeChargeFailureBalanceTransaction = unknown | null;

/**
 * @nullable
 */
export type StripeChargeFailureCode = unknown | null;

/**
 * @nullable
 */
export type StripeChargeFailureMessage = unknown | null;

export type StripeChargeFraudDetails = { [key: string]: unknown };

/**
 * @nullable
 */
export type StripeChargeInvoice = unknown | null;

export type StripeChargeMetadata = { [key: string]: unknown };

export type StripeChargeObject =
    (typeof StripeChargeObject)[keyof typeof StripeChargeObject];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StripeChargeObject = {
    charge: "charge",
} as const;

/**
 * @nullable
 */
export type StripeChargeOnBehalfOf = unknown | null;

/**
 * @nullable
 */
export type StripeChargeOrder = unknown | null;

export type StripeChargeRadarOptions = { [key: string]: unknown };

/**
 * @nullable
 */
export type StripeChargeReview = unknown | null;

/**
 * @nullable
 */
export type StripeChargeSource = unknown | null;

/**
 * @nullable
 */
export type StripeChargeSourceTransfer = unknown | null;

/**
 * @nullable
 */
export type StripeChargeStatementDescriptor = unknown | null;

/**
 * @nullable
 */
export type StripeChargeStatementDescriptorSuffix = unknown | null;

/**
 * @nullable
 */
export type StripeChargeTransferData = unknown | null;

/**
 * @nullable
 */
export type StripeChargeTransferGroup = unknown | null;

export interface StripeCharge {
    amount?: number;
    amount_captured?: number;
    amount_refunded?: number;
    /** @nullable */
    application?: string | null;
    /** @nullable */
    application_fee?: string | null;
    /** @nullable */
    application_fee_amount?: number | null;
    /** @nullable */
    balance_transaction?: string | null;
    billing_details?: StripeBillingDetails;
    calculated_statement_descriptor?: string;
    captured?: boolean;
    created?: number;
    currency?: string;
    /** @nullable */
    customer?: string | null;
    /** @nullable */
    description?: string | null;
    /** @nullable */
    destination?: StripeChargeDestination;
    /** @nullable */
    dispute?: StripeChargeDispute;
    disputed?: boolean;
    /** @nullable */
    failure_balance_transaction?: StripeChargeFailureBalanceTransaction;
    /** @nullable */
    failure_code?: StripeChargeFailureCode;
    /** @nullable */
    failure_message?: StripeChargeFailureMessage;
    fraud_details?: StripeChargeFraudDetails;
    id?: string;
    /** @nullable */
    invoice?: StripeChargeInvoice;
    livemode?: boolean;
    metadata?: StripeChargeMetadata;
    object?: StripeChargeObject;
    /** @nullable */
    on_behalf_of?: StripeChargeOnBehalfOf;
    /** @nullable */
    order?: StripeChargeOrder;
    outcome?: StripeOutcome;
    paid?: boolean;
    payment_intent?: string;
    payment_method?: string;
    payment_method_details?: StripePaymentMethodDetails;
    radar_options?: StripeChargeRadarOptions;
    /** @nullable */
    receipt_email?: string | null;
    /** @nullable */
    receipt_number?: string | null;
    receipt_url?: string;
    refunded?: boolean;
    refunds?: StripeRefundList;
    /** @nullable */
    review?: StripeChargeReview;
    shipping?: StripeShipping;
    /** @nullable */
    source?: StripeChargeSource;
    /** @nullable */
    source_transfer?: StripeChargeSourceTransfer;
    /** @nullable */
    statement_descriptor?: StripeChargeStatementDescriptor;
    /** @nullable */
    statement_descriptor_suffix?: StripeChargeStatementDescriptorSuffix;
    status?: string;
    /** @nullable */
    transfer_data?: StripeChargeTransferData;
    /** @nullable */
    transfer_group?: StripeChargeTransferGroup;
}

export interface StripeChargeList {
    data?: StripeCharge[];
    has_more?: boolean;
    object?: string;
    total_count?: number;
    url?: string;
}

export type StripeEventData = {
    object?: StripePaymentIntent;
};

export type StripeEventObject =
    (typeof StripeEventObject)[keyof typeof StripeEventObject];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StripeEventObject = {
    event: "event",
} as const;

export type StripeEventType =
    (typeof StripeEventType)[keyof typeof StripeEventType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StripeEventType = {
    payment_intentsucceeded: "payment_intent.succeeded",
} as const;

export interface StripeEvent {
    api_version?: string;
    created?: number;
    data: StripeEventData;
    id: string;
    livemode?: boolean;
    object: StripeEventObject;
    pending_webhooks?: number;
    request?: StripeRequestInfo;
    type: StripeEventType;
}

/**
 * @nullable
 */
export type StripeOutcomeAdviceCode = unknown | null;

/**
 * @nullable
 */
export type StripeOutcomeNetworkAdviceCode = unknown | null;

/**
 * @nullable
 */
export type StripeOutcomeNetworkDeclineCode = unknown | null;

/**
 * @nullable
 */
export type StripeOutcomeReason = unknown | null;

export interface StripeOutcome {
    /** @nullable */
    advice_code?: StripeOutcomeAdviceCode;
    /** @nullable */
    network_advice_code?: StripeOutcomeNetworkAdviceCode;
    /** @nullable */
    network_decline_code?: StripeOutcomeNetworkDeclineCode;
    network_status?: string;
    /** @nullable */
    reason?: StripeOutcomeReason;
    risk_level?: string;
    risk_score?: number;
    seller_message?: string;
    type?: string;
}

/**
 * @nullable
 */
export type StripePaymentIntentAutomaticPaymentMethods = unknown | null;

/**
 * @nullable
 */
export type StripePaymentIntentLastPaymentError = unknown | null;

export type StripePaymentIntentMetadata = { [key: string]: unknown };

/**
 * @nullable
 */
export type StripePaymentIntentNextAction = unknown | null;

export type StripePaymentIntentObject =
    (typeof StripePaymentIntentObject)[keyof typeof StripePaymentIntentObject];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StripePaymentIntentObject = {
    payment_intent: "payment_intent",
} as const;

/**
 * @nullable
 */
export type StripePaymentIntentOnBehalfOf = unknown | null;

/**
 * @nullable
 */
export type StripePaymentIntentPaymentMethodConfigurationDetails =
    | unknown
    | null;

/**
 * @nullable
 */
export type StripePaymentIntentProcessing = unknown | null;

/**
 * @nullable
 */
export type StripePaymentIntentReview = unknown | null;

/**
 * @nullable
 */
export type StripePaymentIntentSetupFutureUsage = unknown | null;

/**
 * @nullable
 */
export type StripePaymentIntentSource = unknown | null;

/**
 * @nullable
 */
export type StripePaymentIntentStatementDescriptor = unknown | null;

/**
 * @nullable
 */
export type StripePaymentIntentStatementDescriptorSuffix = unknown | null;

/**
 * @nullable
 */
export type StripePaymentIntentTransferData = unknown | null;

/**
 * @nullable
 */
export type StripePaymentIntentTransferGroup = unknown | null;

export interface StripePaymentIntent {
    amount?: number;
    amount_capturable?: number;
    amount_details?: StripeAmountDetails;
    amount_received?: number;
    /** @nullable */
    application?: string | null;
    /** @nullable */
    application_fee_amount?: number | null;
    /** @nullable */
    automatic_payment_methods?: StripePaymentIntentAutomaticPaymentMethods;
    /** @nullable */
    canceled_at?: number | null;
    /** @nullable */
    cancellation_reason?: string | null;
    capture_method?: string;
    charges?: StripeChargeList;
    client_secret?: string;
    confirmation_method?: string;
    created?: number;
    currency?: string;
    /** @nullable */
    customer?: string | null;
    /** @nullable */
    description?: string | null;
    id?: string;
    /** @nullable */
    invoice?: string | null;
    /** @nullable */
    last_payment_error?: StripePaymentIntentLastPaymentError;
    latest_charge?: string;
    livemode?: boolean;
    metadata?: StripePaymentIntentMetadata;
    /** @nullable */
    next_action?: StripePaymentIntentNextAction;
    object?: StripePaymentIntentObject;
    /** @nullable */
    on_behalf_of?: StripePaymentIntentOnBehalfOf;
    payment_method?: string;
    /** @nullable */
    payment_method_configuration_details?: StripePaymentIntentPaymentMethodConfigurationDetails;
    payment_method_options?: StripePaymentMethodOptions;
    payment_method_types?: string[];
    /** @nullable */
    processing?: StripePaymentIntentProcessing;
    /** @nullable */
    receipt_email?: string | null;
    /** @nullable */
    review?: StripePaymentIntentReview;
    /** @nullable */
    setup_future_usage?: StripePaymentIntentSetupFutureUsage;
    shipping?: StripeShipping;
    /** @nullable */
    source?: StripePaymentIntentSource;
    /** @nullable */
    statement_descriptor?: StripePaymentIntentStatementDescriptor;
    /** @nullable */
    statement_descriptor_suffix?: StripePaymentIntentStatementDescriptorSuffix;
    status?: string;
    /** @nullable */
    transfer_data?: StripePaymentIntentTransferData;
    /** @nullable */
    transfer_group?: StripePaymentIntentTransferGroup;
}

export interface StripePaymentMethodDetails {
    card?: StripeCardDetails;
    type?: string;
}

/**
 * @nullable
 */
export type StripePaymentMethodOptionsCardInstallments = unknown | null;

/**
 * @nullable
 */
export type StripePaymentMethodOptionsCardMandateOptions = unknown | null;

/**
 * @nullable
 */
export type StripePaymentMethodOptionsCardNetwork = unknown | null;

export type StripePaymentMethodOptionsCard = {
    /** @nullable */
    installments?: StripePaymentMethodOptionsCardInstallments;
    /** @nullable */
    mandate_options?: StripePaymentMethodOptionsCardMandateOptions;
    /** @nullable */
    network?: StripePaymentMethodOptionsCardNetwork;
    request_three_d_secure?: string;
};

export interface StripePaymentMethodOptions {
    card?: StripePaymentMethodOptionsCard;
}

export type StripeRefundListDataItem = { [key: string]: unknown };

export interface StripeRefundList {
    data?: StripeRefundListDataItem[];
    has_more?: boolean;
    object?: string;
    total_count?: number;
    url?: string;
}

export interface StripeRequestInfo {
    /** @nullable */
    id?: string | null;
    /** @nullable */
    idempotency_key?: string | null;
}

export interface StripeShipping {
    address?: StripeAddress;
    /** @nullable */
    carrier?: string | null;
    name?: string;
    /** @nullable */
    phone?: string | null;
    /** @nullable */
    tracking_number?: string | null;
}

/**
 * An object specifying the format that the model must output.

Configuring `{ "type": "json_schema" }` enables Structured Outputs, 
which ensures the model will match your supplied JSON schema. Learn more in the 
[Structured Outputs guide](/docs/guides/structured-outputs).

The default format is `{ "type": "text" }` with no additional options.

**Not recommended for gpt-4o and newer models:**

Setting to `{ "type": "json_object" }` enables the older JSON mode, which
ensures the message the model generates is valid JSON. Using `json_schema`
is preferred for models that support it.

 */
export type TextResponseFormatConfiguration =
    | ResponseFormatText
    | TextResponseFormatJsonSchema
    | ResponseFormatJsonObject;

/**
 * The type of response format being defined. Always `json_schema`.
 */
export type TextResponseFormatJsonSchemaType =
    (typeof TextResponseFormatJsonSchemaType)[keyof typeof TextResponseFormatJsonSchemaType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TextResponseFormatJsonSchemaType = {
    json_schema: "json_schema",
} as const;

/**
 * JSON Schema response format. Used to generate structured JSON responses.
Learn more about [Structured Outputs](/docs/guides/structured-outputs).

 */
export interface TextResponseFormatJsonSchema {
    /** A description of what the response format is for, used by the model to
determine how to respond in the format.
 */
    description?: string;
    /** The name of the response format. Must be a-z, A-Z, 0-9, or contain
underscores and dashes, with a maximum length of 64.
 */
    name: string;
    schema: ResponseFormatJsonSchemaSchema;
    /** Whether to enable strict schema adherence when generating the output.
If set to true, the model will always follow the exact schema defined
in the `schema` field. Only a subset of JSON Schema is supported when
`strict` is `true`. To learn more, read the [Structured Outputs
guide](/docs/guides/structured-outputs).
 */
    strict?: boolean;
    /** The type of response format being defined. Always `json_schema`. */
    type: TextResponseFormatJsonSchemaType;
}

export type Tool =
    | FileSearchTool
    | FunctionTool
    | WebSearchPreviewTool
    | ComputerUsePreviewTool;

/**
 * For function calling, the type is always `function`.
 */
export type ToolChoiceFunctionType =
    (typeof ToolChoiceFunctionType)[keyof typeof ToolChoiceFunctionType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolChoiceFunctionType = {
    function: "function",
} as const;

/**
 * Use this option to force the model to call a specific function.

 */
export interface ToolChoiceFunction {
    /** The name of the function to call. */
    name: string;
    /** For function calling, the type is always `function`. */
    type: ToolChoiceFunctionType;
}

/**
 * Controls which (if any) tool is called by the model.

`none` means the model will not call any tool and instead generates a message.

`auto` means the model can pick between generating a message or calling one or
more tools.

`required` means the model must call one or more tools.

 */
export type ToolChoiceOptions =
    (typeof ToolChoiceOptions)[keyof typeof ToolChoiceOptions];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolChoiceOptions = {
    none: "none",
    auto: "auto",
    required: "required",
} as const;

/**
 * The type of hosted tool the model should to use. Learn more about
[built-in tools](/docs/guides/tools).

Allowed values are:
- `file_search`
- `web_search_preview`
- `computer_use_preview`

 */
export type ToolChoiceTypesType =
    (typeof ToolChoiceTypesType)[keyof typeof ToolChoiceTypesType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolChoiceTypesType = {
    file_search: "file_search",
    web_search_preview: "web_search_preview",
    computer_use_preview: "computer_use_preview",
    web_search_preview_2025_03_11: "web_search_preview_2025_03_11",
} as const;

/**
 * Indicates that the model should use a built-in tool to generate a response.
[Learn more about built-in tools](/docs/guides/tools).

 */
export interface ToolChoiceTypes {
    /** The type of hosted tool the model should to use. Learn more about
[built-in tools](/docs/guides/tools).

Allowed values are:
- `file_search`
- `web_search_preview`
- `computer_use_preview`
 */
    type: ToolChoiceTypesType;
}

export type TripoAnimation =
    (typeof TripoAnimation)[keyof typeof TripoAnimation];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoAnimation = {
    "preset:idle": "preset:idle",
    "preset:walk": "preset:walk",
    "preset:climb": "preset:climb",
    "preset:jump": "preset:jump",
    "preset:run": "preset:run",
    "preset:slash": "preset:slash",
    "preset:shoot": "preset:shoot",
    "preset:hurt": "preset:hurt",
    "preset:fall": "preset:fall",
    "preset:turn": "preset:turn",
} as const;

export interface TripoBalance {
    balance: number;
    frozen: number;
}

export type TripoConvertFormat =
    (typeof TripoConvertFormat)[keyof typeof TripoConvertFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoConvertFormat = {
    GLTF: "GLTF",
    USDZ: "USDZ",
    FBX: "FBX",
    OBJ: "OBJ",
    STL: "STL",
    "3MF": "3MF",
} as const;

export type TripoErrorResponseCode =
    (typeof TripoErrorResponseCode)[keyof typeof TripoErrorResponseCode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoErrorResponseCode = {
    NUMBER_1001: 1001,
    NUMBER_2000: 2000,
    NUMBER_2001: 2001,
    NUMBER_2002: 2002,
    NUMBER_2003: 2003,
    NUMBER_2004: 2004,
    NUMBER_2006: 2006,
    NUMBER_2007: 2007,
    NUMBER_2008: 2008,
    NUMBER_2010: 2010,
} as const;

export interface TripoErrorResponse {
    code: TripoErrorResponseCode;
    message: string;
    suggestion: string;
}

/**
 * Task type for Tripo image-to-model generation.
 */
export type TripoImageToModel =
    (typeof TripoImageToModel)[keyof typeof TripoImageToModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoImageToModel = {
    image_to_model: "image_to_model",
} as const;

/**
 * Style for the Tripo model generation.
 */
export type TripoModelStyle =
    (typeof TripoModelStyle)[keyof typeof TripoModelStyle];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoModelStyle = {
    "person:person2cartoon": "person:person2cartoon",
    "animal:venom": "animal:venom",
    "object:clay": "object:clay",
    "object:steampunk": "object:steampunk",
    "object:christmas": "object:christmas",
    "object:barbie": "object:barbie",
    gold: "gold",
    ancient_bronze: "ancient_bronze",
} as const;

/**
 * Version of the Tripo model.
 */
export type TripoModelVersion =
    (typeof TripoModelVersion)[keyof typeof TripoModelVersion];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoModelVersion = {
    "v25-20250123": "v2.5-20250123",
    "v20-20240919": "v2.0-20240919",
    "v14-20240625": "v1.4-20240625",
} as const;

/**
 * Mode for multiview generation, specifying view orientation.
 */
export type TripoMultiviewMode =
    (typeof TripoMultiviewMode)[keyof typeof TripoMultiviewMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoMultiviewMode = {
    LEFT: "LEFT",
    RIGHT: "RIGHT",
} as const;

/**
 * Task type for Tripo multiview-to-model generation.
 */
export type TripoMultiviewToModel =
    (typeof TripoMultiviewToModel)[keyof typeof TripoMultiviewToModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoMultiviewToModel = {
    multiview_to_model: "multiview_to_model",
} as const;

export type TripoOrientation =
    (typeof TripoOrientation)[keyof typeof TripoOrientation];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoOrientation = {
    align_image: "align_image",
    default: "default",
} as const;

/**
 * Standard success code for Tripo API responses. Typically 0 for success.
 */
export type TripoResponseSuccessCode = number;

export type TripoSpec = (typeof TripoSpec)[keyof typeof TripoSpec];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoSpec = {
    mixamo: "mixamo",
    tripo: "tripo",
} as const;

export type TripoStandardFormat =
    (typeof TripoStandardFormat)[keyof typeof TripoStandardFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoStandardFormat = {
    glb: "glb",
    fbx: "fbx",
} as const;

export type TripoStylizeOptions =
    (typeof TripoStylizeOptions)[keyof typeof TripoStylizeOptions];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoStylizeOptions = {
    lego: "lego",
    voxel: "voxel",
    voronoi: "voronoi",
    minecraft: "minecraft",
} as const;

export type TripoSuccessTaskCode =
    (typeof TripoSuccessTaskCode)[keyof typeof TripoSuccessTaskCode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoSuccessTaskCode = {
    NUMBER_0: 0,
} as const;

export type TripoSuccessTaskData = {
    /** used for getTask */
    task_id: string;
};

export interface TripoSuccessTask {
    code: TripoSuccessTaskCode;
    data: TripoSuccessTaskData;
}

export type TripoTaskInput = { [key: string]: unknown };

export type TripoTaskOutputTopology =
    (typeof TripoTaskOutputTopology)[keyof typeof TripoTaskOutputTopology];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTaskOutputTopology = {
    bip: "bip",
    quad: "quad",
} as const;

export type TripoTaskOutput = {
    base_model?: string;
    model?: string;
    pbr_model?: string;
    rendered_image?: string;
    riggable?: boolean;
    topology?: TripoTaskOutputTopology;
};

export type TripoTaskStatus =
    (typeof TripoTaskStatus)[keyof typeof TripoTaskStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTaskStatus = {
    queued: "queued",
    running: "running",
    success: "success",
    failed: "failed",
    cancelled: "cancelled",
    unknown: "unknown",
    banned: "banned",
    expired: "expired",
} as const;

export interface TripoTask {
    create_time: number;
    input: TripoTaskInput;
    output: TripoTaskOutput;
    /**
     * @minimum 0
     * @maximum 100
     */
    progress: number;
    status: TripoTaskStatus;
    task_id: string;
    type: string;
}

/**
 * The type of the Tripo task, specifically for text-to-model operations.
 */
export type TripoTextToModel =
    (typeof TripoTextToModel)[keyof typeof TripoTextToModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTextToModel = {
    text_to_model: "text_to_model",
} as const;

export type TripoTextureAlignment =
    (typeof TripoTextureAlignment)[keyof typeof TripoTextureAlignment];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTextureAlignment = {
    original_image: "original_image",
    geometry: "geometry",
} as const;

export type TripoTextureFormat =
    (typeof TripoTextureFormat)[keyof typeof TripoTextureFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTextureFormat = {
    BMP: "BMP",
    DPX: "DPX",
    HDR: "HDR",
    JPEG: "JPEG",
    OPEN_EXR: "OPEN_EXR",
    PNG: "PNG",
    TARGA: "TARGA",
    TIFF: "TIFF",
    WEBP: "WEBP",
} as const;

export type TripoTextureQuality =
    (typeof TripoTextureQuality)[keyof typeof TripoTextureQuality];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTextureQuality = {
    standard: "standard",
    detailed: "detailed",
} as const;

export type TripoTopology = (typeof TripoTopology)[keyof typeof TripoTopology];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTopology = {
    bip: "bip",
    quad: "quad",
} as const;

export type TripoTypeAnimatePrerigcheck =
    (typeof TripoTypeAnimatePrerigcheck)[keyof typeof TripoTypeAnimatePrerigcheck];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTypeAnimatePrerigcheck = {
    animate_prerigcheck: "animate_prerigcheck",
} as const;

export type TripoTypeAnimateRetarget =
    (typeof TripoTypeAnimateRetarget)[keyof typeof TripoTypeAnimateRetarget];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTypeAnimateRetarget = {
    animate_retarget: "animate_retarget",
} as const;

export type TripoTypeAnimateRig =
    (typeof TripoTypeAnimateRig)[keyof typeof TripoTypeAnimateRig];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTypeAnimateRig = {
    animate_rig: "animate_rig",
} as const;

export type TripoTypeConvertModel =
    (typeof TripoTypeConvertModel)[keyof typeof TripoTypeConvertModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTypeConvertModel = {
    convert_model: "convert_model",
} as const;

export type TripoTypeRefineModel =
    (typeof TripoTypeRefineModel)[keyof typeof TripoTypeRefineModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTypeRefineModel = {
    refine_model: "refine_model",
} as const;

export type TripoTypeStylizeModel =
    (typeof TripoTypeStylizeModel)[keyof typeof TripoTypeStylizeModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTypeStylizeModel = {
    stylize_model: "stylize_model",
} as const;

export type TripoTypeTextureModel =
    (typeof TripoTypeTextureModel)[keyof typeof TripoTypeTextureModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TripoTypeTextureModel = {
    texture_model: "texture_model",
} as const;

export interface User {
    /** The email address for this user. */
    email?: string;
    /** The unique id for this user. */
    id?: string;
    /** Indicates if the user has admin privileges. */
    isAdmin?: boolean;
    /** Indicates if the user is approved. */
    isApproved?: boolean;
    /** The name for this user. */
    name?: string;
}

export interface Veo2GenVidPollRequest {
    /** Full operation name (from predict response) */
    operationName: string;
}

/**
 * Error details if operation failed
 */
export type Veo2GenVidPollResponseError = {
    /** Error code */
    code?: number;
    /** Error message */
    message?: string;
};

export type Veo2GenVidPollResponseResponseVideosItem = {
    /** Base64-encoded video content */
    bytesBase64Encoded?: string;
    /** Cloud Storage URI of the video */
    gcsUri?: string;
    /** Video MIME type */
    mimeType?: string;
};

/**
 * The actual prediction response if done is true
 */
export type Veo2GenVidPollResponseResponse = {
    "@type"?: string;
    /** Count of media filtered by responsible AI policies */
    raiMediaFilteredCount?: number;
    /** Reasons why media was filtered by responsible AI policies */
    raiMediaFilteredReasons?: string[];
    videos?: Veo2GenVidPollResponseResponseVideosItem[];
};

export interface Veo2GenVidPollResponse {
    done?: boolean;
    /** Error details if operation failed */
    error?: Veo2GenVidPollResponseError;
    name?: string;
    /** The actual prediction response if done is true */
    response?: Veo2GenVidPollResponseResponse;
}

/**
 * Optional image to guide video generation
 */
export type Veo2GenVidRequestInstancesItemImage =
    | (unknown & {
          bytesBase64Encoded?: string;
          gcsUri?: string;
          mimeType?: string;
      })
    | (unknown & {
          bytesBase64Encoded?: string;
          gcsUri?: string;
          mimeType?: string;
      });

export type Veo2GenVidRequestInstancesItem = {
    /** Optional image to guide video generation */
    image?: Veo2GenVidRequestInstancesItemImage;
    /** Text description of the video */
    prompt: string;
};

export type Veo2GenVidRequestParametersPersonGeneration =
    (typeof Veo2GenVidRequestParametersPersonGeneration)[keyof typeof Veo2GenVidRequestParametersPersonGeneration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Veo2GenVidRequestParametersPersonGeneration = {
    ALLOW: "ALLOW",
    BLOCK: "BLOCK",
} as const;

export type Veo2GenVidRequestParameters = {
    aspectRatio?: string;
    durationSeconds?: number;
    enhancePrompt?: boolean;
    negativePrompt?: string;
    personGeneration?: Veo2GenVidRequestParametersPersonGeneration;
    sampleCount?: number;
    seed?: number;
    /** Optional Cloud Storage URI to upload the video */
    storageUri?: string;
};

export interface Veo2GenVidRequest {
    instances?: Veo2GenVidRequestInstancesItem[];
    parameters?: Veo2GenVidRequestParameters;
}

export interface Veo2GenVidResponse {
    /** Operation resource name */
    name: string;
}

export interface VeoGenVidPollRequest {
    /** Full operation name (from predict response) */
    operationName: string;
}

/**
 * Error details if operation failed
 */
export type VeoGenVidPollResponseError = {
    /** Error code */
    code?: number;
    /** Error message */
    message?: string;
};

export type VeoGenVidPollResponseResponseVideosItem = {
    /** Base64-encoded video content */
    bytesBase64Encoded?: string;
    /** Cloud Storage URI of the video */
    gcsUri?: string;
    /** Video MIME type */
    mimeType?: string;
};

/**
 * The actual prediction response if done is true
 */
export type VeoGenVidPollResponseResponse = {
    "@type"?: string;
    /** Count of media filtered by responsible AI policies */
    raiMediaFilteredCount?: number;
    /** Reasons why media was filtered by responsible AI policies */
    raiMediaFilteredReasons?: string[];
    videos?: VeoGenVidPollResponseResponseVideosItem[];
};

export interface VeoGenVidPollResponse {
    done?: boolean;
    /** Error details if operation failed */
    error?: VeoGenVidPollResponseError;
    name?: string;
    /** The actual prediction response if done is true */
    response?: VeoGenVidPollResponseResponse;
}

/**
 * Optional image to guide video generation
 */
export type VeoGenVidRequestInstancesItemImage =
    | (unknown & {
          bytesBase64Encoded?: string;
          gcsUri?: string;
          mimeType?: string;
      })
    | (unknown & {
          bytesBase64Encoded?: string;
          gcsUri?: string;
          mimeType?: string;
      });

export type VeoGenVidRequestInstancesItem = {
    /** Optional image to guide video generation */
    image?: VeoGenVidRequestInstancesItemImage;
    /** Text description of the video */
    prompt: string;
};

export type VeoGenVidRequestParametersPersonGeneration =
    (typeof VeoGenVidRequestParametersPersonGeneration)[keyof typeof VeoGenVidRequestParametersPersonGeneration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VeoGenVidRequestParametersPersonGeneration = {
    ALLOW: "ALLOW",
    BLOCK: "BLOCK",
} as const;

export type VeoGenVidRequestParameters = {
    aspectRatio?: string;
    durationSeconds?: number;
    enhancePrompt?: boolean;
    /** Generate audio for the video. Only supported by veo 3 models. */
    generateAudio?: boolean;
    negativePrompt?: string;
    personGeneration?: VeoGenVidRequestParametersPersonGeneration;
    sampleCount?: number;
    seed?: number;
    /** Optional Cloud Storage URI to upload the video */
    storageUri?: string;
};

export interface VeoGenVidRequest {
    instances?: VeoGenVidRequestInstancesItem[];
    parameters?: VeoGenVidRequestParameters;
}

export interface VeoGenVidResponse {
    /** Operation resource name */
    name: string;
}

export interface ViduCreation {
    cover_url?: string;
    id?: string;
    moderation_url?: string[];
    url?: string;
    watermarked_url?: string;
}

export interface ViduGetCreationsReply {
    creations?: ViduCreation[];
    err_code?: string;
    id?: string;
    state?: ViduState;
}

export type ViduState = (typeof ViduState)[keyof typeof ViduState];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ViduState = {
    created: "created",
    processing: "processing",
    queueing: "queueing",
    success: "success",
    failed: "failed",
} as const;

export type ViduTaskReplyMovementAmplitude =
    (typeof ViduTaskReplyMovementAmplitude)[keyof typeof ViduTaskReplyMovementAmplitude];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ViduTaskReplyMovementAmplitude = {
    auto: "auto",
    small: "small",
    medium: "medium",
    large: "large",
} as const;

export type ViduTaskReplyStyle =
    (typeof ViduTaskReplyStyle)[keyof typeof ViduTaskReplyStyle];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ViduTaskReplyStyle = {
    general: "general",
    anime: "anime",
} as const;

export interface ViduTaskReply {
    aspect_ratio?: string;
    created_at?: string;
    credits: number;
    duration?: number;
    images?: string[];
    model?: string;
    movement_amplitude?: ViduTaskReplyMovementAmplitude;
    prompt?: string;
    resolution?: string;
    seed?: number;
    state: ViduState;
    style?: ViduTaskReplyStyle;
    task_id: string;
}

export type ViduTaskRequestMovementAmplitude =
    (typeof ViduTaskRequestMovementAmplitude)[keyof typeof ViduTaskRequestMovementAmplitude];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ViduTaskRequestMovementAmplitude = {
    auto: "auto",
    small: "small",
    medium: "medium",
    large: "large",
} as const;

export type ViduTaskRequestStyle =
    (typeof ViduTaskRequestStyle)[keyof typeof ViduTaskRequestStyle];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ViduTaskRequestStyle = {
    general: "general",
    anime: "anime",
} as const;

export interface ViduTaskRequest {
    aspect_ratio?: string;
    callback_url?: string;
    duration?: number;
    enhance?: boolean;
    images?: string[];
    model?: string;
    movement_amplitude?: ViduTaskRequestMovementAmplitude;
    priority?: number;
    prompt?: string;
    resolution?: string;
    seed?: number;
    style?: ViduTaskRequestStyle;
}

/**
 * Enter basic information, such as prompt words, images, etc.
 */
export type WanImage2ImageGenerationRequestInput = {
    /**
     * Array of image URLs for image-to-image generation
     * @minItems 1
     * @maxItems 2
     */
    images: string[];
    /**
     * Reverse prompt words to describe content that you do not want to see in the image
     * @maxLength 500
     */
    negative_prompt?: string;
    /**
     * Positive prompt words to describe expected image elements and visual features. Support Chinese and English, length not exceeding 2000 characters
     * @maxLength 2000
     */
    prompt: string;
};

/**
 * The ID of the model to call for image-to-image generation
 */
export type WanImage2ImageGenerationRequestModel =
    (typeof WanImage2ImageGenerationRequestModel)[keyof typeof WanImage2ImageGenerationRequestModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WanImage2ImageGenerationRequestModel = {
    "wan25-i2i-preview": "wan2.5-i2i-preview",
} as const;

/**
 * Image processing parameters
 */
export type WanImage2ImageGenerationRequestParameters = {
    /**
     * Number of generated images. Range 1-4, default is 1
     * @minimum 1
     * @maximum 4
     */
    n?: number;
    /**
     * Random number seed to control randomness. Range [0, 2147483647]
     * @minimum 0
     * @maximum 2147483647
     */
    seed?: number;
    /** Output image resolution. Default is 1280*1280. Width and height must be between 384 and 5000 pixels. */
    size?: string;
    /** Whether to add watermark logo in lower right corner */
    watermark?: boolean;
};

export interface WanImage2ImageGenerationRequest {
    /** Enter basic information, such as prompt words, images, etc. */
    input: WanImage2ImageGenerationRequestInput;
    /** The ID of the model to call for image-to-image generation */
    model: WanImage2ImageGenerationRequestModel;
    /** Image processing parameters */
    parameters?: WanImage2ImageGenerationRequestParameters;
}

/**
 * Task status
 */
export type WanImage2ImageGenerationResponseOutputTaskStatus =
    (typeof WanImage2ImageGenerationResponseOutputTaskStatus)[keyof typeof WanImage2ImageGenerationResponseOutputTaskStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WanImage2ImageGenerationResponseOutputTaskStatus = {
    PENDING: "PENDING",
    RUNNING: "RUNNING",
    SUCCEEDED: "SUCCEEDED",
    FAILED: "FAILED",
    CANCELED: "CANCELED",
    UNKNOWN: "UNKNOWN",
} as const;

export type WanImage2ImageGenerationResponseOutput = {
    /** Task ID */
    task_id: string;
    /** Task status */
    task_status: WanImage2ImageGenerationResponseOutputTaskStatus;
};

export interface WanImage2ImageGenerationResponse {
    /** The error code for the failed request (not returned if request is successful) */
    code?: string;
    /** Detailed information about the failed request (not returned if request is successful) */
    message?: string;
    output: WanImage2ImageGenerationResponseOutput;
    /** Unique request identifier */
    request_id: string;
}

/**
 * Enter basic information, such as prompt words, etc.
 */
export type WanImageGenerationRequestInput = {
    /** Reverse prompt words to describe content that you do not want to see in the image */
    negative_prompt?: string;
    /** Positive prompt words to describe expected image elements and visual features. Support Chinese and English, length not exceeding 800 characters */
    prompt: string;
};

/**
 * The ID of the model to call for text-to-image generation
 */
export type WanImageGenerationRequestModel =
    (typeof WanImageGenerationRequestModel)[keyof typeof WanImageGenerationRequestModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WanImageGenerationRequestModel = {
    "wan25-t2i-preview": "wan2.5-t2i-preview",
} as const;

/**
 * Image processing parameters
 */
export type WanImageGenerationRequestParameters = {
    /**
     * Number of generated images. Range 1-4, default is 4
     * @minimum 1
     * @maximum 4
     */
    n?: number;
    /** Enable prompt intelligent rewriting. Default is true */
    prompt_extend?: boolean;
    /**
     * Random number seed to control randomness. Range [0, 2147483647]
     * @minimum 0
     * @maximum 2147483647
     */
    seed?: number;
    /** Output image resolution. Default is 1024*1024. Pixel range [512, 1440], up to 200 megapixels */
    size?: string;
    /** Whether to add watermark logo in lower right corner */
    watermark?: boolean;
};

export interface WanImageGenerationRequest {
    /** Enter basic information, such as prompt words, etc. */
    input: WanImageGenerationRequestInput;
    /** The ID of the model to call for text-to-image generation */
    model: WanImageGenerationRequestModel;
    /** Image processing parameters */
    parameters?: WanImageGenerationRequestParameters;
}

/**
 * Task status
 */
export type WanImageGenerationResponseOutputTaskStatus =
    (typeof WanImageGenerationResponseOutputTaskStatus)[keyof typeof WanImageGenerationResponseOutputTaskStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WanImageGenerationResponseOutputTaskStatus = {
    PENDING: "PENDING",
    RUNNING: "RUNNING",
    SUCCEEDED: "SUCCEEDED",
    FAILED: "FAILED",
    CANCELED: "CANCELED",
    UNKNOWN: "UNKNOWN",
} as const;

export type WanImageGenerationResponseOutput = {
    /** Task ID */
    task_id: string;
    /** Task status */
    task_status: WanImageGenerationResponseOutputTaskStatus;
};

export interface WanImageGenerationResponse {
    /** The error code for the failed request (not returned if request is successful) */
    code?: string;
    /** Detailed information about the failed request (not returned if request is successful) */
    message?: string;
    output: WanImageGenerationResponseOutput;
    /** Unique request identifier */
    request_id: string;
}

export type WanTaskQueryResponseOutputResultsItem = {
    /** Actual prompt after intelligent rewriting (if enabled) */
    actual_prompt?: string;
    /** Image error code (returned when some tasks fail) */
    code?: string;
    /** Image error information (returned when some tasks fail) */
    message?: string;
    /** Original input prompt */
    orig_prompt?: string;
    /** Generated image URL address */
    url?: string;
};

/**
 * Task result statistics for image generation tasks
 */
export type WanTaskQueryResponseOutputTaskMetrics = {
    /** Number of failed tasks */
    FAILED?: number;
    /** Number of successful tasks */
    SUCCEEDED?: number;
    /** Total number of tasks */
    TOTAL?: number;
};

/**
 * Task status
 */
export type WanTaskQueryResponseOutputTaskStatus =
    (typeof WanTaskQueryResponseOutputTaskStatus)[keyof typeof WanTaskQueryResponseOutputTaskStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WanTaskQueryResponseOutputTaskStatus = {
    PENDING: "PENDING",
    RUNNING: "RUNNING",
    SUCCEEDED: "SUCCEEDED",
    FAILED: "FAILED",
    CANCELED: "CANCELED",
    UNKNOWN: "UNKNOWN",
} as const;

export type WanTaskQueryResponseOutput = {
    /** Actual prompt after intelligent rewriting (for video tasks) */
    actual_prompt?: string;
    /** Audio URL for I2V tasks with audio generation */
    check_audio?: string;
    /** The error code for the failed request (not returned if request is successful) */
    code?: string;
    /** Task completion time */
    end_time?: string;
    /** Detailed information about the failed request (not returned if request is successful) */
    message?: string;
    /** Original input prompt (for video tasks) */
    orig_prompt?: string;
    /** List of task results for image generation tasks */
    results?: WanTaskQueryResponseOutputResultsItem[];
    /** Task execution time */
    scheduled_time?: string;
    /** Task submission time */
    submit_time?: string;
    /** Task ID */
    task_id: string;
    /** Task result statistics for image generation tasks */
    task_metrics?: WanTaskQueryResponseOutputTaskMetrics;
    /** Task status */
    task_status: WanTaskQueryResponseOutputTaskStatus;
    /** Video URL for completed video generation tasks. Link validity period 24 hours */
    video_url?: string;
};

/**
 * Output information statistics. Only successful results are counted
 */
export type WanTaskQueryResponseUsage = {
    /** Video resolution level (I2V tasks) */
    SR?: number;
    /** Duration of generated video in seconds (I2V tasks) */
    duration?: number;
    /** Number of generated images (T2I tasks) */
    image_count?: number;
    /** Image resolution (T2I tasks) */
    size?: string;
    /** Number of generated videos (T2V tasks) */
    video_count?: number;
    /** Duration of generated video in seconds (T2V tasks) */
    video_duration?: number;
    /** Video resolution ratio (T2V tasks) */
    video_ratio?: string;
};

export interface WanTaskQueryResponse {
    output: WanTaskQueryResponseOutput;
    /** Unique request identifier */
    request_id: string;
    /** Output information statistics. Only successful results are counted */
    usage?: WanTaskQueryResponseUsage;
}

/**
 * Enter basic information, such as prompt words, etc.
 */
export type WanVideoGenerationRequestInput = {
    /** Audio file download URL. Supported formats: mp3 and wav. */
    audio_url?: string;
    /** First frame image URL or Base64 encoded data. Required for I2V models. Image formats: JPEG, JPG, PNG, BMP, WEBP. Resolution: 360-2000 pixels. File size: max 10MB. */
    img_url?: string;
    /**
     * Reverse prompt words are used to describe content that you do not want to see in the video screen
     * @maxLength 500
     */
    negative_prompt?: string;
    /**
     * Text prompt words. Support Chinese and English, length not exceeding 800 characters
     * @maxLength 800
     */
    prompt: string;
    /** Video effect template name. Optional. Currently supported: squish, flying, carousel. When used, prompt parameter is ignored. */
    template?: string;
};

/**
 * The ID of the model to call
 */
export type WanVideoGenerationRequestModel =
    (typeof WanVideoGenerationRequestModel)[keyof typeof WanVideoGenerationRequestModel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WanVideoGenerationRequestModel = {
    "wan25-t2v-preview": "wan2.5-t2v-preview",
    "wan25-i2v-preview": "wan2.5-i2v-preview",
} as const;

/**
 * The duration of the video generated, in seconds
 */
export type WanVideoGenerationRequestParametersDuration =
    (typeof WanVideoGenerationRequestParametersDuration)[keyof typeof WanVideoGenerationRequestParametersDuration];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WanVideoGenerationRequestParametersDuration = {
    NUMBER_5: 5,
    NUMBER_10: 10,
} as const;

/**
 * Resolution level for I2V models. Supported values vary by model: 480P, 720P, 1080P
 */
export type WanVideoGenerationRequestParametersResolution =
    (typeof WanVideoGenerationRequestParametersResolution)[keyof typeof WanVideoGenerationRequestParametersResolution];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WanVideoGenerationRequestParametersResolution = {
    "480P": "480P",
    "720P": "720P",
    "1080P": "1080P",
} as const;

/**
 * Video processing parameters
 */
export type WanVideoGenerationRequestParameters = {
    /** Whether to add audio to the video */
    audio?: boolean;
    /** The duration of the video generated, in seconds */
    duration?: WanVideoGenerationRequestParametersDuration;
    /** Is it enabled prompt intelligent rewriting. Default is true */
    prompt_extend?: boolean;
    /** Resolution level for I2V models. Supported values vary by model: 480P, 720P, 1080P */
    resolution?: WanVideoGenerationRequestParametersResolution;
    /**
     * Random number seed, used to control the randomness of the model generated content
     * @minimum 0
     * @maximum 2147483647
     */
    seed?: number;
    /** Used to specify the video resolution in the format of ÂÆΩ*È´ò. Supported resolutions vary by model (for T2V models) */
    size?: string;
    /** Whether to add a watermark logo, the watermark is located in the lower right corner */
    watermark?: boolean;
};

export interface WanVideoGenerationRequest {
    /** Enter basic information, such as prompt words, etc. */
    input: WanVideoGenerationRequestInput;
    /** The ID of the model to call */
    model: WanVideoGenerationRequestModel;
    /** Video processing parameters */
    parameters?: WanVideoGenerationRequestParameters;
}

/**
 * Task status
 */
export type WanVideoGenerationResponseOutputTaskStatus =
    (typeof WanVideoGenerationResponseOutputTaskStatus)[keyof typeof WanVideoGenerationResponseOutputTaskStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WanVideoGenerationResponseOutputTaskStatus = {
    PENDING: "PENDING",
    RUNNING: "RUNNING",
    SUCCEEDED: "SUCCEEDED",
    FAILED: "FAILED",
    CANCELED: "CANCELED",
    UNKNOWN: "UNKNOWN",
} as const;

export type WanVideoGenerationResponseOutput = {
    /** Task ID */
    task_id: string;
    /** Task status */
    task_status: WanVideoGenerationResponseOutputTaskStatus;
};

export interface WanVideoGenerationResponse {
    /** The error code for the failed request (not returned if request is successful) */
    code?: string;
    /** Detailed information about the failed request (not returned if request is successful) */
    message?: string;
    output: WanVideoGenerationResponseOutput;
    /** Unique request identifier */
    request_id: string;
}

/**
 * High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default.
 */
export type WebSearchPreviewToolSearchContextSize =
    (typeof WebSearchPreviewToolSearchContextSize)[keyof typeof WebSearchPreviewToolSearchContextSize];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebSearchPreviewToolSearchContextSize = {
    low: "low",
    medium: "medium",
    high: "high",
} as const;

/**
 * The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`.
 */
export type WebSearchPreviewToolType =
    (typeof WebSearchPreviewToolType)[keyof typeof WebSearchPreviewToolType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebSearchPreviewToolType = {
    web_search_preview: "web_search_preview",
    web_search_preview_2025_03_11: "web_search_preview_2025_03_11",
} as const;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search).
 */
export interface WebSearchPreviewTool {
    /** High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default. */
    search_context_size?: WebSearchPreviewToolSearchContextSize;
    /** The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`. */
    type: WebSearchPreviewToolType;
}

/**
 * The status of the web search tool call.

 */
export type WebSearchToolCallStatus =
    (typeof WebSearchToolCallStatus)[keyof typeof WebSearchToolCallStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebSearchToolCallStatus = {
    in_progress: "in_progress",
    searching: "searching",
    completed: "completed",
    failed: "failed",
} as const;

/**
 * The type of the web search tool call. Always `web_search_call`.

 */
export type WebSearchToolCallType =
    (typeof WebSearchToolCallType)[keyof typeof WebSearchToolCallType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebSearchToolCallType = {
    web_search_call: "web_search_call",
} as const;

/**
 * The results of a web search tool call. See the 
[web search guide](/docs/guides/tools-web-search) for more information.

 */
export interface WebSearchToolCall {
    /** The unique ID of the web search tool call.
     */
    id: string;
    /** The status of the web search tool call.
     */
    status: WebSearchToolCallStatus;
    /** The type of the web search tool call. Always `web_search_call`.
     */
    type: WebSearchToolCallType;
}

export type WorkflowRunStatus =
    (typeof WorkflowRunStatus)[keyof typeof WorkflowRunStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkflowRunStatus = {
    WorkflowRunStatusStarted: "WorkflowRunStatusStarted",
    WorkflowRunStatusFailed: "WorkflowRunStatusFailed",
    WorkflowRunStatusCompleted: "WorkflowRunStatusCompleted",
} as const;

/**
 * Unique UUID for each request.
 */
export type PixverseAiTraceIdParameter = string;

export type AdminUpdateNodeVersionBody = {
    status?: NodeVersionStatus;
    /** The reason for the status change. */
    status_reason?: string;
    /** List of accelerators (e.g. CUDA, DirectML, ROCm) that this node supports */
    supported_accelerators?: string[];
    /** Supported versions of ComfyUI frontend */
    supported_comfyui_frontend_version?: string;
    /** Supported versions of ComfyUI */
    supported_comfyui_version?: string;
    /** List of operating systems that this node supports */
    supported_os?: string[];
};

export type GetBranchParams = {
    /**
     * The repo to filter by.
     */
    repo_name?: string;
};

export type GetBranch200 = {
    branches?: string[];
};

export type ComfyNodesBackfillParams = {
    max_node?: number;
};

export type SearchCustomersParams = {
    /**
     * Email address to search for
     */
    email?: string;
    /**
     * Customer name to search for
     */
    name?: string;
    /**
     * Stripe customer ID to search for
     */
    stripe_id?: string;
    /**
     * Metronome customer ID to search for\
     */
    metronome_id?: string;
    /**
     * Page number to retrieve
     */
    page?: number;
    /**
     * Number of customers to return per page
     */
    limit?: number;
};

export type SearchCustomers200 = {
    customers?: Customer[];
    /** Number of customers per page */
    limit?: number;
    /** Current page number */
    page?: number;
    /** Total number of matching customers */
    total?: number;
    /** Total number of pages available */
    totalPages?: number;
};

export type ListCustomerAPIKeys200 = {
    api_keys?: APIKey[];
};

export type CreateCustomerAPIKey201 = {
    api_key?: APIKeyWithPlaintext;
};

export type GetCustomerBalance200 = {
    /** The remaining balance in microamount (1/1,000,000 of the currency unit) */
    amount_micros: number;
    /** The currency code (e.g., "usd") */
    currency: string;
};

export type AccessBillingPortalBody = {
    /** Optional URL to redirect the customer after they're done with the billing portal */
    return_url?: string;
};

export type AccessBillingPortal200 = {
    /** The URL to redirect the customer to the billing portal */
    billing_portal_url?: string;
};

export type InitiateCreditPurchaseBody = {
    /** the amount of the checkout transaction in micro value */
    amount_micros: number;
    /** the currency used in the checkout transaction */
    currency: string;
};

export type InitiateCreditPurchase201 = {
    /** the url to redirect the customer */
    checkout_url?: string;
};

export type GetCustomerEventsParams = {
    /**
     * Page number of the nodes list
     */
    page?: number;
    /**
     * Number of nodes to return per page
     */
    limit?: number;
    /**
     * Event type to filter
     */
    filter?: string;
};

export type GetCustomerEvents200 = {
    events?: AuditLog[];
    /** Maximum number of nodes per page */
    limit?: number;
    /** Current page number */
    page?: number;
    /** Total number of events available */
    total?: number;
    /** Total number of pages available */
    totalPages?: number;
};

export type CreateCustomerStorageResourceBody = {
    /** The content type of the file (e.g., 'image/png') */
    content_type?: string;
    /** The hash of the file. If provided, an existing file with the same hash may be returned. */
    file_hash?: string;
    /** The desired name of the file (e.g., 'profile.jpg') */
    file_name: string;
};

export type GetCustomerUsage200 = {
    /** The dashboard URL for the customer's usage */
    url?: string;
};

export type GetCustomerById200 = {
    customer?: Customer;
};

export type GetCustomerBalanceById200 = {
    /** The remaining balance in microamount (1/1,000,000 of the currency unit) */
    amount_micros: number;
    /** The currency code (e.g., "usd") */
    currency: string;
};

export type GetCustomerEventsByIdParams = {
    /**
     * Page number of the nodes list
     */
    page?: number;
    /**
     * Number of nodes to return per page
     */
    limit?: number;
    /**
     * Event type to filter
     */
    filter?: string;
};

export type GetCustomerEventsById200 = {
    events?: AuditLog[];
    /** Maximum number of nodes per page */
    limit?: number;
    /** Current page number */
    page?: number;
    /** Total number of events available */
    total?: number;
    /** Total number of pages available */
    totalPages?: number;
};

export type GetGitcommitParams = {
    /**
     * The ID of the commit to fetch data for.
     */
    commitId?: string;
    /**
     * The operating system to filter the CI data by.
     */
    operatingSystem?: string;
    /**
     * The name of the workflow to filter the CI data by.
     */
    workflowName?: string;
    /**
     * The branch of the gitcommit to filter the CI data by.
     */
    branch?: string;
    /**
     * The page number to retrieve.
     */
    page?: number;
    /**
     * The number of items to include per page.
     */
    pageSize?: number;
    /**
     * The repo to filter by.
     */
    repoName?: string;
};

export type GetGitcommit200 = {
    jobResults?: ActionJobResult[];
    totalNumberOfPages?: number;
};

export type GetGitcommitsummaryParams = {
    /**
     * The repository name to filter the git commits by.
     */
    repoName?: string;
    /**
     * The branch name to filter the git commits by.
     */
    branchName?: string;
    /**
     * The page number to retrieve.
     */
    page?: number;
    /**
     * The number of items to include per page.
     */
    pageSize?: number;
};

export type GetGitcommitsummary200 = {
    commitSummaries?: GitCommitSummary[];
    totalNumberOfPages?: number;
};

export type GetGitcommitsummary500 = {
    message?: string;
};

export type ListAllNodesParams = {
    /**
     * Page number of the nodes list
     */
    page?: number;
    /**
     * Number of nodes to return per page
     */
    limit?: number;
    /**
     * Filter nodes by supported operating systems
     */
    supported_os?: string;
    /**
     * Filter nodes by supported accelerator
     */
    supported_accelerator?: string;
    /**
     * Number of nodes to return per page
     */
    include_banned?: boolean;
    /**
     * Retrieve nodes created or updated after this timestamp (ISO 8601 format)
     */
    timestamp?: string;
    /**
     * Whether to fetch fresh result from database or use cached one if false
     */
    latest?: boolean;
    /**
     * Database column to use as ascending ordering. Add `;desc` as suffix on each column for descending sort
     */
    sort?: string[];
    /**
     * node_id to use as filter
     */
    node_id?: string[];
    /**
     * Comfy UI version
     */
    comfyui_version?: string;
    /**
     * The platform requesting the nodes
     */
    form_factor?: string;
};

export type ListAllNodes200 = {
    /** Maximum number of nodes per page */
    limit?: number;
    nodes?: Node[];
    /** Current page number */
    page?: number;
    /** Total number of nodes available */
    total?: number;
    /** Total number of pages available */
    totalPages?: number;
};

export type ReindexNodesParams = {
    /**
     * Maximum number of nodes to send to algolia at a time
     */
    max_batch?: number;
};

export type SearchNodesParams = {
    /**
     * Page number of the nodes list
     */
    page?: number;
    /**
     * Number of nodes to return per page
     */
    limit?: number;
    /**
     * Keyword to search the nodes
     */
    search?: string;
    /**
     * Keyword to search the nodes by repository URL
     */
    repository_url_search?: string;
    /**
     * Keyword to search the nodes by comfy node name
     */
    comfy_node_search?: string;
    /**
     * Filter nodes by supported operating systems
     */
    supported_os?: string;
    /**
     * Filter nodes by supported accelerator
     */
    supported_accelerator?: string;
    /**
     * Number of nodes to return per page
     */
    include_banned?: boolean;
};

export type SearchNodes200 = {
    /** Maximum number of nodes per page */
    limit?: number;
    nodes?: Node[];
    /** Current page number */
    page?: number;
    /** Total number of nodes available */
    total?: number;
    /** Total number of pages available */
    totalPages?: number;
};

export type UpdateGithubStarsParams = {
    /**
     * Maximum number of nodes to update in one batch
     */
    max_batch?: number;
};

export type GetNodeParams = {
    /**
     * Whether to include the translation or not
     */
    include_translations?: boolean;
};

export type InstallNodeParams = {
    /**
     * Specific version of the node to retrieve. If omitted, the latest version is returned.
     * @pattern ^\d+\.\d+\.\d+$
     */
    version?: string;
};

export type PostNodeReviewParams = {
    /**
     * number of star given to the node version
     */
    star: number;
};

export type CreateNodeTranslationsBodyData = {
    [key: string]: { [key: string]: unknown };
};

export type CreateNodeTranslationsBody = {
    data?: CreateNodeTranslationsBodyData;
};

export type ListNodeVersionsParams = {
    statuses?: NodeVersionStatus[];
    include_status_reason?: boolean;
};

export type ListComfyNodesParams = {
    /**
     * The page number to retrieve.
     */
    page?: number;
    /**
     * The number of items to include per page.
     */
    limit?: number;
};

export type ListComfyNodes200 = {
    comfy_nodes?: ComfyNode[];
    totalNumberOfPages?: number;
};

export type CreateComfyNodesBodyNodes = { [key: string]: ComfyNode };

export type CreateComfyNodesBody = {
    cloud_build_info?: ComfyNodeCloudBuildInfo;
    nodes?: CreateComfyNodesBodyNodes;
    reason?: string;
    status?: string;
    success?: boolean;
};

export type BFLProCannyV1FluxPro10CannyPost200 =
    | BFLAsyncResponse
    | BFLAsyncWebhookResponse;

export type BFLProDepthV1FluxPro10DepthPost200 =
    | BFLAsyncResponse
    | BFLAsyncWebhookResponse;

export type BFLExpandV1FluxPro10ExpandPost200 =
    | BFLAsyncResponse
    | BFLAsyncWebhookResponse;

export type BFLFillV1FluxPro10FillPost200 =
    | BFLAsyncResponse
    | BFLAsyncWebhookResponse;

export type DummyProxyBody = {
    message?: string;
};

export type KlingQueryResourcePackagesParams = {
    /**
     * Start time for the query, Unix timestamp in ms
     */
    start_time: number;
    /**
     * End time for the query, Unix timestamp in ms
     */
    end_time: number;
    /**
     * Resource package name for precise querying of a specific package
     */
    resource_pack_name?: string;
};

export type KlingImageGenerationsQueryTaskListParams = {
    /**
     * Page number
     * @minimum 1
     * @maximum 1000
     */
    pageNum?: number;
    /**
     * Data volume per page
     * @minimum 1
     * @maximum 500
     */
    pageSize?: number;
};

export type KlingVirtualTryOnQueryTaskListParams = {
    /**
     * Page number
     * @minimum 1
     * @maximum 1000
     */
    pageNum?: number;
    /**
     * Data volume per page
     * @minimum 1
     * @maximum 500
     */
    pageSize?: number;
};

export type KlingVideoEffectsQueryTaskListParams = {
    /**
     * Page number
     * @minimum 1
     * @maximum 1000
     */
    pageNum?: number;
    /**
     * Data volume per page
     * @minimum 1
     * @maximum 500
     */
    pageSize?: number;
};

export type KlingImage2VideoQueryTaskListParams = {
    /**
     * Page number
     * @minimum 1
     * @maximum 1000
     */
    pageNum?: number;
    /**
     * Data volume per page
     * @minimum 1
     * @maximum 500
     */
    pageSize?: number;
};

export type KlingLipSyncQueryTaskListParams = {
    /**
     * Page number
     * @minimum 1
     * @maximum 1000
     */
    pageNum?: number;
    /**
     * Data volume per page
     * @minimum 1
     * @maximum 500
     */
    pageSize?: number;
};

export type KlingText2VideoQueryTaskListParams = {
    /**
     * Page number
     * @minimum 1
     * @maximum 1000
     */
    pageNum?: number;
    /**
     * Data volume per page
     * @minimum 1
     * @maximum 500
     */
    pageSize?: number;
};

export type KlingVideoExtendQueryTaskListParams = {
    /**
     * Page number
     * @minimum 1
     * @maximum 1000
     */
    pageNum?: number;
    /**
     * Data volume per page
     * @minimum 1
     * @maximum 500
     */
    pageSize?: number;
};

export type RetrieveMinimaxFileParams = {
    /**
     * Unique identifier for the file, obtained from the generation response
     */
    file_id: number;
};

export type GetMinimaxVideoGenerationParams = {
    /**
     * The task ID to be queried
     */
    task_id: string;
};

export type GetOpenAIResponseParams = {
    /**
 * Additional fields to include in the response. See the `include`
parameter for Response creation above for more information.

 */
    include?: Includable[];
};

export type PixverseUploadImageBody = {
    image?: Blob;
};

export type RecraftCrispUpscaleBody = {
    /** Image file to process */
    file: Blob;
};

export type RecraftRemoveBackgroundBody = {
    /** Image file to process */
    file: Blob;
};

export type RecraftRemoveBackground200Image = {
    /** URL of the processed image */
    url?: string;
};

export type RecraftRemoveBackground200 = {
    image?: RecraftRemoveBackground200Image;
};

export type RecraftVectorizeBody = {
    /** Image file to process */
    file: Blob;
};

/**
 * The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
  policy and has been blurred as a result.
 */
export type StabilityGetResult200OneFinishReason =
    (typeof StabilityGetResult200OneFinishReason)[keyof typeof StabilityGetResult200OneFinishReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityGetResult200OneFinishReason = {
    SUCCESS: "SUCCESS",
    CONTENT_FILTERED: "CONTENT_FILTERED",
} as const;

export type StabilityGetResult200One = {
    /** The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
  policy and has been blurred as a result. */
    finish_reason: StabilityGetResult200OneFinishReason;
    /** The generated image, encoded to base64. */
    image: string;
    /**
     * The seed used as random noise for this generation.
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
};

/**
 * The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
  policy and has been blurred as a result.
 */
export type StabilityGetResult200TwoFinishReason =
    (typeof StabilityGetResult200TwoFinishReason)[keyof typeof StabilityGetResult200TwoFinishReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityGetResult200TwoFinishReason = {
    SUCCESS: "SUCCESS",
    CONTENT_FILTERED: "CONTENT_FILTERED",
} as const;

export type StabilityGetResult200Two = {
    /** The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
  policy and has been blurred as a result. */
    finish_reason: StabilityGetResult200TwoFinishReason;
    /** The generated image, encoded to base64. */
    image: string;
    /**
     * The seed used as random noise for this generation.
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
};

/**
 * The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
  policy and has been blurred as a result.
 */
export type StabilityGetResult200ThreeFinishReason =
    (typeof StabilityGetResult200ThreeFinishReason)[keyof typeof StabilityGetResult200ThreeFinishReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityGetResult200ThreeFinishReason = {
    SUCCESS: "SUCCESS",
    CONTENT_FILTERED: "CONTENT_FILTERED",
} as const;

export type StabilityGetResult200Three = {
    /** The reason the generation finished.

- `SUCCESS` = successful generation.
- `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
  policy and has been blurred as a result. */
    finish_reason: StabilityGetResult200ThreeFinishReason;
    /** The generated image, encoded to base64. */
    image: string;
    /**
     * The seed used as random noise for this generation.
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
};

/**
 * Controls the aspect ratio of the generated image.
 */
export type StabilityImageGenrationUltraBodyAspectRatio =
    (typeof StabilityImageGenrationUltraBodyAspectRatio)[keyof typeof StabilityImageGenrationUltraBodyAspectRatio];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUltraBodyAspectRatio = {
    "21:9": "21:9",
    "16:9": "16:9",
    "3:2": "3:2",
    "5:4": "5:4",
    "1:1": "1:1",
    "4:5": "4:5",
    "2:3": "2:3",
    "9:16": "9:16",
    "9:21": "9:21",
} as const;

/**
 * Dictates the `content-type` of the generated image.
 */
export type StabilityImageGenrationUltraBodyOutputFormat =
    (typeof StabilityImageGenrationUltraBodyOutputFormat)[keyof typeof StabilityImageGenrationUltraBodyOutputFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUltraBodyOutputFormat = {
    jpeg: "jpeg",
    png: "png",
    webp: "webp",
} as const;

/**
 * Guides the image model towards a particular style.
 */
export type StabilityImageGenrationUltraBodyStylePreset =
    (typeof StabilityImageGenrationUltraBodyStylePreset)[keyof typeof StabilityImageGenrationUltraBodyStylePreset];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUltraBodyStylePreset = {
    enhance: "enhance",
    anime: "anime",
    photographic: "photographic",
    "digital-art": "digital-art",
    "comic-book": "comic-book",
    "fantasy-art": "fantasy-art",
    "line-art": "line-art",
    "analog-film": "analog-film",
    "neon-punk": "neon-punk",
    isometric: "isometric",
    "low-poly": "low-poly",
    origami: "origami",
    "modeling-compound": "modeling-compound",
    cinematic: "cinematic",
    "3d-model": "3d-model",
    "pixel-art": "pixel-art",
    "tile-texture": "tile-texture",
} as const;

export type StabilityImageGenrationUltraBody = {
    /** Controls the aspect ratio of the generated image. */
    aspect_ratio?: StabilityImageGenrationUltraBodyAspectRatio;
    /** The image to use as the starting point for the generation. > **Important:** The `strength` parameter is required when `image` is provided. Supported Formats: - jpeg - png - webp Validation Rules: - Width must be between 64 and 16,384 pixels - Height must be between 64 and 16,384 pixels - Total pixel count must be at least 4,096 pixels */
    image?: Blob;
    /**
     * A blurb of text describing what you **do not** wish to see in the output image. This is an advanced feature.
     * @maxLength 10000
     */
    negative_prompt?: string;
    /** Dictates the `content-type` of the generated image. */
    output_format?: StabilityImageGenrationUltraBodyOutputFormat;
    /**
     * What you wish to see in the output image. A strong, descriptive prompt that clearly defines elements, colors, and subjects will lead to better results. To control the weight of a given word use the format `(word:weight)`, where `word` is the word you'd like to control the weight of and `weight` is a value between 0 and 1. For example: `The sky was a crisp (blue:0.3) and (green:0.8)` would convey a sky that was blue and green, but more green than blue.
     * @minLength 1
     * @maxLength 10000
     */
    prompt: string;
    /**
     * A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
    /**
   * Sometimes referred to as _denoising_, this parameter controls how much influence the 
`image` parameter has on the generated image.  A value of 0 would yield an image that 
is identical to the input.  A value of 1 would be as if you passed in no image at all.

> **Important:** This parameter is required when `image` is provided.
   * @minimum 0
   * @maximum 1
   */
    strength?: number;
    /** Guides the image model towards a particular style. */
    style_preset?: StabilityImageGenrationUltraBodyStylePreset;
};

/**
 * The reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result.
 */
export type StabilityImageGenrationUltra200OneFinishReason =
    (typeof StabilityImageGenrationUltra200OneFinishReason)[keyof typeof StabilityImageGenrationUltra200OneFinishReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUltra200OneFinishReason = {
    SUCCESS: "SUCCESS",
    CONTENT_FILTERED: "CONTENT_FILTERED",
} as const;

export type StabilityImageGenrationUltra200One = {
    /** The reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result. */
    finish_reason: StabilityImageGenrationUltra200OneFinishReason;
    /** The generated image, encoded to base64. */
    image: string;
    /**
     * The seed used as random noise for this generation.
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
};

/**
 * The reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result.
 */
export type StabilityImageGenrationUltra200TwoFinishReason =
    (typeof StabilityImageGenrationUltra200TwoFinishReason)[keyof typeof StabilityImageGenrationUltra200TwoFinishReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUltra200TwoFinishReason = {
    SUCCESS: "SUCCESS",
    CONTENT_FILTERED: "CONTENT_FILTERED",
} as const;

export type StabilityImageGenrationUltra200Two = {
    /** The reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result. */
    finish_reason: StabilityImageGenrationUltra200TwoFinishReason;
    /** The generated image, encoded to base64. */
    image: string;
    /**
     * The seed used as random noise for this generation.
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
};

/**
 * The reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result.
 */
export type StabilityImageGenrationUltra200ThreeFinishReason =
    (typeof StabilityImageGenrationUltra200ThreeFinishReason)[keyof typeof StabilityImageGenrationUltra200ThreeFinishReason];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StabilityImageGenrationUltra200ThreeFinishReason = {
    SUCCESS: "SUCCESS",
    CONTENT_FILTERED: "CONTENT_FILTERED",
} as const;

export type StabilityImageGenrationUltra200Three = {
    /** The reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result. */
    finish_reason: StabilityImageGenrationUltra200ThreeFinishReason;
    /** The generated image, encoded to base64. */
    image: string;
    /**
     * The seed used as random noise for this generation.
     * @minimum 0
     * @maximum 4294967294
     */
    seed?: number;
};

export type StabilityImageGenrationUltra400 = {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
     * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
     * @minLength 1
     */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
};

export type StabilityImageGenrationUltra413 = {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
     * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
     * @minLength 1
     */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
};

export type StabilityImageGenrationUltra422 = {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
     * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
     * @minLength 1
     */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
};

export type StabilityImageGenrationUltra429 = {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
     * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
     * @minLength 1
     */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
};

export type StabilityImageGenrationUltra500 = {
    /**
     * One or more error messages indicating what went wrong.
     * @minItems 1
     */
    errors: string[];
    /**
     * A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
     * @minLength 1
     */
    id: string;
    /**
     * Short-hand name for an error, useful for discriminating between errors with the same status code.
     * @minLength 1
     */
    name: string;
};

export type TripoCreateTaskBodyOneOf = {
    auto_size?: boolean;
    face_limit?: number;
    model_seed?: number;
    model_version?: TripoModelVersion;
    /** @maxLength 1024 */
    negative_prompt?: string;
    pbr?: boolean;
    /** @maxLength 1024 */
    prompt: string;
    quad?: boolean;
    style?: TripoModelStyle;
    text_seed?: number;
    texture?: boolean;
    texture_quality?: TripoTextureQuality;
    texture_seed?: number;
    type: TripoTextToModel;
};

export type TripoCreateTaskBodyOneOfTwoFile = {
    file_token: string;
    type: string;
};

export type TripoCreateTaskBodyOneOfTwo = {
    auto_size?: boolean;
    face_limit?: number;
    file: TripoCreateTaskBodyOneOfTwoFile;
    model_seed?: number;
    model_version?: TripoModelVersion;
    orientation?: TripoOrientation;
    pbr?: boolean;
    quad?: boolean;
    style?: TripoModelStyle;
    texture?: boolean;
    texture_alignment?: TripoTextureAlignment;
    texture_quality?: TripoTextureQuality;
    texture_seed?: number;
    type: TripoImageToModel;
};

export type TripoCreateTaskBodyOneOfFourFilesItem = {
    file_token: string;
    type: string;
};

export type TripoCreateTaskBodyOneOfFour = {
    auto_size?: boolean;
    face_limit?: number;
    files: TripoCreateTaskBodyOneOfFourFilesItem[];
    mode?: TripoMultiviewMode;
    model_seed?: number;
    model_version?: TripoModelVersion;
    orientation?: TripoOrientation;
    orthographic_projection?: boolean;
    pbr?: boolean;
    quad?: boolean;
    texture?: boolean;
    texture_alignment?: TripoTextureAlignment;
    texture_quality?: TripoTextureQuality;
    texture_seed?: number;
    type: TripoMultiviewToModel;
};

export type TripoCreateTaskBodyOneOfSix = {
    model_seed?: number;
    original_model_task_id: string;
    pbr?: boolean;
    texture?: boolean;
    texture_alignment?: TripoTextureAlignment;
    texture_quality?: TripoTextureQuality;
    texture_seed?: number;
    type: TripoTypeTextureModel;
};

export type TripoCreateTaskBodyOneOfSeven = {
    draft_model_task_id: string;
    type: TripoTypeRefineModel;
};

export type TripoCreateTaskBodyOneOfEight = {
    original_model_task_id: string;
    type: TripoTypeAnimatePrerigcheck;
};

export type TripoCreateTaskBodyOneOfNine = {
    original_model_task_id: string;
    out_format?: TripoStandardFormat;
    spec?: TripoSpec;
    topology?: TripoTopology;
    type: TripoTypeAnimateRig;
};

export type TripoCreateTaskBodyOneOfOnezero = {
    animation: TripoAnimation;
    bake_animation?: boolean;
    original_model_task_id: string;
    out_format?: TripoStandardFormat;
    type: TripoTypeAnimateRetarget;
};

export type TripoCreateTaskBodyOneOfOneone = {
    block_size?: number;
    original_model_task_id: string;
    style: TripoStylizeOptions;
    type: TripoTypeStylizeModel;
};

export type TripoCreateTaskBodyOneOfOnetwo = {
    face_limit?: number;
    flatten_bottom?: boolean;
    flatten_bottom_threshold?: number;
    force_symmetry?: boolean;
    format: TripoConvertFormat;
    original_model_task_id: string;
    pivot_to_center_bottom?: boolean;
    quad?: boolean;
    texture_format?: TripoTextureFormat;
    texture_size?: number;
    type: TripoTypeConvertModel;
};

export type TripoCreateTaskBody =
    | TripoCreateTaskBodyOneOf
    | TripoCreateTaskBodyOneOfTwo
    | TripoCreateTaskBodyOneOfFour
    | TripoCreateTaskBodyOneOfSix
    | TripoCreateTaskBodyOneOfSeven
    | TripoCreateTaskBodyOneOfEight
    | TripoCreateTaskBodyOneOfNine
    | TripoCreateTaskBodyOneOfOnezero
    | TripoCreateTaskBodyOneOfOneone
    | TripoCreateTaskBodyOneOfOnetwo;

export type TripoGetTask200 = {
    code: TripoResponseSuccessCode;
    data: TripoTask;
};

export type TripoUploadFileBody = {
    file: Blob;
};

export type TripoUploadFile200Data = {
    image_token: string;
};

export type TripoUploadFile200 = {
    code: TripoResponseSuccessCode;
    data: TripoUploadFile200Data;
};

export type TripoGetBalance200 = {
    code: TripoResponseSuccessCode;
    data: TripoBalance;
};

export type ValidatePublisherParams = {
    /**
     * The publisher username to validate.
     */
    username: string;
};

export type ValidatePublisher200 = {
    /** True if the username is available, false otherwise. */
    isAvailable?: boolean;
};

export type ListNodesForPublisherParams = {
    /**
     * Number of nodes to return per page
     */
    include_banned?: boolean;
};

export type ListNodesForPublisherV2Params = {
    /**
     * Number of nodes to return per page
     */
    include_banned?: boolean;
    /**
     * Page number of the nodes list
     */
    page?: number;
    /**
     * Number of nodes to return per page
     */
    limit?: number;
};

export type ListNodesForPublisherV2200 = {
    /** Maximum number of nodes per page */
    limit?: number;
    nodes?: Node[];
    /** Current page number */
    page?: number;
    /** Total number of nodes available */
    total?: number;
    /** Total number of pages available */
    totalPages?: number;
};

export type GetPermissionOnPublisherNodes200 = {
    canEdit?: boolean;
};

export type PublishNodeVersionBody = {
    node: Node;
    node_version: NodeVersion;
    personal_access_token: string;
};

export type PublishNodeVersion201 = {
    node_version?: NodeVersion;
    /** The signed URL to upload the node version token. */
    signedUrl?: string;
};

export type GetPermissionOnPublisher200 = {
    canEdit?: boolean;
};

export type CreatePersonalAccessToken201 = {
    /** The newly created personal access token. */
    token?: string;
};

export type GetReleaseNotesParams = {
    /**
     * The project to get release notes for
     */
    project: GetReleaseNotesProject;
    /**
     * The current version to filter release notes
     */
    current_version?: string;
    /**
     * The locale for the release notes
     */
    locale?: GetReleaseNotesLocale;
    /**
     * The platform requesting the release notes
     */
    form_factor?: string;
};

export type GetReleaseNotesProject =
    (typeof GetReleaseNotesProject)[keyof typeof GetReleaseNotesProject];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseNotesProject = {
    comfyui: "comfyui",
    comfyui_frontend: "comfyui_frontend",
    desktop: "desktop",
} as const;

export type GetReleaseNotesLocale =
    (typeof GetReleaseNotesLocale)[keyof typeof GetReleaseNotesLocale];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseNotesLocale = {
    en: "en",
    es: "es",
    fr: "fr",
    ja: "ja",
    ko: "ko",
    ru: "ru",
    zh: "zh",
} as const;

export type SecurityScanParams = {
    minAge?: string;
    minSecurityScanAge?: string;
    maxNodes?: number;
};

export type PostUploadArtifactBody = {
    /** The author of the commit */
    author: string;
    /** The average amount of VRAM used in the run. */
    avg_vram?: number;
    branch_name: string;
    /** The name of the bucket where the output files are stored */
    bucket_name?: string;
    /** The path to ComfyUI logs. eg. gs://bucket-name/logs */
    comfy_logs_gcs_path?: string;
    /** The flags used in the comfy run */
    comfy_run_flags?: string;
    commit_hash: string;
    /** The commit message */
    commit_message: string;
    /** The time of the commit in the format of "YYYY-MM-DDTHH:MM:SSZ" (2016-10-10T00:00:00Z) */
    commit_time: string;
    /** Cuda version. */
    cuda_version?: string;
    /** The end time of the job as a Unix timestamp. */
    end_time: number;
    /** Unique identifier for the job */
    job_id: string;
    /** The user who triggered the job */
    job_trigger_user: string;
    machine_stats?: MachineStats;
    /** Operating system used in the run */
    os: string;
    /** A comma separated string that contains GCS path(s) to output files. eg. gs://bucket-name/output, gs://bucket-name/output2 */
    output_files_gcs_paths?: string;
    /** The peak amount of VRAM used in the run. */
    peak_vram?: number;
    /** The pull request number */
    pr_number: string;
    /** The python version used in the run */
    python_version: string;
    /** The pytorch version used in the run */
    pytorch_version?: string;
    /** Repository name */
    repo: string;
    /** Unique identifier for the run */
    run_id: string;
    /** The start time of the job as a Unix timestamp. */
    start_time: number;
    status: WorkflowRunStatus;
    /** The name of the workflow */
    workflow_name: string;
};

export type PostUploadArtifact200 = {
    message?: string;
};

export type ListAllNodeVersionsParams = {
    nodeId?: string;
    statuses?: NodeVersionStatus[];
    include_status_reason?: boolean;
    /**
     * The page number to retrieve.
     */
    page?: number;
    /**
     * The number of items to include per page.
     */
    pageSize?: number;
    /**
     * search for status_reason, case insensitive
     */
    status_reason?: string;
};

export type ListAllNodeVersions200 = {
    /** Current page number */
    page?: number;
    /** Maximum number of node versions per page. Maximum is 100. */
    pageSize?: number;
    /** Total number of node versions available */
    total?: number;
    /** Total number of pages available */
    totalPages?: number;
    versions?: NodeVersion[];
};

export type MetronomeZeroBalanceBodyProperties = {
    /** the metronome customer id */
    customer_id?: string;
    /** the customer remaining balance */
    remaining_balance?: number;
};

export type MetronomeZeroBalanceBody = {
    /** the id of the webhook */
    id: string;
    properties: MetronomeZeroBalanceBodyProperties;
    /** the type of the webhook */
    type: string;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Create a new custom node using admin priviledge
 */
export const adminCreateNode = (
    node: Node,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Node>(
        {
            url: `/admin/nodes`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: node,
            signal,
        },
        options,
    );
};

export const getAdminCreateNodeMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof adminCreateNode>>,
        TError,
        { data: Node },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof adminCreateNode>>,
    TError,
    { data: Node },
    TContext
> => {
    const mutationKey = ["adminCreateNode"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof adminCreateNode>>,
        { data: Node }
    > = (props) => {
        const { data } = props ?? {};

        return adminCreateNode(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type AdminCreateNodeMutationResult = NonNullable<
    Awaited<ReturnType<typeof adminCreateNode>>
>;
export type AdminCreateNodeMutationBody = Node;
export type AdminCreateNodeMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Create a new custom node using admin priviledge
 */
export const useAdminCreateNode = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof adminCreateNode>>,
            TError,
            { data: Node },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof adminCreateNode>>,
    TError,
    { data: Node },
    TContext
> => {
    const mutationOptions = getAdminCreateNodeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Only admins can update a node with admin privileges.
 * @summary Admin Update Node
 */
export const adminUpdateNode = (
    nodeId: string,
    node: Node,
    options?: SecondParameter<typeof customInstance>,
) => {
    return customInstance<Node>(
        {
            url: `/admin/nodes/${nodeId}`,
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            data: node,
        },
        options,
    );
};

export const getAdminUpdateNodeMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof adminUpdateNode>>,
        TError,
        { nodeId: string; data: Node },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof adminUpdateNode>>,
    TError,
    { nodeId: string; data: Node },
    TContext
> => {
    const mutationKey = ["adminUpdateNode"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof adminUpdateNode>>,
        { nodeId: string; data: Node }
    > = (props) => {
        const { nodeId, data } = props ?? {};

        return adminUpdateNode(nodeId, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type AdminUpdateNodeMutationResult = NonNullable<
    Awaited<ReturnType<typeof adminUpdateNode>>
>;
export type AdminUpdateNodeMutationBody = Node;
export type AdminUpdateNodeMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Admin Update Node
 */
export const useAdminUpdateNode = <
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof adminUpdateNode>>,
            TError,
            { nodeId: string; data: Node },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof adminUpdateNode>>,
    TError,
    { nodeId: string; data: Node },
    TContext
> => {
    const mutationOptions = getAdminUpdateNodeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Only admins can approve a node version.
 * @summary Admin Update Node Version Status
 */
export const adminUpdateNodeVersion = (
    nodeId: string,
    versionNumber: string,
    adminUpdateNodeVersionBody: AdminUpdateNodeVersionBody,
    options?: SecondParameter<typeof customInstance>,
) => {
    return customInstance<NodeVersion>(
        {
            url: `/admin/nodes/${nodeId}/versions/${versionNumber}`,
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            data: adminUpdateNodeVersionBody,
        },
        options,
    );
};

export const getAdminUpdateNodeVersionMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof adminUpdateNodeVersion>>,
        TError,
        {
            nodeId: string;
            versionNumber: string;
            data: AdminUpdateNodeVersionBody;
        },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof adminUpdateNodeVersion>>,
    TError,
    { nodeId: string; versionNumber: string; data: AdminUpdateNodeVersionBody },
    TContext
> => {
    const mutationKey = ["adminUpdateNodeVersion"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof adminUpdateNodeVersion>>,
        {
            nodeId: string;
            versionNumber: string;
            data: AdminUpdateNodeVersionBody;
        }
    > = (props) => {
        const { nodeId, versionNumber, data } = props ?? {};

        return adminUpdateNodeVersion(
            nodeId,
            versionNumber,
            data,
            requestOptions,
        );
    };

    return { mutationFn, ...mutationOptions };
};

export type AdminUpdateNodeVersionMutationResult = NonNullable<
    Awaited<ReturnType<typeof adminUpdateNodeVersion>>
>;
export type AdminUpdateNodeVersionMutationBody = AdminUpdateNodeVersionBody;
export type AdminUpdateNodeVersionMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Admin Update Node Version Status
 */
export const useAdminUpdateNodeVersion = <
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof adminUpdateNodeVersion>>,
            TError,
            {
                nodeId: string;
                versionNumber: string;
                data: AdminUpdateNodeVersionBody;
            },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof adminUpdateNodeVersion>>,
    TError,
    { nodeId: string; versionNumber: string; data: AdminUpdateNodeVersionBody },
    TContext
> => {
    const mutationOptions = getAdminUpdateNodeVersionMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Returns all branches for a given repo.
 * @summary Retrieve all distinct branches for a given repo
 */
export const getBranch = (
    params: GetBranchParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetBranch200>(
        { url: `/branch`, method: "GET", params, signal },
        options,
    );
};

export const getGetBranchQueryKey = (params?: GetBranchParams) => {
    return [`/branch`, ...(params ? [params] : [])] as const;
};

export const getGetBranchQueryOptions = <
    TData = Awaited<ReturnType<typeof getBranch>>,
    TError = void | void,
>(
    params: GetBranchParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getBranch>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetBranchQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranch>>> = ({
        signal,
    }) => getBranch(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getBranch>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBranchQueryResult = NonNullable<
    Awaited<ReturnType<typeof getBranch>>
>;
export type GetBranchQueryError = void | void;

export function useGetBranch<
    TData = Awaited<ReturnType<typeof getBranch>>,
    TError = void | void,
>(
    params: GetBranchParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getBranch>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getBranch>>,
                    TError,
                    Awaited<ReturnType<typeof getBranch>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBranch<
    TData = Awaited<ReturnType<typeof getBranch>>,
    TError = void | void,
>(
    params: GetBranchParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getBranch>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getBranch>>,
                    TError,
                    Awaited<ReturnType<typeof getBranch>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBranch<
    TData = Awaited<ReturnType<typeof getBranch>>,
    TError = void | void,
>(
    params: GetBranchParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getBranch>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve all distinct branches for a given repo
 */

export function useGetBranch<
    TData = Awaited<ReturnType<typeof getBranch>>,
    TError = void | void,
>(
    params: GetBranchParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getBranch>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetBranchQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Retrieve multiple node versions in a single request
 */
export const getBulkNodeVersions = (
    bulkNodeVersionsRequest: BulkNodeVersionsRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BulkNodeVersionsResponse>(
        {
            url: `/bulk/nodes/versions`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: bulkNodeVersionsRequest,
            signal,
        },
        options,
    );
};

export const getGetBulkNodeVersionsMutationOptions = <
    TError = ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof getBulkNodeVersions>>,
        TError,
        { data: BulkNodeVersionsRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof getBulkNodeVersions>>,
    TError,
    { data: BulkNodeVersionsRequest },
    TContext
> => {
    const mutationKey = ["getBulkNodeVersions"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof getBulkNodeVersions>>,
        { data: BulkNodeVersionsRequest }
    > = (props) => {
        const { data } = props ?? {};

        return getBulkNodeVersions(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type GetBulkNodeVersionsMutationResult = NonNullable<
    Awaited<ReturnType<typeof getBulkNodeVersions>>
>;
export type GetBulkNodeVersionsMutationBody = BulkNodeVersionsRequest;
export type GetBulkNodeVersionsMutationError = ErrorResponse | ErrorResponse;

/**
 * @summary Retrieve multiple node versions in a single request
 */
export const useGetBulkNodeVersions = <
    TError = ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof getBulkNodeVersions>>,
            TError,
            { data: BulkNodeVersionsRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof getBulkNodeVersions>>,
    TError,
    { data: BulkNodeVersionsRequest },
    TContext
> => {
    const mutationOptions = getGetBulkNodeVersionsMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary trigger comfy nodes backfill
 */
export const comfyNodesBackfill = (
    params?: ComfyNodesBackfillParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        { url: `/comfy-nodes/backfill`, method: "POST", params, signal },
        options,
    );
};

export const getComfyNodesBackfillMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof comfyNodesBackfill>>,
        TError,
        { params?: ComfyNodesBackfillParams },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof comfyNodesBackfill>>,
    TError,
    { params?: ComfyNodesBackfillParams },
    TContext
> => {
    const mutationKey = ["comfyNodesBackfill"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof comfyNodesBackfill>>,
        { params?: ComfyNodesBackfillParams }
    > = (props) => {
        const { params } = props ?? {};

        return comfyNodesBackfill(params, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ComfyNodesBackfillMutationResult = NonNullable<
    Awaited<ReturnType<typeof comfyNodesBackfill>>
>;

export type ComfyNodesBackfillMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary trigger comfy nodes backfill
 */
export const useComfyNodesBackfill = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof comfyNodesBackfill>>,
            TError,
            { params?: ComfyNodesBackfillParams },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof comfyNodesBackfill>>,
    TError,
    { params?: ComfyNodesBackfillParams },
    TContext
> => {
    const mutationOptions = getComfyNodesBackfillMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the node that contains a ComfyUI node with the specified name
 * @summary Retrieve a node by ComfyUI node name
 */
export const getNodeByComfyNodeName = (
    comfyNodeName: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Node>(
        { url: `/comfy-nodes/${comfyNodeName}/node`, method: "GET", signal },
        options,
    );
};

export const getGetNodeByComfyNodeNameQueryKey = (comfyNodeName?: string) => {
    return [`/comfy-nodes/${comfyNodeName}/node`] as const;
};

export const getGetNodeByComfyNodeNameQueryOptions = <
    TData = Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
    TError = ErrorResponse | ErrorResponse,
>(
    comfyNodeName: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getGetNodeByComfyNodeNameQueryKey(comfyNodeName);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getNodeByComfyNodeName>>
    > = ({ signal }) =>
        getNodeByComfyNodeName(comfyNodeName, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!comfyNodeName,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNodeByComfyNodeNameQueryResult = NonNullable<
    Awaited<ReturnType<typeof getNodeByComfyNodeName>>
>;
export type GetNodeByComfyNodeNameQueryError = ErrorResponse | ErrorResponse;

export function useGetNodeByComfyNodeName<
    TData = Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
    TError = ErrorResponse | ErrorResponse,
>(
    comfyNodeName: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
                    TError,
                    Awaited<ReturnType<typeof getNodeByComfyNodeName>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNodeByComfyNodeName<
    TData = Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
    TError = ErrorResponse | ErrorResponse,
>(
    comfyNodeName: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
                    TError,
                    Awaited<ReturnType<typeof getNodeByComfyNodeName>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNodeByComfyNodeName<
    TData = Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
    TError = ErrorResponse | ErrorResponse,
>(
    comfyNodeName: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve a node by ComfyUI node name
 */

export function useGetNodeByComfyNodeName<
    TData = Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
    TError = ErrorResponse | ErrorResponse,
>(
    comfyNodeName: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getNodeByComfyNodeName>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetNodeByComfyNodeNameQueryOptions(
        comfyNodeName,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Search for customers by email, name, Stripe ID, or Metronome ID.
 * @summary Search for customers
 */
export const searchCustomers = (
    params?: SearchCustomersParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<SearchCustomers200>(
        { url: `/customers`, method: "GET", params, signal },
        options,
    );
};

export const getSearchCustomersQueryKey = (params?: SearchCustomersParams) => {
    return [`/customers`, ...(params ? [params] : [])] as const;
};

export const getSearchCustomersQueryOptions = <
    TData = Awaited<ReturnType<typeof searchCustomers>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    params?: SearchCustomersParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof searchCustomers>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getSearchCustomersQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof searchCustomers>>
    > = ({ signal }) => searchCustomers(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof searchCustomers>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchCustomersQueryResult = NonNullable<
    Awaited<ReturnType<typeof searchCustomers>>
>;
export type SearchCustomersQueryError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse;

export function useSearchCustomers<
    TData = Awaited<ReturnType<typeof searchCustomers>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    params: undefined | SearchCustomersParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof searchCustomers>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof searchCustomers>>,
                    TError,
                    Awaited<ReturnType<typeof searchCustomers>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchCustomers<
    TData = Awaited<ReturnType<typeof searchCustomers>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    params?: SearchCustomersParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof searchCustomers>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof searchCustomers>>,
                    TError,
                    Awaited<ReturnType<typeof searchCustomers>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchCustomers<
    TData = Awaited<ReturnType<typeof searchCustomers>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    params?: SearchCustomersParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof searchCustomers>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Search for customers
 */

export function useSearchCustomers<
    TData = Awaited<ReturnType<typeof searchCustomers>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    params?: SearchCustomersParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof searchCustomers>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getSearchCustomersQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Creates a new customer using the provided token. No request body is needed as user information is extracted from the token.
 * @summary Create a new customer
 */
export const createCustomer = (
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Customer | Customer>(
        { url: `/customers`, method: "POST", signal },
        options,
    );
};

export const getCreateCustomerMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createCustomer>>,
        TError,
        void,
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createCustomer>>,
    TError,
    void,
    TContext
> => {
    const mutationKey = ["createCustomer"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createCustomer>>,
        void
    > = () => {
        return createCustomer(requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateCustomerMutationResult = NonNullable<
    Awaited<ReturnType<typeof createCustomer>>
>;

export type CreateCustomerMutationError = ErrorResponse | void | ErrorResponse;

/**
 * @summary Create a new customer
 */
export const useCreateCustomer = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createCustomer>>,
            TError,
            void,
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createCustomer>>,
    TError,
    void,
    TContext
> => {
    const mutationOptions = getCreateCustomerMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary List all API keys for a customer
 */
export const listCustomerAPIKeys = (
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ListCustomerAPIKeys200>(
        { url: `/customers/api-keys`, method: "GET", signal },
        options,
    );
};

export const getListCustomerAPIKeysQueryKey = () => {
    return [`/customers/api-keys`] as const;
};

export const getListCustomerAPIKeysQueryOptions = <
    TData = Awaited<ReturnType<typeof listCustomerAPIKeys>>,
    TError = void | void | ErrorResponse,
>(options?: {
    query?: Partial<
        UseQueryOptions<
            Awaited<ReturnType<typeof listCustomerAPIKeys>>,
            TError,
            TData
        >
    >;
    request?: SecondParameter<typeof customInstance>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getListCustomerAPIKeysQueryKey();

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof listCustomerAPIKeys>>
    > = ({ signal }) => listCustomerAPIKeys(requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof listCustomerAPIKeys>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListCustomerAPIKeysQueryResult = NonNullable<
    Awaited<ReturnType<typeof listCustomerAPIKeys>>
>;
export type ListCustomerAPIKeysQueryError = void | void | ErrorResponse;

export function useListCustomerAPIKeys<
    TData = Awaited<ReturnType<typeof listCustomerAPIKeys>>,
    TError = void | void | ErrorResponse,
>(
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listCustomerAPIKeys>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listCustomerAPIKeys>>,
                    TError,
                    Awaited<ReturnType<typeof listCustomerAPIKeys>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListCustomerAPIKeys<
    TData = Awaited<ReturnType<typeof listCustomerAPIKeys>>,
    TError = void | void | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listCustomerAPIKeys>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listCustomerAPIKeys>>,
                    TError,
                    Awaited<ReturnType<typeof listCustomerAPIKeys>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListCustomerAPIKeys<
    TData = Awaited<ReturnType<typeof listCustomerAPIKeys>>,
    TError = void | void | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listCustomerAPIKeys>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List all API keys for a customer
 */

export function useListCustomerAPIKeys<
    TData = Awaited<ReturnType<typeof listCustomerAPIKeys>>,
    TError = void | void | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listCustomerAPIKeys>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListCustomerAPIKeysQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Create a new API key for a customer
 */
export const createCustomerAPIKey = (
    createAPIKeyRequest: CreateAPIKeyRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<CreateCustomerAPIKey201>(
        {
            url: `/customers/api-keys`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: createAPIKeyRequest,
            signal,
        },
        options,
    );
};

export const getCreateCustomerAPIKeyMutationOptions = <
    TError = ErrorResponse | void | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createCustomerAPIKey>>,
        TError,
        { data: CreateAPIKeyRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createCustomerAPIKey>>,
    TError,
    { data: CreateAPIKeyRequest },
    TContext
> => {
    const mutationKey = ["createCustomerAPIKey"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createCustomerAPIKey>>,
        { data: CreateAPIKeyRequest }
    > = (props) => {
        const { data } = props ?? {};

        return createCustomerAPIKey(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateCustomerAPIKeyMutationResult = NonNullable<
    Awaited<ReturnType<typeof createCustomerAPIKey>>
>;
export type CreateCustomerAPIKeyMutationBody = CreateAPIKeyRequest;
export type CreateCustomerAPIKeyMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse;

/**
 * @summary Create a new API key for a customer
 */
export const useCreateCustomerAPIKey = <
    TError = ErrorResponse | void | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createCustomerAPIKey>>,
            TError,
            { data: CreateAPIKeyRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createCustomerAPIKey>>,
    TError,
    { data: CreateAPIKeyRequest },
    TContext
> => {
    const mutationOptions = getCreateCustomerAPIKeyMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete an API key for a customer
 */
export const deleteCustomerAPIKey = (
    apiKeyId: string,
    options?: SecondParameter<typeof customInstance>,
) => {
    return customInstance<void>(
        { url: `/customers/api-keys/${apiKeyId}`, method: "DELETE" },
        options,
    );
};

export const getDeleteCustomerAPIKeyMutationOptions = <
    TError = void | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof deleteCustomerAPIKey>>,
        TError,
        { apiKeyId: string },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof deleteCustomerAPIKey>>,
    TError,
    { apiKeyId: string },
    TContext
> => {
    const mutationKey = ["deleteCustomerAPIKey"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deleteCustomerAPIKey>>,
        { apiKeyId: string }
    > = (props) => {
        const { apiKeyId } = props ?? {};

        return deleteCustomerAPIKey(apiKeyId, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type DeleteCustomerAPIKeyMutationResult = NonNullable<
    Awaited<ReturnType<typeof deleteCustomerAPIKey>>
>;

export type DeleteCustomerAPIKeyMutationError = void | void | ErrorResponse;

/**
 * @summary Delete an API key for a customer
 */
export const useDeleteCustomerAPIKey = <
    TError = void | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deleteCustomerAPIKey>>,
            TError,
            { apiKeyId: string },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof deleteCustomerAPIKey>>,
    TError,
    { apiKeyId: string },
    TContext
> => {
    const mutationOptions = getDeleteCustomerAPIKeyMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the customer's current remaining balance in microamount and its currency.
 * @summary Get customer's remaining balance
 */
export const getCustomerBalance = (
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetCustomerBalance200>(
        { url: `/customers/balance`, method: "GET", signal },
        options,
    );
};

export const getGetCustomerBalanceQueryKey = () => {
    return [`/customers/balance`] as const;
};

export const getGetCustomerBalanceQueryOptions = <
    TData = Awaited<ReturnType<typeof getCustomerBalance>>,
    TError = void | ErrorResponse | ErrorResponse,
>(options?: {
    query?: Partial<
        UseQueryOptions<
            Awaited<ReturnType<typeof getCustomerBalance>>,
            TError,
            TData
        >
    >;
    request?: SecondParameter<typeof customInstance>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetCustomerBalanceQueryKey();

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getCustomerBalance>>
    > = ({ signal }) => getCustomerBalance(requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getCustomerBalance>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCustomerBalanceQueryResult = NonNullable<
    Awaited<ReturnType<typeof getCustomerBalance>>
>;
export type GetCustomerBalanceQueryError = void | ErrorResponse | ErrorResponse;

export function useGetCustomerBalance<
    TData = Awaited<ReturnType<typeof getCustomerBalance>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerBalance>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCustomerBalance>>,
                    TError,
                    Awaited<ReturnType<typeof getCustomerBalance>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCustomerBalance<
    TData = Awaited<ReturnType<typeof getCustomerBalance>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerBalance>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCustomerBalance>>,
                    TError,
                    Awaited<ReturnType<typeof getCustomerBalance>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCustomerBalance<
    TData = Awaited<ReturnType<typeof getCustomerBalance>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerBalance>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get customer's remaining balance
 */

export function useGetCustomerBalance<
    TData = Awaited<ReturnType<typeof getCustomerBalance>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerBalance>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetCustomerBalanceQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Creates a session for the customer to access their billing portal where they can manage subscriptions, payment methods, and view invoices.
 * @summary Access customer billing portal
 */
export const accessBillingPortal = (
    accessBillingPortalBody: AccessBillingPortalBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<AccessBillingPortal200>(
        {
            url: `/customers/billing`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: accessBillingPortalBody,
            signal,
        },
        options,
    );
};

export const getAccessBillingPortalMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof accessBillingPortal>>,
        TError,
        { data: AccessBillingPortalBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof accessBillingPortal>>,
    TError,
    { data: AccessBillingPortalBody },
    TContext
> => {
    const mutationKey = ["accessBillingPortal"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof accessBillingPortal>>,
        { data: AccessBillingPortalBody }
    > = (props) => {
        const { data } = props ?? {};

        return accessBillingPortal(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type AccessBillingPortalMutationResult = NonNullable<
    Awaited<ReturnType<typeof accessBillingPortal>>
>;
export type AccessBillingPortalMutationBody = AccessBillingPortalBody;
export type AccessBillingPortalMutationError =
    | ErrorResponse
    | void
    | ErrorResponse;

/**
 * @summary Access customer billing portal
 */
export const useAccessBillingPortal = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof accessBillingPortal>>,
            TError,
            { data: AccessBillingPortalBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof accessBillingPortal>>,
    TError,
    { data: AccessBillingPortalBody },
    TContext
> => {
    const mutationOptions = getAccessBillingPortalMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Initiates a Credit Purchase.
 */
export const initiateCreditPurchase = (
    initiateCreditPurchaseBody: InitiateCreditPurchaseBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<InitiateCreditPurchase201>(
        {
            url: `/customers/credit`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: initiateCreditPurchaseBody,
            signal,
        },
        options,
    );
};

export const getInitiateCreditPurchaseMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof initiateCreditPurchase>>,
        TError,
        { data: InitiateCreditPurchaseBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof initiateCreditPurchase>>,
    TError,
    { data: InitiateCreditPurchaseBody },
    TContext
> => {
    const mutationKey = ["initiateCreditPurchase"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof initiateCreditPurchase>>,
        { data: InitiateCreditPurchaseBody }
    > = (props) => {
        const { data } = props ?? {};

        return initiateCreditPurchase(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type InitiateCreditPurchaseMutationResult = NonNullable<
    Awaited<ReturnType<typeof initiateCreditPurchase>>
>;
export type InitiateCreditPurchaseMutationBody = InitiateCreditPurchaseBody;
export type InitiateCreditPurchaseMutationError =
    | ErrorResponse
    | void
    | ErrorResponse;

/**
 * @summary Initiates a Credit Purchase.
 */
export const useInitiateCreditPurchase = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof initiateCreditPurchase>>,
            TError,
            { data: InitiateCreditPurchaseBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof initiateCreditPurchase>>,
    TError,
    { data: InitiateCreditPurchaseBody },
    TContext
> => {
    const mutationOptions = getInitiateCreditPurchaseMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get events related to customer
 */
export const getCustomerEvents = (
    params?: GetCustomerEventsParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetCustomerEvents200>(
        { url: `/customers/events`, method: "GET", params, signal },
        options,
    );
};

export const getGetCustomerEventsQueryKey = (
    params?: GetCustomerEventsParams,
) => {
    return [`/customers/events`, ...(params ? [params] : [])] as const;
};

export const getGetCustomerEventsQueryOptions = <
    TData = Awaited<ReturnType<typeof getCustomerEvents>>,
    TError = void | void | ErrorResponse,
>(
    params?: GetCustomerEventsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerEvents>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetCustomerEventsQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getCustomerEvents>>
    > = ({ signal }) => getCustomerEvents(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getCustomerEvents>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCustomerEventsQueryResult = NonNullable<
    Awaited<ReturnType<typeof getCustomerEvents>>
>;
export type GetCustomerEventsQueryError = void | void | ErrorResponse;

export function useGetCustomerEvents<
    TData = Awaited<ReturnType<typeof getCustomerEvents>>,
    TError = void | void | ErrorResponse,
>(
    params: undefined | GetCustomerEventsParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerEvents>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCustomerEvents>>,
                    TError,
                    Awaited<ReturnType<typeof getCustomerEvents>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCustomerEvents<
    TData = Awaited<ReturnType<typeof getCustomerEvents>>,
    TError = void | void | ErrorResponse,
>(
    params?: GetCustomerEventsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerEvents>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCustomerEvents>>,
                    TError,
                    Awaited<ReturnType<typeof getCustomerEvents>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCustomerEvents<
    TData = Awaited<ReturnType<typeof getCustomerEvents>>,
    TError = void | void | ErrorResponse,
>(
    params?: GetCustomerEventsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerEvents>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get events related to customer
 */

export function useGetCustomerEvents<
    TData = Awaited<ReturnType<typeof getCustomerEvents>>,
    TError = void | void | ErrorResponse,
>(
    params?: GetCustomerEventsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerEvents>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetCustomerEventsQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Returns details about the currently authenticated customer based on their JWT token.
 * @summary Get authenticated customer details
 */
export const getAuthenticatedCustomer = (
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Customer>(
        { url: `/customers/me`, method: "GET", signal },
        options,
    );
};

export const getGetAuthenticatedCustomerQueryKey = () => {
    return [`/customers/me`] as const;
};

export const getGetAuthenticatedCustomerQueryOptions = <
    TData = Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
    TError = void | ErrorResponse | ErrorResponse,
>(options?: {
    query?: Partial<
        UseQueryOptions<
            Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
            TError,
            TData
        >
    >;
    request?: SecondParameter<typeof customInstance>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetAuthenticatedCustomerQueryKey();

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getAuthenticatedCustomer>>
    > = ({ signal }) => getAuthenticatedCustomer(requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthenticatedCustomerQueryResult = NonNullable<
    Awaited<ReturnType<typeof getAuthenticatedCustomer>>
>;
export type GetAuthenticatedCustomerQueryError =
    | void
    | ErrorResponse
    | ErrorResponse;

export function useGetAuthenticatedCustomer<
    TData = Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
                    TError,
                    Awaited<ReturnType<typeof getAuthenticatedCustomer>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAuthenticatedCustomer<
    TData = Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
                    TError,
                    Awaited<ReturnType<typeof getAuthenticatedCustomer>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAuthenticatedCustomer<
    TData = Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get authenticated customer details
 */

export function useGetAuthenticatedCustomer<
    TData = Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getAuthenticatedCustomer>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetAuthenticatedCustomerQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Store a resource for a customer. Resource will have a 24 hour expiry. The signed URL will be generated for the specified file path.
 * @summary Store a resource for a customer
 */
export const createCustomerStorageResource = (
    createCustomerStorageResourceBody: CreateCustomerStorageResourceBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<CustomerStorageResourceResponse>(
        {
            url: `/customers/storage`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: createCustomerStorageResourceBody,
            signal,
        },
        options,
    );
};

export const getCreateCustomerStorageResourceMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createCustomerStorageResource>>,
        TError,
        { data: CreateCustomerStorageResourceBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createCustomerStorageResource>>,
    TError,
    { data: CreateCustomerStorageResourceBody },
    TContext
> => {
    const mutationKey = ["createCustomerStorageResource"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createCustomerStorageResource>>,
        { data: CreateCustomerStorageResourceBody }
    > = (props) => {
        const { data } = props ?? {};

        return createCustomerStorageResource(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateCustomerStorageResourceMutationResult = NonNullable<
    Awaited<ReturnType<typeof createCustomerStorageResource>>
>;
export type CreateCustomerStorageResourceMutationBody =
    CreateCustomerStorageResourceBody;
export type CreateCustomerStorageResourceMutationError =
    | ErrorResponse
    | void
    | ErrorResponse;

/**
 * @summary Store a resource for a customer
 */
export const useCreateCustomerStorageResource = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createCustomerStorageResource>>,
            TError,
            { data: CreateCustomerStorageResourceBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createCustomerStorageResource>>,
    TError,
    { data: CreateCustomerStorageResourceBody },
    TContext
> => {
    const mutationOptions =
        getCreateCustomerStorageResourceMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the customer's as a dashboard URL.
 * @summary Get customer's usage
 */
export const getCustomerUsage = (
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetCustomerUsage200>(
        { url: `/customers/usage`, method: "POST", signal },
        options,
    );
};

export const getGetCustomerUsageMutationOptions = <
    TError = void | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof getCustomerUsage>>,
        TError,
        void,
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof getCustomerUsage>>,
    TError,
    void,
    TContext
> => {
    const mutationKey = ["getCustomerUsage"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof getCustomerUsage>>,
        void
    > = () => {
        return getCustomerUsage(requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type GetCustomerUsageMutationResult = NonNullable<
    Awaited<ReturnType<typeof getCustomerUsage>>
>;

export type GetCustomerUsageMutationError = void | void | ErrorResponse;

/**
 * @summary Get customer's usage
 */
export const useGetCustomerUsage = <
    TError = void | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof getCustomerUsage>>,
            TError,
            void,
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof getCustomerUsage>>,
    TError,
    void,
    TContext
> => {
    const mutationOptions = getGetCustomerUsageMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Returns details about a customer by their ID.
 * @summary Get a customer by ID
 */
export const getCustomerById = (
    customerId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetCustomerById200>(
        { url: `/customers/${customerId}`, method: "GET", signal },
        options,
    );
};

export const getGetCustomerByIdQueryKey = (customerId?: string) => {
    return [`/customers/${customerId}`] as const;
};

export const getGetCustomerByIdQueryOptions = <
    TData = Awaited<ReturnType<typeof getCustomerById>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    customerId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerById>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetCustomerByIdQueryKey(customerId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getCustomerById>>
    > = ({ signal }) => getCustomerById(customerId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!customerId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getCustomerById>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCustomerByIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof getCustomerById>>
>;
export type GetCustomerByIdQueryError = void | ErrorResponse | ErrorResponse;

export function useGetCustomerById<
    TData = Awaited<ReturnType<typeof getCustomerById>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    customerId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerById>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCustomerById>>,
                    TError,
                    Awaited<ReturnType<typeof getCustomerById>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCustomerById<
    TData = Awaited<ReturnType<typeof getCustomerById>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    customerId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerById>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCustomerById>>,
                    TError,
                    Awaited<ReturnType<typeof getCustomerById>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCustomerById<
    TData = Awaited<ReturnType<typeof getCustomerById>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    customerId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerById>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a customer by ID
 */

export function useGetCustomerById<
    TData = Awaited<ReturnType<typeof getCustomerById>>,
    TError = void | ErrorResponse | ErrorResponse,
>(
    customerId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerById>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetCustomerByIdQueryOptions(customerId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Returns the specified customer's current remaining balance in microamount and its currency.
 * @summary Get customer's remaining balance by ID
 */
export const getCustomerBalanceById = (
    customerId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetCustomerBalanceById200>(
        { url: `/customers/${customerId}/balance`, method: "GET", signal },
        options,
    );
};

export const getGetCustomerBalanceByIdQueryKey = (customerId?: string) => {
    return [`/customers/${customerId}/balance`] as const;
};

export const getGetCustomerBalanceByIdQueryOptions = <
    TData = Awaited<ReturnType<typeof getCustomerBalanceById>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    customerId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerBalanceById>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetCustomerBalanceByIdQueryKey(customerId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getCustomerBalanceById>>
    > = ({ signal }) =>
        getCustomerBalanceById(customerId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!customerId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getCustomerBalanceById>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCustomerBalanceByIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof getCustomerBalanceById>>
>;
export type GetCustomerBalanceByIdQueryError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse;

export function useGetCustomerBalanceById<
    TData = Awaited<ReturnType<typeof getCustomerBalanceById>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    customerId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerBalanceById>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCustomerBalanceById>>,
                    TError,
                    Awaited<ReturnType<typeof getCustomerBalanceById>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCustomerBalanceById<
    TData = Awaited<ReturnType<typeof getCustomerBalanceById>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    customerId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerBalanceById>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCustomerBalanceById>>,
                    TError,
                    Awaited<ReturnType<typeof getCustomerBalanceById>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCustomerBalanceById<
    TData = Awaited<ReturnType<typeof getCustomerBalanceById>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    customerId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerBalanceById>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get customer's remaining balance by ID
 */

export function useGetCustomerBalanceById<
    TData = Awaited<ReturnType<typeof getCustomerBalanceById>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    customerId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerBalanceById>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetCustomerBalanceByIdQueryOptions(
        customerId,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Get events related to customer
 */
export const getCustomerEventsById = (
    customerId: string,
    params?: GetCustomerEventsByIdParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetCustomerEventsById200>(
        {
            url: `/customers/${customerId}/events`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getGetCustomerEventsByIdQueryKey = (
    customerId?: string,
    params?: GetCustomerEventsByIdParams,
) => {
    return [
        `/customers/${customerId}/events`,
        ...(params ? [params] : []),
    ] as const;
};

export const getGetCustomerEventsByIdQueryOptions = <
    TData = Awaited<ReturnType<typeof getCustomerEventsById>>,
    TError = void | void | ErrorResponse,
>(
    customerId: string,
    params?: GetCustomerEventsByIdParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerEventsById>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getGetCustomerEventsByIdQueryKey(customerId, params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getCustomerEventsById>>
    > = ({ signal }) =>
        getCustomerEventsById(customerId, params, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!customerId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getCustomerEventsById>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCustomerEventsByIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof getCustomerEventsById>>
>;
export type GetCustomerEventsByIdQueryError = void | void | ErrorResponse;

export function useGetCustomerEventsById<
    TData = Awaited<ReturnType<typeof getCustomerEventsById>>,
    TError = void | void | ErrorResponse,
>(
    customerId: string,
    params: undefined | GetCustomerEventsByIdParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerEventsById>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCustomerEventsById>>,
                    TError,
                    Awaited<ReturnType<typeof getCustomerEventsById>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCustomerEventsById<
    TData = Awaited<ReturnType<typeof getCustomerEventsById>>,
    TError = void | void | ErrorResponse,
>(
    customerId: string,
    params?: GetCustomerEventsByIdParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerEventsById>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCustomerEventsById>>,
                    TError,
                    Awaited<ReturnType<typeof getCustomerEventsById>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCustomerEventsById<
    TData = Awaited<ReturnType<typeof getCustomerEventsById>>,
    TError = void | void | ErrorResponse,
>(
    customerId: string,
    params?: GetCustomerEventsByIdParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerEventsById>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get events related to customer
 */

export function useGetCustomerEventsById<
    TData = Awaited<ReturnType<typeof getCustomerEventsById>>,
    TError = void | void | ErrorResponse,
>(
    customerId: string,
    params?: GetCustomerEventsByIdParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getCustomerEventsById>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetCustomerEventsByIdQueryOptions(
        customerId,
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Returns all runs, jobs, job results, and storage files associated with a given commit.
 * @summary Retrieve CI data for a given commit
 */
export const getGitcommit = (
    params?: GetGitcommitParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetGitcommit200>(
        { url: `/gitcommit`, method: "GET", params, signal },
        options,
    );
};

export const getGetGitcommitQueryKey = (params?: GetGitcommitParams) => {
    return [`/gitcommit`, ...(params ? [params] : [])] as const;
};

export const getGetGitcommitQueryOptions = <
    TData = Awaited<ReturnType<typeof getGitcommit>>,
    TError = void | void,
>(
    params?: GetGitcommitParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getGitcommit>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetGitcommitQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGitcommit>>> = ({
        signal,
    }) => getGitcommit(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getGitcommit>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGitcommitQueryResult = NonNullable<
    Awaited<ReturnType<typeof getGitcommit>>
>;
export type GetGitcommitQueryError = void | void;

export function useGetGitcommit<
    TData = Awaited<ReturnType<typeof getGitcommit>>,
    TError = void | void,
>(
    params: undefined | GetGitcommitParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getGitcommit>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getGitcommit>>,
                    TError,
                    Awaited<ReturnType<typeof getGitcommit>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGitcommit<
    TData = Awaited<ReturnType<typeof getGitcommit>>,
    TError = void | void,
>(
    params?: GetGitcommitParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getGitcommit>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getGitcommit>>,
                    TError,
                    Awaited<ReturnType<typeof getGitcommit>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGitcommit<
    TData = Awaited<ReturnType<typeof getGitcommit>>,
    TError = void | void,
>(
    params?: GetGitcommitParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getGitcommit>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve CI data for a given commit
 */

export function useGetGitcommit<
    TData = Awaited<ReturnType<typeof getGitcommit>>,
    TError = void | void,
>(
    params?: GetGitcommitParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getGitcommit>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetGitcommitQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Returns a summary of git commits, including status, start time, and end time.
 * @summary Retrieve a summary of git commits
 */
export const getGitcommitsummary = (
    params?: GetGitcommitsummaryParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetGitcommitsummary200>(
        { url: `/gitcommitsummary`, method: "GET", params, signal },
        options,
    );
};

export const getGetGitcommitsummaryQueryKey = (
    params?: GetGitcommitsummaryParams,
) => {
    return [`/gitcommitsummary`, ...(params ? [params] : [])] as const;
};

export const getGetGitcommitsummaryQueryOptions = <
    TData = Awaited<ReturnType<typeof getGitcommitsummary>>,
    TError = GetGitcommitsummary500,
>(
    params?: GetGitcommitsummaryParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getGitcommitsummary>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetGitcommitsummaryQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getGitcommitsummary>>
    > = ({ signal }) => getGitcommitsummary(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getGitcommitsummary>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGitcommitsummaryQueryResult = NonNullable<
    Awaited<ReturnType<typeof getGitcommitsummary>>
>;
export type GetGitcommitsummaryQueryError = GetGitcommitsummary500;

export function useGetGitcommitsummary<
    TData = Awaited<ReturnType<typeof getGitcommitsummary>>,
    TError = GetGitcommitsummary500,
>(
    params: undefined | GetGitcommitsummaryParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getGitcommitsummary>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getGitcommitsummary>>,
                    TError,
                    Awaited<ReturnType<typeof getGitcommitsummary>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGitcommitsummary<
    TData = Awaited<ReturnType<typeof getGitcommitsummary>>,
    TError = GetGitcommitsummary500,
>(
    params?: GetGitcommitsummaryParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getGitcommitsummary>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getGitcommitsummary>>,
                    TError,
                    Awaited<ReturnType<typeof getGitcommitsummary>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGitcommitsummary<
    TData = Awaited<ReturnType<typeof getGitcommitsummary>>,
    TError = GetGitcommitsummary500,
>(
    params?: GetGitcommitsummaryParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getGitcommitsummary>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve a summary of git commits
 */

export function useGetGitcommitsummary<
    TData = Awaited<ReturnType<typeof getGitcommitsummary>>,
    TError = GetGitcommitsummary500,
>(
    params?: GetGitcommitsummaryParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getGitcommitsummary>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetGitcommitsummaryQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Returns a paginated list of nodes across all publishers.
 * @summary Retrieves a list of nodes
 */
export const listAllNodes = (
    params?: ListAllNodesParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ListAllNodes200>(
        { url: `/nodes`, method: "GET", params, signal },
        options,
    );
};

export const getListAllNodesQueryKey = (params?: ListAllNodesParams) => {
    return [`/nodes`, ...(params ? [params] : [])] as const;
};

export const getListAllNodesQueryOptions = <
    TData = Awaited<ReturnType<typeof listAllNodes>>,
    TError = void | void | ErrorResponse,
>(
    params?: ListAllNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listAllNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getListAllNodesQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllNodes>>> = ({
        signal,
    }) => listAllNodes(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof listAllNodes>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListAllNodesQueryResult = NonNullable<
    Awaited<ReturnType<typeof listAllNodes>>
>;
export type ListAllNodesQueryError = void | void | ErrorResponse;

export function useListAllNodes<
    TData = Awaited<ReturnType<typeof listAllNodes>>,
    TError = void | void | ErrorResponse,
>(
    params: undefined | ListAllNodesParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listAllNodes>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listAllNodes>>,
                    TError,
                    Awaited<ReturnType<typeof listAllNodes>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListAllNodes<
    TData = Awaited<ReturnType<typeof listAllNodes>>,
    TError = void | void | ErrorResponse,
>(
    params?: ListAllNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listAllNodes>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listAllNodes>>,
                    TError,
                    Awaited<ReturnType<typeof listAllNodes>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListAllNodes<
    TData = Awaited<ReturnType<typeof listAllNodes>>,
    TError = void | void | ErrorResponse,
>(
    params?: ListAllNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listAllNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieves a list of nodes
 */

export function useListAllNodes<
    TData = Awaited<ReturnType<typeof listAllNodes>>,
    TError = void | void | ErrorResponse,
>(
    params?: ListAllNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listAllNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListAllNodesQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Reindex all nodes for searching.
 */
export const reindexNodes = (
    params?: ReindexNodesParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        { url: `/nodes/reindex`, method: "POST", params, signal },
        options,
    );
};

export const getReindexNodesMutationOptions = <
    TError = ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof reindexNodes>>,
        TError,
        { params?: ReindexNodesParams },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof reindexNodes>>,
    TError,
    { params?: ReindexNodesParams },
    TContext
> => {
    const mutationKey = ["reindexNodes"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof reindexNodes>>,
        { params?: ReindexNodesParams }
    > = (props) => {
        const { params } = props ?? {};

        return reindexNodes(params, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ReindexNodesMutationResult = NonNullable<
    Awaited<ReturnType<typeof reindexNodes>>
>;

export type ReindexNodesMutationError = ErrorResponse | ErrorResponse;

/**
 * @summary Reindex all nodes for searching.
 */
export const useReindexNodes = <
    TError = ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof reindexNodes>>,
            TError,
            { params?: ReindexNodesParams },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof reindexNodes>>,
    TError,
    { params?: ReindexNodesParams },
    TContext
> => {
    const mutationOptions = getReindexNodesMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Returns a paginated list of nodes across all publishers.
 * @summary Retrieves a list of nodes
 */
export const searchNodes = (
    params?: SearchNodesParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<SearchNodes200>(
        { url: `/nodes/search`, method: "GET", params, signal },
        options,
    );
};

export const getSearchNodesQueryKey = (params?: SearchNodesParams) => {
    return [`/nodes/search`, ...(params ? [params] : [])] as const;
};

export const getSearchNodesQueryOptions = <
    TData = Awaited<ReturnType<typeof searchNodes>>,
    TError = void | void | ErrorResponse,
>(
    params?: SearchNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof searchNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getSearchNodesQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchNodes>>> = ({
        signal,
    }) => searchNodes(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof searchNodes>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchNodesQueryResult = NonNullable<
    Awaited<ReturnType<typeof searchNodes>>
>;
export type SearchNodesQueryError = void | void | ErrorResponse;

export function useSearchNodes<
    TData = Awaited<ReturnType<typeof searchNodes>>,
    TError = void | void | ErrorResponse,
>(
    params: undefined | SearchNodesParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof searchNodes>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof searchNodes>>,
                    TError,
                    Awaited<ReturnType<typeof searchNodes>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchNodes<
    TData = Awaited<ReturnType<typeof searchNodes>>,
    TError = void | void | ErrorResponse,
>(
    params?: SearchNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof searchNodes>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof searchNodes>>,
                    TError,
                    Awaited<ReturnType<typeof searchNodes>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchNodes<
    TData = Awaited<ReturnType<typeof searchNodes>>,
    TError = void | void | ErrorResponse,
>(
    params?: SearchNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof searchNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieves a list of nodes
 */

export function useSearchNodes<
    TData = Awaited<ReturnType<typeof searchNodes>>,
    TError = void | void | ErrorResponse,
>(
    params?: SearchNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof searchNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getSearchNodesQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Update GitHub stars for nodes
 */
export const updateGithubStars = (
    params?: UpdateGithubStarsParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        { url: `/nodes/update-github-stars`, method: "POST", params, signal },
        options,
    );
};

export const getUpdateGithubStarsMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof updateGithubStars>>,
        TError,
        { params?: UpdateGithubStarsParams },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof updateGithubStars>>,
    TError,
    { params?: UpdateGithubStarsParams },
    TContext
> => {
    const mutationKey = ["updateGithubStars"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof updateGithubStars>>,
        { params?: UpdateGithubStarsParams }
    > = (props) => {
        const { params } = props ?? {};

        return updateGithubStars(params, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type UpdateGithubStarsMutationResult = NonNullable<
    Awaited<ReturnType<typeof updateGithubStars>>
>;

export type UpdateGithubStarsMutationError =
    | ErrorResponse
    | void
    | ErrorResponse;

/**
 * @summary Update GitHub stars for nodes
 */
export const useUpdateGithubStars = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof updateGithubStars>>,
            TError,
            { params?: UpdateGithubStarsParams },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof updateGithubStars>>,
    TError,
    { params?: UpdateGithubStarsParams },
    TContext
> => {
    const mutationOptions = getUpdateGithubStarsMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the details of a specific node.
 * @summary Retrieve a specific node by ID
 */
export const getNode = (
    nodeId: string,
    params?: GetNodeParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Node>(
        { url: `/nodes/${nodeId}`, method: "GET", params, signal },
        options,
    );
};

export const getGetNodeQueryKey = (nodeId?: string, params?: GetNodeParams) => {
    return [`/nodes/${nodeId}`, ...(params ? [params] : [])] as const;
};

export const getGetNodeQueryOptions = <
    TData = Awaited<ReturnType<typeof getNode>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    params?: GetNodeParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetNodeQueryKey(nodeId, params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNode>>> = ({
        signal,
    }) => getNode(nodeId, params, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!nodeId,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type GetNodeQueryResult = NonNullable<
    Awaited<ReturnType<typeof getNode>>
>;
export type GetNodeQueryError = ErrorResponse | ErrorResponse | ErrorResponse;

export function useGetNode<
    TData = Awaited<ReturnType<typeof getNode>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    params: undefined | GetNodeParams,
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getNode>>,
                    TError,
                    Awaited<ReturnType<typeof getNode>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNode<
    TData = Awaited<ReturnType<typeof getNode>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    params?: GetNodeParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getNode>>,
                    TError,
                    Awaited<ReturnType<typeof getNode>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNode<
    TData = Awaited<ReturnType<typeof getNode>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    params?: GetNodeParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve a specific node by ID
 */

export function useGetNode<
    TData = Awaited<ReturnType<typeof getNode>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    params?: GetNodeParams,
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetNodeQueryOptions(nodeId, params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Retrieves the node data for installation, either the latest or a specific version.
 * @summary Returns a node version to be installed.
 */
export const installNode = (
    nodeId: string,
    params?: InstallNodeParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<NodeVersion>(
        { url: `/nodes/${nodeId}/install`, method: "GET", params, signal },
        options,
    );
};

export const getInstallNodeQueryKey = (
    nodeId?: string,
    params?: InstallNodeParams,
) => {
    return [`/nodes/${nodeId}/install`, ...(params ? [params] : [])] as const;
};

export const getInstallNodeQueryOptions = <
    TData = Awaited<ReturnType<typeof installNode>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    params?: InstallNodeParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof installNode>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getInstallNodeQueryKey(nodeId, params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof installNode>>> = ({
        signal,
    }) => installNode(nodeId, params, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!nodeId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof installNode>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type InstallNodeQueryResult = NonNullable<
    Awaited<ReturnType<typeof installNode>>
>;
export type InstallNodeQueryError =
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

export function useInstallNode<
    TData = Awaited<ReturnType<typeof installNode>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    params: undefined | InstallNodeParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof installNode>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof installNode>>,
                    TError,
                    Awaited<ReturnType<typeof installNode>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useInstallNode<
    TData = Awaited<ReturnType<typeof installNode>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    params?: InstallNodeParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof installNode>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof installNode>>,
                    TError,
                    Awaited<ReturnType<typeof installNode>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useInstallNode<
    TData = Awaited<ReturnType<typeof installNode>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    params?: InstallNodeParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof installNode>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Returns a node version to be installed.
 */

export function useInstallNode<
    TData = Awaited<ReturnType<typeof installNode>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    params?: InstallNodeParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof installNode>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getInstallNodeQueryOptions(nodeId, params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Add review to a specific version of a node
 */
export const postNodeReview = (
    nodeId: string,
    params: PostNodeReviewParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Node>(
        { url: `/nodes/${nodeId}/reviews`, method: "POST", params, signal },
        options,
    );
};

export const getPostNodeReviewMutationOptions = <
    TError = void | Error | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postNodeReview>>,
        TError,
        { nodeId: string; params: PostNodeReviewParams },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof postNodeReview>>,
    TError,
    { nodeId: string; params: PostNodeReviewParams },
    TContext
> => {
    const mutationKey = ["postNodeReview"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postNodeReview>>,
        { nodeId: string; params: PostNodeReviewParams }
    > = (props) => {
        const { nodeId, params } = props ?? {};

        return postNodeReview(nodeId, params, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PostNodeReviewMutationResult = NonNullable<
    Awaited<ReturnType<typeof postNodeReview>>
>;

export type PostNodeReviewMutationError = void | Error | ErrorResponse;

/**
 * @summary Add review to a specific version of a node
 */
export const usePostNodeReview = <
    TError = void | Error | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof postNodeReview>>,
            TError,
            { nodeId: string; params: PostNodeReviewParams },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof postNodeReview>>,
    TError,
    { nodeId: string; params: PostNodeReviewParams },
    TContext
> => {
    const mutationOptions = getPostNodeReviewMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create Node Translations
 */
export const createNodeTranslations = (
    nodeId: string,
    createNodeTranslationsBody: CreateNodeTranslationsBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        {
            url: `/nodes/${nodeId}/translations`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: createNodeTranslationsBody,
            signal,
        },
        options,
    );
};

export const getCreateNodeTranslationsMutationOptions = <
    TError = void | Error | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createNodeTranslations>>,
        TError,
        { nodeId: string; data: CreateNodeTranslationsBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createNodeTranslations>>,
    TError,
    { nodeId: string; data: CreateNodeTranslationsBody },
    TContext
> => {
    const mutationKey = ["createNodeTranslations"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createNodeTranslations>>,
        { nodeId: string; data: CreateNodeTranslationsBody }
    > = (props) => {
        const { nodeId, data } = props ?? {};

        return createNodeTranslations(nodeId, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateNodeTranslationsMutationResult = NonNullable<
    Awaited<ReturnType<typeof createNodeTranslations>>
>;
export type CreateNodeTranslationsMutationBody = CreateNodeTranslationsBody;
export type CreateNodeTranslationsMutationError = void | Error | ErrorResponse;

/**
 * @summary Create Node Translations
 */
export const useCreateNodeTranslations = <
    TError = void | Error | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createNodeTranslations>>,
            TError,
            { nodeId: string; data: CreateNodeTranslationsBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createNodeTranslations>>,
    TError,
    { nodeId: string; data: CreateNodeTranslationsBody },
    TContext
> => {
    const mutationOptions = getCreateNodeTranslationsMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary List all versions of a node
 */
export const listNodeVersions = (
    nodeId: string,
    params?: ListNodeVersionsParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<NodeVersion[]>(
        { url: `/nodes/${nodeId}/versions`, method: "GET", params, signal },
        options,
    );
};

export const getListNodeVersionsQueryKey = (
    nodeId?: string,
    params?: ListNodeVersionsParams,
) => {
    return [`/nodes/${nodeId}/versions`, ...(params ? [params] : [])] as const;
};

export const getListNodeVersionsQueryOptions = <
    TData = Awaited<ReturnType<typeof listNodeVersions>>,
    TError = ErrorResponse | Error | ErrorResponse,
>(
    nodeId: string,
    params?: ListNodeVersionsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodeVersions>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getListNodeVersionsQueryKey(nodeId, params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof listNodeVersions>>
    > = ({ signal }) =>
        listNodeVersions(nodeId, params, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!nodeId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof listNodeVersions>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListNodeVersionsQueryResult = NonNullable<
    Awaited<ReturnType<typeof listNodeVersions>>
>;
export type ListNodeVersionsQueryError = ErrorResponse | Error | ErrorResponse;

export function useListNodeVersions<
    TData = Awaited<ReturnType<typeof listNodeVersions>>,
    TError = ErrorResponse | Error | ErrorResponse,
>(
    nodeId: string,
    params: undefined | ListNodeVersionsParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodeVersions>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listNodeVersions>>,
                    TError,
                    Awaited<ReturnType<typeof listNodeVersions>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListNodeVersions<
    TData = Awaited<ReturnType<typeof listNodeVersions>>,
    TError = ErrorResponse | Error | ErrorResponse,
>(
    nodeId: string,
    params?: ListNodeVersionsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodeVersions>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listNodeVersions>>,
                    TError,
                    Awaited<ReturnType<typeof listNodeVersions>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListNodeVersions<
    TData = Awaited<ReturnType<typeof listNodeVersions>>,
    TError = ErrorResponse | Error | ErrorResponse,
>(
    nodeId: string,
    params?: ListNodeVersionsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodeVersions>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List all versions of a node
 */

export function useListNodeVersions<
    TData = Awaited<ReturnType<typeof listNodeVersions>>,
    TError = ErrorResponse | Error | ErrorResponse,
>(
    nodeId: string,
    params?: ListNodeVersionsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodeVersions>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListNodeVersionsQueryOptions(
        nodeId,
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Retrieve a specific version of a node
 */
export const getNodeVersion = (
    nodeId: string,
    versionId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<NodeVersion>(
        {
            url: `/nodes/${nodeId}/versions/${versionId}`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getGetNodeVersionQueryKey = (
    nodeId?: string,
    versionId?: string,
) => {
    return [`/nodes/${nodeId}/versions/${versionId}`] as const;
};

export const getGetNodeVersionQueryOptions = <
    TData = Awaited<ReturnType<typeof getNodeVersion>>,
    TError = Error | ErrorResponse,
>(
    nodeId: string,
    versionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getNodeVersion>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetNodeVersionQueryKey(nodeId, versionId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getNodeVersion>>
    > = ({ signal }) =>
        getNodeVersion(nodeId, versionId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!(nodeId && versionId),
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getNodeVersion>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNodeVersionQueryResult = NonNullable<
    Awaited<ReturnType<typeof getNodeVersion>>
>;
export type GetNodeVersionQueryError = Error | ErrorResponse;

export function useGetNodeVersion<
    TData = Awaited<ReturnType<typeof getNodeVersion>>,
    TError = Error | ErrorResponse,
>(
    nodeId: string,
    versionId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getNodeVersion>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getNodeVersion>>,
                    TError,
                    Awaited<ReturnType<typeof getNodeVersion>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNodeVersion<
    TData = Awaited<ReturnType<typeof getNodeVersion>>,
    TError = Error | ErrorResponse,
>(
    nodeId: string,
    versionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getNodeVersion>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getNodeVersion>>,
                    TError,
                    Awaited<ReturnType<typeof getNodeVersion>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNodeVersion<
    TData = Awaited<ReturnType<typeof getNodeVersion>>,
    TError = Error | ErrorResponse,
>(
    nodeId: string,
    versionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getNodeVersion>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve a specific version of a node
 */

export function useGetNodeVersion<
    TData = Awaited<ReturnType<typeof getNodeVersion>>,
    TError = Error | ErrorResponse,
>(
    nodeId: string,
    versionId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getNodeVersion>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetNodeVersionQueryOptions(
        nodeId,
        versionId,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary list comfy-nodes for node version
 */
export const listComfyNodes = (
    nodeId: string,
    version: string,
    params?: ListComfyNodesParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ListComfyNodes200>(
        {
            url: `/nodes/${nodeId}/versions/${version}/comfy-nodes`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getListComfyNodesQueryKey = (
    nodeId?: string,
    version?: string,
    params?: ListComfyNodesParams,
) => {
    return [
        `/nodes/${nodeId}/versions/${version}/comfy-nodes`,
        ...(params ? [params] : []),
    ] as const;
};

export const getListComfyNodesQueryOptions = <
    TData = Awaited<ReturnType<typeof listComfyNodes>>,
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    version: string,
    params?: ListComfyNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listComfyNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getListComfyNodesQueryKey(nodeId, version, params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof listComfyNodes>>
    > = ({ signal }) =>
        listComfyNodes(nodeId, version, params, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!(nodeId && version),
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof listComfyNodes>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListComfyNodesQueryResult = NonNullable<
    Awaited<ReturnType<typeof listComfyNodes>>
>;
export type ListComfyNodesQueryError =
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

export function useListComfyNodes<
    TData = Awaited<ReturnType<typeof listComfyNodes>>,
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    version: string,
    params: undefined | ListComfyNodesParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listComfyNodes>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listComfyNodes>>,
                    TError,
                    Awaited<ReturnType<typeof listComfyNodes>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListComfyNodes<
    TData = Awaited<ReturnType<typeof listComfyNodes>>,
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    version: string,
    params?: ListComfyNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listComfyNodes>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listComfyNodes>>,
                    TError,
                    Awaited<ReturnType<typeof listComfyNodes>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListComfyNodes<
    TData = Awaited<ReturnType<typeof listComfyNodes>>,
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    version: string,
    params?: ListComfyNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listComfyNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary list comfy-nodes for node version
 */

export function useListComfyNodes<
    TData = Awaited<ReturnType<typeof listComfyNodes>>,
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    version: string,
    params?: ListComfyNodesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listComfyNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListComfyNodesQueryOptions(
        nodeId,
        version,
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary create comfy-nodes for certain node
 */
export const createComfyNodes = (
    nodeId: string,
    version: string,
    createComfyNodesBody: CreateComfyNodesBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        {
            url: `/nodes/${nodeId}/versions/${version}/comfy-nodes`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: createComfyNodesBody,
            signal,
        },
        options,
    );
};

export const getCreateComfyNodesMutationOptions = <
    TError =
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createComfyNodes>>,
        TError,
        { nodeId: string; version: string; data: CreateComfyNodesBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createComfyNodes>>,
    TError,
    { nodeId: string; version: string; data: CreateComfyNodesBody },
    TContext
> => {
    const mutationKey = ["createComfyNodes"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createComfyNodes>>,
        { nodeId: string; version: string; data: CreateComfyNodesBody }
    > = (props) => {
        const { nodeId, version, data } = props ?? {};

        return createComfyNodes(nodeId, version, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateComfyNodesMutationResult = NonNullable<
    Awaited<ReturnType<typeof createComfyNodes>>
>;
export type CreateComfyNodesMutationBody = CreateComfyNodesBody;
export type CreateComfyNodesMutationError =
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary create comfy-nodes for certain node
 */
export const useCreateComfyNodes = <
    TError =
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createComfyNodes>>,
            TError,
            { nodeId: string; version: string; data: CreateComfyNodesBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createComfyNodes>>,
    TError,
    { nodeId: string; version: string; data: CreateComfyNodesBody },
    TContext
> => {
    const mutationOptions = getCreateComfyNodesMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary get specify comfy-node based on its id
 */
export const getComfyNode = (
    nodeId: string,
    version: string,
    comfyNodeName: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ComfyNode>(
        {
            url: `/nodes/${nodeId}/versions/${version}/comfy-nodes/${comfyNodeName}`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getGetComfyNodeQueryKey = (
    nodeId?: string,
    version?: string,
    comfyNodeName?: string,
) => {
    return [
        `/nodes/${nodeId}/versions/${version}/comfy-nodes/${comfyNodeName}`,
    ] as const;
};

export const getGetComfyNodeQueryOptions = <
    TData = Awaited<ReturnType<typeof getComfyNode>>,
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    version: string,
    comfyNodeName: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getComfyNode>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getGetComfyNodeQueryKey(nodeId, version, comfyNodeName);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getComfyNode>>> = ({
        signal,
    }) => getComfyNode(nodeId, version, comfyNodeName, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!(nodeId && version && comfyNodeName),
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getComfyNode>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetComfyNodeQueryResult = NonNullable<
    Awaited<ReturnType<typeof getComfyNode>>
>;
export type GetComfyNodeQueryError =
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

export function useGetComfyNode<
    TData = Awaited<ReturnType<typeof getComfyNode>>,
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    version: string,
    comfyNodeName: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getComfyNode>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getComfyNode>>,
                    TError,
                    Awaited<ReturnType<typeof getComfyNode>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetComfyNode<
    TData = Awaited<ReturnType<typeof getComfyNode>>,
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    version: string,
    comfyNodeName: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getComfyNode>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getComfyNode>>,
                    TError,
                    Awaited<ReturnType<typeof getComfyNode>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetComfyNode<
    TData = Awaited<ReturnType<typeof getComfyNode>>,
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    version: string,
    comfyNodeName: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getComfyNode>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary get specify comfy-node based on its id
 */

export function useGetComfyNode<
    TData = Awaited<ReturnType<typeof getComfyNode>>,
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
>(
    nodeId: string,
    version: string,
    comfyNodeName: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getComfyNode>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetComfyNodeQueryOptions(
        nodeId,
        version,
        comfyNodeName,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Forwards image editing requests to BFL's Flux Kontext Max API and returns the results.
 * @summary Proxy request to BFL Flux Kontext Max for image editing
 */
export const bflFluxKontextMaxGenerate = (
    bFLFluxKontextMaxGenerateRequest: BFLFluxKontextMaxGenerateRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BFLFluxKontextMaxGenerateResponse>(
        {
            url: `/proxy/bfl/flux-kontext-max/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: bFLFluxKontextMaxGenerateRequest,
            signal,
        },
        options,
    );
};

export const getBflFluxKontextMaxGenerateMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>,
        TError,
        { data: BFLFluxKontextMaxGenerateRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>,
    TError,
    { data: BFLFluxKontextMaxGenerateRequest },
    TContext
> => {
    const mutationKey = ["bflFluxKontextMaxGenerate"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>,
        { data: BFLFluxKontextMaxGenerateRequest }
    > = (props) => {
        const { data } = props ?? {};

        return bflFluxKontextMaxGenerate(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type BflFluxKontextMaxGenerateMutationResult = NonNullable<
    Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>
>;
export type BflFluxKontextMaxGenerateMutationBody =
    BFLFluxKontextMaxGenerateRequest;
export type BflFluxKontextMaxGenerateMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Proxy request to BFL Flux Kontext Max for image editing
 */
export const useBflFluxKontextMaxGenerate = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>,
            TError,
            { data: BFLFluxKontextMaxGenerateRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof bflFluxKontextMaxGenerate>>,
    TError,
    { data: BFLFluxKontextMaxGenerateRequest },
    TContext
> => {
    const mutationOptions =
        getBflFluxKontextMaxGenerateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Forwards image editing requests to BFL's Flux Kontext Pro API and returns the results.
 * @summary Proxy request to BFL Flux Kontext Pro for image editing
 */
export const bflFluxKontextProGenerate = (
    bFLFluxKontextProGenerateRequest: BFLFluxKontextProGenerateRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BFLFluxKontextProGenerateResponse>(
        {
            url: `/proxy/bfl/flux-kontext-pro/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: bFLFluxKontextProGenerateRequest,
            signal,
        },
        options,
    );
};

export const getBflFluxKontextProGenerateMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof bflFluxKontextProGenerate>>,
        TError,
        { data: BFLFluxKontextProGenerateRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof bflFluxKontextProGenerate>>,
    TError,
    { data: BFLFluxKontextProGenerateRequest },
    TContext
> => {
    const mutationKey = ["bflFluxKontextProGenerate"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof bflFluxKontextProGenerate>>,
        { data: BFLFluxKontextProGenerateRequest }
    > = (props) => {
        const { data } = props ?? {};

        return bflFluxKontextProGenerate(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type BflFluxKontextProGenerateMutationResult = NonNullable<
    Awaited<ReturnType<typeof bflFluxKontextProGenerate>>
>;
export type BflFluxKontextProGenerateMutationBody =
    BFLFluxKontextProGenerateRequest;
export type BflFluxKontextProGenerateMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Proxy request to BFL Flux Kontext Pro for image editing
 */
export const useBflFluxKontextProGenerate = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof bflFluxKontextProGenerate>>,
            TError,
            { data: BFLFluxKontextProGenerateRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof bflFluxKontextProGenerate>>,
    TError,
    { data: BFLFluxKontextProGenerateRequest },
    TContext
> => {
    const mutationOptions =
        getBflFluxKontextProGenerateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Submits an image generation task with FLUX.1 Canny [pro].
 * @summary Generate an image with FLUX.1 Canny [pro] using a control image.
 */
export const bFLProCannyV1FluxPro10CannyPost = (
    bFLCannyInputs: BFLCannyInputs,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BFLProCannyV1FluxPro10CannyPost200>(
        {
            url: `/proxy/bfl/flux-pro-1.0-canny/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: bFLCannyInputs,
            signal,
        },
        options,
    );
};

export const getBFLProCannyV1FluxPro10CannyPostMutationOptions = <
    TError = BFLHTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>,
        TError,
        { data: BFLCannyInputs },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>,
    TError,
    { data: BFLCannyInputs },
    TContext
> => {
    const mutationKey = ["bFLProCannyV1FluxPro10CannyPost"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>,
        { data: BFLCannyInputs }
    > = (props) => {
        const { data } = props ?? {};

        return bFLProCannyV1FluxPro10CannyPost(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type BFLProCannyV1FluxPro10CannyPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>
>;
export type BFLProCannyV1FluxPro10CannyPostMutationBody = BFLCannyInputs;
export type BFLProCannyV1FluxPro10CannyPostMutationError =
    BFLHTTPValidationError;

/**
 * @summary Generate an image with FLUX.1 Canny [pro] using a control image.
 */
export const useBFLProCannyV1FluxPro10CannyPost = <
    TError = BFLHTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>,
            TError,
            { data: BFLCannyInputs },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof bFLProCannyV1FluxPro10CannyPost>>,
    TError,
    { data: BFLCannyInputs },
    TContext
> => {
    const mutationOptions =
        getBFLProCannyV1FluxPro10CannyPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Submits an image generation task with FLUX.1 Depth [pro].
 * @summary Generate an image with FLUX.1 Depth [pro] using a control image.
 */
export const bFLProDepthV1FluxPro10DepthPost = (
    bFLDepthInputs: BFLDepthInputs,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BFLProDepthV1FluxPro10DepthPost200>(
        {
            url: `/proxy/bfl/flux-pro-1.0-depth/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: bFLDepthInputs,
            signal,
        },
        options,
    );
};

export const getBFLProDepthV1FluxPro10DepthPostMutationOptions = <
    TError = BFLHTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>,
        TError,
        { data: BFLDepthInputs },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>,
    TError,
    { data: BFLDepthInputs },
    TContext
> => {
    const mutationKey = ["bFLProDepthV1FluxPro10DepthPost"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>,
        { data: BFLDepthInputs }
    > = (props) => {
        const { data } = props ?? {};

        return bFLProDepthV1FluxPro10DepthPost(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type BFLProDepthV1FluxPro10DepthPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>
>;
export type BFLProDepthV1FluxPro10DepthPostMutationBody = BFLDepthInputs;
export type BFLProDepthV1FluxPro10DepthPostMutationError =
    BFLHTTPValidationError;

/**
 * @summary Generate an image with FLUX.1 Depth [pro] using a control image.
 */
export const useBFLProDepthV1FluxPro10DepthPost = <
    TError = BFLHTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>,
            TError,
            { data: BFLDepthInputs },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof bFLProDepthV1FluxPro10DepthPost>>,
    TError,
    { data: BFLDepthInputs },
    TContext
> => {
    const mutationOptions =
        getBFLProDepthV1FluxPro10DepthPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Submits an image expansion task that adds the specified number of pixels to any combination of sides (top, bottom, left, right) while maintaining context.
 * @summary Expand an image by adding pixels on any side.
 */
export const bFLExpandV1FluxPro10ExpandPost = (
    bFLFluxProExpandInputs: BFLFluxProExpandInputs,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BFLExpandV1FluxPro10ExpandPost200>(
        {
            url: `/proxy/bfl/flux-pro-1.0-expand/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: bFLFluxProExpandInputs,
            signal,
        },
        options,
    );
};

export const getBFLExpandV1FluxPro10ExpandPostMutationOptions = <
    TError = BFLHTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>,
        TError,
        { data: BFLFluxProExpandInputs },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>,
    TError,
    { data: BFLFluxProExpandInputs },
    TContext
> => {
    const mutationKey = ["bFLExpandV1FluxPro10ExpandPost"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>,
        { data: BFLFluxProExpandInputs }
    > = (props) => {
        const { data } = props ?? {};

        return bFLExpandV1FluxPro10ExpandPost(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type BFLExpandV1FluxPro10ExpandPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>
>;
export type BFLExpandV1FluxPro10ExpandPostMutationBody = BFLFluxProExpandInputs;
export type BFLExpandV1FluxPro10ExpandPostMutationError =
    BFLHTTPValidationError;

/**
 * @summary Expand an image by adding pixels on any side.
 */
export const useBFLExpandV1FluxPro10ExpandPost = <
    TError = BFLHTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>,
            TError,
            { data: BFLFluxProExpandInputs },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof bFLExpandV1FluxPro10ExpandPost>>,
    TError,
    { data: BFLFluxProExpandInputs },
    TContext
> => {
    const mutationOptions =
        getBFLExpandV1FluxPro10ExpandPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Submits an image generation task with the FLUX.1 Fill [pro] model using an input image and mask. Mask can be applied to alpha channel or submitted as a separate image.
 * @summary Generate an image with FLUX.1 Fill [pro] using an input image and mask.
 */
export const bFLFillV1FluxPro10FillPost = (
    bFLFluxProFillInputs: BFLFluxProFillInputs,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BFLFillV1FluxPro10FillPost200>(
        {
            url: `/proxy/bfl/flux-pro-1.0-fill/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: bFLFluxProFillInputs,
            signal,
        },
        options,
    );
};

export const getBFLFillV1FluxPro10FillPostMutationOptions = <
    TError = BFLHTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>,
        TError,
        { data: BFLFluxProFillInputs },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>,
    TError,
    { data: BFLFluxProFillInputs },
    TContext
> => {
    const mutationKey = ["bFLFillV1FluxPro10FillPost"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>,
        { data: BFLFluxProFillInputs }
    > = (props) => {
        const { data } = props ?? {};

        return bFLFillV1FluxPro10FillPost(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type BFLFillV1FluxPro10FillPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>
>;
export type BFLFillV1FluxPro10FillPostMutationBody = BFLFluxProFillInputs;
export type BFLFillV1FluxPro10FillPostMutationError = BFLHTTPValidationError;

/**
 * @summary Generate an image with FLUX.1 Fill [pro] using an input image and mask.
 */
export const useBFLFillV1FluxPro10FillPost = <
    TError = BFLHTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>,
            TError,
            { data: BFLFluxProFillInputs },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof bFLFillV1FluxPro10FillPost>>,
    TError,
    { data: BFLFluxProFillInputs },
    TContext
> => {
    const mutationOptions =
        getBFLFillV1FluxPro10FillPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Forwards image generation requests to BFL's Flux Pro 1.1 Ultra API and returns the results.
 * @summary Proxy request to BFL Flux Pro 1.1 Ultra for image generation
 */
export const bflFluxProGenerate = (
    bFLFluxProGenerateRequest: BFLFluxProGenerateRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BFLFluxProGenerateResponse>(
        {
            url: `/proxy/bfl/flux-pro-1.1-ultra/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: bFLFluxProGenerateRequest,
            signal,
        },
        options,
    );
};

export const getBflFluxProGenerateMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof bflFluxProGenerate>>,
        TError,
        { data: BFLFluxProGenerateRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof bflFluxProGenerate>>,
    TError,
    { data: BFLFluxProGenerateRequest },
    TContext
> => {
    const mutationKey = ["bflFluxProGenerate"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof bflFluxProGenerate>>,
        { data: BFLFluxProGenerateRequest }
    > = (props) => {
        const { data } = props ?? {};

        return bflFluxProGenerate(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type BflFluxProGenerateMutationResult = NonNullable<
    Awaited<ReturnType<typeof bflFluxProGenerate>>
>;
export type BflFluxProGenerateMutationBody = BFLFluxProGenerateRequest;
export type BflFluxProGenerateMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Proxy request to BFL Flux Pro 1.1 Ultra for image generation
 */
export const useBflFluxProGenerate = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof bflFluxProGenerate>>,
            TError,
            { data: BFLFluxProGenerateRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof bflFluxProGenerate>>,
    TError,
    { data: BFLFluxProGenerateRequest },
    TContext
> => {
    const mutationOptions = getBflFluxProGenerateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Forwards image generation requests to BFL's Flux Pro 1.1 API and returns the results.
 * @summary Proxy request to BFL Flux Pro 1.1 for image generation
 */
export const bflFluxPro11Generate = (
    bFLFluxPro11GenerateRequest: BFLFluxPro11GenerateRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BFLFluxPro11GenerateResponse>(
        {
            url: `/proxy/bfl/flux-pro-1.1/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: bFLFluxPro11GenerateRequest,
            signal,
        },
        options,
    );
};

export const getBflFluxPro11GenerateMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof bflFluxPro11Generate>>,
        TError,
        { data: BFLFluxPro11GenerateRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof bflFluxPro11Generate>>,
    TError,
    { data: BFLFluxPro11GenerateRequest },
    TContext
> => {
    const mutationKey = ["bflFluxPro11Generate"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof bflFluxPro11Generate>>,
        { data: BFLFluxPro11GenerateRequest }
    > = (props) => {
        const { data } = props ?? {};

        return bflFluxPro11Generate(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type BflFluxPro11GenerateMutationResult = NonNullable<
    Awaited<ReturnType<typeof bflFluxPro11Generate>>
>;
export type BflFluxPro11GenerateMutationBody = BFLFluxPro11GenerateRequest;
export type BflFluxPro11GenerateMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Proxy request to BFL Flux Pro 1.1 for image generation
 */
export const useBflFluxPro11Generate = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof bflFluxPro11Generate>>,
            TError,
            { data: BFLFluxPro11GenerateRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof bflFluxPro11Generate>>,
    TError,
    { data: BFLFluxPro11GenerateRequest },
    TContext
> => {
    const mutationOptions = getBflFluxPro11GenerateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const byteplusVideoGeneration = (
    bytePlusVideoGenerationRequest: BytePlusVideoGenerationRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BytePlusVideoGenerationResponse>(
        {
            url: `/proxy/byteplus/api/v3/contents/generations/tasks`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: bytePlusVideoGenerationRequest,
            signal,
        },
        options,
    );
};

export const getByteplusVideoGenerationMutationOptions = <
    TError = ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof byteplusVideoGeneration>>,
        TError,
        { data: BytePlusVideoGenerationRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof byteplusVideoGeneration>>,
    TError,
    { data: BytePlusVideoGenerationRequest },
    TContext
> => {
    const mutationKey = ["byteplusVideoGeneration"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof byteplusVideoGeneration>>,
        { data: BytePlusVideoGenerationRequest }
    > = (props) => {
        const { data } = props ?? {};

        return byteplusVideoGeneration(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ByteplusVideoGenerationMutationResult = NonNullable<
    Awaited<ReturnType<typeof byteplusVideoGeneration>>
>;
export type ByteplusVideoGenerationMutationBody =
    BytePlusVideoGenerationRequest;
export type ByteplusVideoGenerationMutationError = ErrorResponse;

export const useByteplusVideoGeneration = <
    TError = ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof byteplusVideoGeneration>>,
            TError,
            { data: BytePlusVideoGenerationRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof byteplusVideoGeneration>>,
    TError,
    { data: BytePlusVideoGenerationRequest },
    TContext
> => {
    const mutationOptions = getByteplusVideoGenerationMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const byteplusVideoGenerationQuery = (
    taskId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BytePlusVideoGenerationQueryResponse>(
        {
            url: `/proxy/byteplus/api/v3/contents/generations/tasks/${taskId}`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getByteplusVideoGenerationQueryQueryKey = (taskId?: string) => {
    return [
        `/proxy/byteplus/api/v3/contents/generations/tasks/${taskId}`,
    ] as const;
};

export const getByteplusVideoGenerationQueryQueryOptions = <
    TData = Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
    TError = ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getByteplusVideoGenerationQueryQueryKey(taskId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>
    > = ({ signal }) =>
        byteplusVideoGenerationQuery(taskId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!taskId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ByteplusVideoGenerationQueryQueryResult = NonNullable<
    Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>
>;
export type ByteplusVideoGenerationQueryQueryError = ErrorResponse;

export function useByteplusVideoGenerationQuery<
    TData = Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
    TError = ErrorResponse,
>(
    taskId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
                    TError,
                    Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useByteplusVideoGenerationQuery<
    TData = Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
    TError = ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
                    TError,
                    Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useByteplusVideoGenerationQuery<
    TData = Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
    TError = ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useByteplusVideoGenerationQuery<
    TData = Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
    TError = ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof byteplusVideoGenerationQuery>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getByteplusVideoGenerationQueryQueryOptions(
        taskId,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

export const byteplusImageGeneration = (
    bytePlusImageGenerationRequest: BytePlusImageGenerationRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<BytePlusImageGenerationResponse>(
        {
            url: `/proxy/byteplus/api/v3/images/generations`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: bytePlusImageGenerationRequest,
            signal,
        },
        options,
    );
};

export const getByteplusImageGenerationMutationOptions = <
    TError = ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof byteplusImageGeneration>>,
        TError,
        { data: BytePlusImageGenerationRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof byteplusImageGeneration>>,
    TError,
    { data: BytePlusImageGenerationRequest },
    TContext
> => {
    const mutationKey = ["byteplusImageGeneration"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof byteplusImageGeneration>>,
        { data: BytePlusImageGenerationRequest }
    > = (props) => {
        const { data } = props ?? {};

        return byteplusImageGeneration(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ByteplusImageGenerationMutationResult = NonNullable<
    Awaited<ReturnType<typeof byteplusImageGeneration>>
>;
export type ByteplusImageGenerationMutationBody =
    BytePlusImageGenerationRequest;
export type ByteplusImageGenerationMutationError = ErrorResponse;

export const useByteplusImageGeneration = <
    TError = ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof byteplusImageGeneration>>,
            TError,
            { data: BytePlusImageGenerationRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof byteplusImageGeneration>>,
    TError,
    { data: BytePlusImageGenerationRequest },
    TContext
> => {
    const mutationOptions = getByteplusImageGenerationMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Dummy proxy endpoint that returns a simple string
 * @summary Dummy proxy
 */
export const dummyProxy = (
    dummyProxyBody: DummyProxyBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        {
            url: `/proxy/dummy`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: dummyProxyBody,
            signal,
        },
        options,
    );
};

export const getDummyProxyMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof dummyProxy>>,
        TError,
        { data: DummyProxyBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof dummyProxy>>,
    TError,
    { data: DummyProxyBody },
    TContext
> => {
    const mutationKey = ["dummyProxy"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof dummyProxy>>,
        { data: DummyProxyBody }
    > = (props) => {
        const { data } = props ?? {};

        return dummyProxy(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type DummyProxyMutationResult = NonNullable<
    Awaited<ReturnType<typeof dummyProxy>>
>;
export type DummyProxyMutationBody = DummyProxyBody;
export type DummyProxyMutationError = unknown;

/**
 * @summary Dummy proxy
 */
export const useDummyProxy = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof dummyProxy>>,
            TError,
            { data: DummyProxyBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof dummyProxy>>,
    TError,
    { data: DummyProxyBody },
    TContext
> => {
    const mutationOptions = getDummyProxyMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Forwards image generation requests to Ideogram's API and returns the results.
 * @summary Proxy request to Ideogram for image generation
 */
export const ideogramGenerate = (
    ideogramGenerateRequest: IdeogramGenerateRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<IdeogramGenerateResponse>(
        {
            url: `/proxy/ideogram/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: ideogramGenerateRequest,
            signal,
        },
        options,
    );
};

export const getIdeogramGenerateMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof ideogramGenerate>>,
        TError,
        { data: IdeogramGenerateRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof ideogramGenerate>>,
    TError,
    { data: IdeogramGenerateRequest },
    TContext
> => {
    const mutationKey = ["ideogramGenerate"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof ideogramGenerate>>,
        { data: IdeogramGenerateRequest }
    > = (props) => {
        const { data } = props ?? {};

        return ideogramGenerate(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type IdeogramGenerateMutationResult = NonNullable<
    Awaited<ReturnType<typeof ideogramGenerate>>
>;
export type IdeogramGenerateMutationBody = IdeogramGenerateRequest;
export type IdeogramGenerateMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Proxy request to Ideogram for image generation
 */
export const useIdeogramGenerate = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof ideogramGenerate>>,
            TError,
            { data: IdeogramGenerateRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof ideogramGenerate>>,
    TError,
    { data: IdeogramGenerateRequest },
    TContext
> => {
    const mutationOptions = getIdeogramGenerateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Forwards image editing requests to Ideogram's API and returns the results.
 * @summary Proxy request to Ideogram for image editing
 */
export const ideogramV3Edit = (
    ideogramV3EditRequest: IdeogramV3EditRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (ideogramV3EditRequest.character_reference_images !== undefined) {
        ideogramV3EditRequest.character_reference_images.forEach((value) =>
            formData.append(`character_reference_images`, value),
        );
    }
    if (ideogramV3EditRequest.character_reference_images_mask !== undefined) {
        ideogramV3EditRequest.character_reference_images_mask.forEach((value) =>
            formData.append(`character_reference_images_mask`, value),
        );
    }
    if (ideogramV3EditRequest.color_palette !== undefined) {
        formData.append(
            `color_palette`,
            JSON.stringify(ideogramV3EditRequest.color_palette),
        );
    }
    if (ideogramV3EditRequest.image !== undefined) {
        formData.append(`image`, ideogramV3EditRequest.image);
    }
    if (ideogramV3EditRequest.magic_prompt !== undefined) {
        formData.append(`magic_prompt`, ideogramV3EditRequest.magic_prompt);
    }
    if (ideogramV3EditRequest.mask !== undefined) {
        formData.append(`mask`, ideogramV3EditRequest.mask);
    }
    if (ideogramV3EditRequest.num_images !== undefined) {
        formData.append(
            `num_images`,
            ideogramV3EditRequest.num_images.toString(),
        );
    }
    formData.append(`prompt`, ideogramV3EditRequest.prompt);
    formData.append(`rendering_speed`, ideogramV3EditRequest.rendering_speed);
    if (ideogramV3EditRequest.seed !== undefined) {
        formData.append(`seed`, ideogramV3EditRequest.seed.toString());
    }
    if (ideogramV3EditRequest.style_codes !== undefined) {
        ideogramV3EditRequest.style_codes.forEach((value) =>
            formData.append(`style_codes`, value),
        );
    }
    if (ideogramV3EditRequest.style_reference_images !== undefined) {
        ideogramV3EditRequest.style_reference_images.forEach((value) =>
            formData.append(`style_reference_images`, value),
        );
    }
    if (ideogramV3EditRequest.style_type !== undefined) {
        formData.append(`style_type`, ideogramV3EditRequest.style_type);
    }

    return customInstance<IdeogramGenerateResponse>(
        {
            url: `/proxy/ideogram/ideogram-v3/edit`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getIdeogramV3EditMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof ideogramV3Edit>>,
        TError,
        { data: IdeogramV3EditRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof ideogramV3Edit>>,
    TError,
    { data: IdeogramV3EditRequest },
    TContext
> => {
    const mutationKey = ["ideogramV3Edit"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof ideogramV3Edit>>,
        { data: IdeogramV3EditRequest }
    > = (props) => {
        const { data } = props ?? {};

        return ideogramV3Edit(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type IdeogramV3EditMutationResult = NonNullable<
    Awaited<ReturnType<typeof ideogramV3Edit>>
>;
export type IdeogramV3EditMutationBody = IdeogramV3EditRequest;
export type IdeogramV3EditMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | void
    | ErrorResponse;

/**
 * @summary Proxy request to Ideogram for image editing
 */
export const useIdeogramV3Edit = <
    TError = ErrorResponse | void | ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof ideogramV3Edit>>,
            TError,
            { data: IdeogramV3EditRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof ideogramV3Edit>>,
    TError,
    { data: IdeogramV3EditRequest },
    TContext
> => {
    const mutationOptions = getIdeogramV3EditMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Forwards image generation requests to Ideogram's API and returns the results.
 * @summary Proxy request to Ideogram for image generation
 */
export const ideogramV3Generate = (
    ideogramV3Request: IdeogramV3Request,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<IdeogramGenerateResponse>(
        {
            url: `/proxy/ideogram/ideogram-v3/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: ideogramV3Request,
            signal,
        },
        options,
    );
};

export const getIdeogramV3GenerateMutationOptions = <
    TError = ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof ideogramV3Generate>>,
        TError,
        { data: IdeogramV3Request },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof ideogramV3Generate>>,
    TError,
    { data: IdeogramV3Request },
    TContext
> => {
    const mutationKey = ["ideogramV3Generate"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof ideogramV3Generate>>,
        { data: IdeogramV3Request }
    > = (props) => {
        const { data } = props ?? {};

        return ideogramV3Generate(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type IdeogramV3GenerateMutationResult = NonNullable<
    Awaited<ReturnType<typeof ideogramV3Generate>>
>;
export type IdeogramV3GenerateMutationBody = IdeogramV3Request;
export type IdeogramV3GenerateMutationError = ErrorResponse;

/**
 * @summary Proxy request to Ideogram for image generation
 */
export const useIdeogramV3Generate = <
    TError = ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof ideogramV3Generate>>,
            TError,
            { data: IdeogramV3Request },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof ideogramV3Generate>>,
    TError,
    { data: IdeogramV3Request },
    TContext
> => {
    const mutationOptions = getIdeogramV3GenerateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Reframe an image to a chosen resolution
 */
export const ideogramV3Reframe = (
    ideogramV3ReframeRequest: IdeogramV3ReframeRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (ideogramV3ReframeRequest.color_palette !== undefined) {
        formData.append(
            `color_palette`,
            JSON.stringify(ideogramV3ReframeRequest.color_palette),
        );
    }
    if (ideogramV3ReframeRequest.image !== undefined) {
        formData.append(`image`, ideogramV3ReframeRequest.image);
    }
    if (ideogramV3ReframeRequest.num_images !== undefined) {
        formData.append(
            `num_images`,
            ideogramV3ReframeRequest.num_images.toString(),
        );
    }
    if (ideogramV3ReframeRequest.rendering_speed !== undefined) {
        formData.append(
            `rendering_speed`,
            ideogramV3ReframeRequest.rendering_speed,
        );
    }
    formData.append(`resolution`, ideogramV3ReframeRequest.resolution);
    if (ideogramV3ReframeRequest.seed !== undefined) {
        formData.append(`seed`, ideogramV3ReframeRequest.seed.toString());
    }
    if (ideogramV3ReframeRequest.style_codes !== undefined) {
        ideogramV3ReframeRequest.style_codes.forEach((value) =>
            formData.append(`style_codes`, value),
        );
    }
    if (ideogramV3ReframeRequest.style_reference_images !== undefined) {
        ideogramV3ReframeRequest.style_reference_images.forEach((value) =>
            formData.append(`style_reference_images`, value),
        );
    }

    return customInstance<IdeogramV3IdeogramResponse>(
        {
            url: `/proxy/ideogram/ideogram-v3/reframe`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getIdeogramV3ReframeMutationOptions = <
    TError = void | void | void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof ideogramV3Reframe>>,
        TError,
        { data: IdeogramV3ReframeRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof ideogramV3Reframe>>,
    TError,
    { data: IdeogramV3ReframeRequest },
    TContext
> => {
    const mutationKey = ["ideogramV3Reframe"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof ideogramV3Reframe>>,
        { data: IdeogramV3ReframeRequest }
    > = (props) => {
        const { data } = props ?? {};

        return ideogramV3Reframe(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type IdeogramV3ReframeMutationResult = NonNullable<
    Awaited<ReturnType<typeof ideogramV3Reframe>>
>;
export type IdeogramV3ReframeMutationBody = IdeogramV3ReframeRequest;
export type IdeogramV3ReframeMutationError = void | void | void | void;

/**
 * @summary Reframe an image to a chosen resolution
 */
export const useIdeogramV3Reframe = <
    TError = void | void | void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof ideogramV3Reframe>>,
            TError,
            { data: IdeogramV3ReframeRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof ideogramV3Reframe>>,
    TError,
    { data: IdeogramV3ReframeRequest },
    TContext
> => {
    const mutationOptions = getIdeogramV3ReframeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Remix an image using a prompt
 */
export const ideogramV3Remix = (
    ideogramV3RemixRequest: IdeogramV3RemixRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (ideogramV3RemixRequest.aspect_ratio !== undefined) {
        formData.append(`aspect_ratio`, ideogramV3RemixRequest.aspect_ratio);
    }
    if (ideogramV3RemixRequest.character_reference_images !== undefined) {
        ideogramV3RemixRequest.character_reference_images.forEach((value) =>
            formData.append(`character_reference_images`, value),
        );
    }
    if (ideogramV3RemixRequest.character_reference_images_mask !== undefined) {
        ideogramV3RemixRequest.character_reference_images_mask.forEach(
            (value) =>
                formData.append(`character_reference_images_mask`, value),
        );
    }
    if (ideogramV3RemixRequest.color_palette !== undefined) {
        formData.append(
            `color_palette`,
            JSON.stringify(ideogramV3RemixRequest.color_palette),
        );
    }
    if (ideogramV3RemixRequest.image !== undefined) {
        formData.append(`image`, ideogramV3RemixRequest.image);
    }
    if (ideogramV3RemixRequest.image_weight !== undefined) {
        formData.append(
            `image_weight`,
            ideogramV3RemixRequest.image_weight.toString(),
        );
    }
    if (ideogramV3RemixRequest.magic_prompt !== undefined) {
        formData.append(`magic_prompt`, ideogramV3RemixRequest.magic_prompt);
    }
    if (ideogramV3RemixRequest.negative_prompt !== undefined) {
        formData.append(
            `negative_prompt`,
            ideogramV3RemixRequest.negative_prompt,
        );
    }
    if (ideogramV3RemixRequest.num_images !== undefined) {
        formData.append(
            `num_images`,
            ideogramV3RemixRequest.num_images.toString(),
        );
    }
    formData.append(`prompt`, ideogramV3RemixRequest.prompt);
    if (ideogramV3RemixRequest.rendering_speed !== undefined) {
        formData.append(
            `rendering_speed`,
            ideogramV3RemixRequest.rendering_speed,
        );
    }
    if (ideogramV3RemixRequest.resolution !== undefined) {
        formData.append(`resolution`, ideogramV3RemixRequest.resolution);
    }
    if (ideogramV3RemixRequest.seed !== undefined) {
        formData.append(`seed`, ideogramV3RemixRequest.seed.toString());
    }
    if (ideogramV3RemixRequest.style_codes !== undefined) {
        ideogramV3RemixRequest.style_codes.forEach((value) =>
            formData.append(`style_codes`, value),
        );
    }
    if (ideogramV3RemixRequest.style_reference_images !== undefined) {
        ideogramV3RemixRequest.style_reference_images.forEach((value) =>
            formData.append(`style_reference_images`, value),
        );
    }
    if (ideogramV3RemixRequest.style_type !== undefined) {
        formData.append(`style_type`, ideogramV3RemixRequest.style_type);
    }

    return customInstance<IdeogramV3IdeogramResponse>(
        {
            url: `/proxy/ideogram/ideogram-v3/remix`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getIdeogramV3RemixMutationOptions = <
    TError = void | void | void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof ideogramV3Remix>>,
        TError,
        { data: IdeogramV3RemixRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof ideogramV3Remix>>,
    TError,
    { data: IdeogramV3RemixRequest },
    TContext
> => {
    const mutationKey = ["ideogramV3Remix"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof ideogramV3Remix>>,
        { data: IdeogramV3RemixRequest }
    > = (props) => {
        const { data } = props ?? {};

        return ideogramV3Remix(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type IdeogramV3RemixMutationResult = NonNullable<
    Awaited<ReturnType<typeof ideogramV3Remix>>
>;
export type IdeogramV3RemixMutationBody = IdeogramV3RemixRequest;
export type IdeogramV3RemixMutationError = void | void | void | void;

/**
 * @summary Remix an image using a prompt
 */
export const useIdeogramV3Remix = <
    TError = void | void | void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof ideogramV3Remix>>,
            TError,
            { data: IdeogramV3RemixRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof ideogramV3Remix>>,
    TError,
    { data: IdeogramV3RemixRequest },
    TContext
> => {
    const mutationOptions = getIdeogramV3RemixMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Replace background of an image using a prompt
 */
export const ideogramV3ReplaceBackground = (
    ideogramV3ReplaceBackgroundRequest: IdeogramV3ReplaceBackgroundRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (ideogramV3ReplaceBackgroundRequest.color_palette !== undefined) {
        formData.append(
            `color_palette`,
            JSON.stringify(ideogramV3ReplaceBackgroundRequest.color_palette),
        );
    }
    if (ideogramV3ReplaceBackgroundRequest.image !== undefined) {
        formData.append(`image`, ideogramV3ReplaceBackgroundRequest.image);
    }
    if (ideogramV3ReplaceBackgroundRequest.magic_prompt !== undefined) {
        formData.append(
            `magic_prompt`,
            ideogramV3ReplaceBackgroundRequest.magic_prompt,
        );
    }
    if (ideogramV3ReplaceBackgroundRequest.num_images !== undefined) {
        formData.append(
            `num_images`,
            ideogramV3ReplaceBackgroundRequest.num_images.toString(),
        );
    }
    formData.append(`prompt`, ideogramV3ReplaceBackgroundRequest.prompt);
    if (ideogramV3ReplaceBackgroundRequest.rendering_speed !== undefined) {
        formData.append(
            `rendering_speed`,
            ideogramV3ReplaceBackgroundRequest.rendering_speed,
        );
    }
    if (ideogramV3ReplaceBackgroundRequest.seed !== undefined) {
        formData.append(
            `seed`,
            ideogramV3ReplaceBackgroundRequest.seed.toString(),
        );
    }
    if (ideogramV3ReplaceBackgroundRequest.style_codes !== undefined) {
        ideogramV3ReplaceBackgroundRequest.style_codes.forEach((value) =>
            formData.append(`style_codes`, value),
        );
    }
    if (
        ideogramV3ReplaceBackgroundRequest.style_reference_images !== undefined
    ) {
        ideogramV3ReplaceBackgroundRequest.style_reference_images.forEach(
            (value) => formData.append(`style_reference_images`, value),
        );
    }

    return customInstance<IdeogramV3IdeogramResponse>(
        {
            url: `/proxy/ideogram/ideogram-v3/replace-background`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getIdeogramV3ReplaceBackgroundMutationOptions = <
    TError = void | void | void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>,
        TError,
        { data: IdeogramV3ReplaceBackgroundRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>,
    TError,
    { data: IdeogramV3ReplaceBackgroundRequest },
    TContext
> => {
    const mutationKey = ["ideogramV3ReplaceBackground"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>,
        { data: IdeogramV3ReplaceBackgroundRequest }
    > = (props) => {
        const { data } = props ?? {};

        return ideogramV3ReplaceBackground(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type IdeogramV3ReplaceBackgroundMutationResult = NonNullable<
    Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>
>;
export type IdeogramV3ReplaceBackgroundMutationBody =
    IdeogramV3ReplaceBackgroundRequest;
export type IdeogramV3ReplaceBackgroundMutationError =
    | void
    | void
    | void
    | void;

/**
 * @summary Replace background of an image using a prompt
 */
export const useIdeogramV3ReplaceBackground = <
    TError = void | void | void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>,
            TError,
            { data: IdeogramV3ReplaceBackgroundRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof ideogramV3ReplaceBackground>>,
    TError,
    { data: IdeogramV3ReplaceBackgroundRequest },
    TContext
> => {
    const mutationOptions =
        getIdeogramV3ReplaceBackgroundMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary KlingAI Query Resource Package Information
 */
export const klingQueryResourcePackages = (
    params: KlingQueryResourcePackagesParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingResourcePackageResponse>(
        { url: `/proxy/kling/v1/account/costs`, method: "GET", params, signal },
        options,
    );
};

export const getKlingQueryResourcePackagesQueryKey = (
    params?: KlingQueryResourcePackagesParams,
) => {
    return [
        `/proxy/kling/v1/account/costs`,
        ...(params ? [params] : []),
    ] as const;
};

export const getKlingQueryResourcePackagesQueryOptions = <
    TData = Awaited<ReturnType<typeof klingQueryResourcePackages>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: KlingQueryResourcePackagesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingQueryResourcePackages>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getKlingQueryResourcePackagesQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingQueryResourcePackages>>
    > = ({ signal }) =>
        klingQueryResourcePackages(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof klingQueryResourcePackages>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingQueryResourcePackagesQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingQueryResourcePackages>>
>;
export type KlingQueryResourcePackagesQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingQueryResourcePackages<
    TData = Awaited<ReturnType<typeof klingQueryResourcePackages>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: KlingQueryResourcePackagesParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingQueryResourcePackages>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingQueryResourcePackages>>,
                    TError,
                    Awaited<ReturnType<typeof klingQueryResourcePackages>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingQueryResourcePackages<
    TData = Awaited<ReturnType<typeof klingQueryResourcePackages>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: KlingQueryResourcePackagesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingQueryResourcePackages>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingQueryResourcePackages>>,
                    TError,
                    Awaited<ReturnType<typeof klingQueryResourcePackages>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingQueryResourcePackages<
    TData = Awaited<ReturnType<typeof klingQueryResourcePackages>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: KlingQueryResourcePackagesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingQueryResourcePackages>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Resource Package Information
 */

export function useKlingQueryResourcePackages<
    TData = Awaited<ReturnType<typeof klingQueryResourcePackages>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: KlingQueryResourcePackagesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingQueryResourcePackages>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingQueryResourcePackagesQueryOptions(
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Query Image Generation Task List
 */
export const klingImageGenerationsQueryTaskList = (
    params?: KlingImageGenerationsQueryTaskListParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingImageGenerationsResponse>(
        {
            url: `/proxy/kling/v1/images/generations`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getKlingImageGenerationsQueryTaskListQueryKey = (
    params?: KlingImageGenerationsQueryTaskListParams,
) => {
    return [
        `/proxy/kling/v1/images/generations`,
        ...(params ? [params] : []),
    ] as const;
};

export const getKlingImageGenerationsQueryTaskListQueryOptions = <
    TData = Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingImageGenerationsQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getKlingImageGenerationsQueryTaskListQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>
    > = ({ signal }) =>
        klingImageGenerationsQueryTaskList(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingImageGenerationsQueryTaskListQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>
>;
export type KlingImageGenerationsQueryTaskListQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingImageGenerationsQueryTaskList<
    TData = Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: undefined | KlingImageGenerationsQueryTaskListParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof klingImageGenerationsQueryTaskList>
                    >,
                    TError,
                    Awaited<
                        ReturnType<typeof klingImageGenerationsQueryTaskList>
                    >
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingImageGenerationsQueryTaskList<
    TData = Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingImageGenerationsQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof klingImageGenerationsQueryTaskList>
                    >,
                    TError,
                    Awaited<
                        ReturnType<typeof klingImageGenerationsQueryTaskList>
                    >
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingImageGenerationsQueryTaskList<
    TData = Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingImageGenerationsQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Image Generation Task List
 */

export function useKlingImageGenerationsQueryTaskList<
    TData = Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingImageGenerationsQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImageGenerationsQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingImageGenerationsQueryTaskListQueryOptions(
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Create Image Generation Task
 */
export const klingCreateImageGeneration = (
    klingImageGenerationsRequest: KlingImageGenerationsRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingImageGenerationsResponse>(
        {
            url: `/proxy/kling/v1/images/generations`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: klingImageGenerationsRequest,
            signal,
        },
        options,
    );
};

export const getKlingCreateImageGenerationMutationOptions = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof klingCreateImageGeneration>>,
        TError,
        { data: KlingImageGenerationsRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof klingCreateImageGeneration>>,
    TError,
    { data: KlingImageGenerationsRequest },
    TContext
> => {
    const mutationKey = ["klingCreateImageGeneration"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof klingCreateImageGeneration>>,
        { data: KlingImageGenerationsRequest }
    > = (props) => {
        const { data } = props ?? {};

        return klingCreateImageGeneration(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type KlingCreateImageGenerationMutationResult = NonNullable<
    Awaited<ReturnType<typeof klingCreateImageGeneration>>
>;
export type KlingCreateImageGenerationMutationBody =
    KlingImageGenerationsRequest;
export type KlingCreateImageGenerationMutationError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

/**
 * @summary KlingAI Create Image Generation Task
 */
export const useKlingCreateImageGeneration = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof klingCreateImageGeneration>>,
            TError,
            { data: KlingImageGenerationsRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof klingCreateImageGeneration>>,
    TError,
    { data: KlingImageGenerationsRequest },
    TContext
> => {
    const mutationOptions =
        getKlingCreateImageGenerationMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary KlingAI Query Single Image Generation Task
 */
export const klingImageGenerationsQuerySingleTask = (
    id: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingImageGenerationsResponse>(
        {
            url: `/proxy/kling/v1/images/generations/${id}`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getKlingImageGenerationsQuerySingleTaskQueryKey = (
    id?: string,
) => {
    return [`/proxy/kling/v1/images/generations/${id}`] as const;
};

export const getKlingImageGenerationsQuerySingleTaskQueryOptions = <
    TData = Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<
                    ReturnType<typeof klingImageGenerationsQuerySingleTask>
                >,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getKlingImageGenerationsQuerySingleTaskQueryKey(id);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>
    > = ({ signal }) =>
        klingImageGenerationsQuerySingleTask(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingImageGenerationsQuerySingleTaskQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>
>;
export type KlingImageGenerationsQuerySingleTaskQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingImageGenerationsQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<
                    ReturnType<typeof klingImageGenerationsQuerySingleTask>
                >,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof klingImageGenerationsQuerySingleTask>
                    >,
                    TError,
                    Awaited<
                        ReturnType<typeof klingImageGenerationsQuerySingleTask>
                    >
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingImageGenerationsQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<
                    ReturnType<typeof klingImageGenerationsQuerySingleTask>
                >,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof klingImageGenerationsQuerySingleTask>
                    >,
                    TError,
                    Awaited<
                        ReturnType<typeof klingImageGenerationsQuerySingleTask>
                    >
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingImageGenerationsQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<
                    ReturnType<typeof klingImageGenerationsQuerySingleTask>
                >,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Single Image Generation Task
 */

export function useKlingImageGenerationsQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingImageGenerationsQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<
                    ReturnType<typeof klingImageGenerationsQuerySingleTask>
                >,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingImageGenerationsQuerySingleTaskQueryOptions(
        id,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Query Virtual Try-On Task List
 */
export const klingVirtualTryOnQueryTaskList = (
    params?: KlingVirtualTryOnQueryTaskListParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingVirtualTryOnResponse>(
        {
            url: `/proxy/kling/v1/images/kolors-virtual-try-on`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getKlingVirtualTryOnQueryTaskListQueryKey = (
    params?: KlingVirtualTryOnQueryTaskListParams,
) => {
    return [
        `/proxy/kling/v1/images/kolors-virtual-try-on`,
        ...(params ? [params] : []),
    ] as const;
};

export const getKlingVirtualTryOnQueryTaskListQueryOptions = <
    TData = Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVirtualTryOnQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getKlingVirtualTryOnQueryTaskListQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>
    > = ({ signal }) =>
        klingVirtualTryOnQueryTaskList(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingVirtualTryOnQueryTaskListQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>
>;
export type KlingVirtualTryOnQueryTaskListQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingVirtualTryOnQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: undefined | KlingVirtualTryOnQueryTaskListParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVirtualTryOnQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVirtualTryOnQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVirtualTryOnQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVirtualTryOnQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Virtual Try-On Task List
 */

export function useKlingVirtualTryOnQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVirtualTryOnQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVirtualTryOnQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingVirtualTryOnQueryTaskListQueryOptions(
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Create Virtual Try-On Task
 */
export const klingCreateVirtualTryOn = (
    klingVirtualTryOnRequest: KlingVirtualTryOnRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingVirtualTryOnResponse>(
        {
            url: `/proxy/kling/v1/images/kolors-virtual-try-on`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: klingVirtualTryOnRequest,
            signal,
        },
        options,
    );
};

export const getKlingCreateVirtualTryOnMutationOptions = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof klingCreateVirtualTryOn>>,
        TError,
        { data: KlingVirtualTryOnRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof klingCreateVirtualTryOn>>,
    TError,
    { data: KlingVirtualTryOnRequest },
    TContext
> => {
    const mutationKey = ["klingCreateVirtualTryOn"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof klingCreateVirtualTryOn>>,
        { data: KlingVirtualTryOnRequest }
    > = (props) => {
        const { data } = props ?? {};

        return klingCreateVirtualTryOn(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type KlingCreateVirtualTryOnMutationResult = NonNullable<
    Awaited<ReturnType<typeof klingCreateVirtualTryOn>>
>;
export type KlingCreateVirtualTryOnMutationBody = KlingVirtualTryOnRequest;
export type KlingCreateVirtualTryOnMutationError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

/**
 * @summary KlingAI Create Virtual Try-On Task
 */
export const useKlingCreateVirtualTryOn = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof klingCreateVirtualTryOn>>,
            TError,
            { data: KlingVirtualTryOnRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof klingCreateVirtualTryOn>>,
    TError,
    { data: KlingVirtualTryOnRequest },
    TContext
> => {
    const mutationOptions = getKlingCreateVirtualTryOnMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary KlingAI Query Single Virtual Try-On Task
 */
export const klingVirtualTryOnQuerySingleTask = (
    id: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingVirtualTryOnResponse>(
        {
            url: `/proxy/kling/v1/images/kolors-virtual-try-on/${id}`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getKlingVirtualTryOnQuerySingleTaskQueryKey = (id?: string) => {
    return [`/proxy/kling/v1/images/kolors-virtual-try-on/${id}`] as const;
};

export const getKlingVirtualTryOnQuerySingleTaskQueryOptions = <
    TData = Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getKlingVirtualTryOnQuerySingleTaskQueryKey(id);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>
    > = ({ signal }) =>
        klingVirtualTryOnQuerySingleTask(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingVirtualTryOnQuerySingleTaskQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>
>;
export type KlingVirtualTryOnQuerySingleTaskQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingVirtualTryOnQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof klingVirtualTryOnQuerySingleTask>
                    >,
                    TError,
                    Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVirtualTryOnQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof klingVirtualTryOnQuerySingleTask>
                    >,
                    TError,
                    Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVirtualTryOnQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Single Virtual Try-On Task
 */

export function useKlingVirtualTryOnQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVirtualTryOnQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingVirtualTryOnQuerySingleTaskQueryOptions(
        id,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Query Video Effects Task List
 */
export const klingVideoEffectsQueryTaskList = (
    params?: KlingVideoEffectsQueryTaskListParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingVideoEffectsResponse>(
        {
            url: `/proxy/kling/v1/videos/effects`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getKlingVideoEffectsQueryTaskListQueryKey = (
    params?: KlingVideoEffectsQueryTaskListParams,
) => {
    return [
        `/proxy/kling/v1/videos/effects`,
        ...(params ? [params] : []),
    ] as const;
};

export const getKlingVideoEffectsQueryTaskListQueryOptions = <
    TData = Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVideoEffectsQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getKlingVideoEffectsQueryTaskListQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>
    > = ({ signal }) =>
        klingVideoEffectsQueryTaskList(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingVideoEffectsQueryTaskListQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>
>;
export type KlingVideoEffectsQueryTaskListQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingVideoEffectsQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: undefined | KlingVideoEffectsQueryTaskListParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVideoEffectsQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVideoEffectsQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVideoEffectsQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVideoEffectsQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Video Effects Task List
 */

export function useKlingVideoEffectsQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVideoEffectsQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoEffectsQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingVideoEffectsQueryTaskListQueryOptions(
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Create Video Effects Task
 */
export const klingCreateVideoEffects = (
    klingVideoEffectsRequest: KlingVideoEffectsRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingVideoEffectsResponse>(
        {
            url: `/proxy/kling/v1/videos/effects`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: klingVideoEffectsRequest,
            signal,
        },
        options,
    );
};

export const getKlingCreateVideoEffectsMutationOptions = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof klingCreateVideoEffects>>,
        TError,
        { data: KlingVideoEffectsRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof klingCreateVideoEffects>>,
    TError,
    { data: KlingVideoEffectsRequest },
    TContext
> => {
    const mutationKey = ["klingCreateVideoEffects"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof klingCreateVideoEffects>>,
        { data: KlingVideoEffectsRequest }
    > = (props) => {
        const { data } = props ?? {};

        return klingCreateVideoEffects(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type KlingCreateVideoEffectsMutationResult = NonNullable<
    Awaited<ReturnType<typeof klingCreateVideoEffects>>
>;
export type KlingCreateVideoEffectsMutationBody = KlingVideoEffectsRequest;
export type KlingCreateVideoEffectsMutationError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

/**
 * @summary KlingAI Create Video Effects Task
 */
export const useKlingCreateVideoEffects = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof klingCreateVideoEffects>>,
            TError,
            { data: KlingVideoEffectsRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof klingCreateVideoEffects>>,
    TError,
    { data: KlingVideoEffectsRequest },
    TContext
> => {
    const mutationOptions = getKlingCreateVideoEffectsMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary KlingAI Query Single Video Effects Task
 */
export const klingVideoEffectsQuerySingleTask = (
    id: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingVideoEffectsResponse>(
        { url: `/proxy/kling/v1/videos/effects/${id}`, method: "GET", signal },
        options,
    );
};

export const getKlingVideoEffectsQuerySingleTaskQueryKey = (id?: string) => {
    return [`/proxy/kling/v1/videos/effects/${id}`] as const;
};

export const getKlingVideoEffectsQuerySingleTaskQueryOptions = <
    TData = Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getKlingVideoEffectsQuerySingleTaskQueryKey(id);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>
    > = ({ signal }) =>
        klingVideoEffectsQuerySingleTask(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingVideoEffectsQuerySingleTaskQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>
>;
export type KlingVideoEffectsQuerySingleTaskQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingVideoEffectsQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof klingVideoEffectsQuerySingleTask>
                    >,
                    TError,
                    Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVideoEffectsQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof klingVideoEffectsQuerySingleTask>
                    >,
                    TError,
                    Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVideoEffectsQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Single Video Effects Task
 */

export function useKlingVideoEffectsQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoEffectsQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingVideoEffectsQuerySingleTaskQueryOptions(
        id,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Query Image2Video Task List
 */
export const klingImage2VideoQueryTaskList = (
    params?: KlingImage2VideoQueryTaskListParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingImage2VideoResponse>(
        {
            url: `/proxy/kling/v1/videos/image2video`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getKlingImage2VideoQueryTaskListQueryKey = (
    params?: KlingImage2VideoQueryTaskListParams,
) => {
    return [
        `/proxy/kling/v1/videos/image2video`,
        ...(params ? [params] : []),
    ] as const;
};

export const getKlingImage2VideoQueryTaskListQueryOptions = <
    TData = Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingImage2VideoQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getKlingImage2VideoQueryTaskListQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>
    > = ({ signal }) =>
        klingImage2VideoQueryTaskList(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingImage2VideoQueryTaskListQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>
>;
export type KlingImage2VideoQueryTaskListQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingImage2VideoQueryTaskList<
    TData = Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: undefined | KlingImage2VideoQueryTaskListParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingImage2VideoQueryTaskList<
    TData = Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingImage2VideoQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingImage2VideoQueryTaskList<
    TData = Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingImage2VideoQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Image2Video Task List
 */

export function useKlingImage2VideoQueryTaskList<
    TData = Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingImage2VideoQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImage2VideoQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingImage2VideoQueryTaskListQueryOptions(
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Create Video from Image
 */
export const klingCreateVideoFromImage = (
    klingImage2VideoRequest: KlingImage2VideoRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingImage2VideoResponse>(
        {
            url: `/proxy/kling/v1/videos/image2video`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: klingImage2VideoRequest,
            signal,
        },
        options,
    );
};

export const getKlingCreateVideoFromImageMutationOptions = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof klingCreateVideoFromImage>>,
        TError,
        { data: KlingImage2VideoRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof klingCreateVideoFromImage>>,
    TError,
    { data: KlingImage2VideoRequest },
    TContext
> => {
    const mutationKey = ["klingCreateVideoFromImage"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof klingCreateVideoFromImage>>,
        { data: KlingImage2VideoRequest }
    > = (props) => {
        const { data } = props ?? {};

        return klingCreateVideoFromImage(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type KlingCreateVideoFromImageMutationResult = NonNullable<
    Awaited<ReturnType<typeof klingCreateVideoFromImage>>
>;
export type KlingCreateVideoFromImageMutationBody = KlingImage2VideoRequest;
export type KlingCreateVideoFromImageMutationError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

/**
 * @summary KlingAI Create Video from Image
 */
export const useKlingCreateVideoFromImage = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof klingCreateVideoFromImage>>,
            TError,
            { data: KlingImage2VideoRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof klingCreateVideoFromImage>>,
    TError,
    { data: KlingImage2VideoRequest },
    TContext
> => {
    const mutationOptions =
        getKlingCreateVideoFromImageMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary KlingAI Query Single Image2Video Task
 */
export const klingImage2VideoQuerySingleTask = (
    id: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingImage2VideoResponse>(
        {
            url: `/proxy/kling/v1/videos/image2video/${id}`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getKlingImage2VideoQuerySingleTaskQueryKey = (id?: string) => {
    return [`/proxy/kling/v1/videos/image2video/${id}`] as const;
};

export const getKlingImage2VideoQuerySingleTaskQueryOptions = <
    TData = Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getKlingImage2VideoQuerySingleTaskQueryKey(id);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>
    > = ({ signal }) =>
        klingImage2VideoQuerySingleTask(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingImage2VideoQuerySingleTaskQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>
>;
export type KlingImage2VideoQuerySingleTaskQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingImage2VideoQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
                    TError,
                    Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingImage2VideoQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
                    TError,
                    Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingImage2VideoQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Single Image2Video Task
 */

export function useKlingImage2VideoQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingImage2VideoQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingImage2VideoQuerySingleTaskQueryOptions(
        id,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Query Lip-Sync Task List
 */
export const klingLipSyncQueryTaskList = (
    params?: KlingLipSyncQueryTaskListParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingLipSyncResponse>(
        {
            url: `/proxy/kling/v1/videos/lip-sync`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getKlingLipSyncQueryTaskListQueryKey = (
    params?: KlingLipSyncQueryTaskListParams,
) => {
    return [
        `/proxy/kling/v1/videos/lip-sync`,
        ...(params ? [params] : []),
    ] as const;
};

export const getKlingLipSyncQueryTaskListQueryOptions = <
    TData = Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingLipSyncQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getKlingLipSyncQueryTaskListQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>
    > = ({ signal }) =>
        klingLipSyncQueryTaskList(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingLipSyncQueryTaskListQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>
>;
export type KlingLipSyncQueryTaskListQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingLipSyncQueryTaskList<
    TData = Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: undefined | KlingLipSyncQueryTaskListParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingLipSyncQueryTaskList<
    TData = Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingLipSyncQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingLipSyncQueryTaskList<
    TData = Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingLipSyncQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Lip-Sync Task List
 */

export function useKlingLipSyncQueryTaskList<
    TData = Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingLipSyncQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingLipSyncQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingLipSyncQueryTaskListQueryOptions(
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Create Lip-Sync Video
 */
export const klingCreateLipSyncVideo = (
    klingLipSyncRequest: KlingLipSyncRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingLipSyncResponse>(
        {
            url: `/proxy/kling/v1/videos/lip-sync`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: klingLipSyncRequest,
            signal,
        },
        options,
    );
};

export const getKlingCreateLipSyncVideoMutationOptions = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof klingCreateLipSyncVideo>>,
        TError,
        { data: KlingLipSyncRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof klingCreateLipSyncVideo>>,
    TError,
    { data: KlingLipSyncRequest },
    TContext
> => {
    const mutationKey = ["klingCreateLipSyncVideo"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof klingCreateLipSyncVideo>>,
        { data: KlingLipSyncRequest }
    > = (props) => {
        const { data } = props ?? {};

        return klingCreateLipSyncVideo(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type KlingCreateLipSyncVideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof klingCreateLipSyncVideo>>
>;
export type KlingCreateLipSyncVideoMutationBody = KlingLipSyncRequest;
export type KlingCreateLipSyncVideoMutationError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

/**
 * @summary KlingAI Create Lip-Sync Video
 */
export const useKlingCreateLipSyncVideo = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof klingCreateLipSyncVideo>>,
            TError,
            { data: KlingLipSyncRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof klingCreateLipSyncVideo>>,
    TError,
    { data: KlingLipSyncRequest },
    TContext
> => {
    const mutationOptions = getKlingCreateLipSyncVideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary KlingAI Query Single Lip-Sync Task
 */
export const klingLipSyncQuerySingleTask = (
    id: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingLipSyncResponse>(
        { url: `/proxy/kling/v1/videos/lip-sync/${id}`, method: "GET", signal },
        options,
    );
};

export const getKlingLipSyncQuerySingleTaskQueryKey = (id?: string) => {
    return [`/proxy/kling/v1/videos/lip-sync/${id}`] as const;
};

export const getKlingLipSyncQuerySingleTaskQueryOptions = <
    TData = Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getKlingLipSyncQuerySingleTaskQueryKey(id);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>
    > = ({ signal }) => klingLipSyncQuerySingleTask(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingLipSyncQuerySingleTaskQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>
>;
export type KlingLipSyncQuerySingleTaskQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingLipSyncQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
                    TError,
                    Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingLipSyncQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
                    TError,
                    Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingLipSyncQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Single Lip-Sync Task
 */

export function useKlingLipSyncQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingLipSyncQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingLipSyncQuerySingleTaskQueryOptions(
        id,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Query Task List
 */
export const klingText2VideoQueryTaskList = (
    params?: KlingText2VideoQueryTaskListParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingText2VideoResponse>(
        {
            url: `/proxy/kling/v1/videos/text2video`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getKlingText2VideoQueryTaskListQueryKey = (
    params?: KlingText2VideoQueryTaskListParams,
) => {
    return [
        `/proxy/kling/v1/videos/text2video`,
        ...(params ? [params] : []),
    ] as const;
};

export const getKlingText2VideoQueryTaskListQueryOptions = <
    TData = Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingText2VideoQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getKlingText2VideoQueryTaskListQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>
    > = ({ signal }) =>
        klingText2VideoQueryTaskList(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingText2VideoQueryTaskListQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>
>;
export type KlingText2VideoQueryTaskListQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingText2VideoQueryTaskList<
    TData = Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: undefined | KlingText2VideoQueryTaskListParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingText2VideoQueryTaskList<
    TData = Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingText2VideoQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingText2VideoQueryTaskList<
    TData = Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingText2VideoQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Task List
 */

export function useKlingText2VideoQueryTaskList<
    TData = Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingText2VideoQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingText2VideoQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingText2VideoQueryTaskListQueryOptions(
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Create Video from Text
 */
export const klingCreateVideoFromText = (
    klingText2VideoRequest: KlingText2VideoRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingText2VideoResponse>(
        {
            url: `/proxy/kling/v1/videos/text2video`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: klingText2VideoRequest,
            signal,
        },
        options,
    );
};

export const getKlingCreateVideoFromTextMutationOptions = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof klingCreateVideoFromText>>,
        TError,
        { data: KlingText2VideoRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof klingCreateVideoFromText>>,
    TError,
    { data: KlingText2VideoRequest },
    TContext
> => {
    const mutationKey = ["klingCreateVideoFromText"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof klingCreateVideoFromText>>,
        { data: KlingText2VideoRequest }
    > = (props) => {
        const { data } = props ?? {};

        return klingCreateVideoFromText(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type KlingCreateVideoFromTextMutationResult = NonNullable<
    Awaited<ReturnType<typeof klingCreateVideoFromText>>
>;
export type KlingCreateVideoFromTextMutationBody = KlingText2VideoRequest;
export type KlingCreateVideoFromTextMutationError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

/**
 * @summary KlingAI Create Video from Text
 */
export const useKlingCreateVideoFromText = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof klingCreateVideoFromText>>,
            TError,
            { data: KlingText2VideoRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof klingCreateVideoFromText>>,
    TError,
    { data: KlingText2VideoRequest },
    TContext
> => {
    const mutationOptions = getKlingCreateVideoFromTextMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary KlingAI Query Single Task
 */
export const klingText2VideoQuerySingleTask = (
    id: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingText2VideoResponse>(
        {
            url: `/proxy/kling/v1/videos/text2video/${id}`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getKlingText2VideoQuerySingleTaskQueryKey = (id?: string) => {
    return [`/proxy/kling/v1/videos/text2video/${id}`] as const;
};

export const getKlingText2VideoQuerySingleTaskQueryOptions = <
    TData = Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getKlingText2VideoQuerySingleTaskQueryKey(id);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>
    > = ({ signal }) =>
        klingText2VideoQuerySingleTask(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingText2VideoQuerySingleTaskQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>
>;
export type KlingText2VideoQuerySingleTaskQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingText2VideoQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
                    TError,
                    Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingText2VideoQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
                    TError,
                    Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingText2VideoQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Single Task
 */

export function useKlingText2VideoQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingText2VideoQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingText2VideoQuerySingleTaskQueryOptions(
        id,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Query Video-Extend Task List
 */
export const klingVideoExtendQueryTaskList = (
    params?: KlingVideoExtendQueryTaskListParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingVideoExtendResponse>(
        {
            url: `/proxy/kling/v1/videos/video-extend`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getKlingVideoExtendQueryTaskListQueryKey = (
    params?: KlingVideoExtendQueryTaskListParams,
) => {
    return [
        `/proxy/kling/v1/videos/video-extend`,
        ...(params ? [params] : []),
    ] as const;
};

export const getKlingVideoExtendQueryTaskListQueryOptions = <
    TData = Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVideoExtendQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getKlingVideoExtendQueryTaskListQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>
    > = ({ signal }) =>
        klingVideoExtendQueryTaskList(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingVideoExtendQueryTaskListQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>
>;
export type KlingVideoExtendQueryTaskListQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingVideoExtendQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params: undefined | KlingVideoExtendQueryTaskListParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVideoExtendQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVideoExtendQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
                    TError,
                    Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVideoExtendQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVideoExtendQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Video-Extend Task List
 */

export function useKlingVideoExtendQueryTaskList<
    TData = Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    params?: KlingVideoExtendQueryTaskListParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoExtendQueryTaskList>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingVideoExtendQueryTaskListQueryOptions(
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary KlingAI Extend Video Duration
 */
export const klingExtendVideo = (
    klingVideoExtendRequest: KlingVideoExtendRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingVideoExtendResponse>(
        {
            url: `/proxy/kling/v1/videos/video-extend`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: klingVideoExtendRequest,
            signal,
        },
        options,
    );
};

export const getKlingExtendVideoMutationOptions = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof klingExtendVideo>>,
        TError,
        { data: KlingVideoExtendRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof klingExtendVideo>>,
    TError,
    { data: KlingVideoExtendRequest },
    TContext
> => {
    const mutationKey = ["klingExtendVideo"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof klingExtendVideo>>,
        { data: KlingVideoExtendRequest }
    > = (props) => {
        const { data } = props ?? {};

        return klingExtendVideo(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type KlingExtendVideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof klingExtendVideo>>
>;
export type KlingExtendVideoMutationBody = KlingVideoExtendRequest;
export type KlingExtendVideoMutationError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

/**
 * @summary KlingAI Extend Video Duration
 */
export const useKlingExtendVideo = <
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof klingExtendVideo>>,
            TError,
            { data: KlingVideoExtendRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof klingExtendVideo>>,
    TError,
    { data: KlingVideoExtendRequest },
    TContext
> => {
    const mutationOptions = getKlingExtendVideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary KlingAI Query Single Video-Extend Task
 */
export const klingVideoExtendQuerySingleTask = (
    id: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<KlingVideoExtendResponse>(
        {
            url: `/proxy/kling/v1/videos/video-extend/${id}`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getKlingVideoExtendQuerySingleTaskQueryKey = (id?: string) => {
    return [`/proxy/kling/v1/videos/video-extend/${id}`] as const;
};

export const getKlingVideoExtendQuerySingleTaskQueryOptions = <
    TData = Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getKlingVideoExtendQuerySingleTaskQueryKey(id);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>
    > = ({ signal }) =>
        klingVideoExtendQuerySingleTask(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KlingVideoExtendQuerySingleTaskQueryResult = NonNullable<
    Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>
>;
export type KlingVideoExtendQuerySingleTaskQueryError =
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse
    | KlingErrorResponse;

export function useKlingVideoExtendQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
                    TError,
                    Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVideoExtendQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
                    TError,
                    Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useKlingVideoExtendQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary KlingAI Query Single Video-Extend Task
 */

export function useKlingVideoExtendQuerySingleTask<
    TData = Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
    TError =
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse
        | KlingErrorResponse,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof klingVideoExtendQuerySingleTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getKlingVideoExtendQuerySingleTaskQueryOptions(
        id,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Initiate a new generation with the provided prompt
 * @summary Create a generation
 */
export const lumaCreateGeneration = (
    lumaGenerationRequest: LumaGenerationRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<LumaGeneration>(
        {
            url: `/proxy/luma/generations`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: lumaGenerationRequest,
            signal,
        },
        options,
    );
};

export const getLumaCreateGenerationMutationOptions = <
    TError = LumaError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof lumaCreateGeneration>>,
        TError,
        { data: LumaGenerationRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof lumaCreateGeneration>>,
    TError,
    { data: LumaGenerationRequest },
    TContext
> => {
    const mutationKey = ["lumaCreateGeneration"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof lumaCreateGeneration>>,
        { data: LumaGenerationRequest }
    > = (props) => {
        const { data } = props ?? {};

        return lumaCreateGeneration(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type LumaCreateGenerationMutationResult = NonNullable<
    Awaited<ReturnType<typeof lumaCreateGeneration>>
>;
export type LumaCreateGenerationMutationBody = LumaGenerationRequest;
export type LumaCreateGenerationMutationError = LumaError;

/**
 * @summary Create a generation
 */
export const useLumaCreateGeneration = <TError = LumaError, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof lumaCreateGeneration>>,
            TError,
            { data: LumaGenerationRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof lumaCreateGeneration>>,
    TError,
    { data: LumaGenerationRequest },
    TContext
> => {
    const mutationOptions = getLumaCreateGenerationMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Generate an image with the provided prompt
 * @summary Generate an image
 */
export const lumaGenerateImage = (
    lumaImageGenerationRequest: LumaImageGenerationRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<LumaGeneration>(
        {
            url: `/proxy/luma/generations/image`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: lumaImageGenerationRequest,
            signal,
        },
        options,
    );
};

export const getLumaGenerateImageMutationOptions = <
    TError = LumaError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof lumaGenerateImage>>,
        TError,
        { data: LumaImageGenerationRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof lumaGenerateImage>>,
    TError,
    { data: LumaImageGenerationRequest },
    TContext
> => {
    const mutationKey = ["lumaGenerateImage"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof lumaGenerateImage>>,
        { data: LumaImageGenerationRequest }
    > = (props) => {
        const { data } = props ?? {};

        return lumaGenerateImage(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type LumaGenerateImageMutationResult = NonNullable<
    Awaited<ReturnType<typeof lumaGenerateImage>>
>;
export type LumaGenerateImageMutationBody = LumaImageGenerationRequest;
export type LumaGenerateImageMutationError = LumaError;

/**
 * @summary Generate an image
 */
export const useLumaGenerateImage = <TError = LumaError, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof lumaGenerateImage>>,
            TError,
            { data: LumaImageGenerationRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof lumaGenerateImage>>,
    TError,
    { data: LumaImageGenerationRequest },
    TContext
> => {
    const mutationOptions = getLumaGenerateImageMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve details of a specific generation by its ID
 * @summary Get a generation
 */
export const lumaGetGeneration = (
    id: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<LumaGeneration>(
        { url: `/proxy/luma/generations/${id}`, method: "GET", signal },
        options,
    );
};

export const getLumaGetGenerationQueryKey = (id?: string) => {
    return [`/proxy/luma/generations/${id}`] as const;
};

export const getLumaGetGenerationQueryOptions = <
    TData = Awaited<ReturnType<typeof lumaGetGeneration>>,
    TError = LumaError,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof lumaGetGeneration>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getLumaGetGenerationQueryKey(id);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof lumaGetGeneration>>
    > = ({ signal }) => lumaGetGeneration(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof lumaGetGeneration>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LumaGetGenerationQueryResult = NonNullable<
    Awaited<ReturnType<typeof lumaGetGeneration>>
>;
export type LumaGetGenerationQueryError = LumaError;

export function useLumaGetGeneration<
    TData = Awaited<ReturnType<typeof lumaGetGeneration>>,
    TError = LumaError,
>(
    id: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof lumaGetGeneration>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof lumaGetGeneration>>,
                    TError,
                    Awaited<ReturnType<typeof lumaGetGeneration>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLumaGetGeneration<
    TData = Awaited<ReturnType<typeof lumaGetGeneration>>,
    TError = LumaError,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof lumaGetGeneration>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof lumaGetGeneration>>,
                    TError,
                    Awaited<ReturnType<typeof lumaGetGeneration>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLumaGetGeneration<
    TData = Awaited<ReturnType<typeof lumaGetGeneration>>,
    TError = LumaError,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof lumaGetGeneration>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a generation
 */

export function useLumaGetGeneration<
    TData = Awaited<ReturnType<typeof lumaGetGeneration>>,
    TError = LumaError,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof lumaGetGeneration>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getLumaGetGenerationQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Proxies a request to Minimax to get the download URL for a file
 * @summary Retrieve download URL for a Minimax file
 */
export const retrieveMinimaxFile = (
    params: RetrieveMinimaxFileParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<MinimaxFileRetrieveResponse>(
        {
            url: `/proxy/minimax/files/retrieve`,
            method: "POST",
            params,
            signal,
        },
        options,
    );
};

export const getRetrieveMinimaxFileMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof retrieveMinimaxFile>>,
        TError,
        { params: RetrieveMinimaxFileParams },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof retrieveMinimaxFile>>,
    TError,
    { params: RetrieveMinimaxFileParams },
    TContext
> => {
    const mutationKey = ["retrieveMinimaxFile"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof retrieveMinimaxFile>>,
        { params: RetrieveMinimaxFileParams }
    > = (props) => {
        const { params } = props ?? {};

        return retrieveMinimaxFile(params, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RetrieveMinimaxFileMutationResult = NonNullable<
    Awaited<ReturnType<typeof retrieveMinimaxFile>>
>;

export type RetrieveMinimaxFileMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Retrieve download URL for a Minimax file
 */
export const useRetrieveMinimaxFile = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof retrieveMinimaxFile>>,
            TError,
            { params: RetrieveMinimaxFileParams },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof retrieveMinimaxFile>>,
    TError,
    { params: RetrieveMinimaxFileParams },
    TContext
> => {
    const mutationOptions = getRetrieveMinimaxFileMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Proxies a request to Minimax to check the status of a video generation task
 * @summary Query status of a Minimax video generation task
 */
export const getMinimaxVideoGeneration = (
    params: GetMinimaxVideoGenerationParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<MinimaxTaskResultResponse>(
        {
            url: `/proxy/minimax/query/video_generation`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getGetMinimaxVideoGenerationQueryKey = (
    params?: GetMinimaxVideoGenerationParams,
) => {
    return [
        `/proxy/minimax/query/video_generation`,
        ...(params ? [params] : []),
    ] as const;
};

export const getGetMinimaxVideoGenerationQueryOptions = <
    TData = Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
>(
    params: GetMinimaxVideoGenerationParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetMinimaxVideoGenerationQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getMinimaxVideoGeneration>>
    > = ({ signal }) =>
        getMinimaxVideoGeneration(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMinimaxVideoGenerationQueryResult = NonNullable<
    Awaited<ReturnType<typeof getMinimaxVideoGeneration>>
>;
export type GetMinimaxVideoGenerationQueryError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

export function useGetMinimaxVideoGeneration<
    TData = Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
>(
    params: GetMinimaxVideoGenerationParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
                    TError,
                    Awaited<ReturnType<typeof getMinimaxVideoGeneration>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMinimaxVideoGeneration<
    TData = Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
>(
    params: GetMinimaxVideoGenerationParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
                    TError,
                    Awaited<ReturnType<typeof getMinimaxVideoGeneration>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMinimaxVideoGeneration<
    TData = Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
>(
    params: GetMinimaxVideoGenerationParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Query status of a Minimax video generation task
 */

export function useGetMinimaxVideoGeneration<
    TData = Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
>(
    params: GetMinimaxVideoGenerationParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getMinimaxVideoGeneration>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetMinimaxVideoGenerationQueryOptions(
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Forwards video generation requests to Minimax's API and returns the task ID for asynchronous processing.
 * @summary Proxy request to Minimax for video generation
 */
export const minimaxVideoGeneration = (
    minimaxVideoGenerationRequest: MinimaxVideoGenerationRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<MinimaxVideoGenerationResponse>(
        {
            url: `/proxy/minimax/video_generation`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: minimaxVideoGenerationRequest,
            signal,
        },
        options,
    );
};

export const getMinimaxVideoGenerationMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof minimaxVideoGeneration>>,
        TError,
        { data: MinimaxVideoGenerationRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof minimaxVideoGeneration>>,
    TError,
    { data: MinimaxVideoGenerationRequest },
    TContext
> => {
    const mutationKey = ["minimaxVideoGeneration"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof minimaxVideoGeneration>>,
        { data: MinimaxVideoGenerationRequest }
    > = (props) => {
        const { data } = props ?? {};

        return minimaxVideoGeneration(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type MinimaxVideoGenerationMutationResult = NonNullable<
    Awaited<ReturnType<typeof minimaxVideoGeneration>>
>;
export type MinimaxVideoGenerationMutationBody = MinimaxVideoGenerationRequest;
export type MinimaxVideoGenerationMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Proxy request to Minimax for video generation
 */
export const useMinimaxVideoGeneration = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof minimaxVideoGeneration>>,
            TError,
            { data: MinimaxVideoGenerationRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof minimaxVideoGeneration>>,
    TError,
    { data: MinimaxVideoGenerationRequest },
    TContext
> => {
    const mutationOptions = getMinimaxVideoGenerationMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create Image to Video Prompt
 */
export const moonvalleyImageToVideo = (
    moonvalleyImageToVideoRequest: MoonvalleyImageToVideoRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<MoonvalleyPromptResponse>(
        {
            url: `/proxy/moonvalley/prompts/image-to-video`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: moonvalleyImageToVideoRequest,
            signal,
        },
        options,
    );
};

export const getMoonvalleyImageToVideoMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof moonvalleyImageToVideo>>,
        TError,
        { data: MoonvalleyImageToVideoRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof moonvalleyImageToVideo>>,
    TError,
    { data: MoonvalleyImageToVideoRequest },
    TContext
> => {
    const mutationKey = ["moonvalleyImageToVideo"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof moonvalleyImageToVideo>>,
        { data: MoonvalleyImageToVideoRequest }
    > = (props) => {
        const { data } = props ?? {};

        return moonvalleyImageToVideo(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type MoonvalleyImageToVideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof moonvalleyImageToVideo>>
>;
export type MoonvalleyImageToVideoMutationBody = MoonvalleyImageToVideoRequest;
export type MoonvalleyImageToVideoMutationError = unknown;

/**
 * @summary Create Image to Video Prompt
 */
export const useMoonvalleyImageToVideo = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof moonvalleyImageToVideo>>,
            TError,
            { data: MoonvalleyImageToVideoRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof moonvalleyImageToVideo>>,
    TError,
    { data: MoonvalleyImageToVideoRequest },
    TContext
> => {
    const mutationOptions = getMoonvalleyImageToVideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create Text to Image Prompt
 */
export const moonvalleyTextToImage = (
    moonvalleyTextToImageRequest: MoonvalleyTextToImageRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<MoonvalleyPromptResponse>(
        {
            url: `/proxy/moonvalley/prompts/text-to-image`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: moonvalleyTextToImageRequest,
            signal,
        },
        options,
    );
};

export const getMoonvalleyTextToImageMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof moonvalleyTextToImage>>,
        TError,
        { data: MoonvalleyTextToImageRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof moonvalleyTextToImage>>,
    TError,
    { data: MoonvalleyTextToImageRequest },
    TContext
> => {
    const mutationKey = ["moonvalleyTextToImage"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof moonvalleyTextToImage>>,
        { data: MoonvalleyTextToImageRequest }
    > = (props) => {
        const { data } = props ?? {};

        return moonvalleyTextToImage(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type MoonvalleyTextToImageMutationResult = NonNullable<
    Awaited<ReturnType<typeof moonvalleyTextToImage>>
>;
export type MoonvalleyTextToImageMutationBody = MoonvalleyTextToImageRequest;
export type MoonvalleyTextToImageMutationError = unknown;

/**
 * @summary Create Text to Image Prompt
 */
export const useMoonvalleyTextToImage = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof moonvalleyTextToImage>>,
            TError,
            { data: MoonvalleyTextToImageRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof moonvalleyTextToImage>>,
    TError,
    { data: MoonvalleyTextToImageRequest },
    TContext
> => {
    const mutationOptions = getMoonvalleyTextToImageMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create Text to Video Prompt
 */
export const moonvalleyTextToVideo = (
    moonvalleyTextToVideoRequest: MoonvalleyTextToVideoRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<MoonvalleyPromptResponse>(
        {
            url: `/proxy/moonvalley/prompts/text-to-video`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: moonvalleyTextToVideoRequest,
            signal,
        },
        options,
    );
};

export const getMoonvalleyTextToVideoMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof moonvalleyTextToVideo>>,
        TError,
        { data: MoonvalleyTextToVideoRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof moonvalleyTextToVideo>>,
    TError,
    { data: MoonvalleyTextToVideoRequest },
    TContext
> => {
    const mutationKey = ["moonvalleyTextToVideo"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof moonvalleyTextToVideo>>,
        { data: MoonvalleyTextToVideoRequest }
    > = (props) => {
        const { data } = props ?? {};

        return moonvalleyTextToVideo(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type MoonvalleyTextToVideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof moonvalleyTextToVideo>>
>;
export type MoonvalleyTextToVideoMutationBody = MoonvalleyTextToVideoRequest;
export type MoonvalleyTextToVideoMutationError = unknown;

/**
 * @summary Create Text to Video Prompt
 */
export const useMoonvalleyTextToVideo = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof moonvalleyTextToVideo>>,
            TError,
            { data: MoonvalleyTextToVideoRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof moonvalleyTextToVideo>>,
    TError,
    { data: MoonvalleyTextToVideoRequest },
    TContext
> => {
    const mutationOptions = getMoonvalleyTextToVideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create Video to Video Prompt
 */
export const moonvalleyVideoToVideo = (
    moonvalleyVideoToVideoRequest: MoonvalleyVideoToVideoRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<MoonvalleyPromptResponse>(
        {
            url: `/proxy/moonvalley/prompts/video-to-video`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: moonvalleyVideoToVideoRequest,
            signal,
        },
        options,
    );
};

export const getMoonvalleyVideoToVideoMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof moonvalleyVideoToVideo>>,
        TError,
        { data: MoonvalleyVideoToVideoRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof moonvalleyVideoToVideo>>,
    TError,
    { data: MoonvalleyVideoToVideoRequest },
    TContext
> => {
    const mutationKey = ["moonvalleyVideoToVideo"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof moonvalleyVideoToVideo>>,
        { data: MoonvalleyVideoToVideoRequest }
    > = (props) => {
        const { data } = props ?? {};

        return moonvalleyVideoToVideo(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type MoonvalleyVideoToVideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof moonvalleyVideoToVideo>>
>;
export type MoonvalleyVideoToVideoMutationBody = MoonvalleyVideoToVideoRequest;
export type MoonvalleyVideoToVideoMutationError = unknown;

/**
 * @summary Create Video to Video Prompt
 */
export const useMoonvalleyVideoToVideo = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof moonvalleyVideoToVideo>>,
            TError,
            { data: MoonvalleyVideoToVideoRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof moonvalleyVideoToVideo>>,
    TError,
    { data: MoonvalleyVideoToVideoRequest },
    TContext
> => {
    const mutationOptions = getMoonvalleyVideoToVideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Resize a video
 */
export const moonvalleyVideoToVideoResize = (
    moonvalleyResizeVideoRequest: MoonvalleyResizeVideoRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<MoonvalleyPromptResponse>(
        {
            url: `/proxy/moonvalley/prompts/video-to-video/resize`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: moonvalleyResizeVideoRequest,
            signal,
        },
        options,
    );
};

export const getMoonvalleyVideoToVideoResizeMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>,
        TError,
        { data: MoonvalleyResizeVideoRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>,
    TError,
    { data: MoonvalleyResizeVideoRequest },
    TContext
> => {
    const mutationKey = ["moonvalleyVideoToVideoResize"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>,
        { data: MoonvalleyResizeVideoRequest }
    > = (props) => {
        const { data } = props ?? {};

        return moonvalleyVideoToVideoResize(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type MoonvalleyVideoToVideoResizeMutationResult = NonNullable<
    Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>
>;
export type MoonvalleyVideoToVideoResizeMutationBody =
    MoonvalleyResizeVideoRequest;
export type MoonvalleyVideoToVideoResizeMutationError = unknown;

/**
 * @summary Resize a video
 */
export const useMoonvalleyVideoToVideoResize = <
    TError = unknown,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>,
            TError,
            { data: MoonvalleyResizeVideoRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof moonvalleyVideoToVideoResize>>,
    TError,
    { data: MoonvalleyResizeVideoRequest },
    TContext
> => {
    const mutationOptions =
        getMoonvalleyVideoToVideoResizeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get Prompt Details
 */
export const moonvalleyGetPrompt = (
    promptId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<MoonvalleyPromptResponse>(
        { url: `/proxy/moonvalley/prompts/${promptId}`, method: "GET", signal },
        options,
    );
};

export const getMoonvalleyGetPromptQueryKey = (promptId?: string) => {
    return [`/proxy/moonvalley/prompts/${promptId}`] as const;
};

export const getMoonvalleyGetPromptQueryOptions = <
    TData = Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
    TError = unknown,
>(
    promptId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getMoonvalleyGetPromptQueryKey(promptId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof moonvalleyGetPrompt>>
    > = ({ signal }) => moonvalleyGetPrompt(promptId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!promptId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoonvalleyGetPromptQueryResult = NonNullable<
    Awaited<ReturnType<typeof moonvalleyGetPrompt>>
>;
export type MoonvalleyGetPromptQueryError = unknown;

export function useMoonvalleyGetPrompt<
    TData = Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
    TError = unknown,
>(
    promptId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
                    TError,
                    Awaited<ReturnType<typeof moonvalleyGetPrompt>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoonvalleyGetPrompt<
    TData = Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
    TError = unknown,
>(
    promptId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
                    TError,
                    Awaited<ReturnType<typeof moonvalleyGetPrompt>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoonvalleyGetPrompt<
    TData = Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
    TError = unknown,
>(
    promptId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Prompt Details
 */

export function useMoonvalleyGetPrompt<
    TData = Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
    TError = unknown,
>(
    promptId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof moonvalleyGetPrompt>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getMoonvalleyGetPromptQueryOptions(promptId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Upload Files
 */
export const moonvalleyUpload = (
    moonvalleyUploadFileRequest: MoonvalleyUploadFileRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (moonvalleyUploadFileRequest.file !== undefined) {
        formData.append(`file`, moonvalleyUploadFileRequest.file);
    }

    return customInstance<MoonvalleyUploadFileResponse>(
        {
            url: `/proxy/moonvalley/uploads`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getMoonvalleyUploadMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof moonvalleyUpload>>,
        TError,
        { data: MoonvalleyUploadFileRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof moonvalleyUpload>>,
    TError,
    { data: MoonvalleyUploadFileRequest },
    TContext
> => {
    const mutationKey = ["moonvalleyUpload"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof moonvalleyUpload>>,
        { data: MoonvalleyUploadFileRequest }
    > = (props) => {
        const { data } = props ?? {};

        return moonvalleyUpload(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type MoonvalleyUploadMutationResult = NonNullable<
    Awaited<ReturnType<typeof moonvalleyUpload>>
>;
export type MoonvalleyUploadMutationBody = MoonvalleyUploadFileRequest;
export type MoonvalleyUploadMutationError = unknown;

/**
 * @summary Upload Files
 */
export const useMoonvalleyUpload = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof moonvalleyUpload>>,
            TError,
            { data: MoonvalleyUploadFileRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof moonvalleyUpload>>,
    TError,
    { data: MoonvalleyUploadFileRequest },
    TContext
> => {
    const mutationOptions = getMoonvalleyUploadMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Edit an image using OpenAI's DALL-E model
 */
export const openAIEditImage = (
    openAIImageEditRequest: OpenAIImageEditRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (openAIImageEditRequest.background !== undefined) {
        formData.append(`background`, openAIImageEditRequest.background);
    }
    formData.append(`model`, openAIImageEditRequest.model);
    if (openAIImageEditRequest.moderation !== undefined) {
        formData.append(`moderation`, openAIImageEditRequest.moderation);
    }
    if (openAIImageEditRequest.n !== undefined) {
        formData.append(`n`, openAIImageEditRequest.n.toString());
    }
    if (openAIImageEditRequest.output_compression !== undefined) {
        formData.append(
            `output_compression`,
            openAIImageEditRequest.output_compression.toString(),
        );
    }
    if (openAIImageEditRequest.output_format !== undefined) {
        formData.append(`output_format`, openAIImageEditRequest.output_format);
    }
    formData.append(`prompt`, openAIImageEditRequest.prompt);
    if (openAIImageEditRequest.quality !== undefined) {
        formData.append(`quality`, openAIImageEditRequest.quality);
    }
    if (openAIImageEditRequest.size !== undefined) {
        formData.append(`size`, openAIImageEditRequest.size);
    }
    if (openAIImageEditRequest.user !== undefined) {
        formData.append(`user`, openAIImageEditRequest.user);
    }

    return customInstance<OpenAIImageGenerationResponse>(
        {
            url: `/proxy/openai/images/edits`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getOpenAIEditImageMutationOptions = <
    TError = ErrorResponse | void | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof openAIEditImage>>,
        TError,
        { data: OpenAIImageEditRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof openAIEditImage>>,
    TError,
    { data: OpenAIImageEditRequest },
    TContext
> => {
    const mutationKey = ["openAIEditImage"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof openAIEditImage>>,
        { data: OpenAIImageEditRequest }
    > = (props) => {
        const { data } = props ?? {};

        return openAIEditImage(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type OpenAIEditImageMutationResult = NonNullable<
    Awaited<ReturnType<typeof openAIEditImage>>
>;
export type OpenAIEditImageMutationBody = OpenAIImageEditRequest;
export type OpenAIEditImageMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse;

/**
 * @summary Edit an image using OpenAI's DALL-E model
 */
export const useOpenAIEditImage = <
    TError = ErrorResponse | void | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof openAIEditImage>>,
            TError,
            { data: OpenAIImageEditRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof openAIEditImage>>,
    TError,
    { data: OpenAIImageEditRequest },
    TContext
> => {
    const mutationOptions = getOpenAIEditImageMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generate an image using OpenAI's models
 */
export const openAIGenerateImage = (
    openAIImageGenerationRequest: OpenAIImageGenerationRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<OpenAIImageGenerationResponse>(
        {
            url: `/proxy/openai/images/generations`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: openAIImageGenerationRequest,
            signal,
        },
        options,
    );
};

export const getOpenAIGenerateImageMutationOptions = <
    TError = ErrorResponse | void | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof openAIGenerateImage>>,
        TError,
        { data: OpenAIImageGenerationRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof openAIGenerateImage>>,
    TError,
    { data: OpenAIImageGenerationRequest },
    TContext
> => {
    const mutationKey = ["openAIGenerateImage"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof openAIGenerateImage>>,
        { data: OpenAIImageGenerationRequest }
    > = (props) => {
        const { data } = props ?? {};

        return openAIGenerateImage(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type OpenAIGenerateImageMutationResult = NonNullable<
    Awaited<ReturnType<typeof openAIGenerateImage>>
>;
export type OpenAIGenerateImageMutationBody = OpenAIImageGenerationRequest;
export type OpenAIGenerateImageMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse;

/**
 * @summary Generate an image using OpenAI's models
 */
export const useOpenAIGenerateImage = <
    TError = ErrorResponse | void | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof openAIGenerateImage>>,
            TError,
            { data: OpenAIImageGenerationRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof openAIGenerateImage>>,
    TError,
    { data: OpenAIImageGenerationRequest },
    TContext
> => {
    const mutationOptions = getOpenAIGenerateImageMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const createOpenAIResponse = (
    openAICreateResponse: OpenAICreateResponse,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<OpenAIResponse | OpenAIResponseStreamEvent>(
        {
            url: `/proxy/openai/v1/responses`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: openAICreateResponse,
            signal,
        },
        options,
    );
};

export const getCreateOpenAIResponseMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createOpenAIResponse>>,
        TError,
        { data: OpenAICreateResponse },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createOpenAIResponse>>,
    TError,
    { data: OpenAICreateResponse },
    TContext
> => {
    const mutationKey = ["createOpenAIResponse"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createOpenAIResponse>>,
        { data: OpenAICreateResponse }
    > = (props) => {
        const { data } = props ?? {};

        return createOpenAIResponse(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateOpenAIResponseMutationResult = NonNullable<
    Awaited<ReturnType<typeof createOpenAIResponse>>
>;
export type CreateOpenAIResponseMutationBody = OpenAICreateResponse;
export type CreateOpenAIResponseMutationError = unknown;

export const useCreateOpenAIResponse = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createOpenAIResponse>>,
            TError,
            { data: OpenAICreateResponse },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createOpenAIResponse>>,
    TError,
    { data: OpenAICreateResponse },
    TContext
> => {
    const mutationOptions = getCreateOpenAIResponseMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Retrieves a model response with the given ID.

 */
export const getOpenAIResponse = (
    id: string,
    params?: GetOpenAIResponseParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<OpenAIResponse>(
        {
            url: `/proxy/openai/v1/responses/${id}`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getGetOpenAIResponseQueryKey = (
    id?: string,
    params?: GetOpenAIResponseParams,
) => {
    return [
        `/proxy/openai/v1/responses/${id}`,
        ...(params ? [params] : []),
    ] as const;
};

export const getGetOpenAIResponseQueryOptions = <
    TData = Awaited<ReturnType<typeof getOpenAIResponse>>,
    TError = unknown,
>(
    id: string,
    params?: GetOpenAIResponseParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getOpenAIResponse>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetOpenAIResponseQueryKey(id, params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getOpenAIResponse>>
    > = ({ signal }) => getOpenAIResponse(id, params, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getOpenAIResponse>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOpenAIResponseQueryResult = NonNullable<
    Awaited<ReturnType<typeof getOpenAIResponse>>
>;
export type GetOpenAIResponseQueryError = unknown;

export function useGetOpenAIResponse<
    TData = Awaited<ReturnType<typeof getOpenAIResponse>>,
    TError = unknown,
>(
    id: string,
    params: undefined | GetOpenAIResponseParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getOpenAIResponse>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getOpenAIResponse>>,
                    TError,
                    Awaited<ReturnType<typeof getOpenAIResponse>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOpenAIResponse<
    TData = Awaited<ReturnType<typeof getOpenAIResponse>>,
    TError = unknown,
>(
    id: string,
    params?: GetOpenAIResponseParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getOpenAIResponse>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getOpenAIResponse>>,
                    TError,
                    Awaited<ReturnType<typeof getOpenAIResponse>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOpenAIResponse<
    TData = Awaited<ReturnType<typeof getOpenAIResponse>>,
    TError = unknown,
>(
    id: string,
    params?: GetOpenAIResponseParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getOpenAIResponse>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieves a model response with the given ID.

 */

export function useGetOpenAIResponse<
    TData = Awaited<ReturnType<typeof getOpenAIResponse>>,
    TError = unknown,
>(
    id: string,
    params?: GetOpenAIResponseParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getOpenAIResponse>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetOpenAIResponseQueryOptions(id, params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Generate 2 2 I2V
 */
export const pikaGenerate22I2vGenerate22I2vPost = (
    pikaBodyGenerate22I2vGenerate22I2vPost: PikaBodyGenerate22I2vGenerate22I2vPost,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (pikaBodyGenerate22I2vGenerate22I2vPost.duration !== undefined) {
        formData.append(
            `duration`,
            pikaBodyGenerate22I2vGenerate22I2vPost.duration.toString(),
        );
    }
    if (
        pikaBodyGenerate22I2vGenerate22I2vPost.image !== undefined &&
        pikaBodyGenerate22I2vGenerate22I2vPost.image !== null
    ) {
        formData.append(`image`, pikaBodyGenerate22I2vGenerate22I2vPost.image);
    }
    if (
        pikaBodyGenerate22I2vGenerate22I2vPost.negativePrompt !== undefined &&
        pikaBodyGenerate22I2vGenerate22I2vPost.negativePrompt !== null
    ) {
        formData.append(
            `negativePrompt`,
            pikaBodyGenerate22I2vGenerate22I2vPost.negativePrompt,
        );
    }
    if (
        pikaBodyGenerate22I2vGenerate22I2vPost.promptText !== undefined &&
        pikaBodyGenerate22I2vGenerate22I2vPost.promptText !== null
    ) {
        formData.append(
            `promptText`,
            pikaBodyGenerate22I2vGenerate22I2vPost.promptText,
        );
    }
    if (pikaBodyGenerate22I2vGenerate22I2vPost.resolution !== undefined) {
        formData.append(
            `resolution`,
            pikaBodyGenerate22I2vGenerate22I2vPost.resolution,
        );
    }
    if (
        pikaBodyGenerate22I2vGenerate22I2vPost.seed !== undefined &&
        pikaBodyGenerate22I2vGenerate22I2vPost.seed !== null
    ) {
        formData.append(
            `seed`,
            pikaBodyGenerate22I2vGenerate22I2vPost.seed.toString(),
        );
    }

    return customInstance<PikaGenerateResponse>(
        {
            url: `/proxy/pika/generate/2.2/i2v`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getPikaGenerate22I2vGenerate22I2vPostMutationOptions = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>,
        TError,
        { data: PikaBodyGenerate22I2vGenerate22I2vPost },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>,
    TError,
    { data: PikaBodyGenerate22I2vGenerate22I2vPost },
    TContext
> => {
    const mutationKey = ["pikaGenerate22I2vGenerate22I2vPost"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>,
        { data: PikaBodyGenerate22I2vGenerate22I2vPost }
    > = (props) => {
        const { data } = props ?? {};

        return pikaGenerate22I2vGenerate22I2vPost(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PikaGenerate22I2vGenerate22I2vPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>
>;
export type PikaGenerate22I2vGenerate22I2vPostMutationBody =
    PikaBodyGenerate22I2vGenerate22I2vPost;
export type PikaGenerate22I2vGenerate22I2vPostMutationError =
    PikaHTTPValidationError;

/**
 * @summary Generate 2 2 I2V
 */
export const usePikaGenerate22I2vGenerate22I2vPost = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>,
            TError,
            { data: PikaBodyGenerate22I2vGenerate22I2vPost },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof pikaGenerate22I2vGenerate22I2vPost>>,
    TError,
    { data: PikaBodyGenerate22I2vGenerate22I2vPost },
    TContext
> => {
    const mutationOptions =
        getPikaGenerate22I2vGenerate22I2vPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generate 2 2 Keyframe
 */
export const pikaGenerate22KeyframeGenerate22PikaframesPost = (
    pikaBodyGenerate22KeyframeGenerate22PikaframesPost: PikaBodyGenerate22KeyframeGenerate22PikaframesPost,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (
        pikaBodyGenerate22KeyframeGenerate22PikaframesPost.duration !==
        undefined
    ) {
        formData.append(
            `duration`,
            pikaBodyGenerate22KeyframeGenerate22PikaframesPost.duration.toString(),
        );
    }
    if (
        pikaBodyGenerate22KeyframeGenerate22PikaframesPost.keyFrames !==
        undefined
    ) {
        pikaBodyGenerate22KeyframeGenerate22PikaframesPost.keyFrames.forEach(
            (value) => formData.append(`keyFrames`, value),
        );
    }
    if (
        pikaBodyGenerate22KeyframeGenerate22PikaframesPost.negativePrompt !==
        undefined
    ) {
        formData.append(
            `negativePrompt`,
            pikaBodyGenerate22KeyframeGenerate22PikaframesPost.negativePrompt,
        );
    }
    formData.append(
        `promptText`,
        pikaBodyGenerate22KeyframeGenerate22PikaframesPost.promptText,
    );
    if (
        pikaBodyGenerate22KeyframeGenerate22PikaframesPost.resolution !==
        undefined
    ) {
        formData.append(
            `resolution`,
            pikaBodyGenerate22KeyframeGenerate22PikaframesPost.resolution,
        );
    }
    if (pikaBodyGenerate22KeyframeGenerate22PikaframesPost.seed !== undefined) {
        formData.append(
            `seed`,
            pikaBodyGenerate22KeyframeGenerate22PikaframesPost.seed.toString(),
        );
    }

    return customInstance<PikaGenerateResponse>(
        {
            url: `/proxy/pika/generate/2.2/pikaframes`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getPikaGenerate22KeyframeGenerate22PikaframesPostMutationOptions =
    <TError = PikaHTTPValidationError, TContext = unknown>(options?: {
        mutation?: UseMutationOptions<
            Awaited<
                ReturnType<
                    typeof pikaGenerate22KeyframeGenerate22PikaframesPost
                >
            >,
            TError,
            { data: PikaBodyGenerate22KeyframeGenerate22PikaframesPost },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    }): UseMutationOptions<
        Awaited<
            ReturnType<typeof pikaGenerate22KeyframeGenerate22PikaframesPost>
        >,
        TError,
        { data: PikaBodyGenerate22KeyframeGenerate22PikaframesPost },
        TContext
    > => {
        const mutationKey = ["pikaGenerate22KeyframeGenerate22PikaframesPost"];
        const { mutation: mutationOptions, request: requestOptions } = options
            ? options.mutation &&
              "mutationKey" in options.mutation &&
              options.mutation.mutationKey
                ? options
                : { ...options, mutation: { ...options.mutation, mutationKey } }
            : { mutation: { mutationKey }, request: undefined };

        const mutationFn: MutationFunction<
            Awaited<
                ReturnType<
                    typeof pikaGenerate22KeyframeGenerate22PikaframesPost
                >
            >,
            { data: PikaBodyGenerate22KeyframeGenerate22PikaframesPost }
        > = (props) => {
            const { data } = props ?? {};

            return pikaGenerate22KeyframeGenerate22PikaframesPost(
                data,
                requestOptions,
            );
        };

        return { mutationFn, ...mutationOptions };
    };

export type PikaGenerate22KeyframeGenerate22PikaframesPostMutationResult =
    NonNullable<
        Awaited<
            ReturnType<typeof pikaGenerate22KeyframeGenerate22PikaframesPost>
        >
    >;
export type PikaGenerate22KeyframeGenerate22PikaframesPostMutationBody =
    PikaBodyGenerate22KeyframeGenerate22PikaframesPost;
export type PikaGenerate22KeyframeGenerate22PikaframesPostMutationError =
    PikaHTTPValidationError;

/**
 * @summary Generate 2 2 Keyframe
 */
export const usePikaGenerate22KeyframeGenerate22PikaframesPost = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<
                ReturnType<
                    typeof pikaGenerate22KeyframeGenerate22PikaframesPost
                >
            >,
            TError,
            { data: PikaBodyGenerate22KeyframeGenerate22PikaframesPost },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof pikaGenerate22KeyframeGenerate22PikaframesPost>>,
    TError,
    { data: PikaBodyGenerate22KeyframeGenerate22PikaframesPost },
    TContext
> => {
    const mutationOptions =
        getPikaGenerate22KeyframeGenerate22PikaframesPostMutationOptions(
            options,
        );

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generate 2 2 C2V
 */
export const pikaGenerate22C2vGenerate22PikascenesPost = (
    pikaBodyGenerate22C2vGenerate22PikascenesPost: PikaBodyGenerate22C2vGenerate22PikascenesPost,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (
        pikaBodyGenerate22C2vGenerate22PikascenesPost.aspectRatio !== undefined
    ) {
        formData.append(
            `aspectRatio`,
            pikaBodyGenerate22C2vGenerate22PikascenesPost.aspectRatio.toString(),
        );
    }
    if (pikaBodyGenerate22C2vGenerate22PikascenesPost.duration !== undefined) {
        formData.append(
            `duration`,
            pikaBodyGenerate22C2vGenerate22PikascenesPost.duration.toString(),
        );
    }
    if (pikaBodyGenerate22C2vGenerate22PikascenesPost.images !== undefined) {
        pikaBodyGenerate22C2vGenerate22PikascenesPost.images.forEach((value) =>
            formData.append(`images`, value),
        );
    }
    formData.append(
        `ingredientsMode`,
        pikaBodyGenerate22C2vGenerate22PikascenesPost.ingredientsMode,
    );
    if (
        pikaBodyGenerate22C2vGenerate22PikascenesPost.negativePrompt !==
        undefined
    ) {
        formData.append(
            `negativePrompt`,
            pikaBodyGenerate22C2vGenerate22PikascenesPost.negativePrompt,
        );
    }
    if (
        pikaBodyGenerate22C2vGenerate22PikascenesPost.promptText !== undefined
    ) {
        formData.append(
            `promptText`,
            pikaBodyGenerate22C2vGenerate22PikascenesPost.promptText,
        );
    }
    if (
        pikaBodyGenerate22C2vGenerate22PikascenesPost.resolution !== undefined
    ) {
        formData.append(
            `resolution`,
            pikaBodyGenerate22C2vGenerate22PikascenesPost.resolution,
        );
    }
    if (pikaBodyGenerate22C2vGenerate22PikascenesPost.seed !== undefined) {
        formData.append(
            `seed`,
            pikaBodyGenerate22C2vGenerate22PikascenesPost.seed.toString(),
        );
    }

    return customInstance<PikaGenerateResponse>(
        {
            url: `/proxy/pika/generate/2.2/pikascenes`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getPikaGenerate22C2vGenerate22PikascenesPostMutationOptions = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>>,
        TError,
        { data: PikaBodyGenerate22C2vGenerate22PikascenesPost },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>>,
    TError,
    { data: PikaBodyGenerate22C2vGenerate22PikascenesPost },
    TContext
> => {
    const mutationKey = ["pikaGenerate22C2vGenerate22PikascenesPost"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>>,
        { data: PikaBodyGenerate22C2vGenerate22PikascenesPost }
    > = (props) => {
        const { data } = props ?? {};

        return pikaGenerate22C2vGenerate22PikascenesPost(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PikaGenerate22C2vGenerate22PikascenesPostMutationResult =
    NonNullable<
        Awaited<ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>>
    >;
export type PikaGenerate22C2vGenerate22PikascenesPostMutationBody =
    PikaBodyGenerate22C2vGenerate22PikascenesPost;
export type PikaGenerate22C2vGenerate22PikascenesPostMutationError =
    PikaHTTPValidationError;

/**
 * @summary Generate 2 2 C2V
 */
export const usePikaGenerate22C2vGenerate22PikascenesPost = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<
                ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>
            >,
            TError,
            { data: PikaBodyGenerate22C2vGenerate22PikascenesPost },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof pikaGenerate22C2vGenerate22PikascenesPost>>,
    TError,
    { data: PikaBodyGenerate22C2vGenerate22PikascenesPost },
    TContext
> => {
    const mutationOptions =
        getPikaGenerate22C2vGenerate22PikascenesPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generate 2 2 T2V
 */
export const pikaGenerate22T2vGenerate22T2vPost = (
    pikaBodyGenerate22T2vGenerate22T2vPost: PikaBodyGenerate22T2vGenerate22T2vPost,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formUrlEncoded = new URLSearchParams();
    if (pikaBodyGenerate22T2vGenerate22T2vPost.aspectRatio !== undefined) {
        formUrlEncoded.append(
            `aspectRatio`,
            pikaBodyGenerate22T2vGenerate22T2vPost.aspectRatio.toString(),
        );
    }
    if (pikaBodyGenerate22T2vGenerate22T2vPost.duration !== undefined) {
        formUrlEncoded.append(
            `duration`,
            pikaBodyGenerate22T2vGenerate22T2vPost.duration.toString(),
        );
    }
    if (
        pikaBodyGenerate22T2vGenerate22T2vPost.negativePrompt !== undefined &&
        pikaBodyGenerate22T2vGenerate22T2vPost.negativePrompt !== null
    ) {
        formUrlEncoded.append(
            `negativePrompt`,
            pikaBodyGenerate22T2vGenerate22T2vPost.negativePrompt,
        );
    }
    formUrlEncoded.append(
        `promptText`,
        pikaBodyGenerate22T2vGenerate22T2vPost.promptText,
    );
    if (pikaBodyGenerate22T2vGenerate22T2vPost.resolution !== undefined) {
        formUrlEncoded.append(
            `resolution`,
            pikaBodyGenerate22T2vGenerate22T2vPost.resolution,
        );
    }
    if (
        pikaBodyGenerate22T2vGenerate22T2vPost.seed !== undefined &&
        pikaBodyGenerate22T2vGenerate22T2vPost.seed !== null
    ) {
        formUrlEncoded.append(
            `seed`,
            pikaBodyGenerate22T2vGenerate22T2vPost.seed.toString(),
        );
    }

    return customInstance<PikaGenerateResponse>(
        {
            url: `/proxy/pika/generate/2.2/t2v`,
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            data: formUrlEncoded,
            signal,
        },
        options,
    );
};

export const getPikaGenerate22T2vGenerate22T2vPostMutationOptions = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>,
        TError,
        { data: PikaBodyGenerate22T2vGenerate22T2vPost },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>,
    TError,
    { data: PikaBodyGenerate22T2vGenerate22T2vPost },
    TContext
> => {
    const mutationKey = ["pikaGenerate22T2vGenerate22T2vPost"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>,
        { data: PikaBodyGenerate22T2vGenerate22T2vPost }
    > = (props) => {
        const { data } = props ?? {};

        return pikaGenerate22T2vGenerate22T2vPost(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PikaGenerate22T2vGenerate22T2vPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>
>;
export type PikaGenerate22T2vGenerate22T2vPostMutationBody =
    PikaBodyGenerate22T2vGenerate22T2vPost;
export type PikaGenerate22T2vGenerate22T2vPostMutationError =
    PikaHTTPValidationError;

/**
 * @summary Generate 2 2 T2V
 */
export const usePikaGenerate22T2vGenerate22T2vPost = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>,
            TError,
            { data: PikaBodyGenerate22T2vGenerate22T2vPost },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof pikaGenerate22T2vGenerate22T2vPost>>,
    TError,
    { data: PikaBodyGenerate22T2vGenerate22T2vPost },
    TContext
> => {
    const mutationOptions =
        getPikaGenerate22T2vGenerate22T2vPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generate Pikadditions
 */
export const pikaGeneratePikadditionsGeneratePikadditionsPost = (
    pikaBodyGeneratePikadditionsGeneratePikadditionsPost: PikaBodyGeneratePikadditionsGeneratePikadditionsPost,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (
        pikaBodyGeneratePikadditionsGeneratePikadditionsPost.image !== undefined
    ) {
        formData.append(
            `image`,
            pikaBodyGeneratePikadditionsGeneratePikadditionsPost.image,
        );
    }
    if (
        pikaBodyGeneratePikadditionsGeneratePikadditionsPost.negativePrompt !==
        undefined
    ) {
        formData.append(
            `negativePrompt`,
            pikaBodyGeneratePikadditionsGeneratePikadditionsPost.negativePrompt,
        );
    }
    if (
        pikaBodyGeneratePikadditionsGeneratePikadditionsPost.promptText !==
        undefined
    ) {
        formData.append(
            `promptText`,
            pikaBodyGeneratePikadditionsGeneratePikadditionsPost.promptText,
        );
    }
    if (
        pikaBodyGeneratePikadditionsGeneratePikadditionsPost.seed !== undefined
    ) {
        formData.append(
            `seed`,
            pikaBodyGeneratePikadditionsGeneratePikadditionsPost.seed.toString(),
        );
    }
    if (
        pikaBodyGeneratePikadditionsGeneratePikadditionsPost.video !== undefined
    ) {
        formData.append(
            `video`,
            pikaBodyGeneratePikadditionsGeneratePikadditionsPost.video,
        );
    }

    return customInstance<PikaGenerateResponse>(
        {
            url: `/proxy/pika/generate/pikadditions`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getPikaGeneratePikadditionsGeneratePikadditionsPostMutationOptions =
    <TError = PikaHTTPValidationError, TContext = unknown>(options?: {
        mutation?: UseMutationOptions<
            Awaited<
                ReturnType<
                    typeof pikaGeneratePikadditionsGeneratePikadditionsPost
                >
            >,
            TError,
            { data: PikaBodyGeneratePikadditionsGeneratePikadditionsPost },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    }): UseMutationOptions<
        Awaited<
            ReturnType<typeof pikaGeneratePikadditionsGeneratePikadditionsPost>
        >,
        TError,
        { data: PikaBodyGeneratePikadditionsGeneratePikadditionsPost },
        TContext
    > => {
        const mutationKey = [
            "pikaGeneratePikadditionsGeneratePikadditionsPost",
        ];
        const { mutation: mutationOptions, request: requestOptions } = options
            ? options.mutation &&
              "mutationKey" in options.mutation &&
              options.mutation.mutationKey
                ? options
                : { ...options, mutation: { ...options.mutation, mutationKey } }
            : { mutation: { mutationKey }, request: undefined };

        const mutationFn: MutationFunction<
            Awaited<
                ReturnType<
                    typeof pikaGeneratePikadditionsGeneratePikadditionsPost
                >
            >,
            { data: PikaBodyGeneratePikadditionsGeneratePikadditionsPost }
        > = (props) => {
            const { data } = props ?? {};

            return pikaGeneratePikadditionsGeneratePikadditionsPost(
                data,
                requestOptions,
            );
        };

        return { mutationFn, ...mutationOptions };
    };

export type PikaGeneratePikadditionsGeneratePikadditionsPostMutationResult =
    NonNullable<
        Awaited<
            ReturnType<typeof pikaGeneratePikadditionsGeneratePikadditionsPost>
        >
    >;
export type PikaGeneratePikadditionsGeneratePikadditionsPostMutationBody =
    PikaBodyGeneratePikadditionsGeneratePikadditionsPost;
export type PikaGeneratePikadditionsGeneratePikadditionsPostMutationError =
    PikaHTTPValidationError;

/**
 * @summary Generate Pikadditions
 */
export const usePikaGeneratePikadditionsGeneratePikadditionsPost = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<
                ReturnType<
                    typeof pikaGeneratePikadditionsGeneratePikadditionsPost
                >
            >,
            TError,
            { data: PikaBodyGeneratePikadditionsGeneratePikadditionsPost },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<
        ReturnType<typeof pikaGeneratePikadditionsGeneratePikadditionsPost>
    >,
    TError,
    { data: PikaBodyGeneratePikadditionsGeneratePikadditionsPost },
    TContext
> => {
    const mutationOptions =
        getPikaGeneratePikadditionsGeneratePikadditionsPostMutationOptions(
            options,
        );

    return useMutation(mutationOptions, queryClient);
};

/**
 * Generate a video with a specific Pikaffect. Supported Pikaffects: Cake-ify, Crumble, Crush, Decapitate, Deflate, Dissolve, Explode, Eye-pop, Inflate, Levitate, Melt, Peel, Poke, Squish, Ta-da, Tear
 * @summary Generate Pikaffects
 */
export const pikaGeneratePikaffectsGeneratePikaffectsPost = (
    pikaBodyGeneratePikaffectsGeneratePikaffectsPost: PikaBodyGeneratePikaffectsGeneratePikaffectsPost,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (pikaBodyGeneratePikaffectsGeneratePikaffectsPost.image !== undefined) {
        formData.append(
            `image`,
            pikaBodyGeneratePikaffectsGeneratePikaffectsPost.image,
        );
    }
    if (
        pikaBodyGeneratePikaffectsGeneratePikaffectsPost.negativePrompt !==
        undefined
    ) {
        formData.append(
            `negativePrompt`,
            pikaBodyGeneratePikaffectsGeneratePikaffectsPost.negativePrompt,
        );
    }
    if (
        pikaBodyGeneratePikaffectsGeneratePikaffectsPost.pikaffect !== undefined
    ) {
        formData.append(
            `pikaffect`,
            pikaBodyGeneratePikaffectsGeneratePikaffectsPost.pikaffect,
        );
    }
    if (
        pikaBodyGeneratePikaffectsGeneratePikaffectsPost.promptText !==
        undefined
    ) {
        formData.append(
            `promptText`,
            pikaBodyGeneratePikaffectsGeneratePikaffectsPost.promptText,
        );
    }
    if (pikaBodyGeneratePikaffectsGeneratePikaffectsPost.seed !== undefined) {
        formData.append(
            `seed`,
            pikaBodyGeneratePikaffectsGeneratePikaffectsPost.seed.toString(),
        );
    }

    return customInstance<PikaGenerateResponse>(
        {
            url: `/proxy/pika/generate/pikaffects`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getPikaGeneratePikaffectsGeneratePikaffectsPostMutationOptions = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<
            ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>
        >,
        TError,
        { data: PikaBodyGeneratePikaffectsGeneratePikaffectsPost },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>>,
    TError,
    { data: PikaBodyGeneratePikaffectsGeneratePikaffectsPost },
    TContext
> => {
    const mutationKey = ["pikaGeneratePikaffectsGeneratePikaffectsPost"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<
            ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>
        >,
        { data: PikaBodyGeneratePikaffectsGeneratePikaffectsPost }
    > = (props) => {
        const { data } = props ?? {};

        return pikaGeneratePikaffectsGeneratePikaffectsPost(
            data,
            requestOptions,
        );
    };

    return { mutationFn, ...mutationOptions };
};

export type PikaGeneratePikaffectsGeneratePikaffectsPostMutationResult =
    NonNullable<
        Awaited<ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>>
    >;
export type PikaGeneratePikaffectsGeneratePikaffectsPostMutationBody =
    PikaBodyGeneratePikaffectsGeneratePikaffectsPost;
export type PikaGeneratePikaffectsGeneratePikaffectsPostMutationError =
    PikaHTTPValidationError;

/**
 * @summary Generate Pikaffects
 */
export const usePikaGeneratePikaffectsGeneratePikaffectsPost = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<
                ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>
            >,
            TError,
            { data: PikaBodyGeneratePikaffectsGeneratePikaffectsPost },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof pikaGeneratePikaffectsGeneratePikaffectsPost>>,
    TError,
    { data: PikaBodyGeneratePikaffectsGeneratePikaffectsPost },
    TContext
> => {
    const mutationOptions =
        getPikaGeneratePikaffectsGeneratePikaffectsPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Exactly one of `modifyRegionMask` and `modifyRegionRoi` must be provided.
 * @summary Generate Pikaswaps
 */
export const pikaGeneratePikaswapsGeneratePikaswapsPost = (
    pikaBodyGeneratePikaswapsGeneratePikaswapsPost: PikaBodyGeneratePikaswapsGeneratePikaswapsPost,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (pikaBodyGeneratePikaswapsGeneratePikaswapsPost.image !== undefined) {
        formData.append(
            `image`,
            pikaBodyGeneratePikaswapsGeneratePikaswapsPost.image,
        );
    }
    if (
        pikaBodyGeneratePikaswapsGeneratePikaswapsPost.modifyRegionMask !==
        undefined
    ) {
        formData.append(
            `modifyRegionMask`,
            pikaBodyGeneratePikaswapsGeneratePikaswapsPost.modifyRegionMask,
        );
    }
    if (
        pikaBodyGeneratePikaswapsGeneratePikaswapsPost.modifyRegionRoi !==
        undefined
    ) {
        formData.append(
            `modifyRegionRoi`,
            pikaBodyGeneratePikaswapsGeneratePikaswapsPost.modifyRegionRoi,
        );
    }
    if (
        pikaBodyGeneratePikaswapsGeneratePikaswapsPost.negativePrompt !==
        undefined
    ) {
        formData.append(
            `negativePrompt`,
            pikaBodyGeneratePikaswapsGeneratePikaswapsPost.negativePrompt,
        );
    }
    if (
        pikaBodyGeneratePikaswapsGeneratePikaswapsPost.promptText !== undefined
    ) {
        formData.append(
            `promptText`,
            pikaBodyGeneratePikaswapsGeneratePikaswapsPost.promptText,
        );
    }
    if (pikaBodyGeneratePikaswapsGeneratePikaswapsPost.seed !== undefined) {
        formData.append(
            `seed`,
            pikaBodyGeneratePikaswapsGeneratePikaswapsPost.seed.toString(),
        );
    }
    if (pikaBodyGeneratePikaswapsGeneratePikaswapsPost.video !== undefined) {
        formData.append(
            `video`,
            pikaBodyGeneratePikaswapsGeneratePikaswapsPost.video,
        );
    }

    return customInstance<PikaGenerateResponse>(
        {
            url: `/proxy/pika/generate/pikaswaps`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getPikaGeneratePikaswapsGeneratePikaswapsPostMutationOptions = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>>,
        TError,
        { data: PikaBodyGeneratePikaswapsGeneratePikaswapsPost },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>>,
    TError,
    { data: PikaBodyGeneratePikaswapsGeneratePikaswapsPost },
    TContext
> => {
    const mutationKey = ["pikaGeneratePikaswapsGeneratePikaswapsPost"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>>,
        { data: PikaBodyGeneratePikaswapsGeneratePikaswapsPost }
    > = (props) => {
        const { data } = props ?? {};

        return pikaGeneratePikaswapsGeneratePikaswapsPost(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PikaGeneratePikaswapsGeneratePikaswapsPostMutationResult =
    NonNullable<
        Awaited<ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>>
    >;
export type PikaGeneratePikaswapsGeneratePikaswapsPostMutationBody =
    PikaBodyGeneratePikaswapsGeneratePikaswapsPost;
export type PikaGeneratePikaswapsGeneratePikaswapsPostMutationError =
    PikaHTTPValidationError;

/**
 * @summary Generate Pikaswaps
 */
export const usePikaGeneratePikaswapsGeneratePikaswapsPost = <
    TError = PikaHTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<
                ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>
            >,
            TError,
            { data: PikaBodyGeneratePikaswapsGeneratePikaswapsPost },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof pikaGeneratePikaswapsGeneratePikaswapsPost>>,
    TError,
    { data: PikaBodyGeneratePikaswapsGeneratePikaswapsPost },
    TContext
> => {
    const mutationOptions =
        getPikaGeneratePikaswapsGeneratePikaswapsPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get Video
 */
export const pikaGetVideoVideosVideoIdGet = (
    videoId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<PikaVideoResponse>(
        { url: `/proxy/pika/videos/${videoId}`, method: "GET", signal },
        options,
    );
};

export const getPikaGetVideoVideosVideoIdGetQueryKey = (videoId?: string) => {
    return [`/proxy/pika/videos/${videoId}`] as const;
};

export const getPikaGetVideoVideosVideoIdGetQueryOptions = <
    TData = Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
    TError = PikaHTTPValidationError,
>(
    videoId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getPikaGetVideoVideosVideoIdGetQueryKey(videoId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>
    > = ({ signal }) =>
        pikaGetVideoVideosVideoIdGet(videoId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!videoId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PikaGetVideoVideosVideoIdGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>
>;
export type PikaGetVideoVideosVideoIdGetQueryError = PikaHTTPValidationError;

export function usePikaGetVideoVideosVideoIdGet<
    TData = Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
    TError = PikaHTTPValidationError,
>(
    videoId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePikaGetVideoVideosVideoIdGet<
    TData = Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
    TError = PikaHTTPValidationError,
>(
    videoId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePikaGetVideoVideosVideoIdGet<
    TData = Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
    TError = PikaHTTPValidationError,
>(
    videoId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Video
 */

export function usePikaGetVideoVideosVideoIdGet<
    TData = Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
    TError = PikaHTTPValidationError,
>(
    videoId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof pikaGetVideoVideosVideoIdGet>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getPikaGetVideoVideosVideoIdGetQueryOptions(
        videoId,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Upload an image to the server.
 */
export const pixverseUploadImage = (
    pixverseUploadImageBody: PixverseUploadImageBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (pixverseUploadImageBody.image !== undefined) {
        formData.append(`image`, pixverseUploadImageBody.image);
    }

    return customInstance<PixverseImageUploadResponse>(
        {
            url: `/proxy/pixverse/image/upload`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getPixverseUploadImageMutationOptions = <
    TError = ErrorResponse | void | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof pixverseUploadImage>>,
        TError,
        { data: PixverseUploadImageBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof pixverseUploadImage>>,
    TError,
    { data: PixverseUploadImageBody },
    TContext
> => {
    const mutationKey = ["pixverseUploadImage"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof pixverseUploadImage>>,
        { data: PixverseUploadImageBody }
    > = (props) => {
        const { data } = props ?? {};

        return pixverseUploadImage(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PixverseUploadImageMutationResult = NonNullable<
    Awaited<ReturnType<typeof pixverseUploadImage>>
>;
export type PixverseUploadImageMutationBody = PixverseUploadImageBody;
export type PixverseUploadImageMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Upload an image to the server.
 */
export const usePixverseUploadImage = <
    TError = ErrorResponse | void | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof pixverseUploadImage>>,
            TError,
            { data: PixverseUploadImageBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof pixverseUploadImage>>,
    TError,
    { data: PixverseUploadImageBody },
    TContext
> => {
    const mutationOptions = getPixverseUploadImageMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generate video from image.
 */
export const pixverseGenerateImageVideo = (
    pixverseImageVideoRequest: PixverseImageVideoRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<PixverseVideoResponse>(
        {
            url: `/proxy/pixverse/video/img/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: pixverseImageVideoRequest,
            signal,
        },
        options,
    );
};

export const getPixverseGenerateImageVideoMutationOptions = <
    TError = ErrorResponse | void | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof pixverseGenerateImageVideo>>,
        TError,
        { data: PixverseImageVideoRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof pixverseGenerateImageVideo>>,
    TError,
    { data: PixverseImageVideoRequest },
    TContext
> => {
    const mutationKey = ["pixverseGenerateImageVideo"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof pixverseGenerateImageVideo>>,
        { data: PixverseImageVideoRequest }
    > = (props) => {
        const { data } = props ?? {};

        return pixverseGenerateImageVideo(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PixverseGenerateImageVideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof pixverseGenerateImageVideo>>
>;
export type PixverseGenerateImageVideoMutationBody = PixverseImageVideoRequest;
export type PixverseGenerateImageVideoMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Generate video from image.
 */
export const usePixverseGenerateImageVideo = <
    TError = ErrorResponse | void | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof pixverseGenerateImageVideo>>,
            TError,
            { data: PixverseImageVideoRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof pixverseGenerateImageVideo>>,
    TError,
    { data: PixverseImageVideoRequest },
    TContext
> => {
    const mutationOptions =
        getPixverseGenerateImageVideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get the result of a video generation.
 */
export const pixverseGetVideoResult = (
    id: number,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<PixverseVideoResultResponse>(
        { url: `/proxy/pixverse/video/result/${id}`, method: "GET", signal },
        options,
    );
};

export const getPixverseGetVideoResultQueryKey = (id?: number) => {
    return [`/proxy/pixverse/video/result/${id}`] as const;
};

export const getPixverseGetVideoResultQueryOptions = <
    TData = Awaited<ReturnType<typeof pixverseGetVideoResult>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof pixverseGetVideoResult>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getPixverseGetVideoResultQueryKey(id);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof pixverseGetVideoResult>>
    > = ({ signal }) => pixverseGetVideoResult(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof pixverseGetVideoResult>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PixverseGetVideoResultQueryResult = NonNullable<
    Awaited<ReturnType<typeof pixverseGetVideoResult>>
>;
export type PixverseGetVideoResultQueryError = unknown;

export function usePixverseGetVideoResult<
    TData = Awaited<ReturnType<typeof pixverseGetVideoResult>>,
    TError = unknown,
>(
    id: number,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof pixverseGetVideoResult>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof pixverseGetVideoResult>>,
                    TError,
                    Awaited<ReturnType<typeof pixverseGetVideoResult>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePixverseGetVideoResult<
    TData = Awaited<ReturnType<typeof pixverseGetVideoResult>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof pixverseGetVideoResult>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof pixverseGetVideoResult>>,
                    TError,
                    Awaited<ReturnType<typeof pixverseGetVideoResult>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePixverseGetVideoResult<
    TData = Awaited<ReturnType<typeof pixverseGetVideoResult>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof pixverseGetVideoResult>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the result of a video generation.
 */

export function usePixverseGetVideoResult<
    TData = Awaited<ReturnType<typeof pixverseGetVideoResult>>,
    TError = unknown,
>(
    id: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof pixverseGetVideoResult>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getPixverseGetVideoResultQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Generate video from text prompt.
 */
export const pixverseGenerateTextVideo = (
    pixverseTextVideoRequest: PixverseTextVideoRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<PixverseVideoResponse>(
        {
            url: `/proxy/pixverse/video/text/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: pixverseTextVideoRequest,
            signal,
        },
        options,
    );
};

export const getPixverseGenerateTextVideoMutationOptions = <
    TError = ErrorResponse | void | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof pixverseGenerateTextVideo>>,
        TError,
        { data: PixverseTextVideoRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof pixverseGenerateTextVideo>>,
    TError,
    { data: PixverseTextVideoRequest },
    TContext
> => {
    const mutationKey = ["pixverseGenerateTextVideo"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof pixverseGenerateTextVideo>>,
        { data: PixverseTextVideoRequest }
    > = (props) => {
        const { data } = props ?? {};

        return pixverseGenerateTextVideo(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PixverseGenerateTextVideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof pixverseGenerateTextVideo>>
>;
export type PixverseGenerateTextVideoMutationBody = PixverseTextVideoRequest;
export type PixverseGenerateTextVideoMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Generate video from text prompt.
 */
export const usePixverseGenerateTextVideo = <
    TError = ErrorResponse | void | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof pixverseGenerateTextVideo>>,
            TError,
            { data: PixverseTextVideoRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof pixverseGenerateTextVideo>>,
    TError,
    { data: PixverseTextVideoRequest },
    TContext
> => {
    const mutationOptions =
        getPixverseGenerateTextVideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generate transition video between two images.
 */
export const pixverseGenerateTransitionVideo = (
    pixverseTransitionVideoRequest: PixverseTransitionVideoRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<PixverseVideoResponse>(
        {
            url: `/proxy/pixverse/video/transition/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: pixverseTransitionVideoRequest,
            signal,
        },
        options,
    );
};

export const getPixverseGenerateTransitionVideoMutationOptions = <
    TError = ErrorResponse | void | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>,
        TError,
        { data: PixverseTransitionVideoRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>,
    TError,
    { data: PixverseTransitionVideoRequest },
    TContext
> => {
    const mutationKey = ["pixverseGenerateTransitionVideo"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>,
        { data: PixverseTransitionVideoRequest }
    > = (props) => {
        const { data } = props ?? {};

        return pixverseGenerateTransitionVideo(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PixverseGenerateTransitionVideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>
>;
export type PixverseGenerateTransitionVideoMutationBody =
    PixverseTransitionVideoRequest;
export type PixverseGenerateTransitionVideoMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Generate transition video between two images.
 */
export const usePixverseGenerateTransitionVideo = <
    TError = ErrorResponse | void | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>,
            TError,
            { data: PixverseTransitionVideoRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof pixverseGenerateTransitionVideo>>,
    TError,
    { data: PixverseTransitionVideoRequest },
    TContext
> => {
    const mutationOptions =
        getPixverseGenerateTransitionVideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Forwards image generation requests to Recraft's API and returns the generated images.
 * @summary Proxy request to Recraft for image generation
 */
export const recraftImageGeneration = (
    recraftImageGenerationRequest: RecraftImageGenerationRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<RecraftImageGenerationResponse>(
        {
            url: `/proxy/recraft/image_generation`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: recraftImageGenerationRequest,
            signal,
        },
        options,
    );
};

export const getRecraftImageGenerationMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof recraftImageGeneration>>,
        TError,
        { data: RecraftImageGenerationRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof recraftImageGeneration>>,
    TError,
    { data: RecraftImageGenerationRequest },
    TContext
> => {
    const mutationKey = ["recraftImageGeneration"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof recraftImageGeneration>>,
        { data: RecraftImageGenerationRequest }
    > = (props) => {
        const { data } = props ?? {};

        return recraftImageGeneration(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RecraftImageGenerationMutationResult = NonNullable<
    Awaited<ReturnType<typeof recraftImageGeneration>>
>;
export type RecraftImageGenerationMutationBody = RecraftImageGenerationRequest;
export type RecraftImageGenerationMutationError =
    | ErrorResponse
    | void
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Proxy request to Recraft for image generation
 */
export const useRecraftImageGeneration = <
    TError =
        | ErrorResponse
        | void
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof recraftImageGeneration>>,
            TError,
            { data: RecraftImageGenerationRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof recraftImageGeneration>>,
    TError,
    { data: RecraftImageGenerationRequest },
    TContext
> => {
    const mutationOptions = getRecraftImageGenerationMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Creative Upscale
 */
export const recraftCreativeUpscale = (
    recraftProcessImageRequest: RecraftProcessImageRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    formData.append(`image`, recraftProcessImageRequest.image);
    if (recraftProcessImageRequest.image_format !== undefined) {
        formData.append(
            `image_format`,
            recraftProcessImageRequest.image_format,
        );
    }
    if (recraftProcessImageRequest.response_format !== undefined) {
        formData.append(
            `response_format`,
            recraftProcessImageRequest.response_format,
        );
    }

    return customInstance<RecraftProcessImageResponse>(
        {
            url: `/proxy/recraft/images/creativeUpscale`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getRecraftCreativeUpscaleMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof recraftCreativeUpscale>>,
        TError,
        { data: RecraftProcessImageRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof recraftCreativeUpscale>>,
    TError,
    { data: RecraftProcessImageRequest },
    TContext
> => {
    const mutationKey = ["recraftCreativeUpscale"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof recraftCreativeUpscale>>,
        { data: RecraftProcessImageRequest }
    > = (props) => {
        const { data } = props ?? {};

        return recraftCreativeUpscale(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RecraftCreativeUpscaleMutationResult = NonNullable<
    Awaited<ReturnType<typeof recraftCreativeUpscale>>
>;
export type RecraftCreativeUpscaleMutationBody = RecraftProcessImageRequest;
export type RecraftCreativeUpscaleMutationError = unknown;

/**
 * @summary Creative Upscale
 */
export const useRecraftCreativeUpscale = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof recraftCreativeUpscale>>,
            TError,
            { data: RecraftProcessImageRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof recraftCreativeUpscale>>,
    TError,
    { data: RecraftProcessImageRequest },
    TContext
> => {
    const mutationOptions = getRecraftCreativeUpscaleMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Upscale an image
 */
export const recraftCrispUpscale = (
    recraftCrispUpscaleBody: RecraftCrispUpscaleBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    formData.append(`file`, recraftCrispUpscaleBody.file);

    return customInstance<RecraftImageGenerationResponse>(
        {
            url: `/proxy/recraft/images/crispUpscale`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getRecraftCrispUpscaleMutationOptions = <
    TError = void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof recraftCrispUpscale>>,
        TError,
        { data: RecraftCrispUpscaleBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof recraftCrispUpscale>>,
    TError,
    { data: RecraftCrispUpscaleBody },
    TContext
> => {
    const mutationKey = ["recraftCrispUpscale"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof recraftCrispUpscale>>,
        { data: RecraftCrispUpscaleBody }
    > = (props) => {
        const { data } = props ?? {};

        return recraftCrispUpscale(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RecraftCrispUpscaleMutationResult = NonNullable<
    Awaited<ReturnType<typeof recraftCrispUpscale>>
>;
export type RecraftCrispUpscaleMutationBody = RecraftCrispUpscaleBody;
export type RecraftCrispUpscaleMutationError = void | void;

/**
 * @summary Upscale an image
 */
export const useRecraftCrispUpscale = <
    TError = void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof recraftCrispUpscale>>,
            TError,
            { data: RecraftCrispUpscaleBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof recraftCrispUpscale>>,
    TError,
    { data: RecraftCrispUpscaleBody },
    TContext
> => {
    const mutationOptions = getRecraftCrispUpscaleMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generate image from image and prompt
 */
export const recraftImageToImage = (
    recraftImageToImageRequest: RecraftImageToImageRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (recraftImageToImageRequest.block_nsfw !== undefined) {
        formData.append(
            `block_nsfw`,
            recraftImageToImageRequest.block_nsfw.toString(),
        );
    }
    if (recraftImageToImageRequest.calculate_features !== undefined) {
        formData.append(
            `calculate_features`,
            recraftImageToImageRequest.calculate_features.toString(),
        );
    }
    if (recraftImageToImageRequest.controls !== undefined) {
        formData.append(
            `controls`,
            JSON.stringify(recraftImageToImageRequest.controls),
        );
    }
    formData.append(`image`, recraftImageToImageRequest.image);
    if (recraftImageToImageRequest.image_format !== undefined) {
        formData.append(
            `image_format`,
            recraftImageToImageRequest.image_format,
        );
    }
    if (recraftImageToImageRequest.model !== undefined) {
        formData.append(`model`, recraftImageToImageRequest.model);
    }
    if (recraftImageToImageRequest.n !== undefined) {
        formData.append(`n`, recraftImageToImageRequest.n.toString());
    }
    if (recraftImageToImageRequest.negative_prompt !== undefined) {
        formData.append(
            `negative_prompt`,
            recraftImageToImageRequest.negative_prompt,
        );
    }
    formData.append(`prompt`, recraftImageToImageRequest.prompt);
    if (recraftImageToImageRequest.response_format !== undefined) {
        formData.append(
            `response_format`,
            recraftImageToImageRequest.response_format,
        );
    }
    formData.append(`strength`, recraftImageToImageRequest.strength.toString());
    if (recraftImageToImageRequest.style !== undefined) {
        formData.append(`style`, recraftImageToImageRequest.style);
    }
    if (recraftImageToImageRequest.style_id !== undefined) {
        formData.append(`style_id`, recraftImageToImageRequest.style_id);
    }
    if (recraftImageToImageRequest.substyle !== undefined) {
        formData.append(`substyle`, recraftImageToImageRequest.substyle);
    }
    if (recraftImageToImageRequest.text_layout !== undefined) {
        recraftImageToImageRequest.text_layout.forEach((value) =>
            formData.append(`text_layout`, JSON.stringify(value)),
        );
    }

    return customInstance<RecraftGenerateImageResponse>(
        {
            url: `/proxy/recraft/images/imageToImage`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getRecraftImageToImageMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof recraftImageToImage>>,
        TError,
        { data: RecraftImageToImageRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof recraftImageToImage>>,
    TError,
    { data: RecraftImageToImageRequest },
    TContext
> => {
    const mutationKey = ["recraftImageToImage"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof recraftImageToImage>>,
        { data: RecraftImageToImageRequest }
    > = (props) => {
        const { data } = props ?? {};

        return recraftImageToImage(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RecraftImageToImageMutationResult = NonNullable<
    Awaited<ReturnType<typeof recraftImageToImage>>
>;
export type RecraftImageToImageMutationBody = RecraftImageToImageRequest;
export type RecraftImageToImageMutationError = unknown;

/**
 * @summary Generate image from image and prompt
 */
export const useRecraftImageToImage = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof recraftImageToImage>>,
            TError,
            { data: RecraftImageToImageRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof recraftImageToImage>>,
    TError,
    { data: RecraftImageToImageRequest },
    TContext
> => {
    const mutationOptions = getRecraftImageToImageMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Inpaint Image
 */
export const recraftInpaintImage = (
    recraftTransformImageWithMaskRequest: RecraftTransformImageWithMaskRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (recraftTransformImageWithMaskRequest.block_nsfw !== undefined) {
        formData.append(
            `block_nsfw`,
            recraftTransformImageWithMaskRequest.block_nsfw.toString(),
        );
    }
    if (recraftTransformImageWithMaskRequest.calculate_features !== undefined) {
        formData.append(
            `calculate_features`,
            recraftTransformImageWithMaskRequest.calculate_features.toString(),
        );
    }
    formData.append(`image`, recraftTransformImageWithMaskRequest.image);
    if (recraftTransformImageWithMaskRequest.image_format !== undefined) {
        formData.append(
            `image_format`,
            recraftTransformImageWithMaskRequest.image_format,
        );
    }
    formData.append(`mask`, recraftTransformImageWithMaskRequest.mask);
    if (recraftTransformImageWithMaskRequest.model !== undefined) {
        formData.append(`model`, recraftTransformImageWithMaskRequest.model);
    }
    if (recraftTransformImageWithMaskRequest.n !== undefined) {
        formData.append(`n`, recraftTransformImageWithMaskRequest.n.toString());
    }
    if (recraftTransformImageWithMaskRequest.negative_prompt !== undefined) {
        formData.append(
            `negative_prompt`,
            recraftTransformImageWithMaskRequest.negative_prompt,
        );
    }
    formData.append(`prompt`, recraftTransformImageWithMaskRequest.prompt);
    if (recraftTransformImageWithMaskRequest.response_format !== undefined) {
        formData.append(
            `response_format`,
            recraftTransformImageWithMaskRequest.response_format,
        );
    }
    if (recraftTransformImageWithMaskRequest.style !== undefined) {
        formData.append(`style`, recraftTransformImageWithMaskRequest.style);
    }
    if (recraftTransformImageWithMaskRequest.style_id !== undefined) {
        formData.append(
            `style_id`,
            recraftTransformImageWithMaskRequest.style_id,
        );
    }
    if (recraftTransformImageWithMaskRequest.substyle !== undefined) {
        formData.append(
            `substyle`,
            recraftTransformImageWithMaskRequest.substyle,
        );
    }
    if (recraftTransformImageWithMaskRequest.text_layout !== undefined) {
        recraftTransformImageWithMaskRequest.text_layout.forEach((value) =>
            formData.append(`text_layout`, JSON.stringify(value)),
        );
    }

    return customInstance<RecraftGenerateImageResponse>(
        {
            url: `/proxy/recraft/images/inpaint`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getRecraftInpaintImageMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof recraftInpaintImage>>,
        TError,
        { data: RecraftTransformImageWithMaskRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof recraftInpaintImage>>,
    TError,
    { data: RecraftTransformImageWithMaskRequest },
    TContext
> => {
    const mutationKey = ["recraftInpaintImage"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof recraftInpaintImage>>,
        { data: RecraftTransformImageWithMaskRequest }
    > = (props) => {
        const { data } = props ?? {};

        return recraftInpaintImage(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RecraftInpaintImageMutationResult = NonNullable<
    Awaited<ReturnType<typeof recraftInpaintImage>>
>;
export type RecraftInpaintImageMutationBody =
    RecraftTransformImageWithMaskRequest;
export type RecraftInpaintImageMutationError = unknown;

/**
 * @summary Inpaint Image
 */
export const useRecraftInpaintImage = <TError = unknown, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof recraftInpaintImage>>,
            TError,
            { data: RecraftTransformImageWithMaskRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof recraftInpaintImage>>,
    TError,
    { data: RecraftTransformImageWithMaskRequest },
    TContext
> => {
    const mutationOptions = getRecraftInpaintImageMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Remove background from an image
 */
export const recraftRemoveBackground = (
    recraftRemoveBackgroundBody: RecraftRemoveBackgroundBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    formData.append(`file`, recraftRemoveBackgroundBody.file);

    return customInstance<RecraftRemoveBackground200>(
        {
            url: `/proxy/recraft/images/removeBackground`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getRecraftRemoveBackgroundMutationOptions = <
    TError = void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof recraftRemoveBackground>>,
        TError,
        { data: RecraftRemoveBackgroundBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof recraftRemoveBackground>>,
    TError,
    { data: RecraftRemoveBackgroundBody },
    TContext
> => {
    const mutationKey = ["recraftRemoveBackground"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof recraftRemoveBackground>>,
        { data: RecraftRemoveBackgroundBody }
    > = (props) => {
        const { data } = props ?? {};

        return recraftRemoveBackground(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RecraftRemoveBackgroundMutationResult = NonNullable<
    Awaited<ReturnType<typeof recraftRemoveBackground>>
>;
export type RecraftRemoveBackgroundMutationBody = RecraftRemoveBackgroundBody;
export type RecraftRemoveBackgroundMutationError = void | void;

/**
 * @summary Remove background from an image
 */
export const useRecraftRemoveBackground = <
    TError = void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof recraftRemoveBackground>>,
            TError,
            { data: RecraftRemoveBackgroundBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof recraftRemoveBackground>>,
    TError,
    { data: RecraftRemoveBackgroundBody },
    TContext
> => {
    const mutationOptions = getRecraftRemoveBackgroundMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Replace Background
 */
export const recraftReplaceBackground = (
    recraftTransformImageWithMaskRequest: RecraftTransformImageWithMaskRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (recraftTransformImageWithMaskRequest.block_nsfw !== undefined) {
        formData.append(
            `block_nsfw`,
            recraftTransformImageWithMaskRequest.block_nsfw.toString(),
        );
    }
    if (recraftTransformImageWithMaskRequest.calculate_features !== undefined) {
        formData.append(
            `calculate_features`,
            recraftTransformImageWithMaskRequest.calculate_features.toString(),
        );
    }
    formData.append(`image`, recraftTransformImageWithMaskRequest.image);
    if (recraftTransformImageWithMaskRequest.image_format !== undefined) {
        formData.append(
            `image_format`,
            recraftTransformImageWithMaskRequest.image_format,
        );
    }
    formData.append(`mask`, recraftTransformImageWithMaskRequest.mask);
    if (recraftTransformImageWithMaskRequest.model !== undefined) {
        formData.append(`model`, recraftTransformImageWithMaskRequest.model);
    }
    if (recraftTransformImageWithMaskRequest.n !== undefined) {
        formData.append(`n`, recraftTransformImageWithMaskRequest.n.toString());
    }
    if (recraftTransformImageWithMaskRequest.negative_prompt !== undefined) {
        formData.append(
            `negative_prompt`,
            recraftTransformImageWithMaskRequest.negative_prompt,
        );
    }
    formData.append(`prompt`, recraftTransformImageWithMaskRequest.prompt);
    if (recraftTransformImageWithMaskRequest.response_format !== undefined) {
        formData.append(
            `response_format`,
            recraftTransformImageWithMaskRequest.response_format,
        );
    }
    if (recraftTransformImageWithMaskRequest.style !== undefined) {
        formData.append(`style`, recraftTransformImageWithMaskRequest.style);
    }
    if (recraftTransformImageWithMaskRequest.style_id !== undefined) {
        formData.append(
            `style_id`,
            recraftTransformImageWithMaskRequest.style_id,
        );
    }
    if (recraftTransformImageWithMaskRequest.substyle !== undefined) {
        formData.append(
            `substyle`,
            recraftTransformImageWithMaskRequest.substyle,
        );
    }
    if (recraftTransformImageWithMaskRequest.text_layout !== undefined) {
        recraftTransformImageWithMaskRequest.text_layout.forEach((value) =>
            formData.append(`text_layout`, JSON.stringify(value)),
        );
    }

    return customInstance<RecraftGenerateImageResponse>(
        {
            url: `/proxy/recraft/images/replaceBackground`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getRecraftReplaceBackgroundMutationOptions = <
    TError = unknown,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof recraftReplaceBackground>>,
        TError,
        { data: RecraftTransformImageWithMaskRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof recraftReplaceBackground>>,
    TError,
    { data: RecraftTransformImageWithMaskRequest },
    TContext
> => {
    const mutationKey = ["recraftReplaceBackground"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof recraftReplaceBackground>>,
        { data: RecraftTransformImageWithMaskRequest }
    > = (props) => {
        const { data } = props ?? {};

        return recraftReplaceBackground(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RecraftReplaceBackgroundMutationResult = NonNullable<
    Awaited<ReturnType<typeof recraftReplaceBackground>>
>;
export type RecraftReplaceBackgroundMutationBody =
    RecraftTransformImageWithMaskRequest;
export type RecraftReplaceBackgroundMutationError = unknown;

/**
 * @summary Replace Background
 */
export const useRecraftReplaceBackground = <
    TError = unknown,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof recraftReplaceBackground>>,
            TError,
            { data: RecraftTransformImageWithMaskRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof recraftReplaceBackground>>,
    TError,
    { data: RecraftTransformImageWithMaskRequest },
    TContext
> => {
    const mutationOptions = getRecraftReplaceBackgroundMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Vectorize an image
 */
export const recraftVectorize = (
    recraftVectorizeBody: RecraftVectorizeBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    formData.append(`file`, recraftVectorizeBody.file);

    return customInstance<RecraftImageGenerationResponse>(
        {
            url: `/proxy/recraft/images/vectorize`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getRecraftVectorizeMutationOptions = <
    TError = void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof recraftVectorize>>,
        TError,
        { data: RecraftVectorizeBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof recraftVectorize>>,
    TError,
    { data: RecraftVectorizeBody },
    TContext
> => {
    const mutationKey = ["recraftVectorize"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof recraftVectorize>>,
        { data: RecraftVectorizeBody }
    > = (props) => {
        const { data } = props ?? {};

        return recraftVectorize(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RecraftVectorizeMutationResult = NonNullable<
    Awaited<ReturnType<typeof recraftVectorize>>
>;
export type RecraftVectorizeMutationBody = RecraftVectorizeBody;
export type RecraftVectorizeMutationError = void | void;

/**
 * @summary Vectorize an image
 */
export const useRecraftVectorize = <TError = void | void, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof recraftVectorize>>,
            TError,
            { data: RecraftVectorizeBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof recraftVectorize>>,
    TError,
    { data: RecraftVectorizeBody },
    TContext
> => {
    const mutationOptions = getRecraftVectorizeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get rodin 3D Assets download list.
 */
export const rodinDownload = (
    rodin3DDownloadRequest: Rodin3DDownloadRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    formData.append(`task_uuid`, rodin3DDownloadRequest.task_uuid);

    return customInstance<Rodin3DDownloadResponse>(
        {
            url: `/proxy/rodin/api/v2/download`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getRodinDownloadMutationOptions = <
    TError = void | void | void | void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof rodinDownload>>,
        TError,
        { data: Rodin3DDownloadRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof rodinDownload>>,
    TError,
    { data: Rodin3DDownloadRequest },
    TContext
> => {
    const mutationKey = ["rodinDownload"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof rodinDownload>>,
        { data: Rodin3DDownloadRequest }
    > = (props) => {
        const { data } = props ?? {};

        return rodinDownload(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RodinDownloadMutationResult = NonNullable<
    Awaited<ReturnType<typeof rodinDownload>>
>;
export type RodinDownloadMutationBody = Rodin3DDownloadRequest;
export type RodinDownloadMutationError = void | void | void | void | void;

/**
 * @summary Get rodin 3D Assets download list.
 */
export const useRodinDownload = <
    TError = void | void | void | void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof rodinDownload>>,
            TError,
            { data: Rodin3DDownloadRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof rodinDownload>>,
    TError,
    { data: Rodin3DDownloadRequest },
    TContext
> => {
    const mutationOptions = getRodinDownloadMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create 3D generate Task using Rodin API.
 */
export const rodinGenerate3DAsset = (
    rodin3DGenerateRequest: Rodin3DGenerateRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    formData.append(`images`, rodin3DGenerateRequest.images);
    if (rodin3DGenerateRequest.material !== undefined) {
        formData.append(`material`, rodin3DGenerateRequest.material);
    }
    if (rodin3DGenerateRequest.mesh_mode !== undefined) {
        formData.append(`mesh_mode`, rodin3DGenerateRequest.mesh_mode);
    }
    if (rodin3DGenerateRequest.quality !== undefined) {
        formData.append(`quality`, rodin3DGenerateRequest.quality);
    }
    if (rodin3DGenerateRequest.seed !== undefined) {
        formData.append(`seed`, rodin3DGenerateRequest.seed.toString());
    }
    if (rodin3DGenerateRequest.tier !== undefined) {
        formData.append(`tier`, rodin3DGenerateRequest.tier);
    }

    return customInstance<Rodin3DGenerateResponse>(
        {
            url: `/proxy/rodin/api/v2/rodin`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getRodinGenerate3DAssetMutationOptions = <
    TError = void | void | void | void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof rodinGenerate3DAsset>>,
        TError,
        { data: Rodin3DGenerateRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof rodinGenerate3DAsset>>,
    TError,
    { data: Rodin3DGenerateRequest },
    TContext
> => {
    const mutationKey = ["rodinGenerate3DAsset"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof rodinGenerate3DAsset>>,
        { data: Rodin3DGenerateRequest }
    > = (props) => {
        const { data } = props ?? {};

        return rodinGenerate3DAsset(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RodinGenerate3DAssetMutationResult = NonNullable<
    Awaited<ReturnType<typeof rodinGenerate3DAsset>>
>;
export type RodinGenerate3DAssetMutationBody = Rodin3DGenerateRequest;
export type RodinGenerate3DAssetMutationError =
    | void
    | void
    | void
    | void
    | void;

/**
 * @summary Create 3D generate Task using Rodin API.
 */
export const useRodinGenerate3DAsset = <
    TError = void | void | void | void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof rodinGenerate3DAsset>>,
            TError,
            { data: Rodin3DGenerateRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof rodinGenerate3DAsset>>,
    TError,
    { data: Rodin3DGenerateRequest },
    TContext
> => {
    const mutationOptions = getRodinGenerate3DAssetMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Check Rodin 3D Generate Status.
 */
export const rodinCheckStatus = (
    rodin3DCheckStatusRequest: Rodin3DCheckStatusRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    formData.append(
        `subscription_key`,
        rodin3DCheckStatusRequest.subscription_key,
    );

    return customInstance<Rodin3DCheckStatusResponse>(
        {
            url: `/proxy/rodin/api/v2/status`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getRodinCheckStatusMutationOptions = <
    TError = void | void | void | void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof rodinCheckStatus>>,
        TError,
        { data: Rodin3DCheckStatusRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof rodinCheckStatus>>,
    TError,
    { data: Rodin3DCheckStatusRequest },
    TContext
> => {
    const mutationKey = ["rodinCheckStatus"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof rodinCheckStatus>>,
        { data: Rodin3DCheckStatusRequest }
    > = (props) => {
        const { data } = props ?? {};

        return rodinCheckStatus(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RodinCheckStatusMutationResult = NonNullable<
    Awaited<ReturnType<typeof rodinCheckStatus>>
>;
export type RodinCheckStatusMutationBody = Rodin3DCheckStatusRequest;
export type RodinCheckStatusMutationError = void | void | void | void | void;

/**
 * @summary Check Rodin 3D Generate Status.
 */
export const useRodinCheckStatus = <
    TError = void | void | void | void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof rodinCheckStatus>>,
            TError,
            { data: Rodin3DCheckStatusRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof rodinCheckStatus>>,
    TError,
    { data: Rodin3DCheckStatusRequest },
    TContext
> => {
    const mutationOptions = getRodinCheckStatusMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Converts an image to a video using Runway's API
 * @summary Runway Image to Video Generation
 */
export const runwayImageToVideo = (
    runwayImageToVideoRequest: RunwayImageToVideoRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<RunwayImageToVideoResponse>(
        {
            url: `/proxy/runway/image_to_video`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: runwayImageToVideoRequest,
            signal,
        },
        options,
    );
};

export const getRunwayImageToVideoMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof runwayImageToVideo>>,
        TError,
        { data: RunwayImageToVideoRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof runwayImageToVideo>>,
    TError,
    { data: RunwayImageToVideoRequest },
    TContext
> => {
    const mutationKey = ["runwayImageToVideo"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof runwayImageToVideo>>,
        { data: RunwayImageToVideoRequest }
    > = (props) => {
        const { data } = props ?? {};

        return runwayImageToVideo(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RunwayImageToVideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof runwayImageToVideo>>
>;
export type RunwayImageToVideoMutationBody = RunwayImageToVideoRequest;
export type RunwayImageToVideoMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Runway Image to Video Generation
 */
export const useRunwayImageToVideo = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof runwayImageToVideo>>,
            TError,
            { data: RunwayImageToVideoRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof runwayImageToVideo>>,
    TError,
    { data: RunwayImageToVideoRequest },
    TContext
> => {
    const mutationOptions = getRunwayImageToVideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Get the status and output of a Runway task
 * @summary Get Runway Task Status
 */
export const runwayGetTaskStatus = (
    taskId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<RunwayTaskStatusResponse>(
        { url: `/proxy/runway/tasks/${taskId}`, method: "GET", signal },
        options,
    );
};

export const getRunwayGetTaskStatusQueryKey = (taskId?: string) => {
    return [`/proxy/runway/tasks/${taskId}`] as const;
};

export const getRunwayGetTaskStatusQueryOptions = <
    TData = Awaited<ReturnType<typeof runwayGetTaskStatus>>,
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof runwayGetTaskStatus>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getRunwayGetTaskStatusQueryKey(taskId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof runwayGetTaskStatus>>
    > = ({ signal }) => runwayGetTaskStatus(taskId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!taskId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof runwayGetTaskStatus>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RunwayGetTaskStatusQueryResult = NonNullable<
    Awaited<ReturnType<typeof runwayGetTaskStatus>>
>;
export type RunwayGetTaskStatusQueryError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

export function useRunwayGetTaskStatus<
    TData = Awaited<ReturnType<typeof runwayGetTaskStatus>>,
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
>(
    taskId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof runwayGetTaskStatus>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof runwayGetTaskStatus>>,
                    TError,
                    Awaited<ReturnType<typeof runwayGetTaskStatus>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRunwayGetTaskStatus<
    TData = Awaited<ReturnType<typeof runwayGetTaskStatus>>,
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof runwayGetTaskStatus>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof runwayGetTaskStatus>>,
                    TError,
                    Awaited<ReturnType<typeof runwayGetTaskStatus>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRunwayGetTaskStatus<
    TData = Awaited<ReturnType<typeof runwayGetTaskStatus>>,
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof runwayGetTaskStatus>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Runway Task Status
 */

export function useRunwayGetTaskStatus<
    TData = Awaited<ReturnType<typeof runwayGetTaskStatus>>,
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof runwayGetTaskStatus>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getRunwayGetTaskStatusQueryOptions(taskId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Generates an image from text using Runway's API
 * @summary Runway Text to Image Generation
 */
export const runwayTextToImage = (
    runwayTextToImageRequest: RunwayTextToImageRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<RunwayTextToImageResponse>(
        {
            url: `/proxy/runway/text_to_image`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: runwayTextToImageRequest,
            signal,
        },
        options,
    );
};

export const getRunwayTextToImageMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof runwayTextToImage>>,
        TError,
        { data: RunwayTextToImageRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof runwayTextToImage>>,
    TError,
    { data: RunwayTextToImageRequest },
    TContext
> => {
    const mutationKey = ["runwayTextToImage"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof runwayTextToImage>>,
        { data: RunwayTextToImageRequest }
    > = (props) => {
        const { data } = props ?? {};

        return runwayTextToImage(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type RunwayTextToImageMutationResult = NonNullable<
    Awaited<ReturnType<typeof runwayTextToImage>>
>;
export type RunwayTextToImageMutationBody = RunwayTextToImageRequest;
export type RunwayTextToImageMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Runway Text to Image Generation
 */
export const useRunwayTextToImage = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof runwayTextToImage>>,
            TError,
            { data: RunwayTextToImageRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof runwayTextToImage>>,
    TError,
    { data: RunwayTextToImageRequest },
    TContext
> => {
    const mutationOptions = getRunwayTextToImageMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Proxy request to Stable Audio for audio-to-audio transformation
 */
export const stableAudio25AudioToAudio = (
    stableAudio25AudioToAudioRequest: StableAudio25AudioToAudioRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    formData.append(`audio`, stableAudio25AudioToAudioRequest.audio);
    if (stableAudio25AudioToAudioRequest.cfg_scale !== undefined) {
        formData.append(
            `cfg_scale`,
            stableAudio25AudioToAudioRequest.cfg_scale.toString(),
        );
    }
    if (stableAudio25AudioToAudioRequest.duration !== undefined) {
        formData.append(
            `duration`,
            stableAudio25AudioToAudioRequest.duration.toString(),
        );
    }
    formData.append(`model`, stableAudio25AudioToAudioRequest.model);
    if (stableAudio25AudioToAudioRequest.output_format !== undefined) {
        formData.append(
            `output_format`,
            stableAudio25AudioToAudioRequest.output_format,
        );
    }
    formData.append(`prompt`, stableAudio25AudioToAudioRequest.prompt);
    if (stableAudio25AudioToAudioRequest.seed !== undefined) {
        formData.append(
            `seed`,
            stableAudio25AudioToAudioRequest.seed.toString(),
        );
    }
    if (stableAudio25AudioToAudioRequest.steps !== undefined) {
        formData.append(
            `steps`,
            stableAudio25AudioToAudioRequest.steps.toString(),
        );
    }
    if (stableAudio25AudioToAudioRequest.strength !== undefined) {
        formData.append(
            `strength`,
            stableAudio25AudioToAudioRequest.strength.toString(),
        );
    }

    return customInstance<StableAudio25AudioResponse>(
        {
            url: `/proxy/stability/v2beta/audio/stable-audio-2/audio-to-audio`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getStableAudio25AudioToAudioMutationOptions = <
    TError = ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof stableAudio25AudioToAudio>>,
        TError,
        { data: StableAudio25AudioToAudioRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof stableAudio25AudioToAudio>>,
    TError,
    { data: StableAudio25AudioToAudioRequest },
    TContext
> => {
    const mutationKey = ["stableAudio25AudioToAudio"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof stableAudio25AudioToAudio>>,
        { data: StableAudio25AudioToAudioRequest }
    > = (props) => {
        const { data } = props ?? {};

        return stableAudio25AudioToAudio(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type StableAudio25AudioToAudioMutationResult = NonNullable<
    Awaited<ReturnType<typeof stableAudio25AudioToAudio>>
>;
export type StableAudio25AudioToAudioMutationBody =
    StableAudio25AudioToAudioRequest;
export type StableAudio25AudioToAudioMutationError = ErrorResponse;

/**
 * @summary Proxy request to Stable Audio for audio-to-audio transformation
 */
export const useStableAudio25AudioToAudio = <
    TError = ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof stableAudio25AudioToAudio>>,
            TError,
            { data: StableAudio25AudioToAudioRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof stableAudio25AudioToAudio>>,
    TError,
    { data: StableAudio25AudioToAudioRequest },
    TContext
> => {
    const mutationOptions =
        getStableAudio25AudioToAudioMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Proxy request to Stable Audio 2.5 for audio inpainting
 */
export const stableAudio25Inpaint = (
    stableAudio25InpaintRequest: StableAudio25InpaintRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    formData.append(`audio`, stableAudio25InpaintRequest.audio);
    if (stableAudio25InpaintRequest.duration !== undefined) {
        formData.append(
            `duration`,
            stableAudio25InpaintRequest.duration.toString(),
        );
    }
    if (stableAudio25InpaintRequest.mask_end !== undefined) {
        formData.append(
            `mask_end`,
            stableAudio25InpaintRequest.mask_end.toString(),
        );
    }
    if (stableAudio25InpaintRequest.mask_start !== undefined) {
        formData.append(
            `mask_start`,
            stableAudio25InpaintRequest.mask_start.toString(),
        );
    }
    if (stableAudio25InpaintRequest.output_format !== undefined) {
        formData.append(
            `output_format`,
            stableAudio25InpaintRequest.output_format,
        );
    }
    formData.append(`prompt`, stableAudio25InpaintRequest.prompt);
    if (stableAudio25InpaintRequest.seed !== undefined) {
        formData.append(`seed`, stableAudio25InpaintRequest.seed.toString());
    }
    if (stableAudio25InpaintRequest.steps !== undefined) {
        formData.append(`steps`, stableAudio25InpaintRequest.steps.toString());
    }

    return customInstance<StableAudio25AudioResponse>(
        {
            url: `/proxy/stability/v2beta/audio/stable-audio-2/inpaint`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getStableAudio25InpaintMutationOptions = <
    TError = ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof stableAudio25Inpaint>>,
        TError,
        { data: StableAudio25InpaintRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof stableAudio25Inpaint>>,
    TError,
    { data: StableAudio25InpaintRequest },
    TContext
> => {
    const mutationKey = ["stableAudio25Inpaint"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof stableAudio25Inpaint>>,
        { data: StableAudio25InpaintRequest }
    > = (props) => {
        const { data } = props ?? {};

        return stableAudio25Inpaint(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type StableAudio25InpaintMutationResult = NonNullable<
    Awaited<ReturnType<typeof stableAudio25Inpaint>>
>;
export type StableAudio25InpaintMutationBody = StableAudio25InpaintRequest;
export type StableAudio25InpaintMutationError = ErrorResponse;

/**
 * @summary Proxy request to Stable Audio 2.5 for audio inpainting
 */
export const useStableAudio25Inpaint = <
    TError = ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof stableAudio25Inpaint>>,
            TError,
            { data: StableAudio25InpaintRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof stableAudio25Inpaint>>,
    TError,
    { data: StableAudio25InpaintRequest },
    TContext
> => {
    const mutationOptions = getStableAudio25InpaintMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Proxy request to Stable Audio 2.5 for text-to-audio generation
 */
export const stableAudio25TextToAudio = (
    stableAudio25TextToAudioRequest: StableAudio25TextToAudioRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (stableAudio25TextToAudioRequest.cfg_scale !== undefined) {
        formData.append(
            `cfg_scale`,
            stableAudio25TextToAudioRequest.cfg_scale.toString(),
        );
    }
    if (stableAudio25TextToAudioRequest.duration !== undefined) {
        formData.append(
            `duration`,
            stableAudio25TextToAudioRequest.duration.toString(),
        );
    }
    formData.append(`model`, stableAudio25TextToAudioRequest.model);
    if (stableAudio25TextToAudioRequest.output_format !== undefined) {
        formData.append(
            `output_format`,
            stableAudio25TextToAudioRequest.output_format,
        );
    }
    formData.append(`prompt`, stableAudio25TextToAudioRequest.prompt);
    if (stableAudio25TextToAudioRequest.seed !== undefined) {
        formData.append(
            `seed`,
            stableAudio25TextToAudioRequest.seed.toString(),
        );
    }
    if (stableAudio25TextToAudioRequest.steps !== undefined) {
        formData.append(
            `steps`,
            stableAudio25TextToAudioRequest.steps.toString(),
        );
    }

    return customInstance<StableAudio25AudioResponse>(
        {
            url: `/proxy/stability/v2beta/audio/stable-audio-2/text-to-audio`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getStableAudio25TextToAudioMutationOptions = <
    TError = ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof stableAudio25TextToAudio>>,
        TError,
        { data: StableAudio25TextToAudioRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof stableAudio25TextToAudio>>,
    TError,
    { data: StableAudio25TextToAudioRequest },
    TContext
> => {
    const mutationKey = ["stableAudio25TextToAudio"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof stableAudio25TextToAudio>>,
        { data: StableAudio25TextToAudioRequest }
    > = (props) => {
        const { data } = props ?? {};

        return stableAudio25TextToAudio(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type StableAudio25TextToAudioMutationResult = NonNullable<
    Awaited<ReturnType<typeof stableAudio25TextToAudio>>
>;
export type StableAudio25TextToAudioMutationBody =
    StableAudio25TextToAudioRequest;
export type StableAudio25TextToAudioMutationError = ErrorResponse;

/**
 * @summary Proxy request to Stable Audio 2.5 for text-to-audio generation
 */
export const useStableAudio25TextToAudio = <
    TError = ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof stableAudio25TextToAudio>>,
            TError,
            { data: StableAudio25TextToAudioRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof stableAudio25TextToAudio>>,
    TError,
    { data: StableAudio25TextToAudioRequest },
    TContext
> => {
    const mutationOptions = getStableAudio25TextToAudioMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Get the result of a generation
 * @summary Get Result
 */
export const stabilityGetResult = (
    id: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<
        | StabilityGetResult200One
        | StabilityGetResult200Two
        | StabilityGetResult200Three
        | Blob
        | StabilityGetResultResponse202
    >(
        { url: `/proxy/stability/v2beta/results/${id}`, method: "GET", signal },
        options,
    );
};

export const getStabilityGetResultQueryKey = (id?: string) => {
    return [`/proxy/stability/v2beta/results/${id}`] as const;
};

export const getStabilityGetResultQueryOptions = <
    TData = Awaited<ReturnType<typeof stabilityGetResult>>,
    TError = StabilityError | StabilityError | StabilityError,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof stabilityGetResult>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getStabilityGetResultQueryKey(id);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof stabilityGetResult>>
    > = ({ signal }) => stabilityGetResult(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof stabilityGetResult>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StabilityGetResultQueryResult = NonNullable<
    Awaited<ReturnType<typeof stabilityGetResult>>
>;
export type StabilityGetResultQueryError =
    | StabilityError
    | StabilityError
    | StabilityError;

export function useStabilityGetResult<
    TData = Awaited<ReturnType<typeof stabilityGetResult>>,
    TError = StabilityError | StabilityError | StabilityError,
>(
    id: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof stabilityGetResult>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof stabilityGetResult>>,
                    TError,
                    Awaited<ReturnType<typeof stabilityGetResult>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStabilityGetResult<
    TData = Awaited<ReturnType<typeof stabilityGetResult>>,
    TError = StabilityError | StabilityError | StabilityError,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof stabilityGetResult>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof stabilityGetResult>>,
                    TError,
                    Awaited<ReturnType<typeof stabilityGetResult>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStabilityGetResult<
    TData = Awaited<ReturnType<typeof stabilityGetResult>>,
    TError = StabilityError | StabilityError | StabilityError,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof stabilityGetResult>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Result
 */

export function useStabilityGetResult<
    TData = Awaited<ReturnType<typeof stabilityGetResult>>,
    TError = StabilityError | StabilityError | StabilityError,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof stabilityGetResult>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getStabilityGetResultQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Generate using Stable Diffusion 3.5 models, Stability AI latest base model:

- **Stable Diffusion 3.5 Large**: At 8 billion parameters, with superior quality and



  prompt adherence, this base model is the most powerful in the Stable Diffusion
  family. This model is ideal for professional use cases at 1 megapixel resolution.

- **Stable Diffusion 3.5 Large Turbo**: A distilled version of Stable Diffusion 3.5 Large.



  SD3.5 Large Turbo generates high-quality images with exceptional prompt adherence
  in just 4 steps, making it considerably faster than Stable Diffusion 3.5 Large.

- **Stable Diffusion 3.5 Medium**: With 2.5 billion parameters, the model delivers an



  optimal balance between prompt accuracy and image quality, making it an efficient
  choice for fast high-performance image generation.

Read more about the model capabilities [here](https://stability.ai/news/introducing-stable-diffusion-3-5).

As of April 17, 2025, we have deprecated the Stable Diffusion 3.0 APIs and will be automatically
re-routing calls to Stable Diffusion 3.0 models to Stable Diffusion 3.5 APIs at no extra cost.
You can read more in the [release notes](/docs/release-notes#api-deprecation-notice).

### Try it out
Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/SD3_API.ipynb)

### How to use
Please invoke this endpoint with a `POST` request.

The headers of the request must include an API key in the `authorization` field. The body of the request must be
`multipart/form-data`.  The accept header should be set to one of the following:
- `image/*` to receive the image in the format specified by the `output_format` parameter.
- `application/json` to receive the image encoded as base64 in a JSON response.

#### **Generating with a prompt**
Commonly referred to as **text-to-image**, this mode generates an image from text alone. While the only required
parameter is the `prompt`, it also supports an `aspect_ratio` parameter which can be used to control the
aspect ratio of the generated image.

#### **Generating with a prompt *and* an image**
Commonly referred to as **image-to-image**, this mode also generates an image from text but uses an existing image as the
starting point. The required parameters are:
- `prompt` - text to generate the image from
- `image` - the image to use as the starting point for the generation
- `strength` - controls how much influence the `image` parameter has on the output image
- `mode` - must be set to `image-to-image`

> **Note:** maximum request size is 10MiB.

#### **Optional Parameters:**
Both modes support the following optional parameters:
- `model` - the model to use (SD3.5 Large, SD3.5 Large Turbo, SD3.5 Medium)
- `output_format` - the the format of the output image
- `seed` - the randomness seed to use for the generation
- `negative_prompt` - keywords of what you **do not** wish to see in the output image
- `cfg_scale` - controls how strictly the diffusion process adheres to the prompt text
- `style_preset` - guides the image model towards a particular style

> **Note:** for more details about these parameters please see the request schema below.

### Output
The resolution of the generated image will be 1MP. The default resolution is 1024x1024.

### Credits
- **SD 3.5 Large**: Flat rate of 6.5 credits per successful generation.
- **SD 3.5 Large Turbo**: Flat rate of 4 credits per successful generation.
- **SD 3.5 Medium**: Flat rate of 3.5 credits per successful generation.

As always, you will not be charged for failed generations.
 * @summary Stable Diffusion 3.5
 */
export const stabilityImageGenrationSD3 = (
    stabilityImageGenerationSD3Request: StabilityImageGenerationSD3Request,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (stabilityImageGenerationSD3Request.aspect_ratio !== undefined) {
        formData.append(
            `aspect_ratio`,
            stabilityImageGenerationSD3Request.aspect_ratio,
        );
    }
    if (stabilityImageGenerationSD3Request.cfg_scale !== undefined) {
        formData.append(
            `cfg_scale`,
            stabilityImageGenerationSD3Request.cfg_scale.toString(),
        );
    }
    if (stabilityImageGenerationSD3Request.image !== undefined) {
        formData.append(`image`, stabilityImageGenerationSD3Request.image);
    }
    if (stabilityImageGenerationSD3Request.mode !== undefined) {
        formData.append(`mode`, stabilityImageGenerationSD3Request.mode);
    }
    if (stabilityImageGenerationSD3Request.model !== undefined) {
        formData.append(`model`, stabilityImageGenerationSD3Request.model);
    }
    if (stabilityImageGenerationSD3Request.negative_prompt !== undefined) {
        formData.append(
            `negative_prompt`,
            stabilityImageGenerationSD3Request.negative_prompt,
        );
    }
    if (stabilityImageGenerationSD3Request.output_format !== undefined) {
        formData.append(
            `output_format`,
            stabilityImageGenerationSD3Request.output_format,
        );
    }
    formData.append(`prompt`, stabilityImageGenerationSD3Request.prompt);
    if (stabilityImageGenerationSD3Request.seed !== undefined) {
        formData.append(
            `seed`,
            stabilityImageGenerationSD3Request.seed.toString(),
        );
    }
    if (stabilityImageGenerationSD3Request.strength !== undefined) {
        formData.append(
            `strength`,
            stabilityImageGenerationSD3Request.strength.toString(),
        );
    }
    if (stabilityImageGenerationSD3Request.style_preset !== undefined) {
        formData.append(
            `style_preset`,
            stabilityImageGenerationSD3Request.style_preset,
        );
    }

    return customInstance<StabilityImageGenrationSD3Response200 | Blob>(
        {
            url: `/proxy/stability/v2beta/stable-image/generate/sd3`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getStabilityImageGenrationSD3MutationOptions = <
    TError =
        | StabilityImageGenrationSD3Response400
        | StabilityContentModerationResponse
        | StabilityImageGenrationSD3Response413
        | StabilityImageGenrationSD3Response422
        | StabilityImageGenrationSD3Response429
        | StabilityImageGenrationSD3Response500,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof stabilityImageGenrationSD3>>,
        TError,
        { data: StabilityImageGenerationSD3Request },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof stabilityImageGenrationSD3>>,
    TError,
    { data: StabilityImageGenerationSD3Request },
    TContext
> => {
    const mutationKey = ["stabilityImageGenrationSD3"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof stabilityImageGenrationSD3>>,
        { data: StabilityImageGenerationSD3Request }
    > = (props) => {
        const { data } = props ?? {};

        return stabilityImageGenrationSD3(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type StabilityImageGenrationSD3MutationResult = NonNullable<
    Awaited<ReturnType<typeof stabilityImageGenrationSD3>>
>;
export type StabilityImageGenrationSD3MutationBody =
    StabilityImageGenerationSD3Request;
export type StabilityImageGenrationSD3MutationError =
    | StabilityImageGenrationSD3Response400
    | StabilityContentModerationResponse
    | StabilityImageGenrationSD3Response413
    | StabilityImageGenrationSD3Response422
    | StabilityImageGenrationSD3Response429
    | StabilityImageGenrationSD3Response500;

/**
 * @summary Stable Diffusion 3.5
 */
export const useStabilityImageGenrationSD3 = <
    TError =
        | StabilityImageGenrationSD3Response400
        | StabilityContentModerationResponse
        | StabilityImageGenrationSD3Response413
        | StabilityImageGenrationSD3Response422
        | StabilityImageGenrationSD3Response429
        | StabilityImageGenrationSD3Response500,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof stabilityImageGenrationSD3>>,
            TError,
            { data: StabilityImageGenerationSD3Request },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof stabilityImageGenrationSD3>>,
    TError,
    { data: StabilityImageGenerationSD3Request },
    TContext
> => {
    const mutationOptions =
        getStabilityImageGenrationSD3MutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Our most advanced text to image generation service, Stable Image Ultra creates the highest quality images with unprecedented prompt understanding. Ultra excels in typography, complex compositions, dynamic lighting, vibrant hues, and overall cohesion and structure of an art piece. Made from the most advanced models, including Stable Diffusion 3.5, Ultra offers the best of the Stable Diffusion ecosystem. ### Try it out Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=yXhs626oZdr1) ### How to use Please invoke this endpoint with a `POST` request. The headers of the request must include an API key in the `authorization` field. The body of the request must be `multipart/form-data`.  The accept header should be set to one of the following: - `image/*` to receive the image in the format specified by the `output_format` parameter. - `application/json` to receive the image in the format specified by the `output_format` parameter, but encoded to base64 in a JSON response. The only required parameter is the `prompt` field, which should contain the text prompt for the image generation. The body of the request should include: - `prompt` - text to generate the image from The body may optionally include: - `image` - the image to use as the starting point for the generation - `strength` - controls how much influence the `image` parameter has on the output image - `aspect_ratio` - the aspect ratio of the output image - `negative_prompt` - keywords of what you **do not** wish to see in the output image - `seed` - the randomness seed to use for the generation - `output_format` - the the format of the output image > **Note:** for the full list of optional parameters, please see the request schema below. ### Output The resolution of the generated image will be 1 megapixel. The default resolution is 1024x1024. ### Credits The Ultra service uses 8 credits per successful result. You will not be charged for failed results.
 * @summary Stable Image Ultra
 */
export const stabilityImageGenrationUltra = (
    stabilityImageGenrationUltraBody: StabilityImageGenrationUltraBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (stabilityImageGenrationUltraBody.aspect_ratio !== undefined) {
        formData.append(
            `aspect_ratio`,
            stabilityImageGenrationUltraBody.aspect_ratio,
        );
    }
    if (stabilityImageGenrationUltraBody.image !== undefined) {
        formData.append(`image`, stabilityImageGenrationUltraBody.image);
    }
    if (stabilityImageGenrationUltraBody.negative_prompt !== undefined) {
        formData.append(
            `negative_prompt`,
            stabilityImageGenrationUltraBody.negative_prompt,
        );
    }
    if (stabilityImageGenrationUltraBody.output_format !== undefined) {
        formData.append(
            `output_format`,
            stabilityImageGenrationUltraBody.output_format,
        );
    }
    formData.append(`prompt`, stabilityImageGenrationUltraBody.prompt);
    if (stabilityImageGenrationUltraBody.seed !== undefined) {
        formData.append(
            `seed`,
            stabilityImageGenrationUltraBody.seed.toString(),
        );
    }
    if (stabilityImageGenrationUltraBody.strength !== undefined) {
        formData.append(
            `strength`,
            stabilityImageGenrationUltraBody.strength.toString(),
        );
    }
    if (stabilityImageGenrationUltraBody.style_preset !== undefined) {
        formData.append(
            `style_preset`,
            stabilityImageGenrationUltraBody.style_preset,
        );
    }

    return customInstance<
        | StabilityImageGenrationUltra200One
        | StabilityImageGenrationUltra200Two
        | StabilityImageGenrationUltra200Three
        | Blob
    >(
        {
            url: `/proxy/stability/v2beta/stable-image/generate/ultra`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getStabilityImageGenrationUltraMutationOptions = <
    TError =
        | StabilityImageGenrationUltra400
        | StabilityContentModerationResponse
        | StabilityImageGenrationUltra413
        | StabilityImageGenrationUltra422
        | StabilityImageGenrationUltra429
        | StabilityImageGenrationUltra500,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof stabilityImageGenrationUltra>>,
        TError,
        { data: StabilityImageGenrationUltraBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof stabilityImageGenrationUltra>>,
    TError,
    { data: StabilityImageGenrationUltraBody },
    TContext
> => {
    const mutationKey = ["stabilityImageGenrationUltra"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof stabilityImageGenrationUltra>>,
        { data: StabilityImageGenrationUltraBody }
    > = (props) => {
        const { data } = props ?? {};

        return stabilityImageGenrationUltra(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type StabilityImageGenrationUltraMutationResult = NonNullable<
    Awaited<ReturnType<typeof stabilityImageGenrationUltra>>
>;
export type StabilityImageGenrationUltraMutationBody =
    StabilityImageGenrationUltraBody;
export type StabilityImageGenrationUltraMutationError =
    | StabilityImageGenrationUltra400
    | StabilityContentModerationResponse
    | StabilityImageGenrationUltra413
    | StabilityImageGenrationUltra422
    | StabilityImageGenrationUltra429
    | StabilityImageGenrationUltra500;

/**
 * @summary Stable Image Ultra
 */
export const useStabilityImageGenrationUltra = <
    TError =
        | StabilityImageGenrationUltra400
        | StabilityContentModerationResponse
        | StabilityImageGenrationUltra413
        | StabilityImageGenrationUltra422
        | StabilityImageGenrationUltra429
        | StabilityImageGenrationUltra500,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof stabilityImageGenrationUltra>>,
            TError,
            { data: StabilityImageGenrationUltraBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof stabilityImageGenrationUltra>>,
    TError,
    { data: StabilityImageGenrationUltraBody },
    TContext
> => {
    const mutationOptions =
        getStabilityImageGenrationUltraMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Takes images between 64x64 and 1 megapixel and upscales them all the way to 4K resolution. Put more generally, it can upscale images ~20-40x times while preserving all aspects. Conservative Upscale minimizes alterations to the image and should not be used to reimagine an image.

### Try it out
Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=t1Q4w2uvvza0)

### How to use

Please invoke this endpoint with a `POST` request.

The headers of the request must include an API key in the `authorization` field. The body of the request must be
`multipart/form-data`, and the `accept` header should be set to one of the following:



  - `image/*` to receive the image in the format specified by the `output_format` parameter.
  - `application/json` to receive the image encoded as base64 in a JSON response.

The body of the request must include:
- `image`
- `prompt`

Optionally, the body of the request may also include:
- `negative_prompt`
- `seed`
- `output_format`
- `creativity`

> **Note:** for more details about these parameters please see the request schema below.

### Output
The resolution of the generated image will be 4 megapixels.

### Credits
Flat rate of 25 credits per successful generation.  You will not be charged for failed generations.
 * @summary Conservative
 */
export const stabilityImageGenrationUpscaleConservative = (
    stabilityImageGenrationUpscaleConservativeRequest: StabilityImageGenrationUpscaleConservativeRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (
        stabilityImageGenrationUpscaleConservativeRequest.creativity !==
        undefined
    ) {
        formData.append(
            `creativity`,
            stabilityImageGenrationUpscaleConservativeRequest.creativity.toString(),
        );
    }
    formData.append(
        `image`,
        stabilityImageGenrationUpscaleConservativeRequest.image,
    );
    if (
        stabilityImageGenrationUpscaleConservativeRequest.negative_prompt !==
        undefined
    ) {
        formData.append(
            `negative_prompt`,
            stabilityImageGenrationUpscaleConservativeRequest.negative_prompt,
        );
    }
    if (
        stabilityImageGenrationUpscaleConservativeRequest.output_format !==
        undefined
    ) {
        formData.append(
            `output_format`,
            stabilityImageGenrationUpscaleConservativeRequest.output_format,
        );
    }
    formData.append(
        `prompt`,
        stabilityImageGenrationUpscaleConservativeRequest.prompt,
    );
    if (stabilityImageGenrationUpscaleConservativeRequest.seed !== undefined) {
        formData.append(
            `seed`,
            stabilityImageGenrationUpscaleConservativeRequest.seed.toString(),
        );
    }

    return customInstance<
        StabilityImageGenrationUpscaleConservativeResponse200 | Blob
    >(
        {
            url: `/proxy/stability/v2beta/stable-image/upscale/conservative`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getStabilityImageGenrationUpscaleConservativeMutationOptions = <
    TError =
        | StabilityImageGenrationUpscaleConservativeResponse400
        | StabilityContentModerationResponse
        | StabilityImageGenrationUpscaleConservativeResponse413
        | StabilityImageGenrationUpscaleConservativeResponse422
        | StabilityImageGenrationUpscaleConservativeResponse429
        | StabilityImageGenrationUpscaleConservativeResponse500,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof stabilityImageGenrationUpscaleConservative>>,
        TError,
        { data: StabilityImageGenrationUpscaleConservativeRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof stabilityImageGenrationUpscaleConservative>>,
    TError,
    { data: StabilityImageGenrationUpscaleConservativeRequest },
    TContext
> => {
    const mutationKey = ["stabilityImageGenrationUpscaleConservative"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof stabilityImageGenrationUpscaleConservative>>,
        { data: StabilityImageGenrationUpscaleConservativeRequest }
    > = (props) => {
        const { data } = props ?? {};

        return stabilityImageGenrationUpscaleConservative(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type StabilityImageGenrationUpscaleConservativeMutationResult =
    NonNullable<
        Awaited<ReturnType<typeof stabilityImageGenrationUpscaleConservative>>
    >;
export type StabilityImageGenrationUpscaleConservativeMutationBody =
    StabilityImageGenrationUpscaleConservativeRequest;
export type StabilityImageGenrationUpscaleConservativeMutationError =
    | StabilityImageGenrationUpscaleConservativeResponse400
    | StabilityContentModerationResponse
    | StabilityImageGenrationUpscaleConservativeResponse413
    | StabilityImageGenrationUpscaleConservativeResponse422
    | StabilityImageGenrationUpscaleConservativeResponse429
    | StabilityImageGenrationUpscaleConservativeResponse500;

/**
 * @summary Conservative
 */
export const useStabilityImageGenrationUpscaleConservative = <
    TError =
        | StabilityImageGenrationUpscaleConservativeResponse400
        | StabilityContentModerationResponse
        | StabilityImageGenrationUpscaleConservativeResponse413
        | StabilityImageGenrationUpscaleConservativeResponse422
        | StabilityImageGenrationUpscaleConservativeResponse429
        | StabilityImageGenrationUpscaleConservativeResponse500,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<
                ReturnType<typeof stabilityImageGenrationUpscaleConservative>
            >,
            TError,
            { data: StabilityImageGenrationUpscaleConservativeRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof stabilityImageGenrationUpscaleConservative>>,
    TError,
    { data: StabilityImageGenrationUpscaleConservativeRequest },
    TContext
> => {
    const mutationOptions =
        getStabilityImageGenrationUpscaleConservativeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Takes images between 64x64 and 1 megapixel and upscales them all the way to **4K** resolution.  Put more
generally, it can upscale images ~20-40x times while preserving, and often enhancing, quality.
Creative Upscale **works best on highly degraded images and is not for photos of 1mp or above** as it performs
heavy reimagining (controlled by creativity scale).

### Try it out
Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=QXxi9tfI425t)


### How to use
Please invoke this endpoint with a `POST` request.

The headers of the request must include an API key in the `authorization` field. The body of the request must be
`multipart/form-data`.

The body of the request should include:
- `image`
- `prompt`

The body may optionally include:
- `seed`
- `negative_prompt`
- `output_format`
- `creativity`
- `style_preset`

> **Note:** for more details about these parameters please see the request schema below.

### Results
After invoking this endpoint with the required parameters, use the `id` in the response to poll for results at the
[results/{id} endpoint](#tag/Results/paths/~1v2beta~1results~1%7Bid%7D/get).  Rate-limiting or other errors may occur if you poll more than once every 10 seconds.

### Credits
Flat rate of 25 credits per successful generation.  You will not be charged for failed generations.
 * @summary Creative Upscale (async)
 */
export const stabilityImageGenrationUpscaleCreative = (
    stabilityImageGenrationUpscaleCreativeRequest: StabilityImageGenrationUpscaleCreativeRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    if (
        stabilityImageGenrationUpscaleCreativeRequest.creativity !== undefined
    ) {
        formData.append(
            `creativity`,
            stabilityImageGenrationUpscaleCreativeRequest.creativity.toString(),
        );
    }
    formData.append(
        `image`,
        stabilityImageGenrationUpscaleCreativeRequest.image,
    );
    if (
        stabilityImageGenrationUpscaleCreativeRequest.negative_prompt !==
        undefined
    ) {
        formData.append(
            `negative_prompt`,
            stabilityImageGenrationUpscaleCreativeRequest.negative_prompt,
        );
    }
    if (
        stabilityImageGenrationUpscaleCreativeRequest.output_format !==
        undefined
    ) {
        formData.append(
            `output_format`,
            stabilityImageGenrationUpscaleCreativeRequest.output_format,
        );
    }
    formData.append(
        `prompt`,
        stabilityImageGenrationUpscaleCreativeRequest.prompt,
    );
    if (stabilityImageGenrationUpscaleCreativeRequest.seed !== undefined) {
        formData.append(
            `seed`,
            stabilityImageGenrationUpscaleCreativeRequest.seed.toString(),
        );
    }
    if (
        stabilityImageGenrationUpscaleCreativeRequest.style_preset !== undefined
    ) {
        formData.append(
            `style_preset`,
            stabilityImageGenrationUpscaleCreativeRequest.style_preset,
        );
    }

    return customInstance<StabilityImageGenrationUpscaleCreativeResponse200>(
        {
            url: `/proxy/stability/v2beta/stable-image/upscale/creative`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getStabilityImageGenrationUpscaleCreativeMutationOptions = <
    TError =
        | StabilityImageGenrationUpscaleCreativeResponse400
        | StabilityContentModerationResponse
        | StabilityImageGenrationUpscaleCreativeResponse413
        | StabilityImageGenrationUpscaleCreativeResponse422
        | StabilityImageGenrationUpscaleCreativeResponse429
        | StabilityImageGenrationUpscaleCreativeResponse500,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>,
        TError,
        { data: StabilityImageGenrationUpscaleCreativeRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>,
    TError,
    { data: StabilityImageGenrationUpscaleCreativeRequest },
    TContext
> => {
    const mutationKey = ["stabilityImageGenrationUpscaleCreative"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>,
        { data: StabilityImageGenrationUpscaleCreativeRequest }
    > = (props) => {
        const { data } = props ?? {};

        return stabilityImageGenrationUpscaleCreative(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type StabilityImageGenrationUpscaleCreativeMutationResult = NonNullable<
    Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>
>;
export type StabilityImageGenrationUpscaleCreativeMutationBody =
    StabilityImageGenrationUpscaleCreativeRequest;
export type StabilityImageGenrationUpscaleCreativeMutationError =
    | StabilityImageGenrationUpscaleCreativeResponse400
    | StabilityContentModerationResponse
    | StabilityImageGenrationUpscaleCreativeResponse413
    | StabilityImageGenrationUpscaleCreativeResponse422
    | StabilityImageGenrationUpscaleCreativeResponse429
    | StabilityImageGenrationUpscaleCreativeResponse500;

/**
 * @summary Creative Upscale (async)
 */
export const useStabilityImageGenrationUpscaleCreative = <
    TError =
        | StabilityImageGenrationUpscaleCreativeResponse400
        | StabilityContentModerationResponse
        | StabilityImageGenrationUpscaleCreativeResponse413
        | StabilityImageGenrationUpscaleCreativeResponse422
        | StabilityImageGenrationUpscaleCreativeResponse429
        | StabilityImageGenrationUpscaleCreativeResponse500,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>,
            TError,
            { data: StabilityImageGenrationUpscaleCreativeRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof stabilityImageGenrationUpscaleCreative>>,
    TError,
    { data: StabilityImageGenrationUpscaleCreativeRequest },
    TContext
> => {
    const mutationOptions =
        getStabilityImageGenrationUpscaleCreativeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Our Fast Upscaler service enhances image resolution by 4x using predictive and generative AI. This lightweight and fast service (processing in ~1 second) is ideal for enhancing the quality of compressed images, making it suitable for social media posts and other applications.

### Try it out
Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=t1Q4w2uvvza0)

### How to use

Please invoke this endpoint with a `POST` request.

The headers of the request must include an API key in the `authorization` field. The body of the request must be
`multipart/form-data`, and the `accept` header should be set to one of the following:



  - `image/*` to receive the image in the format specified by the `output_format` parameter.
  - `application/json` to receive the image encoded as base64 in a JSON response.

The body of the request must include:
- `image`

Optionally, the body of the request may also include:
- `output_format`

> **Note:** for more details about these parameters please see the request schema below.

### Output
The resolution of the generated image is 4 times that of the input image with a maximum size of 16 megapixels.

### Credits
Flat rate of 1 credit per successful generation. You will not be charged for failed generations.
 * @summary Fast
 */
export const stabilityImageGenerationUpscaleFast = (
    stabilityImageGenrationUpscaleFastRequest: StabilityImageGenrationUpscaleFastRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    formData.append(`image`, stabilityImageGenrationUpscaleFastRequest.image);
    if (stabilityImageGenrationUpscaleFastRequest.output_format !== undefined) {
        formData.append(
            `output_format`,
            stabilityImageGenrationUpscaleFastRequest.output_format,
        );
    }

    return customInstance<StabilityImageGenrationUpscaleFastResponse200 | Blob>(
        {
            url: `/proxy/stability/v2beta/stable-image/upscale/fast`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getStabilityImageGenerationUpscaleFastMutationOptions = <
    TError =
        | StabilityImageGenrationUpscaleFastResponse400
        | StabilityContentModerationResponse
        | StabilityImageGenrationUpscaleFastResponse413
        | StabilityImageGenrationUpscaleFastResponse422
        | StabilityImageGenrationUpscaleFastResponse429
        | StabilityImageGenrationUpscaleFastResponse500,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>,
        TError,
        { data: StabilityImageGenrationUpscaleFastRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>,
    TError,
    { data: StabilityImageGenrationUpscaleFastRequest },
    TContext
> => {
    const mutationKey = ["stabilityImageGenerationUpscaleFast"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>,
        { data: StabilityImageGenrationUpscaleFastRequest }
    > = (props) => {
        const { data } = props ?? {};

        return stabilityImageGenerationUpscaleFast(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type StabilityImageGenerationUpscaleFastMutationResult = NonNullable<
    Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>
>;
export type StabilityImageGenerationUpscaleFastMutationBody =
    StabilityImageGenrationUpscaleFastRequest;
export type StabilityImageGenerationUpscaleFastMutationError =
    | StabilityImageGenrationUpscaleFastResponse400
    | StabilityContentModerationResponse
    | StabilityImageGenrationUpscaleFastResponse413
    | StabilityImageGenrationUpscaleFastResponse422
    | StabilityImageGenrationUpscaleFastResponse429
    | StabilityImageGenrationUpscaleFastResponse500;

/**
 * @summary Fast
 */
export const useStabilityImageGenerationUpscaleFast = <
    TError =
        | StabilityImageGenrationUpscaleFastResponse400
        | StabilityContentModerationResponse
        | StabilityImageGenrationUpscaleFastResponse413
        | StabilityImageGenrationUpscaleFastResponse422
        | StabilityImageGenrationUpscaleFastResponse429
        | StabilityImageGenrationUpscaleFastResponse500,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>,
            TError,
            { data: StabilityImageGenrationUpscaleFastRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof stabilityImageGenerationUpscaleFast>>,
    TError,
    { data: StabilityImageGenrationUpscaleFastRequest },
    TContext
> => {
    const mutationOptions =
        getStabilityImageGenerationUpscaleFastMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create 3D Generation Task
 */
export const tripoCreateTask = (
    tripoCreateTaskBody: TripoCreateTaskBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<TripoSuccessTask>(
        {
            url: `/proxy/tripo/v2/openapi/task`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: tripoCreateTaskBody,
            signal,
        },
        options,
    );
};

export const getTripoCreateTaskMutationOptions = <
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof tripoCreateTask>>,
        TError,
        { data: TripoCreateTaskBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof tripoCreateTask>>,
    TError,
    { data: TripoCreateTaskBody },
    TContext
> => {
    const mutationKey = ["tripoCreateTask"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof tripoCreateTask>>,
        { data: TripoCreateTaskBody }
    > = (props) => {
        const { data } = props ?? {};

        return tripoCreateTask(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type TripoCreateTaskMutationResult = NonNullable<
    Awaited<ReturnType<typeof tripoCreateTask>>
>;
export type TripoCreateTaskMutationBody = TripoCreateTaskBody;
export type TripoCreateTaskMutationError =
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse;

/**
 * @summary Create 3D Generation Task
 */
export const useTripoCreateTask = <
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof tripoCreateTask>>,
            TError,
            { data: TripoCreateTaskBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof tripoCreateTask>>,
    TError,
    { data: TripoCreateTaskBody },
    TContext
> => {
    const mutationOptions = getTripoCreateTaskMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get Task Status
 */
export const tripoGetTask = (
    taskId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<TripoGetTask200>(
        {
            url: `/proxy/tripo/v2/openapi/task/${taskId}`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getTripoGetTaskQueryKey = (taskId?: string) => {
    return [`/proxy/tripo/v2/openapi/task/${taskId}`] as const;
};

export const getTripoGetTaskQueryOptions = <
    TData = Awaited<ReturnType<typeof tripoGetTask>>,
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof tripoGetTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getTripoGetTaskQueryKey(taskId);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tripoGetTask>>> = ({
        signal,
    }) => tripoGetTask(taskId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!taskId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof tripoGetTask>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TripoGetTaskQueryResult = NonNullable<
    Awaited<ReturnType<typeof tripoGetTask>>
>;
export type TripoGetTaskQueryError =
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse;

export function useTripoGetTask<
    TData = Awaited<ReturnType<typeof tripoGetTask>>,
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
>(
    taskId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof tripoGetTask>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof tripoGetTask>>,
                    TError,
                    Awaited<ReturnType<typeof tripoGetTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTripoGetTask<
    TData = Awaited<ReturnType<typeof tripoGetTask>>,
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof tripoGetTask>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof tripoGetTask>>,
                    TError,
                    Awaited<ReturnType<typeof tripoGetTask>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTripoGetTask<
    TData = Awaited<ReturnType<typeof tripoGetTask>>,
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof tripoGetTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Task Status
 */

export function useTripoGetTask<
    TData = Awaited<ReturnType<typeof tripoGetTask>>,
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof tripoGetTask>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getTripoGetTaskQueryOptions(taskId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Upload File for 3D Generation
 */
export const tripoUploadFile = (
    tripoUploadFileBody: TripoUploadFileBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    const formData = new FormData();
    formData.append(`file`, tripoUploadFileBody.file);

    return customInstance<TripoUploadFile200>(
        {
            url: `/proxy/tripo/v2/openapi/upload`,
            method: "POST",
            headers: { "Content-Type": "multipart/form-data" },
            data: formData,
            signal,
        },
        options,
    );
};

export const getTripoUploadFileMutationOptions = <
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof tripoUploadFile>>,
        TError,
        { data: TripoUploadFileBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof tripoUploadFile>>,
    TError,
    { data: TripoUploadFileBody },
    TContext
> => {
    const mutationKey = ["tripoUploadFile"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof tripoUploadFile>>,
        { data: TripoUploadFileBody }
    > = (props) => {
        const { data } = props ?? {};

        return tripoUploadFile(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type TripoUploadFileMutationResult = NonNullable<
    Awaited<ReturnType<typeof tripoUploadFile>>
>;
export type TripoUploadFileMutationBody = TripoUploadFileBody;
export type TripoUploadFileMutationError =
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse;

/**
 * @summary Upload File for 3D Generation
 */
export const useTripoUploadFile = <
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof tripoUploadFile>>,
            TError,
            { data: TripoUploadFileBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof tripoUploadFile>>,
    TError,
    { data: TripoUploadFileBody },
    TContext
> => {
    const mutationOptions = getTripoUploadFileMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Query Account Balance
 */
export const tripoGetBalance = (
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<TripoGetBalance200>(
        { url: `/proxy/tripo/v2/openapi/user/balance`, method: "GET", signal },
        options,
    );
};

export const getTripoGetBalanceQueryKey = () => {
    return [`/proxy/tripo/v2/openapi/user/balance`] as const;
};

export const getTripoGetBalanceQueryOptions = <
    TData = Awaited<ReturnType<typeof tripoGetBalance>>,
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
>(options?: {
    query?: Partial<
        UseQueryOptions<
            Awaited<ReturnType<typeof tripoGetBalance>>,
            TError,
            TData
        >
    >;
    request?: SecondParameter<typeof customInstance>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getTripoGetBalanceQueryKey();

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof tripoGetBalance>>
    > = ({ signal }) => tripoGetBalance(requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof tripoGetBalance>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TripoGetBalanceQueryResult = NonNullable<
    Awaited<ReturnType<typeof tripoGetBalance>>
>;
export type TripoGetBalanceQueryError =
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse
    | TripoErrorResponse;

export function useTripoGetBalance<
    TData = Awaited<ReturnType<typeof tripoGetBalance>>,
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
>(
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof tripoGetBalance>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof tripoGetBalance>>,
                    TError,
                    Awaited<ReturnType<typeof tripoGetBalance>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTripoGetBalance<
    TData = Awaited<ReturnType<typeof tripoGetBalance>>,
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof tripoGetBalance>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof tripoGetBalance>>,
                    TError,
                    Awaited<ReturnType<typeof tripoGetBalance>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTripoGetBalance<
    TData = Awaited<ReturnType<typeof tripoGetBalance>>,
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof tripoGetBalance>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Query Account Balance
 */

export function useTripoGetBalance<
    TData = Awaited<ReturnType<typeof tripoGetBalance>>,
    TError =
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse
        | TripoErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof tripoGetBalance>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getTripoGetBalanceQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Generate a video from a text prompt and optional image. Deprecated. Use /proxy/veo/{modelId}/generate instead.
 */
export const veoGenerate = (
    veo2GenVidRequest: Veo2GenVidRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Veo2GenVidResponse>(
        {
            url: `/proxy/veo/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: veo2GenVidRequest,
            signal,
        },
        options,
    );
};

export const getVeoGenerateMutationOptions = <
    TError = void | void | void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof veoGenerate>>,
        TError,
        { data: Veo2GenVidRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof veoGenerate>>,
    TError,
    { data: Veo2GenVidRequest },
    TContext
> => {
    const mutationKey = ["veoGenerate"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof veoGenerate>>,
        { data: Veo2GenVidRequest }
    > = (props) => {
        const { data } = props ?? {};

        return veoGenerate(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type VeoGenerateMutationResult = NonNullable<
    Awaited<ReturnType<typeof veoGenerate>>
>;
export type VeoGenerateMutationBody = Veo2GenVidRequest;
export type VeoGenerateMutationError = void | void | void | void;

/**
 * @summary Generate a video from a text prompt and optional image. Deprecated. Use /proxy/veo/{modelId}/generate instead.
 */
export const useVeoGenerate = <
    TError = void | void | void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof veoGenerate>>,
            TError,
            { data: Veo2GenVidRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof veoGenerate>>,
    TError,
    { data: Veo2GenVidRequest },
    TContext
> => {
    const mutationOptions = getVeoGenerateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Poll the status of a Veo prediction operation. Deprecated. Use /proxy/veo/{modelId}/generate instead.
 */
export const veoPoll = (
    veo2GenVidPollRequest: Veo2GenVidPollRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Veo2GenVidPollResponse>(
        {
            url: `/proxy/veo/poll`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: veo2GenVidPollRequest,
            signal,
        },
        options,
    );
};

export const getVeoPollMutationOptions = <
    TError = void | void | void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof veoPoll>>,
        TError,
        { data: Veo2GenVidPollRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof veoPoll>>,
    TError,
    { data: Veo2GenVidPollRequest },
    TContext
> => {
    const mutationKey = ["veoPoll"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof veoPoll>>,
        { data: Veo2GenVidPollRequest }
    > = (props) => {
        const { data } = props ?? {};

        return veoPoll(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type VeoPollMutationResult = NonNullable<
    Awaited<ReturnType<typeof veoPoll>>
>;
export type VeoPollMutationBody = Veo2GenVidPollRequest;
export type VeoPollMutationError = void | void | void | void;

/**
 * @summary Poll the status of a Veo prediction operation. Deprecated. Use /proxy/veo/{modelId}/generate instead.
 */
export const useVeoPoll = <
    TError = void | void | void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof veoPoll>>,
            TError,
            { data: Veo2GenVidPollRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof veoPoll>>,
    TError,
    { data: Veo2GenVidPollRequest },
    TContext
> => {
    const mutationOptions = getVeoPollMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generate a video from a text prompt and optional image
 */
export const veoGenerateNew = (
    modelId: string,
    veoGenVidRequest: VeoGenVidRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<VeoGenVidResponse>(
        {
            url: `/proxy/veo/${modelId}/generate`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: veoGenVidRequest,
            signal,
        },
        options,
    );
};

export const getVeoGenerateNewMutationOptions = <
    TError = void | void | void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof veoGenerateNew>>,
        TError,
        { modelId: string; data: VeoGenVidRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof veoGenerateNew>>,
    TError,
    { modelId: string; data: VeoGenVidRequest },
    TContext
> => {
    const mutationKey = ["veoGenerateNew"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof veoGenerateNew>>,
        { modelId: string; data: VeoGenVidRequest }
    > = (props) => {
        const { modelId, data } = props ?? {};

        return veoGenerateNew(modelId, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type VeoGenerateNewMutationResult = NonNullable<
    Awaited<ReturnType<typeof veoGenerateNew>>
>;
export type VeoGenerateNewMutationBody = VeoGenVidRequest;
export type VeoGenerateNewMutationError = void | void | void | void;

/**
 * @summary Generate a video from a text prompt and optional image
 */
export const useVeoGenerateNew = <
    TError = void | void | void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof veoGenerateNew>>,
            TError,
            { modelId: string; data: VeoGenVidRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof veoGenerateNew>>,
    TError,
    { modelId: string; data: VeoGenVidRequest },
    TContext
> => {
    const mutationOptions = getVeoGenerateNewMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Poll the status of a Veo prediction operation
 */
export const veoPollNew = (
    modelId: string,
    veoGenVidPollRequest: VeoGenVidPollRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<VeoGenVidPollResponse>(
        {
            url: `/proxy/veo/${modelId}/poll`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: veoGenVidPollRequest,
            signal,
        },
        options,
    );
};

export const getVeoPollNewMutationOptions = <
    TError = void | void | void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof veoPollNew>>,
        TError,
        { modelId: string; data: VeoGenVidPollRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof veoPollNew>>,
    TError,
    { modelId: string; data: VeoGenVidPollRequest },
    TContext
> => {
    const mutationKey = ["veoPollNew"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof veoPollNew>>,
        { modelId: string; data: VeoGenVidPollRequest }
    > = (props) => {
        const { modelId, data } = props ?? {};

        return veoPollNew(modelId, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type VeoPollNewMutationResult = NonNullable<
    Awaited<ReturnType<typeof veoPollNew>>
>;
export type VeoPollNewMutationBody = VeoGenVidPollRequest;
export type VeoPollNewMutationError = void | void | void | void;

/**
 * @summary Poll the status of a Veo prediction operation
 */
export const useVeoPollNew = <
    TError = void | void | void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof veoPollNew>>,
            TError,
            { modelId: string; data: VeoGenVidPollRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof veoPollNew>>,
    TError,
    { modelId: string; data: VeoGenVidPollRequest },
    TContext
> => {
    const mutationOptions = getVeoPollNewMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generate content using a specified model.
 */
export const geminiGenerateContent = (
    model: string,
    geminiGenerateContentRequest: GeminiGenerateContentRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GeminiGenerateContentResponse>(
        {
            url: `/proxy/vertexai/gemini/${model}`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: geminiGenerateContentRequest,
            signal,
        },
        options,
    );
};

export const getGeminiGenerateContentMutationOptions = <
    TError = void | void | void | void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof geminiGenerateContent>>,
        TError,
        { model: string; data: GeminiGenerateContentRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof geminiGenerateContent>>,
    TError,
    { model: string; data: GeminiGenerateContentRequest },
    TContext
> => {
    const mutationKey = ["geminiGenerateContent"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof geminiGenerateContent>>,
        { model: string; data: GeminiGenerateContentRequest }
    > = (props) => {
        const { model, data } = props ?? {};

        return geminiGenerateContent(model, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type GeminiGenerateContentMutationResult = NonNullable<
    Awaited<ReturnType<typeof geminiGenerateContent>>
>;
export type GeminiGenerateContentMutationBody = GeminiGenerateContentRequest;
export type GeminiGenerateContentMutationError =
    | void
    | void
    | void
    | void
    | void;

/**
 * @summary Generate content using a specified model.
 */
export const useGeminiGenerateContent = <
    TError = void | void | void | void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof geminiGenerateContent>>,
            TError,
            { model: string; data: GeminiGenerateContentRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof geminiGenerateContent>>,
    TError,
    { model: string; data: GeminiGenerateContentRequest },
    TContext
> => {
    const mutationOptions = getGeminiGenerateContentMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generate images from a text prompt
 */
export const imagenGenerateImages = (
    model:
        | "imagen-3.0-generate-002"
        | "imagen-3.0-generate-001"
        | "imagen-3.0-fast-generate-001"
        | "imagegeneration@006"
        | "imagegeneration@005"
        | "imagegeneration@002",
    imagenGenerateImageRequest: ImagenGenerateImageRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ImagenGenerateImageResponse>(
        {
            url: `/proxy/vertexai/imagen/${model}`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: imagenGenerateImageRequest,
            signal,
        },
        options,
    );
};

export const getImagenGenerateImagesMutationOptions = <
    TError = void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof imagenGenerateImages>>,
        TError,
        {
            model:
                | "imagen-3.0-generate-002"
                | "imagen-3.0-generate-001"
                | "imagen-3.0-fast-generate-001"
                | "imagegeneration@006"
                | "imagegeneration@005"
                | "imagegeneration@002";
            data: ImagenGenerateImageRequest;
        },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof imagenGenerateImages>>,
    TError,
    {
        model:
            | "imagen-3.0-generate-002"
            | "imagen-3.0-generate-001"
            | "imagen-3.0-fast-generate-001"
            | "imagegeneration@006"
            | "imagegeneration@005"
            | "imagegeneration@002";
        data: ImagenGenerateImageRequest;
    },
    TContext
> => {
    const mutationKey = ["imagenGenerateImages"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof imagenGenerateImages>>,
        {
            model:
                | "imagen-3.0-generate-002"
                | "imagen-3.0-generate-001"
                | "imagen-3.0-fast-generate-001"
                | "imagegeneration@006"
                | "imagegeneration@005"
                | "imagegeneration@002";
            data: ImagenGenerateImageRequest;
        }
    > = (props) => {
        const { model, data } = props ?? {};

        return imagenGenerateImages(model, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ImagenGenerateImagesMutationResult = NonNullable<
    Awaited<ReturnType<typeof imagenGenerateImages>>
>;
export type ImagenGenerateImagesMutationBody = ImagenGenerateImageRequest;
export type ImagenGenerateImagesMutationError = void | void;

/**
 * @summary Generate images from a text prompt
 */
export const useImagenGenerateImages = <
    TError = void | void,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof imagenGenerateImages>>,
            TError,
            {
                model:
                    | "imagen-3.0-generate-002"
                    | "imagen-3.0-generate-001"
                    | "imagen-3.0-fast-generate-001"
                    | "imagegeneration@006"
                    | "imagegeneration@005"
                    | "imagegeneration@002";
                data: ImagenGenerateImageRequest;
            },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof imagenGenerateImages>>,
    TError,
    {
        model:
            | "imagen-3.0-generate-002"
            | "imagen-3.0-generate-001"
            | "imagen-3.0-fast-generate-001"
            | "imagegeneration@006"
            | "imagegeneration@005"
            | "imagegeneration@002";
        data: ImagenGenerateImageRequest;
    },
    TContext
> => {
    const mutationOptions = getImagenGenerateImagesMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const viduImg2Video = (
    viduTaskRequest: ViduTaskRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ViduTaskReply>(
        {
            url: `/proxy/vidu/img2video`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: viduTaskRequest,
            signal,
        },
        options,
    );
};

export const getViduImg2VideoMutationOptions = <
    TError = Error | Error,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof viduImg2Video>>,
        TError,
        { data: ViduTaskRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof viduImg2Video>>,
    TError,
    { data: ViduTaskRequest },
    TContext
> => {
    const mutationKey = ["viduImg2Video"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof viduImg2Video>>,
        { data: ViduTaskRequest }
    > = (props) => {
        const { data } = props ?? {};

        return viduImg2Video(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ViduImg2VideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof viduImg2Video>>
>;
export type ViduImg2VideoMutationBody = ViduTaskRequest;
export type ViduImg2VideoMutationError = Error | Error;

export const useViduImg2Video = <TError = Error | Error, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof viduImg2Video>>,
            TError,
            { data: ViduTaskRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof viduImg2Video>>,
    TError,
    { data: ViduTaskRequest },
    TContext
> => {
    const mutationOptions = getViduImg2VideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const viduReference2Video = (
    viduTaskRequest: ViduTaskRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ViduTaskReply>(
        {
            url: `/proxy/vidu/reference2video`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: viduTaskRequest,
            signal,
        },
        options,
    );
};

export const getViduReference2VideoMutationOptions = <
    TError = Error | Error,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof viduReference2Video>>,
        TError,
        { data: ViduTaskRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof viduReference2Video>>,
    TError,
    { data: ViduTaskRequest },
    TContext
> => {
    const mutationKey = ["viduReference2Video"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof viduReference2Video>>,
        { data: ViduTaskRequest }
    > = (props) => {
        const { data } = props ?? {};

        return viduReference2Video(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ViduReference2VideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof viduReference2Video>>
>;
export type ViduReference2VideoMutationBody = ViduTaskRequest;
export type ViduReference2VideoMutationError = Error | Error;

export const useViduReference2Video = <
    TError = Error | Error,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof viduReference2Video>>,
            TError,
            { data: ViduTaskRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof viduReference2Video>>,
    TError,
    { data: ViduTaskRequest },
    TContext
> => {
    const mutationOptions = getViduReference2VideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const viduStartEnd2Video = (
    viduTaskRequest: ViduTaskRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ViduTaskReply>(
        {
            url: `/proxy/vidu/start-end2video`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: viduTaskRequest,
            signal,
        },
        options,
    );
};

export const getViduStartEnd2VideoMutationOptions = <
    TError = Error | Error,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof viduStartEnd2Video>>,
        TError,
        { data: ViduTaskRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof viduStartEnd2Video>>,
    TError,
    { data: ViduTaskRequest },
    TContext
> => {
    const mutationKey = ["viduStartEnd2Video"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof viduStartEnd2Video>>,
        { data: ViduTaskRequest }
    > = (props) => {
        const { data } = props ?? {};

        return viduStartEnd2Video(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ViduStartEnd2VideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof viduStartEnd2Video>>
>;
export type ViduStartEnd2VideoMutationBody = ViduTaskRequest;
export type ViduStartEnd2VideoMutationError = Error | Error;

export const useViduStartEnd2Video = <
    TError = Error | Error,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof viduStartEnd2Video>>,
            TError,
            { data: ViduTaskRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof viduStartEnd2Video>>,
    TError,
    { data: ViduTaskRequest },
    TContext
> => {
    const mutationOptions = getViduStartEnd2VideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const viduGetCreations = (
    id: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ViduGetCreationsReply>(
        { url: `/proxy/vidu/tasks/${id}/creations`, method: "GET", signal },
        options,
    );
};

export const getViduGetCreationsQueryKey = (id?: string) => {
    return [`/proxy/vidu/tasks/${id}/creations`] as const;
};

export const getViduGetCreationsQueryOptions = <
    TData = Awaited<ReturnType<typeof viduGetCreations>>,
    TError = Error | Error,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof viduGetCreations>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getViduGetCreationsQueryKey(id);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof viduGetCreations>>
    > = ({ signal }) => viduGetCreations(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof viduGetCreations>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ViduGetCreationsQueryResult = NonNullable<
    Awaited<ReturnType<typeof viduGetCreations>>
>;
export type ViduGetCreationsQueryError = Error | Error;

export function useViduGetCreations<
    TData = Awaited<ReturnType<typeof viduGetCreations>>,
    TError = Error | Error,
>(
    id: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof viduGetCreations>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof viduGetCreations>>,
                    TError,
                    Awaited<ReturnType<typeof viduGetCreations>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useViduGetCreations<
    TData = Awaited<ReturnType<typeof viduGetCreations>>,
    TError = Error | Error,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof viduGetCreations>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof viduGetCreations>>,
                    TError,
                    Awaited<ReturnType<typeof viduGetCreations>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useViduGetCreations<
    TData = Awaited<ReturnType<typeof viduGetCreations>>,
    TError = Error | Error,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof viduGetCreations>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useViduGetCreations<
    TData = Awaited<ReturnType<typeof viduGetCreations>>,
    TError = Error | Error,
>(
    id: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof viduGetCreations>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getViduGetCreationsQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

export const viduText2Video = (
    viduTaskRequest: ViduTaskRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ViduTaskReply>(
        {
            url: `/proxy/vidu/text2video`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: viduTaskRequest,
            signal,
        },
        options,
    );
};

export const getViduText2VideoMutationOptions = <
    TError = Error | Error,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof viduText2Video>>,
        TError,
        { data: ViduTaskRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof viduText2Video>>,
    TError,
    { data: ViduTaskRequest },
    TContext
> => {
    const mutationKey = ["viduText2Video"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof viduText2Video>>,
        { data: ViduTaskRequest }
    > = (props) => {
        const { data } = props ?? {};

        return viduText2Video(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ViduText2VideoMutationResult = NonNullable<
    Awaited<ReturnType<typeof viduText2Video>>
>;
export type ViduText2VideoMutationBody = ViduTaskRequest;
export type ViduText2VideoMutationError = Error | Error;

export const useViduText2Video = <TError = Error | Error, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof viduText2Video>>,
            TError,
            { data: ViduTaskRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof viduText2Video>>,
    TError,
    { data: ViduTaskRequest },
    TContext
> => {
    const mutationOptions = getViduText2VideoMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const wanImage2ImageGeneration = (
    wanImage2ImageGenerationRequest: WanImage2ImageGenerationRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<WanImage2ImageGenerationResponse>(
        {
            url: `/proxy/wan/api/v1/services/aigc/image2image/image-synthesis`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: wanImage2ImageGenerationRequest,
            signal,
        },
        options,
    );
};

export const getWanImage2ImageGenerationMutationOptions = <
    TError = ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof wanImage2ImageGeneration>>,
        TError,
        { data: WanImage2ImageGenerationRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof wanImage2ImageGeneration>>,
    TError,
    { data: WanImage2ImageGenerationRequest },
    TContext
> => {
    const mutationKey = ["wanImage2ImageGeneration"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof wanImage2ImageGeneration>>,
        { data: WanImage2ImageGenerationRequest }
    > = (props) => {
        const { data } = props ?? {};

        return wanImage2ImageGeneration(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type WanImage2ImageGenerationMutationResult = NonNullable<
    Awaited<ReturnType<typeof wanImage2ImageGeneration>>
>;
export type WanImage2ImageGenerationMutationBody =
    WanImage2ImageGenerationRequest;
export type WanImage2ImageGenerationMutationError = ErrorResponse;

export const useWanImage2ImageGeneration = <
    TError = ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof wanImage2ImageGeneration>>,
            TError,
            { data: WanImage2ImageGenerationRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof wanImage2ImageGeneration>>,
    TError,
    { data: WanImage2ImageGenerationRequest },
    TContext
> => {
    const mutationOptions = getWanImage2ImageGenerationMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const wanImageGeneration = (
    wanImageGenerationRequest: WanImageGenerationRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<WanImageGenerationResponse>(
        {
            url: `/proxy/wan/api/v1/services/aigc/text2image/image-synthesis`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: wanImageGenerationRequest,
            signal,
        },
        options,
    );
};

export const getWanImageGenerationMutationOptions = <
    TError = ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof wanImageGeneration>>,
        TError,
        { data: WanImageGenerationRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof wanImageGeneration>>,
    TError,
    { data: WanImageGenerationRequest },
    TContext
> => {
    const mutationKey = ["wanImageGeneration"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof wanImageGeneration>>,
        { data: WanImageGenerationRequest }
    > = (props) => {
        const { data } = props ?? {};

        return wanImageGeneration(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type WanImageGenerationMutationResult = NonNullable<
    Awaited<ReturnType<typeof wanImageGeneration>>
>;
export type WanImageGenerationMutationBody = WanImageGenerationRequest;
export type WanImageGenerationMutationError = ErrorResponse;

export const useWanImageGeneration = <
    TError = ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof wanImageGeneration>>,
            TError,
            { data: WanImageGenerationRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof wanImageGeneration>>,
    TError,
    { data: WanImageGenerationRequest },
    TContext
> => {
    const mutationOptions = getWanImageGenerationMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const wanVideoGeneration = (
    wanVideoGenerationRequest: WanVideoGenerationRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<WanVideoGenerationResponse>(
        {
            url: `/proxy/wan/api/v1/services/aigc/video-generation/video-synthesis`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: wanVideoGenerationRequest,
            signal,
        },
        options,
    );
};

export const getWanVideoGenerationMutationOptions = <
    TError = ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof wanVideoGeneration>>,
        TError,
        { data: WanVideoGenerationRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof wanVideoGeneration>>,
    TError,
    { data: WanVideoGenerationRequest },
    TContext
> => {
    const mutationKey = ["wanVideoGeneration"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof wanVideoGeneration>>,
        { data: WanVideoGenerationRequest }
    > = (props) => {
        const { data } = props ?? {};

        return wanVideoGeneration(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type WanVideoGenerationMutationResult = NonNullable<
    Awaited<ReturnType<typeof wanVideoGeneration>>
>;
export type WanVideoGenerationMutationBody = WanVideoGenerationRequest;
export type WanVideoGenerationMutationError = ErrorResponse;

export const useWanVideoGeneration = <
    TError = ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof wanVideoGeneration>>,
            TError,
            { data: WanVideoGenerationRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof wanVideoGeneration>>,
    TError,
    { data: WanVideoGenerationRequest },
    TContext
> => {
    const mutationOptions = getWanVideoGenerationMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const wanTaskQueryProxy = (
    taskId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<WanTaskQueryResponse>(
        { url: `/proxy/wan/api/v1/tasks/${taskId}`, method: "GET", signal },
        options,
    );
};

export const getWanTaskQueryProxyQueryKey = (taskId?: string) => {
    return [`/proxy/wan/api/v1/tasks/${taskId}`] as const;
};

export const getWanTaskQueryProxyQueryOptions = <
    TData = Awaited<ReturnType<typeof wanTaskQueryProxy>>,
    TError = ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof wanTaskQueryProxy>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getWanTaskQueryProxyQueryKey(taskId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof wanTaskQueryProxy>>
    > = ({ signal }) => wanTaskQueryProxy(taskId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!taskId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof wanTaskQueryProxy>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WanTaskQueryProxyQueryResult = NonNullable<
    Awaited<ReturnType<typeof wanTaskQueryProxy>>
>;
export type WanTaskQueryProxyQueryError = ErrorResponse;

export function useWanTaskQueryProxy<
    TData = Awaited<ReturnType<typeof wanTaskQueryProxy>>,
    TError = ErrorResponse,
>(
    taskId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof wanTaskQueryProxy>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof wanTaskQueryProxy>>,
                    TError,
                    Awaited<ReturnType<typeof wanTaskQueryProxy>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWanTaskQueryProxy<
    TData = Awaited<ReturnType<typeof wanTaskQueryProxy>>,
    TError = ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof wanTaskQueryProxy>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof wanTaskQueryProxy>>,
                    TError,
                    Awaited<ReturnType<typeof wanTaskQueryProxy>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWanTaskQueryProxy<
    TData = Awaited<ReturnType<typeof wanTaskQueryProxy>>,
    TError = ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof wanTaskQueryProxy>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};

export function useWanTaskQueryProxy<
    TData = Awaited<ReturnType<typeof wanTaskQueryProxy>>,
    TError = ErrorResponse,
>(
    taskId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof wanTaskQueryProxy>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getWanTaskQueryProxyQueryOptions(taskId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Retrieve all publishers
 */
export const listPublishers = (
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Publisher[]>(
        { url: `/publishers`, method: "GET", signal },
        options,
    );
};

export const getListPublishersQueryKey = () => {
    return [`/publishers`] as const;
};

export const getListPublishersQueryOptions = <
    TData = Awaited<ReturnType<typeof listPublishers>>,
    TError = ErrorResponse | ErrorResponse,
>(options?: {
    query?: Partial<
        UseQueryOptions<
            Awaited<ReturnType<typeof listPublishers>>,
            TError,
            TData
        >
    >;
    request?: SecondParameter<typeof customInstance>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getListPublishersQueryKey();

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof listPublishers>>
    > = ({ signal }) => listPublishers(requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof listPublishers>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListPublishersQueryResult = NonNullable<
    Awaited<ReturnType<typeof listPublishers>>
>;
export type ListPublishersQueryError = ErrorResponse | ErrorResponse;

export function useListPublishers<
    TData = Awaited<ReturnType<typeof listPublishers>>,
    TError = ErrorResponse | ErrorResponse,
>(
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPublishers>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listPublishers>>,
                    TError,
                    Awaited<ReturnType<typeof listPublishers>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListPublishers<
    TData = Awaited<ReturnType<typeof listPublishers>>,
    TError = ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPublishers>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listPublishers>>,
                    TError,
                    Awaited<ReturnType<typeof listPublishers>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListPublishers<
    TData = Awaited<ReturnType<typeof listPublishers>>,
    TError = ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPublishers>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve all publishers
 */

export function useListPublishers<
    TData = Awaited<ReturnType<typeof listPublishers>>,
    TError = ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPublishers>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListPublishersQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Create a new publisher
 */
export const createPublisher = (
    publisher: Publisher,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Publisher>(
        {
            url: `/publishers`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: publisher,
            signal,
        },
        options,
    );
};

export const getCreatePublisherMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createPublisher>>,
        TError,
        { data: Publisher },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createPublisher>>,
    TError,
    { data: Publisher },
    TContext
> => {
    const mutationKey = ["createPublisher"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createPublisher>>,
        { data: Publisher }
    > = (props) => {
        const { data } = props ?? {};

        return createPublisher(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreatePublisherMutationResult = NonNullable<
    Awaited<ReturnType<typeof createPublisher>>
>;
export type CreatePublisherMutationBody = Publisher;
export type CreatePublisherMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Create a new publisher
 */
export const useCreatePublisher = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createPublisher>>,
            TError,
            { data: Publisher },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createPublisher>>,
    TError,
    { data: Publisher },
    TContext
> => {
    const mutationOptions = getCreatePublisherMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Checks if the publisher username is already taken.
 * @summary Validate if a publisher username is available
 */
export const validatePublisher = (
    params: ValidatePublisherParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ValidatePublisher200>(
        { url: `/publishers/validate`, method: "GET", params, signal },
        options,
    );
};

export const getValidatePublisherQueryKey = (
    params?: ValidatePublisherParams,
) => {
    return [`/publishers/validate`, ...(params ? [params] : [])] as const;
};

export const getValidatePublisherQueryOptions = <
    TData = Awaited<ReturnType<typeof validatePublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    params: ValidatePublisherParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof validatePublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getValidatePublisherQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof validatePublisher>>
    > = ({ signal }) => validatePublisher(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof validatePublisher>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ValidatePublisherQueryResult = NonNullable<
    Awaited<ReturnType<typeof validatePublisher>>
>;
export type ValidatePublisherQueryError = ErrorResponse | ErrorResponse;

export function useValidatePublisher<
    TData = Awaited<ReturnType<typeof validatePublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    params: ValidatePublisherParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof validatePublisher>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof validatePublisher>>,
                    TError,
                    Awaited<ReturnType<typeof validatePublisher>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useValidatePublisher<
    TData = Awaited<ReturnType<typeof validatePublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    params: ValidatePublisherParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof validatePublisher>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof validatePublisher>>,
                    TError,
                    Awaited<ReturnType<typeof validatePublisher>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useValidatePublisher<
    TData = Awaited<ReturnType<typeof validatePublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    params: ValidatePublisherParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof validatePublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Validate if a publisher username is available
 */

export function useValidatePublisher<
    TData = Awaited<ReturnType<typeof validatePublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    params: ValidatePublisherParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof validatePublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getValidatePublisherQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Delete a publisher
 */
export const deletePublisher = (
    publisherId: string,
    options?: SecondParameter<typeof customInstance>,
) => {
    return customInstance<void>(
        { url: `/publishers/${publisherId}`, method: "DELETE" },
        options,
    );
};

export const getDeletePublisherMutationOptions = <
    TError = ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof deletePublisher>>,
        TError,
        { publisherId: string },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof deletePublisher>>,
    TError,
    { publisherId: string },
    TContext
> => {
    const mutationKey = ["deletePublisher"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deletePublisher>>,
        { publisherId: string }
    > = (props) => {
        const { publisherId } = props ?? {};

        return deletePublisher(publisherId, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type DeletePublisherMutationResult = NonNullable<
    Awaited<ReturnType<typeof deletePublisher>>
>;

export type DeletePublisherMutationError = ErrorResponse | ErrorResponse;

/**
 * @summary Delete a publisher
 */
export const useDeletePublisher = <
    TError = ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deletePublisher>>,
            TError,
            { publisherId: string },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof deletePublisher>>,
    TError,
    { publisherId: string },
    TContext
> => {
    const mutationOptions = getDeletePublisherMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Retrieve a publisher by ID
 */
export const getPublisher = (
    publisherId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Publisher>(
        { url: `/publishers/${publisherId}`, method: "GET", signal },
        options,
    );
};

export const getGetPublisherQueryKey = (publisherId?: string) => {
    return [`/publishers/${publisherId}`] as const;
};

export const getGetPublisherQueryOptions = <
    TData = Awaited<ReturnType<typeof getPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetPublisherQueryKey(publisherId);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublisher>>> = ({
        signal,
    }) => getPublisher(publisherId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!publisherId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getPublisher>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPublisherQueryResult = NonNullable<
    Awaited<ReturnType<typeof getPublisher>>
>;
export type GetPublisherQueryError = ErrorResponse | ErrorResponse;

export function useGetPublisher<
    TData = Awaited<ReturnType<typeof getPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPublisher>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getPublisher>>,
                    TError,
                    Awaited<ReturnType<typeof getPublisher>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPublisher<
    TData = Awaited<ReturnType<typeof getPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPublisher>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getPublisher>>,
                    TError,
                    Awaited<ReturnType<typeof getPublisher>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPublisher<
    TData = Awaited<ReturnType<typeof getPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve a publisher by ID
 */

export function useGetPublisher<
    TData = Awaited<ReturnType<typeof getPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetPublisherQueryOptions(publisherId, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Update a publisher
 */
export const updatePublisher = (
    publisherId: string,
    publisher: Publisher,
    options?: SecondParameter<typeof customInstance>,
) => {
    return customInstance<Publisher>(
        {
            url: `/publishers/${publisherId}`,
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            data: publisher,
        },
        options,
    );
};

export const getUpdatePublisherMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof updatePublisher>>,
        TError,
        { publisherId: string; data: Publisher },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof updatePublisher>>,
    TError,
    { publisherId: string; data: Publisher },
    TContext
> => {
    const mutationKey = ["updatePublisher"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof updatePublisher>>,
        { publisherId: string; data: Publisher }
    > = (props) => {
        const { publisherId, data } = props ?? {};

        return updatePublisher(publisherId, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type UpdatePublisherMutationResult = NonNullable<
    Awaited<ReturnType<typeof updatePublisher>>
>;
export type UpdatePublisherMutationBody = Publisher;
export type UpdatePublisherMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Update a publisher
 */
export const useUpdatePublisher = <
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof updatePublisher>>,
            TError,
            { publisherId: string; data: Publisher },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof updatePublisher>>,
    TError,
    { publisherId: string; data: Publisher },
    TContext
> => {
    const mutationOptions = getUpdatePublisherMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Ban a publisher
 */
export const banPublisher = (
    publisherId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        { url: `/publishers/${publisherId}/ban`, method: "POST", signal },
        options,
    );
};

export const getBanPublisherMutationOptions = <
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof banPublisher>>,
        TError,
        { publisherId: string },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof banPublisher>>,
    TError,
    { publisherId: string },
    TContext
> => {
    const mutationKey = ["banPublisher"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof banPublisher>>,
        { publisherId: string }
    > = (props) => {
        const { publisherId } = props ?? {};

        return banPublisher(publisherId, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type BanPublisherMutationResult = NonNullable<
    Awaited<ReturnType<typeof banPublisher>>
>;

export type BanPublisherMutationError =
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Ban a publisher
 */
export const useBanPublisher = <
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof banPublisher>>,
            TError,
            { publisherId: string },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof banPublisher>>,
    TError,
    { publisherId: string },
    TContext
> => {
    const mutationOptions = getBanPublisherMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Retrieve all nodes
 */
export const listNodesForPublisher = (
    publisherId: string,
    params?: ListNodesForPublisherParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Node[]>(
        {
            url: `/publishers/${publisherId}/nodes`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getListNodesForPublisherQueryKey = (
    publisherId?: string,
    params?: ListNodesForPublisherParams,
) => {
    return [
        `/publishers/${publisherId}/nodes`,
        ...(params ? [params] : []),
    ] as const;
};

export const getListNodesForPublisherQueryOptions = <
    TData = Awaited<ReturnType<typeof listNodesForPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    params?: ListNodesForPublisherParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodesForPublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getListNodesForPublisherQueryKey(publisherId, params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof listNodesForPublisher>>
    > = ({ signal }) =>
        listNodesForPublisher(publisherId, params, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!publisherId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof listNodesForPublisher>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListNodesForPublisherQueryResult = NonNullable<
    Awaited<ReturnType<typeof listNodesForPublisher>>
>;
export type ListNodesForPublisherQueryError = ErrorResponse | ErrorResponse;

export function useListNodesForPublisher<
    TData = Awaited<ReturnType<typeof listNodesForPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    params: undefined | ListNodesForPublisherParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodesForPublisher>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listNodesForPublisher>>,
                    TError,
                    Awaited<ReturnType<typeof listNodesForPublisher>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListNodesForPublisher<
    TData = Awaited<ReturnType<typeof listNodesForPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    params?: ListNodesForPublisherParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodesForPublisher>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listNodesForPublisher>>,
                    TError,
                    Awaited<ReturnType<typeof listNodesForPublisher>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListNodesForPublisher<
    TData = Awaited<ReturnType<typeof listNodesForPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    params?: ListNodesForPublisherParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodesForPublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve all nodes
 */

export function useListNodesForPublisher<
    TData = Awaited<ReturnType<typeof listNodesForPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    params?: ListNodesForPublisherParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodesForPublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListNodesForPublisherQueryOptions(
        publisherId,
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Create a new custom node
 */
export const createNode = (
    publisherId: string,
    node: Node,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Node>(
        {
            url: `/publishers/${publisherId}/nodes`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: node,
            signal,
        },
        options,
    );
};

export const getCreateNodeMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createNode>>,
        TError,
        { publisherId: string; data: Node },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createNode>>,
    TError,
    { publisherId: string; data: Node },
    TContext
> => {
    const mutationKey = ["createNode"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createNode>>,
        { publisherId: string; data: Node }
    > = (props) => {
        const { publisherId, data } = props ?? {};

        return createNode(publisherId, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateNodeMutationResult = NonNullable<
    Awaited<ReturnType<typeof createNode>>
>;
export type CreateNodeMutationBody = Node;
export type CreateNodeMutationError = ErrorResponse | void | ErrorResponse;

/**
 * @summary Create a new custom node
 */
export const useCreateNode = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createNode>>,
            TError,
            { publisherId: string; data: Node },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createNode>>,
    TError,
    { publisherId: string; data: Node },
    TContext
> => {
    const mutationOptions = getCreateNodeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Retrieve all nodes
 */
export const listNodesForPublisherV2 = (
    publisherId: string,
    params?: ListNodesForPublisherV2Params,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ListNodesForPublisherV2200>(
        {
            url: `/publishers/${publisherId}/nodes/v2`,
            method: "GET",
            params,
            signal,
        },
        options,
    );
};

export const getListNodesForPublisherV2QueryKey = (
    publisherId?: string,
    params?: ListNodesForPublisherV2Params,
) => {
    return [
        `/publishers/${publisherId}/nodes/v2`,
        ...(params ? [params] : []),
    ] as const;
};

export const getListNodesForPublisherV2QueryOptions = <
    TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    params?: ListNodesForPublisherV2Params,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodesForPublisherV2>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getListNodesForPublisherV2QueryKey(publisherId, params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof listNodesForPublisherV2>>
    > = ({ signal }) =>
        listNodesForPublisherV2(publisherId, params, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!publisherId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof listNodesForPublisherV2>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListNodesForPublisherV2QueryResult = NonNullable<
    Awaited<ReturnType<typeof listNodesForPublisherV2>>
>;
export type ListNodesForPublisherV2QueryError = ErrorResponse | ErrorResponse;

export function useListNodesForPublisherV2<
    TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    params: undefined | ListNodesForPublisherV2Params,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodesForPublisherV2>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listNodesForPublisherV2>>,
                    TError,
                    Awaited<ReturnType<typeof listNodesForPublisherV2>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListNodesForPublisherV2<
    TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    params?: ListNodesForPublisherV2Params,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodesForPublisherV2>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listNodesForPublisherV2>>,
                    TError,
                    Awaited<ReturnType<typeof listNodesForPublisherV2>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListNodesForPublisherV2<
    TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    params?: ListNodesForPublisherV2Params,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodesForPublisherV2>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve all nodes
 */

export function useListNodesForPublisherV2<
    TData = Awaited<ReturnType<typeof listNodesForPublisherV2>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    params?: ListNodesForPublisherV2Params,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listNodesForPublisherV2>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListNodesForPublisherV2QueryOptions(
        publisherId,
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Delete a specific node
 */
export const deleteNode = (
    publisherId: string,
    nodeId: string,
    options?: SecondParameter<typeof customInstance>,
) => {
    return customInstance<void>(
        { url: `/publishers/${publisherId}/nodes/${nodeId}`, method: "DELETE" },
        options,
    );
};

export const getDeleteNodeMutationOptions = <
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof deleteNode>>,
        TError,
        { publisherId: string; nodeId: string },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof deleteNode>>,
    TError,
    { publisherId: string; nodeId: string },
    TContext
> => {
    const mutationKey = ["deleteNode"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deleteNode>>,
        { publisherId: string; nodeId: string }
    > = (props) => {
        const { publisherId, nodeId } = props ?? {};

        return deleteNode(publisherId, nodeId, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type DeleteNodeMutationResult = NonNullable<
    Awaited<ReturnType<typeof deleteNode>>
>;

export type DeleteNodeMutationError =
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Delete a specific node
 */
export const useDeleteNode = <
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deleteNode>>,
            TError,
            { publisherId: string; nodeId: string },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof deleteNode>>,
    TError,
    { publisherId: string; nodeId: string },
    TContext
> => {
    const mutationOptions = getDeleteNodeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Update a specific node
 */
export const updateNode = (
    publisherId: string,
    nodeId: string,
    node: Node,
    options?: SecondParameter<typeof customInstance>,
) => {
    return customInstance<Node>(
        {
            url: `/publishers/${publisherId}/nodes/${nodeId}`,
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            data: node,
        },
        options,
    );
};

export const getUpdateNodeMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof updateNode>>,
        TError,
        { publisherId: string; nodeId: string; data: Node },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof updateNode>>,
    TError,
    { publisherId: string; nodeId: string; data: Node },
    TContext
> => {
    const mutationKey = ["updateNode"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof updateNode>>,
        { publisherId: string; nodeId: string; data: Node }
    > = (props) => {
        const { publisherId, nodeId, data } = props ?? {};

        return updateNode(publisherId, nodeId, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type UpdateNodeMutationResult = NonNullable<
    Awaited<ReturnType<typeof updateNode>>
>;
export type UpdateNodeMutationBody = Node;
export type UpdateNodeMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Update a specific node
 */
export const useUpdateNode = <
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof updateNode>>,
            TError,
            { publisherId: string; nodeId: string; data: Node },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof updateNode>>,
    TError,
    { publisherId: string; nodeId: string; data: Node },
    TContext
> => {
    const mutationOptions = getUpdateNodeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Ban a publisher's Node
 */
export const banPublisherNode = (
    publisherId: string,
    nodeId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        {
            url: `/publishers/${publisherId}/nodes/${nodeId}/ban`,
            method: "POST",
            signal,
        },
        options,
    );
};

export const getBanPublisherNodeMutationOptions = <
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof banPublisherNode>>,
        TError,
        { publisherId: string; nodeId: string },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof banPublisherNode>>,
    TError,
    { publisherId: string; nodeId: string },
    TContext
> => {
    const mutationKey = ["banPublisherNode"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof banPublisherNode>>,
        { publisherId: string; nodeId: string }
    > = (props) => {
        const { publisherId, nodeId } = props ?? {};

        return banPublisherNode(publisherId, nodeId, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type BanPublisherNodeMutationResult = NonNullable<
    Awaited<ReturnType<typeof banPublisherNode>>
>;

export type BanPublisherNodeMutationError =
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Ban a publisher's Node
 */
export const useBanPublisherNode = <
    TError = void | ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof banPublisherNode>>,
            TError,
            { publisherId: string; nodeId: string },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof banPublisherNode>>,
    TError,
    { publisherId: string; nodeId: string },
    TContext
> => {
    const mutationOptions = getBanPublisherNodeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * This endpoint allows a publisher to claim an unclaimed node that they own the repo, which is identified by the nodeId. The unclaimed node's repository must be owned by the authenticated user.

 * @summary Claim nodeId into publisherId for the authenticated publisher
 */
export const claimMyNode = (
    publisherId: string,
    nodeId: string,
    claimMyNodeRequest: ClaimMyNodeRequest,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        {
            url: `/publishers/${publisherId}/nodes/${nodeId}/claim-my-node`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: claimMyNodeRequest,
            signal,
        },
        options,
    );
};

export const getClaimMyNodeMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof claimMyNode>>,
        TError,
        { publisherId: string; nodeId: string; data: ClaimMyNodeRequest },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof claimMyNode>>,
    TError,
    { publisherId: string; nodeId: string; data: ClaimMyNodeRequest },
    TContext
> => {
    const mutationKey = ["claimMyNode"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof claimMyNode>>,
        { publisherId: string; nodeId: string; data: ClaimMyNodeRequest }
    > = (props) => {
        const { publisherId, nodeId, data } = props ?? {};

        return claimMyNode(publisherId, nodeId, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ClaimMyNodeMutationResult = NonNullable<
    Awaited<ReturnType<typeof claimMyNode>>
>;
export type ClaimMyNodeMutationBody = ClaimMyNodeRequest;
export type ClaimMyNodeMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Claim nodeId into publisherId for the authenticated publisher
 */
export const useClaimMyNode = <
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof claimMyNode>>,
            TError,
            { publisherId: string; nodeId: string; data: ClaimMyNodeRequest },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof claimMyNode>>,
    TError,
    { publisherId: string; nodeId: string; data: ClaimMyNodeRequest },
    TContext
> => {
    const mutationOptions = getClaimMyNodeMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Retrieve permissions the user has for a given publisher
 */
export const getPermissionOnPublisherNodes = (
    publisherId: string,
    nodeId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetPermissionOnPublisherNodes200>(
        {
            url: `/publishers/${publisherId}/nodes/${nodeId}/permissions`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getGetPermissionOnPublisherNodesQueryKey = (
    publisherId?: string,
    nodeId?: string,
) => {
    return [`/publishers/${publisherId}/nodes/${nodeId}/permissions`] as const;
};

export const getGetPermissionOnPublisherNodesQueryOptions = <
    TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    nodeId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getGetPermissionOnPublisherNodesQueryKey(publisherId, nodeId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>
    > = ({ signal }) =>
        getPermissionOnPublisherNodes(
            publisherId,
            nodeId,
            requestOptions,
            signal,
        );

    return {
        queryKey,
        queryFn,
        enabled: !!(publisherId && nodeId),
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPermissionOnPublisherNodesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>
>;
export type GetPermissionOnPublisherNodesQueryError =
    | ErrorResponse
    | ErrorResponse;

export function useGetPermissionOnPublisherNodes<
    TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    nodeId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
                    TError,
                    Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPermissionOnPublisherNodes<
    TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    nodeId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
                    TError,
                    Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPermissionOnPublisherNodes<
    TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    nodeId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve permissions the user has for a given publisher
 */

export function useGetPermissionOnPublisherNodes<
    TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    nodeId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetPermissionOnPublisherNodesQueryOptions(
        publisherId,
        nodeId,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Publish a new version of a node
 */
export const publishNodeVersion = (
    publisherId: string,
    nodeId: string,
    publishNodeVersionBody: PublishNodeVersionBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<PublishNodeVersion201>(
        {
            url: `/publishers/${publisherId}/nodes/${nodeId}/versions`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: publishNodeVersionBody,
            signal,
        },
        options,
    );
};

export const getPublishNodeVersionMutationOptions = <
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof publishNodeVersion>>,
        TError,
        { publisherId: string; nodeId: string; data: PublishNodeVersionBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof publishNodeVersion>>,
    TError,
    { publisherId: string; nodeId: string; data: PublishNodeVersionBody },
    TContext
> => {
    const mutationKey = ["publishNodeVersion"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof publishNodeVersion>>,
        { publisherId: string; nodeId: string; data: PublishNodeVersionBody }
    > = (props) => {
        const { publisherId, nodeId, data } = props ?? {};

        return publishNodeVersion(publisherId, nodeId, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PublishNodeVersionMutationResult = NonNullable<
    Awaited<ReturnType<typeof publishNodeVersion>>
>;
export type PublishNodeVersionMutationBody = PublishNodeVersionBody;
export type PublishNodeVersionMutationError =
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Publish a new version of a node
 */
export const usePublishNodeVersion = <
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof publishNodeVersion>>,
            TError,
            {
                publisherId: string;
                nodeId: string;
                data: PublishNodeVersionBody;
            },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof publishNodeVersion>>,
    TError,
    { publisherId: string; nodeId: string; data: PublishNodeVersionBody },
    TContext
> => {
    const mutationOptions = getPublishNodeVersionMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Unpublish (delete) a specific version of a node
 */
export const deleteNodeVersion = (
    publisherId: string,
    nodeId: string,
    versionId: string,
    options?: SecondParameter<typeof customInstance>,
) => {
    return customInstance<void>(
        {
            url: `/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`,
            method: "DELETE",
        },
        options,
    );
};

export const getDeleteNodeVersionMutationOptions = <
    TError = ErrorResponse | Error | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof deleteNodeVersion>>,
        TError,
        { publisherId: string; nodeId: string; versionId: string },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof deleteNodeVersion>>,
    TError,
    { publisherId: string; nodeId: string; versionId: string },
    TContext
> => {
    const mutationKey = ["deleteNodeVersion"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deleteNodeVersion>>,
        { publisherId: string; nodeId: string; versionId: string }
    > = (props) => {
        const { publisherId, nodeId, versionId } = props ?? {};

        return deleteNodeVersion(
            publisherId,
            nodeId,
            versionId,
            requestOptions,
        );
    };

    return { mutationFn, ...mutationOptions };
};

export type DeleteNodeVersionMutationResult = NonNullable<
    Awaited<ReturnType<typeof deleteNodeVersion>>
>;

export type DeleteNodeVersionMutationError =
    | ErrorResponse
    | Error
    | ErrorResponse;

/**
 * @summary Unpublish (delete) a specific version of a node
 */
export const useDeleteNodeVersion = <
    TError = ErrorResponse | Error | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deleteNodeVersion>>,
            TError,
            { publisherId: string; nodeId: string; versionId: string },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof deleteNodeVersion>>,
    TError,
    { publisherId: string; nodeId: string; versionId: string },
    TContext
> => {
    const mutationOptions = getDeleteNodeVersionMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Update only the changelog and deprecated status of a specific version of a node.
 * @summary Update changelog and deprecation status of a node version
 */
export const updateNodeVersion = (
    publisherId: string,
    nodeId: string,
    versionId: string,
    nodeVersionUpdateRequest: NodeVersionUpdateRequest,
    options?: SecondParameter<typeof customInstance>,
) => {
    return customInstance<NodeVersion>(
        {
            url: `/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`,
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            data: nodeVersionUpdateRequest,
        },
        options,
    );
};

export const getUpdateNodeVersionMutationOptions = <
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof updateNodeVersion>>,
        TError,
        {
            publisherId: string;
            nodeId: string;
            versionId: string;
            data: NodeVersionUpdateRequest;
        },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof updateNodeVersion>>,
    TError,
    {
        publisherId: string;
        nodeId: string;
        versionId: string;
        data: NodeVersionUpdateRequest;
    },
    TContext
> => {
    const mutationKey = ["updateNodeVersion"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof updateNodeVersion>>,
        {
            publisherId: string;
            nodeId: string;
            versionId: string;
            data: NodeVersionUpdateRequest;
        }
    > = (props) => {
        const { publisherId, nodeId, versionId, data } = props ?? {};

        return updateNodeVersion(
            publisherId,
            nodeId,
            versionId,
            data,
            requestOptions,
        );
    };

    return { mutationFn, ...mutationOptions };
};

export type UpdateNodeVersionMutationResult = NonNullable<
    Awaited<ReturnType<typeof updateNodeVersion>>
>;
export type UpdateNodeVersionMutationBody = NodeVersionUpdateRequest;
export type UpdateNodeVersionMutationError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Update changelog and deprecation status of a node version
 */
export const useUpdateNodeVersion = <
    TError =
        | ErrorResponse
        | void
        | ErrorResponse
        | ErrorResponse
        | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof updateNodeVersion>>,
            TError,
            {
                publisherId: string;
                nodeId: string;
                versionId: string;
                data: NodeVersionUpdateRequest;
            },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof updateNodeVersion>>,
    TError,
    {
        publisherId: string;
        nodeId: string;
        versionId: string;
        data: NodeVersionUpdateRequest;
    },
    TContext
> => {
    const mutationOptions = getUpdateNodeVersionMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Retrieve permissions the user has for a given publisher
 */
export const getPermissionOnPublisher = (
    publisherId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<GetPermissionOnPublisher200>(
        {
            url: `/publishers/${publisherId}/permissions`,
            method: "GET",
            signal,
        },
        options,
    );
};

export const getGetPermissionOnPublisherQueryKey = (publisherId?: string) => {
    return [`/publishers/${publisherId}/permissions`] as const;
};

export const getGetPermissionOnPublisherQueryOptions = <
    TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPermissionOnPublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getGetPermissionOnPublisherQueryKey(publisherId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getPermissionOnPublisher>>
    > = ({ signal }) =>
        getPermissionOnPublisher(publisherId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!publisherId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getPermissionOnPublisher>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPermissionOnPublisherQueryResult = NonNullable<
    Awaited<ReturnType<typeof getPermissionOnPublisher>>
>;
export type GetPermissionOnPublisherQueryError = ErrorResponse | ErrorResponse;

export function useGetPermissionOnPublisher<
    TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPermissionOnPublisher>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getPermissionOnPublisher>>,
                    TError,
                    Awaited<ReturnType<typeof getPermissionOnPublisher>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPermissionOnPublisher<
    TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPermissionOnPublisher>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getPermissionOnPublisher>>,
                    TError,
                    Awaited<ReturnType<typeof getPermissionOnPublisher>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPermissionOnPublisher<
    TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPermissionOnPublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve permissions the user has for a given publisher
 */

export function useGetPermissionOnPublisher<
    TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>,
    TError = ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPermissionOnPublisher>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetPermissionOnPublisherQueryOptions(
        publisherId,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Retrieve all personal access tokens for a publisher
 */
export const listPersonalAccessTokens = (
    publisherId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<PersonalAccessToken[]>(
        { url: `/publishers/${publisherId}/tokens`, method: "GET", signal },
        options,
    );
};

export const getListPersonalAccessTokensQueryKey = (publisherId?: string) => {
    return [`/publishers/${publisherId}/tokens`] as const;
};

export const getListPersonalAccessTokensQueryOptions = <
    TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPersonalAccessTokens>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getListPersonalAccessTokensQueryKey(publisherId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof listPersonalAccessTokens>>
    > = ({ signal }) =>
        listPersonalAccessTokens(publisherId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!publisherId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof listPersonalAccessTokens>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListPersonalAccessTokensQueryResult = NonNullable<
    Awaited<ReturnType<typeof listPersonalAccessTokens>>
>;
export type ListPersonalAccessTokensQueryError =
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

export function useListPersonalAccessTokens<
    TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPersonalAccessTokens>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listPersonalAccessTokens>>,
                    TError,
                    Awaited<ReturnType<typeof listPersonalAccessTokens>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListPersonalAccessTokens<
    TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPersonalAccessTokens>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listPersonalAccessTokens>>,
                    TError,
                    Awaited<ReturnType<typeof listPersonalAccessTokens>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListPersonalAccessTokens<
    TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPersonalAccessTokens>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve all personal access tokens for a publisher
 */

export function useListPersonalAccessTokens<
    TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    publisherId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPersonalAccessTokens>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListPersonalAccessTokensQueryOptions(
        publisherId,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Create a new personal access token
 */
export const createPersonalAccessToken = (
    publisherId: string,
    personalAccessToken: PersonalAccessToken,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<CreatePersonalAccessToken201>(
        {
            url: `/publishers/${publisherId}/tokens`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: personalAccessToken,
            signal,
        },
        options,
    );
};

export const getCreatePersonalAccessTokenMutationOptions = <
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createPersonalAccessToken>>,
        TError,
        { publisherId: string; data: PersonalAccessToken },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createPersonalAccessToken>>,
    TError,
    { publisherId: string; data: PersonalAccessToken },
    TContext
> => {
    const mutationKey = ["createPersonalAccessToken"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createPersonalAccessToken>>,
        { publisherId: string; data: PersonalAccessToken }
    > = (props) => {
        const { publisherId, data } = props ?? {};

        return createPersonalAccessToken(publisherId, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreatePersonalAccessTokenMutationResult = NonNullable<
    Awaited<ReturnType<typeof createPersonalAccessToken>>
>;
export type CreatePersonalAccessTokenMutationBody = PersonalAccessToken;
export type CreatePersonalAccessTokenMutationError =
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Create a new personal access token
 */
export const useCreatePersonalAccessToken = <
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createPersonalAccessToken>>,
            TError,
            { publisherId: string; data: PersonalAccessToken },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createPersonalAccessToken>>,
    TError,
    { publisherId: string; data: PersonalAccessToken },
    TContext
> => {
    const mutationOptions =
        getCreatePersonalAccessTokenMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete a specific personal access token
 */
export const deletePersonalAccessToken = (
    publisherId: string,
    tokenId: string,
    options?: SecondParameter<typeof customInstance>,
) => {
    return customInstance<void>(
        {
            url: `/publishers/${publisherId}/tokens/${tokenId}`,
            method: "DELETE",
        },
        options,
    );
};

export const getDeletePersonalAccessTokenMutationOptions = <
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof deletePersonalAccessToken>>,
        TError,
        { publisherId: string; tokenId: string },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof deletePersonalAccessToken>>,
    TError,
    { publisherId: string; tokenId: string },
    TContext
> => {
    const mutationKey = ["deletePersonalAccessToken"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deletePersonalAccessToken>>,
        { publisherId: string; tokenId: string }
    > = (props) => {
        const { publisherId, tokenId } = props ?? {};

        return deletePersonalAccessToken(publisherId, tokenId, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type DeletePersonalAccessTokenMutationResult = NonNullable<
    Awaited<ReturnType<typeof deletePersonalAccessToken>>
>;

export type DeletePersonalAccessTokenMutationError =
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Delete a specific personal access token
 */
export const useDeletePersonalAccessToken = <
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deletePersonalAccessToken>>,
            TError,
            { publisherId: string; tokenId: string },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof deletePersonalAccessToken>>,
    TError,
    { publisherId: string; tokenId: string },
    TContext
> => {
    const mutationOptions =
        getDeletePersonalAccessTokenMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Fetch release notes from Strapi with caching
 * @summary Get release notes
 */
export const getReleaseNotes = (
    params: GetReleaseNotesParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ReleaseNote[]>(
        { url: `/releases`, method: "GET", params, signal },
        options,
    );
};

export const getGetReleaseNotesQueryKey = (params?: GetReleaseNotesParams) => {
    return [`/releases`, ...(params ? [params] : [])] as const;
};

export const getGetReleaseNotesQueryOptions = <
    TData = Awaited<ReturnType<typeof getReleaseNotes>>,
    TError = ErrorResponse | ErrorResponse,
>(
    params: GetReleaseNotesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getReleaseNotes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetReleaseNotesQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getReleaseNotes>>
    > = ({ signal }) => getReleaseNotes(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getReleaseNotes>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReleaseNotesQueryResult = NonNullable<
    Awaited<ReturnType<typeof getReleaseNotes>>
>;
export type GetReleaseNotesQueryError = ErrorResponse | ErrorResponse;

export function useGetReleaseNotes<
    TData = Awaited<ReturnType<typeof getReleaseNotes>>,
    TError = ErrorResponse | ErrorResponse,
>(
    params: GetReleaseNotesParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getReleaseNotes>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getReleaseNotes>>,
                    TError,
                    Awaited<ReturnType<typeof getReleaseNotes>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetReleaseNotes<
    TData = Awaited<ReturnType<typeof getReleaseNotes>>,
    TError = ErrorResponse | ErrorResponse,
>(
    params: GetReleaseNotesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getReleaseNotes>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getReleaseNotes>>,
                    TError,
                    Awaited<ReturnType<typeof getReleaseNotes>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetReleaseNotes<
    TData = Awaited<ReturnType<typeof getReleaseNotes>>,
    TError = ErrorResponse | ErrorResponse,
>(
    params: GetReleaseNotesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getReleaseNotes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get release notes
 */

export function useGetReleaseNotes<
    TData = Awaited<ReturnType<typeof getReleaseNotes>>,
    TError = ErrorResponse | ErrorResponse,
>(
    params: GetReleaseNotesParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getReleaseNotes>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetReleaseNotesQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Webhook endpoint to process Github release events and generate release notes
 * @summary Process Github release webhook
 */
export const processReleaseWebhook = (
    githubReleaseWebhook: GithubReleaseWebhook,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        {
            url: `/releases`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: githubReleaseWebhook,
            signal,
        },
        options,
    );
};

export const getProcessReleaseWebhookMutationOptions = <
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof processReleaseWebhook>>,
        TError,
        { data: GithubReleaseWebhook },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof processReleaseWebhook>>,
    TError,
    { data: GithubReleaseWebhook },
    TContext
> => {
    const mutationKey = ["processReleaseWebhook"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof processReleaseWebhook>>,
        { data: GithubReleaseWebhook }
    > = (props) => {
        const { data } = props ?? {};

        return processReleaseWebhook(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ProcessReleaseWebhookMutationResult = NonNullable<
    Awaited<ReturnType<typeof processReleaseWebhook>>
>;
export type ProcessReleaseWebhookMutationBody = GithubReleaseWebhook;
export type ProcessReleaseWebhookMutationError =
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

/**
 * @summary Process Github release webhook
 */
export const useProcessReleaseWebhook = <
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof processReleaseWebhook>>,
            TError,
            { data: GithubReleaseWebhook },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof processReleaseWebhook>>,
    TError,
    { data: GithubReleaseWebhook },
    TContext
> => {
    const mutationOptions = getProcessReleaseWebhookMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Pull all pending node versions and conduct security scans.
 * @summary Security Scan
 */
export const securityScan = (
    params?: SecurityScanParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        { url: `/security-scan`, method: "GET", params, signal },
        options,
    );
};

export const getSecurityScanQueryKey = (params?: SecurityScanParams) => {
    return [`/security-scan`, ...(params ? [params] : [])] as const;
};

export const getSecurityScanQueryOptions = <
    TData = Awaited<ReturnType<typeof securityScan>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    params?: SecurityScanParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof securityScan>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getSecurityScanQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof securityScan>>> = ({
        signal,
    }) => securityScan(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof securityScan>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SecurityScanQueryResult = NonNullable<
    Awaited<ReturnType<typeof securityScan>>
>;
export type SecurityScanQueryError =
    | ErrorResponse
    | void
    | ErrorResponse
    | ErrorResponse;

export function useSecurityScan<
    TData = Awaited<ReturnType<typeof securityScan>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    params: undefined | SecurityScanParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof securityScan>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof securityScan>>,
                    TError,
                    Awaited<ReturnType<typeof securityScan>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSecurityScan<
    TData = Awaited<ReturnType<typeof securityScan>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    params?: SecurityScanParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof securityScan>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof securityScan>>,
                    TError,
                    Awaited<ReturnType<typeof securityScan>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSecurityScan<
    TData = Awaited<ReturnType<typeof securityScan>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    params?: SecurityScanParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof securityScan>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Security Scan
 */

export function useSecurityScan<
    TData = Awaited<ReturnType<typeof securityScan>>,
    TError = ErrorResponse | void | ErrorResponse | ErrorResponse,
>(
    params?: SecurityScanParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof securityScan>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getSecurityScanQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * Receive artifacts (output files) from the ComfyUI GitHub Action
 * @summary Receive artifacts (output files) from the ComfyUI GitHub Action
 */
export const postUploadArtifact = (
    postUploadArtifactBody: PostUploadArtifactBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<PostUploadArtifact200>(
        {
            url: `/upload-artifact`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: postUploadArtifactBody,
            signal,
        },
        options,
    );
};

export const getPostUploadArtifactMutationOptions = <
    TError = void | void,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postUploadArtifact>>,
        TError,
        { data: PostUploadArtifactBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof postUploadArtifact>>,
    TError,
    { data: PostUploadArtifactBody },
    TContext
> => {
    const mutationKey = ["postUploadArtifact"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postUploadArtifact>>,
        { data: PostUploadArtifactBody }
    > = (props) => {
        const { data } = props ?? {};

        return postUploadArtifact(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PostUploadArtifactMutationResult = NonNullable<
    Awaited<ReturnType<typeof postUploadArtifact>>
>;
export type PostUploadArtifactMutationBody = PostUploadArtifactBody;
export type PostUploadArtifactMutationError = void | void;

/**
 * @summary Receive artifacts (output files) from the ComfyUI GitHub Action
 */
export const usePostUploadArtifact = <TError = void | void, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof postUploadArtifact>>,
            TError,
            { data: PostUploadArtifactBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof postUploadArtifact>>,
    TError,
    { data: PostUploadArtifactBody },
    TContext
> => {
    const mutationOptions = getPostUploadArtifactMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get information about the calling user.
 */
export const getUser = (
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<User>(
        { url: `/users`, method: "GET", signal },
        options,
    );
};

export const getGetUserQueryKey = () => {
    return [`/users`] as const;
};

export const getGetUserQueryOptions = <
    TData = Awaited<ReturnType<typeof getUser>>,
    TError = void | void,
>(options?: {
    query?: Partial<
        UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
        signal,
    }) => getUser(requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserQueryResult = NonNullable<
    Awaited<ReturnType<typeof getUser>>
>;
export type GetUserQueryError = void | void;

export function useGetUser<
    TData = Awaited<ReturnType<typeof getUser>>,
    TError = void | void,
>(
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getUser>>,
                    TError,
                    Awaited<ReturnType<typeof getUser>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUser<
    TData = Awaited<ReturnType<typeof getUser>>,
    TError = void | void,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getUser>>,
                    TError,
                    Awaited<ReturnType<typeof getUser>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUser<
    TData = Awaited<ReturnType<typeof getUser>>,
    TError = void | void,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get information about the calling user.
 */

export function useGetUser<
    TData = Awaited<ReturnType<typeof getUser>>,
    TError = void | void,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetUserQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Retrieve all publishers for a given user
 */
export const listPublishersForUser = (
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<Publisher[]>(
        { url: `/users/publishers/`, method: "GET", signal },
        options,
    );
};

export const getListPublishersForUserQueryKey = () => {
    return [`/users/publishers/`] as const;
};

export const getListPublishersForUserQueryOptions = <
    TData = Awaited<ReturnType<typeof listPublishersForUser>>,
    TError = ErrorResponse | ErrorResponse,
>(options?: {
    query?: Partial<
        UseQueryOptions<
            Awaited<ReturnType<typeof listPublishersForUser>>,
            TError,
            TData
        >
    >;
    request?: SecondParameter<typeof customInstance>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getListPublishersForUserQueryKey();

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof listPublishersForUser>>
    > = ({ signal }) => listPublishersForUser(requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof listPublishersForUser>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListPublishersForUserQueryResult = NonNullable<
    Awaited<ReturnType<typeof listPublishersForUser>>
>;
export type ListPublishersForUserQueryError = ErrorResponse | ErrorResponse;

export function useListPublishersForUser<
    TData = Awaited<ReturnType<typeof listPublishersForUser>>,
    TError = ErrorResponse | ErrorResponse,
>(
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPublishersForUser>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listPublishersForUser>>,
                    TError,
                    Awaited<ReturnType<typeof listPublishersForUser>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListPublishersForUser<
    TData = Awaited<ReturnType<typeof listPublishersForUser>>,
    TError = ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPublishersForUser>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listPublishersForUser>>,
                    TError,
                    Awaited<ReturnType<typeof listPublishersForUser>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListPublishersForUser<
    TData = Awaited<ReturnType<typeof listPublishersForUser>>,
    TError = ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPublishersForUser>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve all publishers for a given user
 */

export function useListPublishersForUser<
    TData = Awaited<ReturnType<typeof listPublishersForUser>>,
    TError = ErrorResponse | ErrorResponse,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listPublishersForUser>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListPublishersForUserQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary List all node versions given some filters.
 */
export const listAllNodeVersions = (
    params?: ListAllNodeVersionsParams,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ListAllNodeVersions200>(
        { url: `/versions`, method: "GET", params, signal },
        options,
    );
};

export const getListAllNodeVersionsQueryKey = (
    params?: ListAllNodeVersionsParams,
) => {
    return [`/versions`, ...(params ? [params] : [])] as const;
};

export const getListAllNodeVersionsQueryOptions = <
    TData = Awaited<ReturnType<typeof listAllNodeVersions>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    params?: ListAllNodeVersionsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listAllNodeVersions>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getListAllNodeVersionsQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof listAllNodeVersions>>
    > = ({ signal }) => listAllNodeVersions(params, requestOptions, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof listAllNodeVersions>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListAllNodeVersionsQueryResult = NonNullable<
    Awaited<ReturnType<typeof listAllNodeVersions>>
>;
export type ListAllNodeVersionsQueryError =
    | ErrorResponse
    | ErrorResponse
    | ErrorResponse;

export function useListAllNodeVersions<
    TData = Awaited<ReturnType<typeof listAllNodeVersions>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    params: undefined | ListAllNodeVersionsParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listAllNodeVersions>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listAllNodeVersions>>,
                    TError,
                    Awaited<ReturnType<typeof listAllNodeVersions>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListAllNodeVersions<
    TData = Awaited<ReturnType<typeof listAllNodeVersions>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    params?: ListAllNodeVersionsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listAllNodeVersions>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listAllNodeVersions>>,
                    TError,
                    Awaited<ReturnType<typeof listAllNodeVersions>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListAllNodeVersions<
    TData = Awaited<ReturnType<typeof listAllNodeVersions>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    params?: ListAllNodeVersionsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listAllNodeVersions>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List all node versions given some filters.
 */

export function useListAllNodeVersions<
    TData = Awaited<ReturnType<typeof listAllNodeVersions>>,
    TError = ErrorResponse | ErrorResponse | ErrorResponse,
>(
    params?: ListAllNodeVersionsParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof listAllNodeVersions>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getListAllNodeVersionsQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary receive alert on remaining balance is 0
 */
export const metronomeZeroBalance = (
    metronomeZeroBalanceBody: MetronomeZeroBalanceBody,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<IdeogramGenerateResponse>(
        {
            url: `/webhook/metronome/zero-balance`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: metronomeZeroBalanceBody,
            signal,
        },
        options,
    );
};

export const getMetronomeZeroBalanceMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof metronomeZeroBalance>>,
        TError,
        { data: MetronomeZeroBalanceBody },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof metronomeZeroBalance>>,
    TError,
    { data: MetronomeZeroBalanceBody },
    TContext
> => {
    const mutationKey = ["metronomeZeroBalance"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof metronomeZeroBalance>>,
        { data: MetronomeZeroBalanceBody }
    > = (props) => {
        const { data } = props ?? {};

        return metronomeZeroBalance(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type MetronomeZeroBalanceMutationResult = NonNullable<
    Awaited<ReturnType<typeof metronomeZeroBalance>>
>;
export type MetronomeZeroBalanceMutationBody = MetronomeZeroBalanceBody;
export type MetronomeZeroBalanceMutationError =
    | ErrorResponse
    | void
    | ErrorResponse;

/**
 * @summary receive alert on remaining balance is 0
 */
export const useMetronomeZeroBalance = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof metronomeZeroBalance>>,
            TError,
            { data: MetronomeZeroBalanceBody },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof metronomeZeroBalance>>,
    TError,
    { data: MetronomeZeroBalanceBody },
    TContext
> => {
    const mutationOptions = getMetronomeZeroBalanceMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Handle Stripe checkout.session.completed webhook event
 */
export const stripeInvoiceStatus = (
    stripeEvent: StripeEvent,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<void>(
        {
            url: `/webhook/stripe/invoice-status`,
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: stripeEvent,
            signal,
        },
        options,
    );
};

export const getStripeInvoiceStatusMutationOptions = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof stripeInvoiceStatus>>,
        TError,
        { data: StripeEvent },
        TContext
    >;
    request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof stripeInvoiceStatus>>,
    TError,
    { data: StripeEvent },
    TContext
> => {
    const mutationKey = ["stripeInvoiceStatus"];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation &&
          "mutationKey" in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof stripeInvoiceStatus>>,
        { data: StripeEvent }
    > = (props) => {
        const { data } = props ?? {};

        return stripeInvoiceStatus(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type StripeInvoiceStatusMutationResult = NonNullable<
    Awaited<ReturnType<typeof stripeInvoiceStatus>>
>;
export type StripeInvoiceStatusMutationBody = StripeEvent;
export type StripeInvoiceStatusMutationError =
    | ErrorResponse
    | void
    | ErrorResponse;

/**
 * @summary Handle Stripe checkout.session.completed webhook event
 */
export const useStripeInvoiceStatus = <
    TError = ErrorResponse | void | ErrorResponse,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof stripeInvoiceStatus>>,
            TError,
            { data: StripeEvent },
            TContext
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof stripeInvoiceStatus>>,
    TError,
    { data: StripeEvent },
    TContext
> => {
    const mutationOptions = getStripeInvoiceStatusMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Retrieve a specific commit by ID
 */
export const getWorkflowResult = (
    workflowResultId: string,
    options?: SecondParameter<typeof customInstance>,
    signal?: AbortSignal,
) => {
    return customInstance<ActionJobResult>(
        { url: `/workflowresult/${workflowResultId}`, method: "GET", signal },
        options,
    );
};

export const getGetWorkflowResultQueryKey = (workflowResultId?: string) => {
    return [`/workflowresult/${workflowResultId}`] as const;
};

export const getGetWorkflowResultQueryOptions = <
    TData = Awaited<ReturnType<typeof getWorkflowResult>>,
    TError = ErrorResponse | ErrorResponse,
>(
    workflowResultId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getWorkflowResult>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getGetWorkflowResultQueryKey(workflowResultId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getWorkflowResult>>
    > = ({ signal }) =>
        getWorkflowResult(workflowResultId, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!workflowResultId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getWorkflowResult>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWorkflowResultQueryResult = NonNullable<
    Awaited<ReturnType<typeof getWorkflowResult>>
>;
export type GetWorkflowResultQueryError = ErrorResponse | ErrorResponse;

export function useGetWorkflowResult<
    TData = Awaited<ReturnType<typeof getWorkflowResult>>,
    TError = ErrorResponse | ErrorResponse,
>(
    workflowResultId: string,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getWorkflowResult>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getWorkflowResult>>,
                    TError,
                    Awaited<ReturnType<typeof getWorkflowResult>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetWorkflowResult<
    TData = Awaited<ReturnType<typeof getWorkflowResult>>,
    TError = ErrorResponse | ErrorResponse,
>(
    workflowResultId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getWorkflowResult>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getWorkflowResult>>,
                    TError,
                    Awaited<ReturnType<typeof getWorkflowResult>>
                >,
                "initialData"
            >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetWorkflowResult<
    TData = Awaited<ReturnType<typeof getWorkflowResult>>,
    TError = ErrorResponse | ErrorResponse,
>(
    workflowResultId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getWorkflowResult>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve a specific commit by ID
 */

export function useGetWorkflowResult<
    TData = Awaited<ReturnType<typeof getWorkflowResult>>,
    TError = ErrorResponse | ErrorResponse,
>(
    workflowResultId: string,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getWorkflowResult>>,
                TError,
                TData
            >
        >;
        request?: SecondParameter<typeof customInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetWorkflowResultQueryOptions(
        workflowResultId,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}
