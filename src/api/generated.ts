/**
 * Generated by orval v6.23.0 üç∫
 * Do not edit manually.
 * Drip API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { customInstance } from './mutator/axios-instance';
export type LoadWorkspaceSnapshot200 = {
  /** A message confirming the workspace snapshot was loaded */
  message?: string;
};

export type CreateWorkspaceSnapshot201 = {
  /** The unique identifier for the workspace snapshot */
  workspaceSnapshotId?: string;
};

export type CreateWorkspaceSnapshotBody = {
  /** A description of the workspace snapshot */
  description?: string;
};

export type GetWorkspaceSnapshots200 = {
  workspaceSnapshots?: WorkspaceSnapshot[];
};

export type UpdateWorkspace200 = {
  /** The unique identifier for the workspace */
  workspaceId?: string;
};

export type UpdateWorkspaceBody = {
  machine?: Machine;
  workflow?: Workflow;
};

export type GetWorkspace200 = {
  workspace?: Workspace;
};

export type CreateDefaultWorkspace201 = {
  /** The unique identifier for the default workspace */
  workspaceId?: string;
};

export type CreateWorkspace201 = {
  /** The unique identifier for the workspace */
  workspaceId?: string;
};

export type CreateWorkspaceBody = {
  /** The name of the workspace */
  name?: string;
};

export type GetWorkspaces200 = {
  workspaces?: Workspace[];
};

export type GetWorkspacesParams = {
limit?: number;
offset?: number;
};

export type CancelWorkflowJob200 = {
  /** A message confirming the cancellation request */
  message?: string;
};

export type UpdateWorkflowJobBody = {
  /** The updated list of output URLs generated by the workflow job */
  outputUrls?: string[];
  status?: WorkflowJobStatus;
};

export type CreateWorkflowJobBody = {
  /** The webhook will be called when the status of the job changes */
  webhookUrl: string;
};

export type GetWorkflow200AllOf = {
  authorId?: string;
  sessionId?: string;
};

export type GetWorkflow200 = Workflow & GetWorkflow200AllOf;

export type CreateWorkflowBody = {
  /** The JSON file content of the workflow. */
  fileContent: string;
  /** User-defined name for the workflow */
  name: string;
};

export type GetUserWorkflows200 = {
  workflows?: Workflow[];
};

export type GetUserWorkflowsParams = {
limit?: number;
offset?: number;
};

export type PostValidateTokenBody = {
  /** The access token to be validated. */
  token: string;
};

export type UpdateSessionBody = {
  /** The number of GPUs attached to this session. Can be 0 or 1. */
  gpuCount?: number;
  gpuType?: GPUType;
  /** Whether to update the end time of the session to 30 minutes from now. */
  updateEndTime?: boolean;
};

export type CreateSessionBody = {
  'gpu-type'?: GPUType;
};

export type GetSessions200 = {
  sessions?: Session[];
};

export type GetSessionsParams = {
/**
 * Filter sessions by status
 */
status?: SessionStatus;
};

export type PostUploadArtifact200 = {
  message?: string;
};

export type PostUploadArtifactBody = {
  branch_name: string;
  /** The name of the bucket where the output files are stored */
  bucket_name?: string;
  /** The path to ComfyUI logs. eg. gs://bucket-name/logs */
  comfy_logs_gcs_path?: string;
  commit_hash: string;
  /** Cuda version. */
  cuda_version?: string;
  /** The end time of the job as a Unix timestamp. */
  end_time: number;
  /** Unique identifier for the job */
  job_id: string;
  /** Operating system used in the run */
  os: string;
  /** A comma separated string that contains GCS path(s) to output files. eg. gs://bucket-name/output, gs://bucket-name/output2 */
  output_files_gcs_paths?: string;
  /** Repository name */
  repo: string;
  /** Unique identifier for the run */
  run_id: string;
  /** The start time of the job as a Unix timestamp. */
  start_time: number;
  /** The name of the workflow */
  workflow_name: string;
};

export type CreatePersonalAccessToken201 = {
  /** The newly created personal access token. */
  token?: string;
};

export type PublishNodeVersion201 = {
  node_version?: NodeVersion;
  /** The signed URL to upload the node version token. */
  signedUrl?: string;
};

export type PublishNodeVersionBody = {
  node: Node;
  node_version: NodeVersion;
  personal_access_token: string;
};

export type ValidatePublisher200 = {
  /** True if the username is available, false otherwise. */
  isAvailable?: boolean;
};

export type ValidatePublisherParams = {
/**
 * The publisher username to validate.
 */
username: string;
};

export type InstallNodeParams = {
/**
 * Specific version of the node to retrieve. If omitted, the latest version is returned.
 */
version?: string;
};

export type ListAllNodes200 = {
  /** Maximum number of nodes per page */
  limit?: number;
  nodes?: Node[];
  /** Current page number */
  page?: number;
  /** Total number of nodes available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

export type ListAllNodesParams = {
/**
 * Page number of the nodes list
 */
page?: number;
/**
 * Number of nodes to return per page
 */
limit?: number;
};

export type GetGitcommit200 = {
  jobResults?: ActionJobResult[];
  totalNumberOfPages?: number;
};

export type GetGitcommitParams = {
/**
 * The ID of the commit to fetch data for.
 */
commitId?: string;
/**
 * The operating system to filter the CI data by.
 */
operatingSystem?: string;
/**
 * The name of the workflow to filter the CI data by.
 */
workflowName?: string;
/**
 * The branch of the gitcommit to filter the CI data by.
 */
branch?: string;
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * The number of items to include per page.
 */
pageSize?: number;
/**
 * The repo to filter by.
 */
repoName?: string;
};

export type GetBranch200 = {
  branches?: string[];
};

export type GetBranchParams = {
/**
 * The repo to filter by.
 */
repo_name?: string;
};

export interface WorkspaceSnapshot {
  /** A description of the workspace snapshot */
  description?: string;
  /** The unique id for this workflow snapshot. */
  id?: string;
}

/**
 * The status of the workflow being executed:
- `queued` - The job is in queue and will be executed soon.
- `started` - The job has started executing.
- `failed` - The job has failed.
- `succeeded` - The job has finished successfully.

 */
export type WorkflowJobStatus = typeof WorkflowJobStatus[keyof typeof WorkflowJobStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkflowJobStatus = {
  queued: 'queued',
  started: 'started',
  failed: 'failed',
  succeeded: 'succeeded',
} as const;

export interface WorkflowJob {
  id?: string;
  /** A list of URLs to the output generated by the workflow job. */
  outputUrls?: string[];
  status?: WorkflowJobStatus;
  /** This webhook will be called when the status of the job changes */
  webhookUrl?: string;
}

export interface Workflow {
  /** The unique id for this workflow. */
  id?: string;
  /** The date and time the workflow was last updated. */
  updatedAt?: string;
  /** The JSON representation of the workflow. */
  workflowJSON?: string;
  /** Name of the workflow */
  workflowName?: string;
}

export interface Workspace {
  /** The unique id for this workspace. */
  id?: string;
  machine?: Machine;
  /** The name of the workspace. */
  name?: string;
  workflow?: Workflow;
}

export interface User {
  /** The email address for this user. */
  email?: string;
  /** The unique id for this user. */
  id?: string;
  /** Indicates if the user has admin privileges. */
  isAdmin?: boolean;
  /** Indicates if the user is approved. */
  isApproved?: boolean;
  /** The name for this user. */
  name?: string;
}

export interface StorageFile {
  /** Path to the file in storage */
  file_path?: string;
  /** Unique identifier for the storage file */
  id?: string;
  /** Public URL */
  public_url?: string;
}

/**
 * The status of the workflow being executed:
- `active` - The session is active and can be used.
- `inactive` - The session is inactive and cannot be used.

 */
export type SessionStatus = typeof SessionStatus[keyof typeof SessionStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SessionStatus = {
  active: 'active',
  inactive: 'inactive',
} as const;

export interface PublisherMember {
  /** The unique identifier for the publisher member. */
  id?: string;
  /** The role of the user in the publisher. */
  role?: string;
  user?: User;
}

export interface Publisher {
  /** The date and time the publisher was created. */
  createdAt?: string;
  description?: string;
  /** The unique identifier for the publisher. It's akin to a username. Should be lowercase. */
  id?: string;
  /** URL to the publisher's logo. */
  logo?: string;
  /** A list of members in the publisher. */
  members?: PublisherMember[];
  name?: string;
  source_code_repo?: string;
  support?: string;
  website?: string;
}

export interface PersonalAccessToken {
  /** [Output Only]The date and time the token was created. */
  createdAt?: string;
  /** Optional. A more detailed description of the token's intended use. */
  description?: string;
  /** Unique identifier for the GitCommit */
  id?: string;
  /** Required. The name of the token. Can be a simple description. */
  name?: string;
  /** [Output Only]. The personal access token. Only returned during creation. */
  token?: string;
}

export interface NodeVersionUpdateRequest {
  /** The changelog describing the version changes. */
  changelog?: string;
  /** Whether the version is deprecated. */
  deprecated?: boolean;
}

export interface NodeVersion {
  /** Summary of changes made in this version */
  changelog?: string;
  /** A list of pip dependencies required by the node. */
  dependencies?: string[];
  /** Indicates if this version is deprecated. */
  deprecated?: boolean;
  /** [Output Only] URL to download this version of the node */
  downloadUrl?: string;
  id?: string;
  /** The version identifier, following semantic versioning. Must be unique for the node. */
  version?: string;
}

export interface Node {
  author?: string;
  description?: string;
  /** URL to the node's icon. */
  icon?: string;
  /** The unique identifier of the node. */
  id?: string;
  /** The path to the LICENSE file in the node's repository. */
  license?: string;
  /** The display name of the node. */
  name?: string;
  /** URL to the node's repository. */
  repository?: string;
  tags?: string[];
}

export type MachineType = typeof MachineType[keyof typeof MachineType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MachineType = {
  'n1-standard-1': 'n1-standard-1',
  'n1-standard-2': 'n1-standard-2',
  'n1-standard-4': 'n1-standard-4',
  'n1-standard-8': 'n1-standard-8',
  'n1-standard-16': 'n1-standard-16',
  'n1-standard-32': 'n1-standard-32',
  'n1-standard-64': 'n1-standard-64',
  'n1-standard-96': 'n1-standard-96',
  'a2-highgpu-1g': 'a2-highgpu-1g',
  'a2-highgpu-2g': 'a2-highgpu-2g',
  'a2-highgpu-4g': 'a2-highgpu-4g',
  'a2-highgpu-8g': 'a2-highgpu-8g',
  'a2-megagpu-16g': 'a2-megagpu-16g',
  'a2-ultragpu-1g': 'a2-ultragpu-1g',
  'a2-ultragpu-2g': 'a2-ultragpu-2g',
  'a2-ultragpu-4g': 'a2-ultragpu-4g',
  'a2-ultragpu-8g': 'a2-ultragpu-8g',
  'a3-highgpu-8g': 'a3-highgpu-8g',
  'g2-standard-4': 'g2-standard-4',
  'g2-standard-8': 'g2-standard-8',
  'g2-standard-12': 'g2-standard-12',
  'g2-standard-16': 'g2-standard-16',
  'g2-standard-24': 'g2-standard-24',
  'g2-standard-32': 'g2-standard-32',
  'g2-standard-48': 'g2-standard-48',
  'g2-standard-96': 'g2-standard-96',
} as const;

export type GPUType = typeof GPUType[keyof typeof GPUType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GPUType = {
  'nvidia-h100-80gb': 'nvidia-h100-80gb',
  'nvidia-l4': 'nvidia-l4',
  'nvidia-tesla-a100': 'nvidia-tesla-a100',
  'nvidia-a100-80gb': 'nvidia-a100-80gb',
  'nvidia-tesla-t4': 'nvidia-tesla-t4',
  'nvidia-tesla-v100': 'nvidia-tesla-v100',
  'nvidia-tesla-p100': 'nvidia-tesla-p100',
  'nvidia-tesla-p4': 'nvidia-tesla-p4',
} as const;

export interface Session {
  /** [Output only] The number of GPUs attached to this session. */
  gpuCount?: number;
  gpuType?: GPUType;
  id?: string;
  machineType?: MachineType;
  /** This url to interface with this session. */
  publicUrl?: string;
  /** [Output only] The storage capacity of the session. */
  storage?: string;
}

export interface Machine {
  /** [Output only] The number of GPUs attached to this session. */
  gpuCount?: number;
  gpuType?: GPUType;
  /** The unique id for this machine. */
  id?: string;
  machineType?: MachineType;
  /** This url to interface with this session. */
  publicUrl?: string;
  /** [Output only] The storage capacity of the session. */
  storage?: string;
}

export interface ErrorResponse {
  error: string;
  message: string;
}

export interface Error {
  /** Optional detailed information about the error or hints for resolving it. */
  details?: string[];
  /** A clear and concise description of the error. */
  message?: string;
}

export interface ActionJobResult {
  /** Identifier of the run this result belongs to */
  action_run_id?: string;
  /** The hash of the commit */
  commit_hash?: string;
  /** The ID of the commit */
  commit_id?: string;
  /** The end time of the job as a Unix timestamp. */
  end_time?: number;
  /** The repository name */
  git_repo?: string;
  /** GPU type used */
  gpu_type?: string;
  /** Unique identifier for the job result */
  id?: string;
  /** Operating system used */
  operating_system?: string;
  /** PyTorch version used */
  pytorch_version?: string;
  /** The start time of the job as a Unix timestamp. */
  start_time?: number;
  storage_file?: StorageFile;
  /** Name of the workflow */
  workflow_name?: string;
}




// eslint-disable-next-line
  type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;


/**
 * Returns all branches for a given repo.
 * @summary Retrieve all distinct branches for a given repo
 */
export const getBranch = (
    params: GetBranchParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetBranch200>(
      {url: `/branch`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetBranchQueryKey = (params: GetBranchParams,) => {
    return [`/branch`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBranchQueryOptions = <TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranch>>> = ({ signal }) => getBranch(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetBranchQueryResult = NonNullable<Awaited<ReturnType<typeof getBranch>>>
export type GetBranchQueryError = void

/**
 * @summary Retrieve all distinct branches for a given repo
 */
export const useGetBranch = <TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(
 params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetBranchQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns all runs, jobs, job results, and storage files associated with a given commit.
 * @summary Retrieve CI data for a given commit
 */
export const getGitcommit = (
    params?: GetGitcommitParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGitcommit200>(
      {url: `/gitcommit`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetGitcommitQueryKey = (params?: GetGitcommitParams,) => {
    return [`/gitcommit`, ...(params ? [params]: [])] as const;
    }

    
export const getGetGitcommitQueryOptions = <TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGitcommitQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGitcommit>>> = ({ signal }) => getGitcommit(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGitcommitQueryResult = NonNullable<Awaited<ReturnType<typeof getGitcommit>>>
export type GetGitcommitQueryError = void

/**
 * @summary Retrieve CI data for a given commit
 */
export const useGetGitcommit = <TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(
 params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGitcommitQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a paginated list of nodes across all publishers.
 * @summary Retrieves a list of nodes
 */
export const listAllNodes = (
    params?: ListAllNodesParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ListAllNodes200>(
      {url: `/nodes`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListAllNodesQueryKey = (params?: ListAllNodesParams,) => {
    return [`/nodes`, ...(params ? [params]: [])] as const;
    }

    
    export const getListAllNodesQueryOptions = <TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void>(
      params?: ListAllNodesParams,
      options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>>;
        request?: SecondParameter<typeof customInstance>;
      }
    ) => {
      const { query: queryOptions, request: requestOptions } = options ?? {};
      const queryKey = queryOptions?.queryKey ?? getListAllNodesQueryKey(params);
    
      // Modify request headers to include the custom header
      const updatedRequestOptions = {
     
        headers: {
         
          'ngrok-skip-browser-warning': 'skip-browser-warning'
        }
      };
    
      const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllNodes>>> = ({ signal }) =>
        listAllNodes(params, updatedRequestOptions, signal);
    
      return {
        queryKey,
        queryFn,
        ...queryOptions
      } as UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData> & { queryKey: QueryKey };
    }

export type ListAllNodesQueryResult = NonNullable<Awaited<ReturnType<typeof listAllNodes>>>
export type ListAllNodesQueryError = void

/**
 * @summary Retrieves a list of nodes
 */
export const useListAllNodes = <TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void>(
 params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListAllNodesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves the node data for installation, either the latest or a specific version.
 * @summary Returns a node version to be installed.
 */
export const installNode = (
    nodeId: string,
    params?: InstallNodeParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NodeVersion>(
      {url: `/nodes/${nodeId}/install`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getInstallNodeQueryKey = (nodeId: string,
    params?: InstallNodeParams,) => {
    return [`/nodes/${nodeId}/install`, ...(params ? [params]: [])] as const;
    }

    
export const getInstallNodeQueryOptions = <TData = Awaited<ReturnType<typeof installNode>>, TError = Error | void>(nodeId: string,
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInstallNodeQueryKey(nodeId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof installNode>>> = ({ signal }) => installNode(nodeId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData> & { queryKey: QueryKey }
}

export type InstallNodeQueryResult = NonNullable<Awaited<ReturnType<typeof installNode>>>
export type InstallNodeQueryError = Error | void

/**
 * @summary Returns a node version to be installed.
 */
export const useInstallNode = <TData = Awaited<ReturnType<typeof installNode>>, TError = Error | void>(
 nodeId: string,
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getInstallNodeQueryOptions(nodeId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Retrieve all publishers
 */
export const listPublishers = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Publisher[]>(
      {url: `/publishers`, method: 'GET', signal
    },
      options);
    }
  

export const getListPublishersQueryKey = () => {
    return [`/publishers`] as const;
    }

    
export const getListPublishersQueryOptions = <TData = Awaited<ReturnType<typeof listPublishers>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPublishersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPublishers>>> = ({ signal }) => listPublishers(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPublishersQueryResult = NonNullable<Awaited<ReturnType<typeof listPublishers>>>
export type ListPublishersQueryError = void

/**
 * @summary Retrieve all publishers
 */
export const useListPublishers = <TData = Awaited<ReturnType<typeof listPublishers>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListPublishersQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new publisher
 */
export const createPublisher = (
    publisher: Publisher,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Publisher>(
      {url: `/publishers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: publisher
    },
      options);
    }
  


export const getCreatePublisherMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPublisher>>, {data: Publisher}> = (props) => {
          const {data} = props ?? {};

          return  createPublisher(data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof createPublisher>>>
    export type CreatePublisherMutationBody = Publisher
    export type CreatePublisherMutationError = void

    /**
 * @summary Create a new publisher
 */
export const useCreatePublisher = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getCreatePublisherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Checks if the publisher username is already taken.
 * @summary Validate if a publisher username is available
 */
export const validatePublisher = (
    params: ValidatePublisherParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ValidatePublisher200>(
      {url: `/publishers/validate`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getValidatePublisherQueryKey = (params: ValidatePublisherParams,) => {
    return [`/publishers/validate`, ...(params ? [params]: [])] as const;
    }

    
export const getValidatePublisherQueryOptions = <TData = Awaited<ReturnType<typeof validatePublisher>>, TError = Error | void>(params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidatePublisherQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validatePublisher>>> = ({ signal }) => validatePublisher(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData> & { queryKey: QueryKey }
}

export type ValidatePublisherQueryResult = NonNullable<Awaited<ReturnType<typeof validatePublisher>>>
export type ValidatePublisherQueryError = Error | void

/**
 * @summary Validate if a publisher username is available
 */
export const useValidatePublisher = <TData = Awaited<ReturnType<typeof validatePublisher>>, TError = Error | void>(
 params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getValidatePublisherQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete a publisher
 */
export const deletePublisher = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeletePublisherMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePublisher>>, {publisherId: string}> = (props) => {
          const {publisherId} = props ?? {};

          return  deletePublisher(publisherId,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type DeletePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof deletePublisher>>>
    
    export type DeletePublisherMutationError = Error

    /**
 * @summary Delete a publisher
 */
export const useDeletePublisher = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getDeletePublisherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Retrieve a publisher by ID
 */
export const getPublisher = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Publisher>(
      {url: `/publishers/${publisherId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPublisherQueryKey = (publisherId: string,) => {
    return [`/publishers/${publisherId}`] as const;
    }

    
export const getGetPublisherQueryOptions = <TData = Awaited<ReturnType<typeof getPublisher>>, TError = void>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublisherQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublisher>>> = ({ signal }) => getPublisher(publisherId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof getPublisher>>>
export type GetPublisherQueryError = void

/**
 * @summary Retrieve a publisher by ID
 */
export const useGetPublisher = <TData = Awaited<ReturnType<typeof getPublisher>>, TError = void>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPublisherQueryOptions(publisherId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a publisher
 */
export const updatePublisher = (
    publisherId: string,
    publisher: Publisher,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Publisher>(
      {url: `/publishers/${publisherId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: publisher
    },
      options);
    }
  


export const getUpdatePublisherMutationOptions = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePublisher>>, {publisherId: string;data: Publisher}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  updatePublisher(publisherId,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type UpdatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof updatePublisher>>>
    export type UpdatePublisherMutationBody = Publisher
    export type UpdatePublisherMutationError = Error | void

    /**
 * @summary Update a publisher
 */
export const useUpdatePublisher = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getUpdatePublisherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Retrieve all nodes
 */
export const listNodesForPublisher = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Node[]>(
      {url: `/publishers/${publisherId}/nodes`, method: 'GET', signal
    },
      options);
    }
  

export const getListNodesForPublisherQueryKey = (publisherId: string,) => {
    return [`/publishers/${publisherId}/nodes`] as const;
    }

    
export const getListNodesForPublisherQueryOptions = <TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = void>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListNodesForPublisherQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodesForPublisher>>> = ({ signal }) => listNodesForPublisher(publisherId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData> & { queryKey: QueryKey }
}

export type ListNodesForPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof listNodesForPublisher>>>
export type ListNodesForPublisherQueryError = void

/**
 * @summary Retrieve all nodes
 */
export const useListNodesForPublisher = <TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = void>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListNodesForPublisherQueryOptions(publisherId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new custom node
 */
export const createNode = (
    publisherId: string,
    node: Node,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Node>(
      {url: `/publishers/${publisherId}/nodes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: node
    },
      options);
    }
  


export const getCreateNodeMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNode>>, {publisherId: string;data: Node}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  createNode(publisherId,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof createNode>>>
    export type CreateNodeMutationBody = Node
    export type CreateNodeMutationError = Error

    /**
 * @summary Create a new custom node
 */
export const useCreateNode = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getCreateNodeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a specific node
 */
export const deleteNode = (
    publisherId: string,
    nodeId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteNodeMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNode>>, {publisherId: string;nodeId: string}> = (props) => {
          const {publisherId,nodeId} = props ?? {};

          return  deleteNode(publisherId,nodeId,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type DeleteNodeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNode>>>
    
    export type DeleteNodeMutationError = Error

    /**
 * @summary Delete a specific node
 */
export const useDeleteNode = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getDeleteNodeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Retrieve a specific node by ID
 */
export const getNode = (
    publisherId: string,
    nodeId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Node>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNodeQueryKey = (publisherId: string,
    nodeId: string,) => {
    return [`/publishers/${publisherId}/nodes/${nodeId}`] as const;
    }

    
export const getGetNodeQueryOptions = <TData = Awaited<ReturnType<typeof getNode>>, TError = Error>(publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeQueryKey(publisherId,nodeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNode>>> = ({ signal }) => getNode(publisherId,nodeId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId && nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNodeQueryResult = NonNullable<Awaited<ReturnType<typeof getNode>>>
export type GetNodeQueryError = Error

/**
 * @summary Retrieve a specific node by ID
 */
export const useGetNode = <TData = Awaited<ReturnType<typeof getNode>>, TError = Error>(
 publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetNodeQueryOptions(publisherId,nodeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a specific node
 */
export const updateNode = (
    publisherId: string,
    nodeId: string,
    node: Node,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Node>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: node
    },
      options);
    }
  


export const getUpdateNodeMutationOptions = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNode>>, {publisherId: string;nodeId: string;data: Node}> = (props) => {
          const {publisherId,nodeId,data} = props ?? {};

          return  updateNode(publisherId,nodeId,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type UpdateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof updateNode>>>
    export type UpdateNodeMutationBody = Node
    export type UpdateNodeMutationError = Error | void

    /**
 * @summary Update a specific node
 */
export const useUpdateNode = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getUpdateNodeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary List all versions of a node
 */
export const listNodeVersions = (
    publisherId: string,
    nodeId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NodeVersion[]>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/versions`, method: 'GET', signal
    },
      options);
    }
  

export const getListNodeVersionsQueryKey = (publisherId: string,
    nodeId: string,) => {
    return [`/publishers/${publisherId}/nodes/${nodeId}/versions`] as const;
    }

    
export const getListNodeVersionsQueryOptions = <TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = Error>(publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListNodeVersionsQueryKey(publisherId,nodeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodeVersions>>> = ({ signal }) => listNodeVersions(publisherId,nodeId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId && nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData> & { queryKey: QueryKey }
}

export type ListNodeVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof listNodeVersions>>>
export type ListNodeVersionsQueryError = Error

/**
 * @summary List all versions of a node
 */
export const useListNodeVersions = <TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = Error>(
 publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListNodeVersionsQueryOptions(publisherId,nodeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Publish a new version of a node
 */
export const publishNodeVersion = (
    publisherId: string,
    nodeId: string,
    publishNodeVersionBody: PublishNodeVersionBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<PublishNodeVersion201>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/versions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: publishNodeVersionBody
    },
      options);
    }
  


export const getPublishNodeVersionMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof publishNodeVersion>>, {publisherId: string;nodeId: string;data: PublishNodeVersionBody}> = (props) => {
          const {publisherId,nodeId,data} = props ?? {};

          return  publishNodeVersion(publisherId,nodeId,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type PublishNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof publishNodeVersion>>>
    export type PublishNodeVersionMutationBody = PublishNodeVersionBody
    export type PublishNodeVersionMutationError = Error

    /**
 * @summary Publish a new version of a node
 */
export const usePublishNodeVersion = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getPublishNodeVersionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Unpublish (delete) a specific version of a node
 */
export const deleteNodeVersion = (
    publisherId: string,
    nodeId: string,
    versionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteNodeVersionMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNodeVersion>>, {publisherId: string;nodeId: string;versionId: string}> = (props) => {
          const {publisherId,nodeId,versionId} = props ?? {};

          return  deleteNodeVersion(publisherId,nodeId,versionId,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type DeleteNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNodeVersion>>>
    
    export type DeleteNodeVersionMutationError = Error

    /**
 * @summary Unpublish (delete) a specific version of a node
 */
export const useDeleteNodeVersion = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getDeleteNodeVersionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Retrieve a specific version of a node
 */
export const getNodeVersion = (
    publisherId: string,
    nodeId: string,
    versionId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NodeVersion>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNodeVersionQueryKey = (publisherId: string,
    nodeId: string,
    versionId: string,) => {
    return [`/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`] as const;
    }

    
export const getGetNodeVersionQueryOptions = <TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error>(publisherId: string,
    nodeId: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeVersionQueryKey(publisherId,nodeId,versionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeVersion>>> = ({ signal }) => getNodeVersion(publisherId,nodeId,versionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId && nodeId && versionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNodeVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getNodeVersion>>>
export type GetNodeVersionQueryError = Error

/**
 * @summary Retrieve a specific version of a node
 */
export const useGetNodeVersion = <TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error>(
 publisherId: string,
    nodeId: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetNodeVersionQueryOptions(publisherId,nodeId,versionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update only the changelog and deprecated status of a specific version of a node.
 * @summary Update changelog and deprecation status of a node version
 */
export const updateNodeVersion = (
    publisherId: string,
    nodeId: string,
    versionId: string,
    nodeVersionUpdateRequest: NodeVersionUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<NodeVersion>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: nodeVersionUpdateRequest
    },
      options);
    }
  


export const getUpdateNodeVersionMutationOptions = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNodeVersion>>, {publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}> = (props) => {
          const {publisherId,nodeId,versionId,data} = props ?? {};

          return  updateNodeVersion(publisherId,nodeId,versionId,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type UpdateNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof updateNodeVersion>>>
    export type UpdateNodeVersionMutationBody = NodeVersionUpdateRequest
    export type UpdateNodeVersionMutationError = Error | void

    /**
 * @summary Update changelog and deprecation status of a node version
 */
export const useUpdateNodeVersion = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getUpdateNodeVersionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Retrieve all personal access tokens for a publisher
 */
export const listPersonalAccessTokens = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonalAccessToken[]>(
      {url: `/publishers/${publisherId}/tokens`, method: 'GET', signal
    },
      options);
    }
  

export const getListPersonalAccessTokensQueryKey = (publisherId: string,) => {
    return [`/publishers/${publisherId}/tokens`] as const;
    }

    
export const getListPersonalAccessTokensQueryOptions = <TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = Error>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPersonalAccessTokensQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPersonalAccessTokens>>> = ({ signal }) => listPersonalAccessTokens(publisherId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPersonalAccessTokensQueryResult = NonNullable<Awaited<ReturnType<typeof listPersonalAccessTokens>>>
export type ListPersonalAccessTokensQueryError = Error

/**
 * @summary Retrieve all personal access tokens for a publisher
 */
export const useListPersonalAccessTokens = <TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = Error>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListPersonalAccessTokensQueryOptions(publisherId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new personal access token
 */
export const createPersonalAccessToken = (
    publisherId: string,
    personalAccessToken: PersonalAccessToken,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreatePersonalAccessToken201>(
      {url: `/publishers/${publisherId}/tokens`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: personalAccessToken
    },
      options);
    }
  


export const getCreatePersonalAccessTokenMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPersonalAccessToken>>, {publisherId: string;data: PersonalAccessToken}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  createPersonalAccessToken(publisherId,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreatePersonalAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof createPersonalAccessToken>>>
    export type CreatePersonalAccessTokenMutationBody = PersonalAccessToken
    export type CreatePersonalAccessTokenMutationError = Error

    /**
 * @summary Create a new personal access token
 */
export const useCreatePersonalAccessToken = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getCreatePersonalAccessTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a specific personal access token
 */
export const deletePersonalAccessToken = (
    publisherId: string,
    tokenId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/tokens/${tokenId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeletePersonalAccessTokenMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePersonalAccessToken>>, {publisherId: string;tokenId: string}> = (props) => {
          const {publisherId,tokenId} = props ?? {};

          return  deletePersonalAccessToken(publisherId,tokenId,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type DeletePersonalAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof deletePersonalAccessToken>>>
    
    export type DeletePersonalAccessTokenMutationError = Error

    /**
 * @summary Delete a specific personal access token
 */
export const useDeletePersonalAccessToken = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getDeletePersonalAccessTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Receive artifacts (output files) from the ComfyUI GitHub Action
 */
export const postUploadArtifact = (
    postUploadArtifactBody: PostUploadArtifactBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<PostUploadArtifact200>(
      {url: `/upload-artifact`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postUploadArtifactBody
    },
      options);
    }
  


export const getPostUploadArtifactMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUploadArtifact>>, {data: PostUploadArtifactBody}> = (props) => {
          const {data} = props ?? {};

          return  postUploadArtifact(data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type PostUploadArtifactMutationResult = NonNullable<Awaited<ReturnType<typeof postUploadArtifact>>>
    export type PostUploadArtifactMutationBody = PostUploadArtifactBody
    export type PostUploadArtifactMutationError = void

    /**
 * @summary Receive artifacts (output files) from the ComfyUI GitHub Action
 */
export const usePostUploadArtifact = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getPostUploadArtifactMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get information about the calling user.
 */
export const getUser = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<User>(
      {url: `/users`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserQueryKey = () => {
    return [`/users`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = void

/**
 * @summary Get information about the calling user.
 */
export const useGetUser = <TData = Awaited<ReturnType<typeof getUser>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Retrieve all publishers for a given user
 */
export const listPublishersForUser = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Publisher[]>(
      {url: `/users/publishers/`, method: 'GET', signal
    },
      options);
    }
  

export const getListPublishersForUserQueryKey = () => {
    return [`/users/publishers/`] as const;
    }

    
export const getListPublishersForUserQueryOptions = <TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPublishersForUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPublishersForUser>>> = ({ signal }) => listPublishersForUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPublishersForUserQueryResult = NonNullable<Awaited<ReturnType<typeof listPublishersForUser>>>
export type ListPublishersForUserQueryError = void

/**
 * @summary Retrieve all publishers for a given user
 */
export const useListPublishersForUser = <TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListPublishersForUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Stop sessions that have no active usage.
 */
export const stopExpiredSessions = (
    
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Session>(
      {url: `/users/sessions`, method: 'DELETE'
    },
      options);
    }
  


export const getStopExpiredSessionsMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stopExpiredSessions>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stopExpiredSessions>>, TError,void, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof stopExpiredSessions>>, void> = () => {
          

          return  stopExpiredSessions(requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type StopExpiredSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof stopExpiredSessions>>>
    
    export type StopExpiredSessionsMutationError = void

    /**
 * @summary Stop sessions that have no active usage.
 */
export const useStopExpiredSessions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stopExpiredSessions>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getStopExpiredSessionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get information about the calling user's session.
 */
export const getSessions = (
    params?: GetSessionsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSessions200>(
      {url: `/users/sessions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSessionsQueryKey = (params?: GetSessionsParams,) => {
    return [`/users/sessions`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSessionsQueryOptions = <TData = Awaited<ReturnType<typeof getSessions>>, TError = void>(params?: GetSessionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessions>>> = ({ signal }) => getSessions(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessions>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionsQueryResult = NonNullable<Awaited<ReturnType<typeof getSessions>>>
export type GetSessionsQueryError = void

/**
 * @summary Get information about the calling user's session.
 */
export const useGetSessions = <TData = Awaited<ReturnType<typeof getSessions>>, TError = void>(
 params?: GetSessionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSessionsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new session for a user. If an existing session is active (not deleted), it will be returned.
 */
export const createSession = (
    createSessionBody: CreateSessionBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Session>(
      {url: `/users/sessions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSessionBody
    },
      options);
    }
  


export const getCreateSessionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: CreateSessionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: CreateSessionBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSession>>, {data: CreateSessionBody}> = (props) => {
          const {data} = props ?? {};

          return  createSession(data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof createSession>>>
    export type CreateSessionMutationBody = CreateSessionBody
    export type CreateSessionMutationError = void

    /**
 * @summary Create a new session for a user. If an existing session is active (not deleted), it will be returned.
 */
export const useCreateSession = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: CreateSessionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getCreateSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a specific session by its ID.
 */
export const getSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Session>(
      {url: `/users/sessions/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSessionQueryKey = (sessionId: string,) => {
    return [`/users/sessions/${sessionId}`] as const;
    }

    
export const getGetSessionQueryOptions = <TData = Awaited<ReturnType<typeof getSession>>, TError = void>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionQueryError = void

/**
 * @summary Get a specific session by its ID.
 */
export const useGetSession = <TData = Awaited<ReturnType<typeof getSession>>, TError = void>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSessionQueryOptions(sessionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a session by its ID.
 */
export const updateSession = (
    sessionId: string,
    updateSessionBody: UpdateSessionBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Session>(
      {url: `/users/sessions/${sessionId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateSessionBody
    },
      options);
    }
  


export const getUpdateSessionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: UpdateSessionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: UpdateSessionBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSession>>, {sessionId: string;data: UpdateSessionBody}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateSession(sessionId,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type UpdateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSession>>>
    export type UpdateSessionMutationBody = UpdateSessionBody
    export type UpdateSessionMutationError = void

    /**
 * @summary Update a session by its ID.
 */
export const useUpdateSession = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: UpdateSessionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getUpdateSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Validates the provided access token and returns a session ID if valid.
 * @summary Validate an access token
 */
export const postValidateToken = (
    postValidateTokenBody: PostValidateTokenBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Session>(
      {url: `/validateToken`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postValidateTokenBody
    },
      options);
    }
  


export const getPostValidateTokenMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postValidateToken>>, TError,{data: PostValidateTokenBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postValidateToken>>, TError,{data: PostValidateTokenBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postValidateToken>>, {data: PostValidateTokenBody}> = (props) => {
          const {data} = props ?? {};

          return  postValidateToken(data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type PostValidateTokenMutationResult = NonNullable<Awaited<ReturnType<typeof postValidateToken>>>
    export type PostValidateTokenMutationBody = PostValidateTokenBody
    export type PostValidateTokenMutationError = void

    /**
 * @summary Validate an access token
 */
export const usePostValidateToken = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postValidateToken>>, TError,{data: PostValidateTokenBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getPostValidateTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all workflows
 */
export const getUserWorkflows = (
    params?: GetUserWorkflowsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetUserWorkflows200>(
      {url: `/workflows`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetUserWorkflowsQueryKey = (params?: GetUserWorkflowsParams,) => {
    return [`/workflows`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserWorkflowsQueryOptions = <TData = Awaited<ReturnType<typeof getUserWorkflows>>, TError = unknown>(params?: GetUserWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserWorkflows>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserWorkflowsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserWorkflows>>> = ({ signal }) => getUserWorkflows(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserWorkflows>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserWorkflowsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserWorkflows>>>
export type GetUserWorkflowsQueryError = unknown

/**
 * @summary Get all workflows
 */
export const useGetUserWorkflows = <TData = Awaited<ReturnType<typeof getUserWorkflows>>, TError = unknown>(
 params?: GetUserWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserWorkflows>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserWorkflowsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new workflow
 */
export const createWorkflow = (
    createWorkflowBody: CreateWorkflowBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Workflow>(
      {url: `/workflows`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createWorkflowBody
    },
      options);
    }
  


export const getCreateWorkflowMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkflow>>, TError,{data: CreateWorkflowBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createWorkflow>>, TError,{data: CreateWorkflowBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWorkflow>>, {data: CreateWorkflowBody}> = (props) => {
          const {data} = props ?? {};

          return  createWorkflow(data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreateWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof createWorkflow>>>
    export type CreateWorkflowMutationBody = CreateWorkflowBody
    export type CreateWorkflowMutationError = void

    /**
 * @summary Create a new workflow
 */
export const useCreateWorkflow = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkflow>>, TError,{data: CreateWorkflowBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getCreateWorkflowMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a workflow
 */
export const deleteWorkflow = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/workflows/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteWorkflowMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{id: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWorkflow>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteWorkflow(id,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type DeleteWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWorkflow>>>
    
    export type DeleteWorkflowMutationError = unknown

    /**
 * @summary Delete a workflow
 */
export const useDeleteWorkflow = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getDeleteWorkflowMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a workflow
 */
export const getWorkflow = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetWorkflow200>(
      {url: `/workflows/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWorkflowQueryKey = (id: string,) => {
    return [`/workflows/${id}`] as const;
    }

    
export const getGetWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflow>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflow>>> = ({ signal }) => getWorkflow(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflow>>>
export type GetWorkflowQueryError = void

/**
 * @summary Get a workflow
 */
export const useGetWorkflow = <TData = Awaited<ReturnType<typeof getWorkflow>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWorkflowQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update an existing workflow
 */
export const updateWorkflow = (
    id: string,
    workflow: Workflow,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Workflow>(
      {url: `/workflows/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: workflow
    },
      options);
    }
  


export const getUpdateWorkflowMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkflow>>, TError,{id: string;data: Workflow}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateWorkflow>>, TError,{id: string;data: Workflow}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWorkflow>>, {id: string;data: Workflow}> = (props) => {
          const {id,data} = props ?? {};

          return  updateWorkflow(id,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type UpdateWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof updateWorkflow>>>
    export type UpdateWorkflowMutationBody = Workflow
    export type UpdateWorkflowMutationError = void

    /**
 * @summary Update an existing workflow
 */
export const useUpdateWorkflow = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkflow>>, TError,{id: string;data: Workflow}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getUpdateWorkflowMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Create a new job for a specific workflow
 */
export const createWorkflowJob = (
    workflowId: string,
    createWorkflowJobBody: CreateWorkflowJobBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<WorkflowJob>(
      {url: `/workflows/${workflowId}/jobs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createWorkflowJobBody
    },
      options);
    }
  


export const getCreateWorkflowJobMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkflowJob>>, TError,{workflowId: string;data: CreateWorkflowJobBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createWorkflowJob>>, TError,{workflowId: string;data: CreateWorkflowJobBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWorkflowJob>>, {workflowId: string;data: CreateWorkflowJobBody}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  createWorkflowJob(workflowId,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreateWorkflowJobMutationResult = NonNullable<Awaited<ReturnType<typeof createWorkflowJob>>>
    export type CreateWorkflowJobMutationBody = CreateWorkflowJobBody
    export type CreateWorkflowJobMutationError = void

    /**
 * @summary Create a new job for a specific workflow
 */
export const useCreateWorkflowJob = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkflowJob>>, TError,{workflowId: string;data: CreateWorkflowJobBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getCreateWorkflowJobMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a job by ID for a specific workflow
 */
export const getWorkflowJob = (
    workflowId: string,
    jobId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkflowJob>(
      {url: `/workflows/${workflowId}/jobs/${jobId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWorkflowJobQueryKey = (workflowId: string,
    jobId: string,) => {
    return [`/workflows/${workflowId}/jobs/${jobId}`] as const;
    }

    
export const getGetWorkflowJobQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowJob>>, TError = void>(workflowId: string,
    jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowJob>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowJobQueryKey(workflowId,jobId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowJob>>> = ({ signal }) => getWorkflowJob(workflowId,jobId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(workflowId && jobId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowJob>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWorkflowJobQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowJob>>>
export type GetWorkflowJobQueryError = void

/**
 * @summary Get a job by ID for a specific workflow
 */
export const useGetWorkflowJob = <TData = Awaited<ReturnType<typeof getWorkflowJob>>, TError = void>(
 workflowId: string,
    jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowJob>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWorkflowJobQueryOptions(workflowId,jobId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a job's status and output URLs for a specific workflow
 */
export const updateWorkflowJob = (
    workflowId: string,
    jobId: string,
    updateWorkflowJobBody: UpdateWorkflowJobBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<WorkflowJob>(
      {url: `/workflows/${workflowId}/jobs/${jobId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateWorkflowJobBody
    },
      options);
    }
  


export const getUpdateWorkflowJobMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkflowJob>>, TError,{workflowId: string;jobId: string;data: UpdateWorkflowJobBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateWorkflowJob>>, TError,{workflowId: string;jobId: string;data: UpdateWorkflowJobBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWorkflowJob>>, {workflowId: string;jobId: string;data: UpdateWorkflowJobBody}> = (props) => {
          const {workflowId,jobId,data} = props ?? {};

          return  updateWorkflowJob(workflowId,jobId,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type UpdateWorkflowJobMutationResult = NonNullable<Awaited<ReturnType<typeof updateWorkflowJob>>>
    export type UpdateWorkflowJobMutationBody = UpdateWorkflowJobBody
    export type UpdateWorkflowJobMutationError = ErrorResponse

    /**
 * @summary Update a job's status and output URLs for a specific workflow
 */
export const useUpdateWorkflowJob = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkflowJob>>, TError,{workflowId: string;jobId: string;data: UpdateWorkflowJobBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getUpdateWorkflowJobMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Cancel a specific job for a workflow
 */
export const cancelWorkflowJob = (
    workflowId: string,
    jobId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CancelWorkflowJob200>(
      {url: `/workflows/${workflowId}/jobs/${jobId}/cancel`, method: 'POST'
    },
      options);
    }
  


export const getCancelWorkflowJobMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowJob>>, TError,{workflowId: string;jobId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowJob>>, TError,{workflowId: string;jobId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelWorkflowJob>>, {workflowId: string;jobId: string}> = (props) => {
          const {workflowId,jobId} = props ?? {};

          return  cancelWorkflowJob(workflowId,jobId,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CancelWorkflowJobMutationResult = NonNullable<Awaited<ReturnType<typeof cancelWorkflowJob>>>
    
    export type CancelWorkflowJobMutationError = void

    /**
 * @summary Cancel a specific job for a workflow
 */
export const useCancelWorkflowJob = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowJob>>, TError,{workflowId: string;jobId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getCancelWorkflowJobMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all workspaces for the user
 */
export const getWorkspaces = (
    params?: GetWorkspacesParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetWorkspaces200>(
      {url: `/workspace`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetWorkspacesQueryKey = (params?: GetWorkspacesParams,) => {
    return [`/workspace`, ...(params ? [params]: [])] as const;
    }

    
export const getGetWorkspacesQueryOptions = <TData = Awaited<ReturnType<typeof getWorkspaces>>, TError = void>(params?: GetWorkspacesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspaces>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkspacesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkspaces>>> = ({ signal }) => getWorkspaces(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkspaces>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWorkspacesQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkspaces>>>
export type GetWorkspacesQueryError = void

/**
 * @summary Get all workspaces for the user
 */
export const useGetWorkspaces = <TData = Awaited<ReturnType<typeof getWorkspaces>>, TError = void>(
 params?: GetWorkspacesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspaces>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWorkspacesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new workspace
 */
export const createWorkspace = (
    createWorkspaceBody: CreateWorkspaceBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateWorkspace201>(
      {url: `/workspace`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createWorkspaceBody
    },
      options);
    }
  


export const getCreateWorkspaceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkspace>>, TError,{data: CreateWorkspaceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createWorkspace>>, TError,{data: CreateWorkspaceBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWorkspace>>, {data: CreateWorkspaceBody}> = (props) => {
          const {data} = props ?? {};

          return  createWorkspace(data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreateWorkspaceMutationResult = NonNullable<Awaited<ReturnType<typeof createWorkspace>>>
    export type CreateWorkspaceMutationBody = CreateWorkspaceBody
    export type CreateWorkspaceMutationError = void

    /**
 * @summary Create a new workspace
 */
export const useCreateWorkspace = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkspace>>, TError,{data: CreateWorkspaceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getCreateWorkspaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Create the default workspace. It retrieves the default workspace if it already exists.
 */
export const createDefaultWorkspace = (
    
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateDefaultWorkspace201>(
      {url: `/workspace/default`, method: 'POST'
    },
      options);
    }
  


export const getCreateDefaultWorkspaceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDefaultWorkspace>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createDefaultWorkspace>>, TError,void, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDefaultWorkspace>>, void> = () => {
          

          return  createDefaultWorkspace(requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreateDefaultWorkspaceMutationResult = NonNullable<Awaited<ReturnType<typeof createDefaultWorkspace>>>
    
    export type CreateDefaultWorkspaceMutationError = void

    /**
 * @summary Create the default workspace. It retrieves the default workspace if it already exists.
 */
export const useCreateDefaultWorkspace = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDefaultWorkspace>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getCreateDefaultWorkspaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a workspace by ID
 */
export const getWorkspace = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetWorkspace200>(
      {url: `/workspace/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWorkspaceQueryKey = (id: string,) => {
    return [`/workspace/${id}`] as const;
    }

    
export const getGetWorkspaceQueryOptions = <TData = Awaited<ReturnType<typeof getWorkspace>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkspaceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkspace>>> = ({ signal }) => getWorkspace(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkspace>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWorkspaceQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkspace>>>
export type GetWorkspaceQueryError = void

/**
 * @summary Get a workspace by ID
 */
export const useGetWorkspace = <TData = Awaited<ReturnType<typeof getWorkspace>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWorkspaceQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update the workspace with the workflow content
 */
export const updateWorkspace = (
    id: string,
    updateWorkspaceBody: UpdateWorkspaceBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateWorkspace200>(
      {url: `/workspace/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateWorkspaceBody
    },
      options);
    }
  


export const getUpdateWorkspaceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkspace>>, TError,{id: string;data: UpdateWorkspaceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateWorkspace>>, TError,{id: string;data: UpdateWorkspaceBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWorkspace>>, {id: string;data: UpdateWorkspaceBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateWorkspace(id,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type UpdateWorkspaceMutationResult = NonNullable<Awaited<ReturnType<typeof updateWorkspace>>>
    export type UpdateWorkspaceMutationBody = UpdateWorkspaceBody
    export type UpdateWorkspaceMutationError = void

    /**
 * @summary Update the workspace with the workflow content
 */
export const useUpdateWorkspace = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkspace>>, TError,{id: string;data: UpdateWorkspaceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getUpdateWorkspaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all snapshots for the workspace
 */
export const getWorkspaceSnapshots = (
    workspaceId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetWorkspaceSnapshots200>(
      {url: `/workspace/${workspaceId}/snapshot`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWorkspaceSnapshotsQueryKey = (workspaceId: string,) => {
    return [`/workspace/${workspaceId}/snapshot`] as const;
    }

    
export const getGetWorkspaceSnapshotsQueryOptions = <TData = Awaited<ReturnType<typeof getWorkspaceSnapshots>>, TError = void>(workspaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspaceSnapshots>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkspaceSnapshotsQueryKey(workspaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkspaceSnapshots>>> = ({ signal }) => getWorkspaceSnapshots(workspaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(workspaceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkspaceSnapshots>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWorkspaceSnapshotsQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkspaceSnapshots>>>
export type GetWorkspaceSnapshotsQueryError = void

/**
 * @summary Get all snapshots for the workspace
 */
export const useGetWorkspaceSnapshots = <TData = Awaited<ReturnType<typeof getWorkspaceSnapshots>>, TError = void>(
 workspaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspaceSnapshots>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWorkspaceSnapshotsQueryOptions(workspaceId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a snapshot of the current workspace
 */
export const createWorkspaceSnapshot = (
    workspaceId: string,
    createWorkspaceSnapshotBody: CreateWorkspaceSnapshotBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateWorkspaceSnapshot201>(
      {url: `/workspace/${workspaceId}/snapshot/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createWorkspaceSnapshotBody
    },
      options);
    }
  


export const getCreateWorkspaceSnapshotMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkspaceSnapshot>>, TError,{workspaceId: string;data: CreateWorkspaceSnapshotBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createWorkspaceSnapshot>>, TError,{workspaceId: string;data: CreateWorkspaceSnapshotBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWorkspaceSnapshot>>, {workspaceId: string;data: CreateWorkspaceSnapshotBody}> = (props) => {
          const {workspaceId,data} = props ?? {};

          return  createWorkspaceSnapshot(workspaceId,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreateWorkspaceSnapshotMutationResult = NonNullable<Awaited<ReturnType<typeof createWorkspaceSnapshot>>>
    export type CreateWorkspaceSnapshotMutationBody = CreateWorkspaceSnapshotBody
    export type CreateWorkspaceSnapshotMutationError = void

    /**
 * @summary Create a snapshot of the current workspace
 */
export const useCreateWorkspaceSnapshot = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkspaceSnapshot>>, TError,{workspaceId: string;data: CreateWorkspaceSnapshotBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getCreateWorkspaceSnapshotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Load a workspace snapshot
 */
export const loadWorkspaceSnapshot = (
    workspaceId: string,
    snapshotId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<LoadWorkspaceSnapshot200>(
      {url: `/workspace/${workspaceId}/snapshot/${snapshotId}/load/`, method: 'POST'
    },
      options);
    }
  


export const getLoadWorkspaceSnapshotMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loadWorkspaceSnapshot>>, TError,{workspaceId: string;snapshotId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loadWorkspaceSnapshot>>, TError,{workspaceId: string;snapshotId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loadWorkspaceSnapshot>>, {workspaceId: string;snapshotId: string}> = (props) => {
          const {workspaceId,snapshotId} = props ?? {};

          return  loadWorkspaceSnapshot(workspaceId,snapshotId,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type LoadWorkspaceSnapshotMutationResult = NonNullable<Awaited<ReturnType<typeof loadWorkspaceSnapshot>>>
    
    export type LoadWorkspaceSnapshotMutationError = void

    /**
 * @summary Load a workspace snapshot
 */
export const useLoadWorkspaceSnapshot = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loadWorkspaceSnapshot>>, TError,{workspaceId: string;snapshotId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getLoadWorkspaceSnapshotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
